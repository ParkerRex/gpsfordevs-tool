[
  {
    "title": "CLLiveUpdateConfigurationDefault | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clliveupdateconfiguration/clliveupdateconfigurationdefault",
    "html": "See Also\nUpdate types\nCLLiveUpdateConfigurationAirborne\nA configuration for airborne use cases.\nCLLiveUpdateConfigurationAutomotiveNavigation\nA configuration for automotive navigation use cases.\nCLLiveUpdateConfigurationFitness\nA configuration for fitness use cases.\nCLLiveUpdateConfigurationOtherNavigation\nA configuration for other navigation use cases."
  },
  {
    "title": "CLLiveUpdateConfigurationFitness | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clliveupdateconfiguration/clliveupdateconfigurationfitness",
    "html": "See Also\nUpdate types\nCLLiveUpdateConfigurationDefault\nThe default configuration.\nCLLiveUpdateConfigurationAirborne\nA configuration for airborne use cases.\nCLLiveUpdateConfigurationAutomotiveNavigation\nA configuration for automotive navigation use cases.\nCLLiveUpdateConfigurationOtherNavigation\nA configuration for other navigation use cases."
  },
  {
    "title": "CLLiveUpdateConfigurationAutomotiveNavigation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clliveupdateconfiguration/clliveupdateconfigurationautomotivenavigation",
    "html": "See Also\nUpdate types\nCLLiveUpdateConfigurationDefault\nThe default configuration.\nCLLiveUpdateConfigurationAirborne\nA configuration for airborne use cases.\nCLLiveUpdateConfigurationFitness\nA configuration for fitness use cases.\nCLLiveUpdateConfigurationOtherNavigation\nA configuration for other navigation use cases."
  },
  {
    "title": "CLLiveUpdateConfigurationAirborne | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clliveupdateconfiguration/clliveupdateconfigurationairborne",
    "html": "See Also\nUpdate types\nCLLiveUpdateConfigurationDefault\nThe default configuration.\nCLLiveUpdateConfigurationAutomotiveNavigation\nA configuration for automotive navigation use cases.\nCLLiveUpdateConfigurationFitness\nA configuration for fitness use cases.\nCLLiveUpdateConfigurationOtherNavigation\nA configuration for other navigation use cases."
  },
  {
    "title": "CLMonitoringStateSatisfied | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringstate/clmonitoringstatesatisfied",
    "html": "See Also\nCondition states\nCLMonitoringStateUnknown\nThe condition is in an unknown state.\nCLMonitoringStateUnsatisfied\nThe condition is in an unsatisfied state."
  },
  {
    "title": "CLMonitoringStateUnsatisfied | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringstate/clmonitoringstateunsatisfied",
    "html": "See Also\nCondition states\nCLMonitoringStateSatisfied\nThe condition is in a satisfied state.\nCLMonitoringStateUnknown\nThe condition is in an unknown state."
  },
  {
    "title": "CLLiveUpdateConfigurationOtherNavigation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clliveupdateconfiguration/clliveupdateconfigurationothernavigation",
    "html": "See Also\nUpdate types\nCLLiveUpdateConfigurationDefault\nThe default configuration.\nCLLiveUpdateConfigurationAirborne\nA configuration for airborne use cases.\nCLLiveUpdateConfigurationAutomotiveNavigation\nA configuration for automotive navigation use cases.\nCLLiveUpdateConfigurationFitness\nA configuration for fitness use cases."
  },
  {
    "title": "resume | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdater/4126872-resume",
    "html": "See Also\nControlling the updater\n- invalidate\nInvalidates the updater.\n- pause\nPauses the updater."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/iterator/4155863-next",
    "html": "Return Value\n\nReturns a CLMonitor.Events.Element, or nil if the sequence is exhausted.\n\nRelationships\nFrom Protocol\nAsyncIteratorProtocol"
  },
  {
    "title": "CLMonitoringStateUnknown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringstate/clmonitoringstateunknown",
    "html": "See Also\nCondition states\nCLMonitoringStateSatisfied\nThe condition is in a satisfied state.\nCLMonitoringStateUnsatisfied\nThe condition is in an unsatisfied state."
  },
  {
    "title": "condition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringrecord/4240038-condition",
    "html": "See Also\nEvent properties\nlastEvent\nAn object that contains the specifics of the most recent event."
  },
  {
    "title": "lastEvent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringrecord/4155604-lastevent",
    "html": "Discussion\n\nThis includes the state, the date, and the specifics of the condition, if applicable.\n\nSee Also\nEvent properties\ncondition\nThe condition that the framework is monitoring events for."
  },
  {
    "title": "queue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitorconfiguration/4172835-queue",
    "html": "Discussion\n\nYou need to perform all interactions related to the CLMonitor instance on this queue, and the framework delivers events that the CLMonitor instance generates to the handler on this queue.\n\nSee Also\nInstance properties\neventHandler\nThe block the framework calls as the event handler for the location monitor instance.\nname\nThe name of the monitor instance."
  },
  {
    "title": "liveUpdaterWithConfiguration:queue:handler: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdater/4210217-liveupdaterwithconfiguration",
    "html": "Parameters\nconfiguration\n\nSpecifies the live update configuration that the framework uses.\n\nqueue\n\nSpecifies the queue to which the framework submits the handler with each available update.\n\nhandler\n\nThe block that the framework invokes with each update.\n\nReturn Value\n\nReturns a location updater instance with the specified configuration, queue, and update handler.\n\nSee Also\nCreating a location updater\n+ liveUpdaterWithQueue:handler:\nCreates a location updater on the queue you specify.\nCLLiveUpdateConfiguration\nSpecifies the types of locations that a location updater generates."
  },
  {
    "title": "CLError.Code.regionMonitoringResponseDelayed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/regionmonitoringresponsedelayed",
    "html": "Discussion\n\nThe user information dictionary might contain an alternate region that you can monitor instead. Use kCLErrorUserInfoAlternateRegionKey to retrieve the CLRegion object.\n\nSee Also\nGetting region monitoring errors\ncase regionMonitoringDenied\nA constant that indicates the user denied access to the region monitoring service.\ncase regionMonitoringFailure\nA constant that indicates the location manager failed to monitor a registered region.\ncase regionMonitoringSetupDelayed\nA constant that indicates Core Location failed to initialize the region monitoring feature."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/iterator/4211283-next",
    "html": "Return Value\n\nReturns the next CLLocationUpdate.Updates.Element, or nil if there are no additional elements available.\n\nRelationships\nFrom Protocol\nAsyncIteratorProtocol"
  },
  {
    "title": "liveUpdaterWithQueue:handler: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdater/4210218-liveupdaterwithqueue",
    "html": "Parameters\nqueue\n\nSpecifies the queue to which the framework submits the handler with each available update\n\nhandler\n\nThe block that the framework invokes with each update.\n\nReturn Value\n\nReturns a location updater instance with the specified queue and update handler.\n\nSee Also\nCreating a location updater\n+ liveUpdaterWithConfiguration:queue:handler:\nCreates a location updater with the configuration and queue that you specify.\nCLLiveUpdateConfiguration\nSpecifies the types of locations that a location updater generates."
  },
  {
    "title": "CLLiveUpdateConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clliveupdateconfiguration",
    "html": "Topics\nUpdate types\nCLLiveUpdateConfigurationDefault\nThe default configuration.\nCLLiveUpdateConfigurationAirborne\nA configuration for airborne use cases.\nCLLiveUpdateConfigurationAutomotiveNavigation\nA configuration for automotive navigation use cases.\nCLLiveUpdateConfigurationFitness\nA configuration for fitness use cases.\nCLLiveUpdateConfigurationOtherNavigation\nA configuration for other navigation use cases.\nSee Also\nCreating a location updater\n+ liveUpdaterWithConfiguration:queue:handler:\nCreates a location updater with the configuration and queue that you specify.\n+ liveUpdaterWithQueue:handler:\nCreates a location updater on the queue you specify."
  },
  {
    "title": "pause | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdater/4126871-pause",
    "html": "See Also\nControlling the updater\n- invalidate\nInvalidates the updater.\n- resume\nResumes the updater."
  },
  {
    "title": "invalidate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdater/4190867-invalidate",
    "html": "See Also\nControlling the updater\n- pause\nPauses the updater.\n- resume\nResumes the updater."
  },
  {
    "title": "location | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clupdate/4126879-location",
    "html": "Discussion\n\nIf the location isn’t available, the value is nil.\n\nSee Also\nUpdate properties\nisStationary\nA Boolean value that indicates whether the device is stationary."
  },
  {
    "title": "UUID | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconidentitycondition/4240023-uuid",
    "html": "See Also\nAccessing the beacon’s properties\nmajor\nThe most significant value associated with the beacon.\nminor\nThe least significant value associated with the beacon."
  },
  {
    "title": "isStationary | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clupdate/4126878-isstationary",
    "html": "Discussion\n\nUpdates may stop flowing temporarily for several reasons including if the app is no longer authorized to receive location updates or if its location becomes unknown. If Core Location stops delivering updates because the device is stationary, then it sets isStationary to YES; otherwise, it’s NO.\n\nIf isStationary is YES, then the framework can suspend updates until the person starts moving, or their location becomes unknown.\n\nSee Also\nUpdate properties\nlocation\nA person’s location, if available."
  },
  {
    "title": "minor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconidentitycondition/4240028-minor",
    "html": "See Also\nAccessing the beacon’s properties\nUUID\nA universally unique identifier that represent the beacon’s identifier.\nmajor\nThe most significant value associated with the beacon."
  },
  {
    "title": "CLDeviceOrientation.portraitUpsideDown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cldeviceorientation/portraitupsidedown",
    "html": "See Also\nDevice Orientations\ncase unknown\nThe orientation is currently not known.\ncase portrait\nThe device is in portrait mode, with the device held upright and the home button at the bottom.\ncase landscapeLeft\nThe device is in landscape mode, with the device held upright and the home button on the right side.\ncase landscapeRight\nThe device is in landscape mode, with the device held upright and the home button on the left side.\ncase faceUp\nThe device is held parallel to the ground with the screen facing upwards.\ncase faceDown\nThe device is held parallel to the ground with the screen facing downwards."
  },
  {
    "title": "CLMonitoringState | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringstate",
    "html": "Topics\nCondition states\nCLMonitoringStateSatisfied\nThe condition is in a satisfied state.\nCLMonitoringStateUnknown\nThe condition is in an unknown state.\nCLMonitoringStateUnsatisfied\nThe condition is in an unsatisfied state.\nConstants\nCLMonitoringStateUnmonitored\nSee Also\nEvent properties\ndate\nThe date the event occurs.\nidentifier\nA string that represents the identifier of a monitored condition.\nrefinement\nAn optional instance of a condition that represents the most specific condition to that this event can apply to.\nstate\nThe state of the condition at the time of the event."
  },
  {
    "title": "date | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringevent/4155594-date",
    "html": "See Also\nEvent properties\nidentifier\nA string that represents the identifier of a monitored condition.\nrefinement\nAn optional instance of a condition that represents the most specific condition to that this event can apply to.\nstate\nThe state of the condition at the time of the event.\nCLMonitoringState\nValues that represent the current state of a monitoring condition."
  },
  {
    "title": "identifier | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringevent/4155595-identifier",
    "html": "See Also\nEvent properties\ndate\nThe date the event occurs.\nrefinement\nAn optional instance of a condition that represents the most specific condition to that this event can apply to.\nstate\nThe state of the condition at the time of the event.\nCLMonitoringState\nValues that represent the current state of a monitoring condition."
  },
  {
    "title": "eventHandler | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitorconfiguration/4172833-eventhandler",
    "html": "See Also\nInstance properties\nname\nThe name of the monitor instance.\nqueue\nThe dispatch queue to bind the instance of a location monitor to."
  },
  {
    "title": "state | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringevent/4155597-state",
    "html": "See Also\nEvent properties\ndate\nThe date the event occurs.\nidentifier\nA string that represents the identifier of a monitored condition.\nrefinement\nAn optional instance of a condition that represents the most specific condition to that this event can apply to.\nCLMonitoringState\nValues that represent the current state of a monitoring condition."
  },
  {
    "title": "refinement | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringevent/4155596-refinement",
    "html": "Discussion\n\nThe type of the refinement condition depends on the monitored condition itself.\n\nSee Also\nEvent properties\ndate\nThe date the event occurs.\nidentifier\nA string that represents the identifier of a monitored condition.\nstate\nThe state of the condition at the time of the event.\nCLMonitoringState\nValues that represent the current state of a monitoring condition."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitorconfiguration/4172834-name",
    "html": "Discussion\n\nname can contain only alphanumeric characters and can’t start with an underscore (_).\n\nSee Also\nInstance properties\neventHandler\nThe block the framework calls as the event handler for the location monitor instance.\nqueue\nThe dispatch queue to bind the instance of a location monitor to."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4172830-name",
    "html": "See Also\nAccessing the location monitor’s identifiers\nmonitoredIdentifiers\nAn array that contains all the identifiers for each condition that the monitor is monitoring."
  },
  {
    "title": "CLError.Code.geocodeCanceled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/geocodecanceled",
    "html": "See Also\nGetting geocoding errors\ncase geocodeFoundNoResult\nA constant that indicates the geocode request yielded no result.\ncase geocodeFoundPartialResult\nA constant that indicates the geocode request yielded a partial result."
  },
  {
    "title": "CLRegionState.unknown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregionstate/unknown",
    "html": "See Also\nRegion States\ncase inside\nThe location is inside of the given region.\ncase outside\nThe location is outside of the given region."
  },
  {
    "title": "initWithUUID:major:minor: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconidentitycondition/4240026-initwithuuid",
    "html": "Parameters\nuuid\n\nA UUID to use as the beacon’s identifier.\n\nmajor\n\nA CLBeaconMajorValue to use as the beacon’s major value.\n\nminor\n\nA CLBeaconMinorValue to use as the beacon’s minor value.\n\nSee Also\nCreating beacon identity conditions\n- initWithUUID:\nCreates a new beacon identity condition with the identifier you specify.\n- initWithUUID:major:\nCreates a new beacon identity condition with the identifier and major value you specify."
  },
  {
    "title": "initWithUUID:major: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconidentitycondition/4240025-initwithuuid",
    "html": "Parameters\nuuid\n\nA UUID to use as the beacon’s identifier.\n\nmajor\n\nA CLBeaconMajorValue to use as the beacon’s major value.\n\nSee Also\nCreating beacon identity conditions\n- initWithUUID:\nCreates a new beacon identity condition with the identifier you specify.\n- initWithUUID:major:minor:\nCreates a new beacon identity condition with the identifier, and major and minor values you specify."
  },
  {
    "title": "initWithUUID: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconidentitycondition/4240024-initwithuuid",
    "html": "Parameters\nuuid\n\nA UUID to use as the beacon’s identifier.\n\nSee Also\nCreating beacon identity conditions\n- initWithUUID:major:\nCreates a new beacon identity condition with the identifier and major value you specify.\n- initWithUUID:major:minor:\nCreates a new beacon identity condition with the identifier, and major and minor values you specify."
  },
  {
    "title": "init(center:radius:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/circulargeographiccondition/4240073-init",
    "html": "Parameters\ncenter\n\nThe center point of the circular geographic condition.\n\nradius\n\nThe radius of the circular geographic condition, in meters.\n\nSee Also\nCreating a circular geographic condition\ninit(from: Decoder)\nCreates a circular geographic condition from previously saved data."
  },
  {
    "title": "major | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconidentitycondition/4240027-major",
    "html": "See Also\nAccessing the beacon’s properties\nUUID\nA universally unique identifier that represent the beacon’s identifier.\nminor\nThe least significant value associated with the beacon."
  },
  {
    "title": "major | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconidentityconstraint/3240602-major",
    "html": "Discussion\n\nThe major characteristic is optional. If it’s present, a beacon’s major value needs to match the constraint’s major value to represent a match. If the constraint has no major value, it acts as a wildcard and matches any major value. You can specify the major value when initializing the constraint.\n\nSee Also\nGetting the beacon identity\nvar minor: UInt16?\nThe constraint’s value for the minor identity characteristic."
  },
  {
    "title": "CLProximity.immediate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clproximity/immediate",
    "html": "See Also\nProximity Values\ncase unknown\nThe proximity of the beacon could not be determined.\ncase near\nThe beacon is relatively close to the user.\ncase far\nThe beacon is far away."
  },
  {
    "title": "requestMonitorWithConfiguration:completion: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4240037-requestmonitorwithconfiguration",
    "html": "Parameters\nconfig\n\nThe configuration that describes the conditions that satisfy this location monitor.\n\ncompletionHandler\n\nThe handler the framework calls with events that satisfy the monitor’s conditions.\n\nDiscussion\n\nConfigure the location monitor by adding or removing conditions for monitoring by this instance of CLMonitor. When an event occurs, the framework calls the block you pass in on the specified queue and delivers an instance of CLMonitoringEvent. The event contains the identifier for the condition you’re monitoring, an optional instance of CLCondition containing specifics, the new state, and the event’s timestamp.\n\nAll interaction directly with the returned CLMonitor needs to occur on the specified queue. Failing to do so results in undefined behavior.\n\nConditions you add to an instance of CLMonitor persist until you remove them from monitoring. However, Core Location stops monitoring conditions if an event is pending for them, and there isn’t a configured CLMonitor to receive it.\n\nThe framework stores conditions in an opaque file at ~/Library/CoreLocation/BundleId. Alternatively, you can access the conditions in the file at ~/Library/CoreLocation/process name/name.monitor. You can determine your app’s process name using the ActivityMonitor app or by using the UNIX ps -al command in Terminal.\n\nNote that for containerized apps, this is inside the data container. Apps need to observe when protected data becomes available using UIApplicationProtectedDataDidBecomeAvailable before creating a CLMonitor instance. Persistence of conditions enables an app to query efficiently for conditions it’s currently monitoring and the most recent event it delivers for each.\n\nThe app can choose to initialize the monitoring state for a condition. By default, the monitoring state is CLMonitoringStateUnknown.\n\nNote\n\nAn app can only open one instance of CLMonitor with a given name at a time. Attempting to open another instance with the same name returns false.\n\nSee Also\nCreating a monitor\nCLMonitorConfiguration\nAn object for configuring a location monitor instance."
  },
  {
    "title": "CLMonitoringRecord | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringrecord",
    "html": "Overview\n\nWhen handling a new CLMonitoringEvent, the CLMonitoringRecord available for the indicated identifier from the CLMonitor contains the prior event. The CLMonitoringRecord updates with the new event when the handling is complete.\n\nTopics\nEvent properties\ncondition\nThe condition that the framework is monitoring events for.\nlastEvent\nAn object that contains the specifics of the most recent event.\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nLocation monitor events\nCLMonitoringEvent\nThe object that the framework passes to the monitor’s callback handler upon receiving an event."
  },
  {
    "title": "CLMonitorConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitorconfiguration",
    "html": "Topics\nCreating a monitor configuration\n+ configWithMonitorName:queue:eventHandler:\nCreates a location monitor instance with the name, dispatch queue, and event handler you specify.\nInstance properties\neventHandler\nThe block the framework calls as the event handler for the location monitor instance.\nname\nThe name of the monitor instance.\nqueue\nThe dispatch queue to bind the instance of a location monitor to.\nRelationships\nInherits From\nNSObject\nSee Also\nCreating a monitor\n+ requestMonitorWithConfiguration:completion:\nCreates a location monitor with the configuration and event handler you provide."
  },
  {
    "title": "CLMonitoringEvent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitoringevent",
    "html": "Overview\n\nInstances of CLMonitoringEvent contain detailed information about an event in the monitoring of a CLCondition by a CLMonitor.\n\nTopics\nEvent properties\ndate\nThe date the event occurs.\nidentifier\nA string that represents the identifier of a monitored condition.\nrefinement\nAn optional instance of a condition that represents the most specific condition to that this event can apply to.\nstate\nThe state of the condition at the time of the event.\nCLMonitoringState\nValues that represent the current state of a monitoring condition.\nRelationships\nInherits From\nNSObject\nConforms To\nNSSecureCoding\nSee Also\nLocation monitor events\nCLMonitoringRecord\nAn object that represents a condition and its associated information that a location monitor is monitoring."
  },
  {
    "title": "monitoredIdentifiers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4155590-monitoredidentifiers",
    "html": "See Also\nAccessing the location monitor’s identifiers\nname\nThe name associated with the location monitor instance."
  },
  {
    "title": "radius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clcirculargeographiccondition/4240032-radius",
    "html": "See Also\nInstance properties\ncenter\nThe center of the circular geographic condition."
  },
  {
    "title": "initWithCenter:radius: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clcirculargeographiccondition/4240031-initwithcenter",
    "html": "Parameters\ncenter\n\nThe center of the circular geographic condition.\n\nradius\n\nThe radius of the circular geographic condition.\n\nReturn Value\n\nReturns an instance of CLCircularGeographicCondition with the specified center coordinate and radius."
  },
  {
    "title": "center | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clcirculargeographiccondition/4240030-center",
    "html": "See Also\nInstance properties\nradius\nThe radius of the circular geographic condition."
  },
  {
    "title": "CLError.Code.headingFailure | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/headingfailure",
    "html": "See Also\nGetting general errors\ncase locationUnknown\nA constant that indicates the location manager was unable to obtain a location value right now.\ncase denied\nA constant that indicates the user denied access to the location service.\ncase promptDeclined\nA constant that indicates the user didn’t grant the requested temporary authorization.\ncase network\nA constant that indicates the network was unavailable or a network error occurred.\ncase rangingUnavailable\nA constant that indicates ranging is disabled.\ncase rangingFailure\nA constant that indicates a general ranging error occurred."
  },
  {
    "title": "CLError.Code.denied | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/denied",
    "html": "See Also\nGetting general errors\ncase locationUnknown\nA constant that indicates the location manager was unable to obtain a location value right now.\ncase promptDeclined\nA constant that indicates the user didn’t grant the requested temporary authorization.\ncase network\nA constant that indicates the network was unavailable or a network error occurred.\ncase headingFailure\nA constant that indicates the location manager can’t determine the heading.\ncase rangingUnavailable\nA constant that indicates ranging is disabled.\ncase rangingFailure\nA constant that indicates a general ranging error occurred."
  },
  {
    "title": "CLError.Code.rangingFailure | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/rangingfailure",
    "html": "See Also\nGetting general errors\ncase locationUnknown\nA constant that indicates the location manager was unable to obtain a location value right now.\ncase denied\nA constant that indicates the user denied access to the location service.\ncase promptDeclined\nA constant that indicates the user didn’t grant the requested temporary authorization.\ncase network\nA constant that indicates the network was unavailable or a network error occurred.\ncase headingFailure\nA constant that indicates the location manager can’t determine the heading.\ncase rangingUnavailable\nA constant that indicates ranging is disabled."
  },
  {
    "title": "CLError.Code.regionMonitoringDenied | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/regionmonitoringdenied",
    "html": "See Also\nGetting region monitoring errors\ncase regionMonitoringFailure\nA constant that indicates the location manager failed to monitor a registered region.\ncase regionMonitoringSetupDelayed\nA constant that indicates Core Location failed to initialize the region monitoring feature.\ncase regionMonitoringResponseDelayed\nA constant that indicates Core Location will deliver events but they may be delayed."
  },
  {
    "title": "CLError.Code.rangingUnavailable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/rangingunavailable",
    "html": "Discussion\n\nThis might happen if the device is in Airplane mode or if Bluetooth or location services are disabled.\n\nSee Also\nGetting general errors\ncase locationUnknown\nA constant that indicates the location manager was unable to obtain a location value right now.\ncase denied\nA constant that indicates the user denied access to the location service.\ncase promptDeclined\nA constant that indicates the user didn’t grant the requested temporary authorization.\ncase network\nA constant that indicates the network was unavailable or a network error occurred.\ncase headingFailure\nA constant that indicates the location manager can’t determine the heading.\ncase rangingFailure\nA constant that indicates a general ranging error occurred."
  },
  {
    "title": "CLError.Code.regionMonitoringSetupDelayed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/regionmonitoringsetupdelayed",
    "html": "See Also\nGetting region monitoring errors\ncase regionMonitoringDenied\nA constant that indicates the user denied access to the region monitoring service.\ncase regionMonitoringFailure\nA constant that indicates the location manager failed to monitor a registered region.\ncase regionMonitoringResponseDelayed\nA constant that indicates Core Location will deliver events but they may be delayed."
  },
  {
    "title": "CLLocationUpdater | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdater",
    "html": "Topics\nCreating a location updater\n+ liveUpdaterWithConfiguration:queue:handler:\nCreates a location updater with the configuration and queue that you specify.\n+ liveUpdaterWithQueue:handler:\nCreates a location updater on the queue you specify.\nCLLiveUpdateConfiguration\nSpecifies the types of locations that a location updater generates.\nControlling the updater\n- invalidate\nInvalidates the updater.\n- pause\nPauses the updater.\n- resume\nResumes the updater.\nRelationships\nInherits From\nNSObject\nSee Also\nLocation updates\nGetting the current location of a device\nStart location services and provide information the system needs to optimize power usage for those services.\nHandling location updates in the background\nConfigure your app to receive location updates when it isn’t running in the foreground.\nCreating a location push service extension\nAdd and configure an extension to enable your location sharing app to access a user’s location in response to a request from another user.\nCLLocation\nThe latitude, longitude, and course information reported by the system.\nCLLocationCoordinate2D\nThe latitude and longitude associated with a location, specified using the WGS 84 reference frame.\nCLFloor\nThe floor of a building on which the user's device is located.\nCLVisit\nInformation about the user's location during a specific period of time.\nCLLocationSourceInformation\nInformation about the source that provides a location."
  },
  {
    "title": "CLError.Code.geocodeFoundNoResult | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/geocodefoundnoresult",
    "html": "See Also\nGetting geocoding errors\ncase geocodeCanceled\nA constant that indicates the geocode request was canceled.\ncase geocodeFoundPartialResult\nA constant that indicates the geocode request yielded a partial result."
  },
  {
    "title": "CLUpdate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clupdate",
    "html": "Topics\nUpdate properties\nisStationary\nA Boolean value that indicates whether the device is stationary.\nlocation\nA person’s location, if available.\nRelationships\nInherits From\nNSObject\nSee Also\nMonitoring\nCLMonitor\nAn object that monitors the conditions you add to it."
  },
  {
    "title": "CLError.Code.geocodeFoundPartialResult | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/geocodefoundpartialresult",
    "html": "See Also\nGetting geocoding errors\ncase geocodeCanceled\nA constant that indicates the geocode request was canceled.\ncase geocodeFoundNoResult\nA constant that indicates the geocode request yielded no result."
  },
  {
    "title": "CLError.Code.deferredFailed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/deferredfailed",
    "html": "Discussion\n\nThis error can occur if GPS is unavailable, not active, or is temporarily interrupted. If you get this error on a device that has GPS hardware, the solution is to try again.\n\nSee Also\nGetting deffered location update errors\ncase deferredCanceled\nA constant that indicates your app or the location manager canceled the request for deferred updates.\ncase deferredAccuracyTooLow\nA constant that indicates deferred mode isn’t supported for the requested accuracy.\ncase deferredDistanceFiltered\nA constant that indicates deferred mode doesn’t support distance filters.\ncase deferredNotUpdatingLocation\nA constant that indicates the location manager didn’t enter deferred mode because location updates were already disabled or paused."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155868-compactmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155885-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155899-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure."
  },
  {
    "title": "minor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/1621414-minor",
    "html": "Discussion\n\nIf you don’t specify a minor value for the beacon, the value of this property is nil. Operations that compare a beacon’s identity characteristics with the constraint’s characteristics ignore the minor value if this property is nil.\n\nSee Also\nGetting the beacon identity\nvar uuid: UUID\nThe UUID value from the beacon identity constraint that defines the beacon region.\nDeprecated\nvar major: NSNumber?\nThe major value from the beacon identity constraint that defines the beacon region.\nDeprecated\nvar beaconIdentityConstraint: CLBeaconIdentityConstraint\nThe beacon identity constraint that defines the beacon region.\nDeprecated"
  },
  {
    "title": "CLBeaconMinorValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconminorvalue",
    "html": "See Also\nCreating a beacon region\ninit(beaconIdentityConstraint: CLBeaconIdentityConstraint, identifier: String)\nCreates and returns a region object that targets beacons that satisfy the specified beacon identity constraints.\nDeprecated\ninit(uuid: UUID, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID.\nDeprecated\ninit(uuid: UUID, major: CLBeaconMajorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID and major value.\nDeprecated\ninit(uuid: UUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID, and major and minor values.\nDeprecated\ntypealias CLBeaconMajorValue\nThe most significant value in a beacon."
  },
  {
    "title": "CLMonitor.Events.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/iterator",
    "html": "Overview\n\nUse CLMonitor.Events.Iterator to process events that CLMonitor delivers.\n\nTopics\nType aliases\ntypealias CLMonitor.Events.Iterator.Element\nThe type that represents the iterator’s element.\nGetting the next element\nfunc next() -> CLMonitor.Events.Element?\nGets the next element in the sequence.\nRelationships\nConforms To\nAsyncIteratorProtocol"
  },
  {
    "title": "locationUnknown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320673-locationunknown",
    "html": "See Also\nGetting general errors\nstatic var denied: CLError.Code\nA constant that indicates the user denied access to the location service.\nstatic var promptDeclined: CLError.Code\nA constant that indicates the user didn’t grant the requested temporary authorization.\nstatic var network: CLError.Code\nA constant that indicates the network was unavailable or a network error occurred.\nstatic var headingFailure: CLError.Code\nA constant that indicates the location manager can’t determine the heading.\nstatic var rangingUnavailable: CLError.Code\nA constant that indicates ranging is disabled.\nstatic var rangingFailure: CLError.Code\nA constant that indicates a general ranging error occurred.\nenum CLError.Code\nError codes returned by the location manager object."
  },
  {
    "title": "headingFailure | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320676-headingfailure",
    "html": "See Also\nGetting general errors\nstatic var locationUnknown: CLError.Code\nA constant that indicates the location manager was unable to obtain a location value right now.\nstatic var denied: CLError.Code\nA constant that indicates the user denied access to the location service.\nstatic var promptDeclined: CLError.Code\nA constant that indicates the user didn’t grant the requested temporary authorization.\nstatic var network: CLError.Code\nA constant that indicates the network was unavailable or a network error occurred.\nstatic var rangingUnavailable: CLError.Code\nA constant that indicates ranging is disabled.\nstatic var rangingFailure: CLError.Code\nA constant that indicates a general ranging error occurred.\nenum CLError.Code\nError codes returned by the location manager object."
  },
  {
    "title": "CLError.Code.deferredAccuracyTooLow | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/deferredaccuracytoolow",
    "html": "Discussion\n\nThe accuracy must be set to kCLLocationAccuracyBest or kCLLocationAccuracyBestForNavigation.\n\nSee Also\nGetting deffered location update errors\ncase deferredFailed\nA constant that indicates the location manager didn’t enter deferred mode for an unknown reason.\ncase deferredCanceled\nA constant that indicates your app or the location manager canceled the request for deferred updates.\ncase deferredDistanceFiltered\nA constant that indicates deferred mode doesn’t support distance filters.\ncase deferredNotUpdatingLocation\nA constant that indicates the location manager didn’t enter deferred mode because location updates were already disabled or paused."
  },
  {
    "title": "CLError.Code.deferredCanceled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/deferredcanceled",
    "html": "Discussion\n\nThis error is returned if you call the disallowDeferredLocationUpdates() method or schedule a new deferred update before the previous deferred update request is processed. The location manager may also report this error too. For example, if the app is in the foreground when a new location is determined, the location manager cancels deferred updates and delivers the location data to your app.\n\nSee Also\nGetting deffered location update errors\ncase deferredFailed\nA constant that indicates the location manager didn’t enter deferred mode for an unknown reason.\ncase deferredAccuracyTooLow\nA constant that indicates deferred mode isn’t supported for the requested accuracy.\ncase deferredDistanceFiltered\nA constant that indicates deferred mode doesn’t support distance filters.\ncase deferredNotUpdatingLocation\nA constant that indicates the location manager didn’t enter deferred mode because location updates were already disabled or paused."
  },
  {
    "title": "CLError.Code.deferredDistanceFiltered | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/deferreddistancefiltered",
    "html": "Discussion\n\nSet the distance filter to kCLDistanceFilterNone.\n\nSee Also\nGetting deffered location update errors\ncase deferredFailed\nA constant that indicates the location manager didn’t enter deferred mode for an unknown reason.\ncase deferredCanceled\nA constant that indicates your app or the location manager canceled the request for deferred updates.\ncase deferredAccuracyTooLow\nA constant that indicates deferred mode isn’t supported for the requested accuracy.\ncase deferredNotUpdatingLocation\nA constant that indicates the location manager didn’t enter deferred mode because location updates were already disabled or paused."
  },
  {
    "title": "CLError.Code.deferredNotUpdatingLocation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/deferrednotupdatinglocation",
    "html": "See Also\nGetting deffered location update errors\ncase deferredFailed\nA constant that indicates the location manager didn’t enter deferred mode for an unknown reason.\ncase deferredCanceled\nA constant that indicates your app or the location manager canceled the request for deferred updates.\ncase deferredAccuracyTooLow\nA constant that indicates deferred mode isn’t supported for the requested accuracy.\ncase deferredDistanceFiltered\nA constant that indicates deferred mode doesn’t support distance filters."
  },
  {
    "title": "CLRegionState.inside | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregionstate/inside",
    "html": "See Also\nRegion States\ncase unknown\nIt is unknown whether the location is inside or outside of the region.\ncase outside\nThe location is outside of the given region."
  },
  {
    "title": "CLRegionState.outside | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregionstate/outside",
    "html": "See Also\nRegion States\ncase unknown\nIt is unknown whether the location is inside or outside of the region.\ncase inside\nThe location is inside of the given region."
  },
  {
    "title": "lastEvent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/record/4155902-lastevent",
    "html": "Discussion\n\nThe event record contains the specifics of the most recent event, including its state, date, and the specifics of the condition, if applicable.\n\nSee Also\nRecord characteristics\nlet condition: CLCondition\nThe condition that the framework is monitoring for."
  },
  {
    "title": "center | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/circulargeographiccondition/4240071-center",
    "html": "See Also\nCondition characteristics\nlet radius: CLLocationDistance\nThe radius of the condition’s area, in meters."
  },
  {
    "title": "condition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/record/4240077-condition",
    "html": "See Also\nRecord characteristics\nlet lastEvent: CLMonitor.Event\nThe most recent event the monitor records."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/circulargeographiccondition/4240074-init",
    "html": "Parameters\ndecoder\n\nA decoder that implements the Decoder protocol.\n\nRelationships\nFrom Protocol\nDecodable\nSee Also\nCreating a circular geographic condition\ninit(center: CLLocationCoordinate2D, radius: CLLocationDistance)\nCreates a circular geographic condition with a center point and radius you specify."
  },
  {
    "title": "CLDeviceOrientation.portrait | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cldeviceorientation/portrait",
    "html": "See Also\nDevice Orientations\ncase unknown\nThe orientation is currently not known.\ncase portraitUpsideDown\nThe device is in portrait mode but upside down, with the device held upright and the home button at the top.\ncase landscapeLeft\nThe device is in landscape mode, with the device held upright and the home button on the right side.\ncase landscapeRight\nThe device is in landscape mode, with the device held upright and the home button on the left side.\ncase faceUp\nThe device is held parallel to the ground with the screen facing upwards.\ncase faceDown\nThe device is held parallel to the ground with the screen facing downwards."
  },
  {
    "title": "CLError.Code.regionMonitoringFailure | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/regionmonitoringfailure",
    "html": "Discussion\n\nMonitoring can fail if the app exceeds the maximum number of regions that it can monitor simultaneously. Monitoring can also fail if the region’s radius distance is too large.\n\nSee Also\nGetting region monitoring errors\ncase regionMonitoringDenied\nA constant that indicates the user denied access to the region monitoring service.\ncase regionMonitoringSetupDelayed\nA constant that indicates Core Location failed to initialize the region monitoring feature.\ncase regionMonitoringResponseDelayed\nA constant that indicates Core Location will deliver events but they may be delayed."
  },
  {
    "title": "CLDeviceOrientation.landscapeRight | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cldeviceorientation/landscaperight",
    "html": "See Also\nDevice Orientations\ncase unknown\nThe orientation is currently not known.\ncase portrait\nThe device is in portrait mode, with the device held upright and the home button at the bottom.\ncase portraitUpsideDown\nThe device is in portrait mode but upside down, with the device held upright and the home button at the top.\ncase landscapeLeft\nThe device is in landscape mode, with the device held upright and the home button on the right side.\ncase faceUp\nThe device is held parallel to the ground with the screen facing upwards.\ncase faceDown\nThe device is held parallel to the ground with the screen facing downwards."
  },
  {
    "title": "CLDeviceOrientation.landscapeLeft | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cldeviceorientation/landscapeleft",
    "html": "See Also\nDevice Orientations\ncase unknown\nThe orientation is currently not known.\ncase portrait\nThe device is in portrait mode, with the device held upright and the home button at the bottom.\ncase portraitUpsideDown\nThe device is in portrait mode but upside down, with the device held upright and the home button at the top.\ncase landscapeRight\nThe device is in landscape mode, with the device held upright and the home button on the left side.\ncase faceUp\nThe device is held parallel to the ground with the screen facing upwards.\ncase faceDown\nThe device is held parallel to the ground with the screen facing downwards."
  },
  {
    "title": "kCLLocationAccuracyNearestTenMeters | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kcllocationaccuracynearesttenmeters",
    "html": "Discussion\n\nThis level of accurate is available only if isAuthorizedForPreciseLocation is true.\n\nSee Also\nDesired Accuracy Constants\nlet kCLLocationAccuracyBestForNavigation: CLLocationAccuracy\nThe highest possible accuracy that uses additional sensor data to facilitate navigation apps.\nlet kCLLocationAccuracyBest: CLLocationAccuracy\nThe best level of accuracy available.\nlet kCLLocationAccuracyHundredMeters: CLLocationAccuracy\nAccurate to within one hundred meters.\nlet kCLLocationAccuracyKilometer: CLLocationAccuracy\nAccurate to the nearest kilometer.\nlet kCLLocationAccuracyThreeKilometers: CLLocationAccuracy\nAccurate to the nearest three kilometers.\nlet kCLLocationAccuracyReduced: CLLocationAccuracy\nThe level of accuracy used when an app isn’t authorized for full accuracy location data."
  },
  {
    "title": "init(uuid:major:identifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/3183026-init",
    "html": "Parameters\nuuid\n\nA UUID that identifies the beacons to target.\n\nmajor\n\nThe CLBeaconMajorValue that characterizes beacons for this region to target.\n\nidentifier\n\nA unique identifier to associate with the returned region object. You use this identifier to differentiate regions within your app. This value can’t be nil.\n\nSee Also\nCreating a beacon region\ninit(beaconIdentityConstraint: CLBeaconIdentityConstraint, identifier: String)\nCreates and returns a region object that targets beacons that satisfy the specified beacon identity constraints.\nDeprecated\ninit(uuid: UUID, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID.\nDeprecated\ninit(uuid: UUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID, and major and minor values.\nDeprecated\ntypealias CLBeaconMajorValue\nThe most significant value in a beacon.\ntypealias CLBeaconMinorValue\nThe least significant value in a beacon."
  },
  {
    "title": "init(uuid:identifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/3183025-init",
    "html": "Parameters\nuuid\n\nA UUID that identifies the beacons to target.\n\nidentifier\n\nA unique identifier to associate with the returned region object. You use this identifier to differentiate regions within your app. This value can’t be nil.\n\nSee Also\nCreating a beacon region\ninit(beaconIdentityConstraint: CLBeaconIdentityConstraint, identifier: String)\nCreates and returns a region object that targets beacons that satisfy the specified beacon identity constraints.\nDeprecated\ninit(uuid: UUID, major: CLBeaconMajorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID and major value.\nDeprecated\ninit(uuid: UUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID, and major and minor values.\nDeprecated\ntypealias CLBeaconMajorValue\nThe most significant value in a beacon.\ntypealias CLBeaconMinorValue\nThe least significant value in a beacon."
  },
  {
    "title": "kCLLocationAccuracyBestForNavigation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kcllocationaccuracybestfornavigation",
    "html": "Discussion\n\nThis level of accuracy is intended for use in navigation apps that require precise position information at all times. Because of the extra power requirements, use this level of accuracy only while the device is plugged in.\n\nThis level of accurate is available only if isAuthorizedForPreciseLocation is true.\n\nSee Also\nDesired Accuracy Constants\nlet kCLLocationAccuracyBest: CLLocationAccuracy\nThe best level of accuracy available.\nlet kCLLocationAccuracyNearestTenMeters: CLLocationAccuracy\nAccurate to within ten meters of the desired target.\nlet kCLLocationAccuracyHundredMeters: CLLocationAccuracy\nAccurate to within one hundred meters.\nlet kCLLocationAccuracyKilometer: CLLocationAccuracy\nAccurate to the nearest kilometer.\nlet kCLLocationAccuracyThreeKilometers: CLLocationAccuracy\nAccurate to the nearest three kilometers.\nlet kCLLocationAccuracyReduced: CLLocationAccuracy\nThe level of accuracy used when an app isn’t authorized for full accuracy location data."
  },
  {
    "title": "CLProximity.near | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clproximity/near",
    "html": "See Also\nProximity Values\ncase unknown\nThe proximity of the beacon could not be determined.\ncase immediate\nThe beacon is in the user’s immediate vicinity.\ncase far\nThe beacon is far away."
  },
  {
    "title": "CLProximity.far | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clproximity/far",
    "html": "See Also\nProximity Values\ncase unknown\nThe proximity of the beacon could not be determined.\ncase immediate\nThe beacon is in the user’s immediate vicinity.\ncase near\nThe beacon is relatively close to the user."
  },
  {
    "title": "addConditionForMonitoring:identifier:assumedState: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4240035-addconditionformonitoring",
    "html": "Parameters\ncondition\n\nA CLCondition to monitor for.\n\nidentifier\n\nA string you use to identify this condition.\n\nstate\n\nA CLMonitoringState that satisfies condition.\n\nSee Also\nAdding and removing conditions\n- addConditionForMonitoring:identifier:\nAdds a condition to monitor with the identifier you provide.\n- monitoringRecordForIdentifier:\nGets the monitoring record containing the condition and most recent monitoring event for the identifier you supply, if applicable.\n- removeConditionFromMonitoringWithIdentifier:\nRemoves the monitoring record with the identifier from monitoring."
  },
  {
    "title": "removeConditionFromMonitoringWithIdentifier: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4240036-removeconditionfrommonitoringwit",
    "html": "Parameters\nidentifier\n\nA string that identifies the monitoring record.\n\nSee Also\nAdding and removing conditions\n- addConditionForMonitoring:identifier:\nAdds a condition to monitor with the identifier you provide.\n- addConditionForMonitoring:identifier:assumedState:\nAdds a condition to monitor with the state and identifier you provide.\n- monitoringRecordForIdentifier:\nGets the monitoring record containing the condition and most recent monitoring event for the identifier you supply, if applicable."
  },
  {
    "title": "monitoringRecordForIdentifier: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4155591-monitoringrecordforidentifier",
    "html": "Parameters\nidentifier\n\nA string that identifies the monitoring record.\n\nReturn Value\n\nThe monitoring record; otherwise, nil.\n\nSee Also\nAdding and removing conditions\n- addConditionForMonitoring:identifier:\nAdds a condition to monitor with the identifier you provide.\n- addConditionForMonitoring:identifier:assumedState:\nAdds a condition to monitor with the state and identifier you provide.\n- removeConditionFromMonitoringWithIdentifier:\nRemoves the monitoring record with the identifier from monitoring."
  },
  {
    "title": "init(_:userInfo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/3726356-init",
    "html": "Parameters\ncode\n\nThe error code value.\n\nuserInfo\n\nThe dictionary containing information about the error."
  },
  {
    "title": "deferredLocationUpdatesAvailable() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423830-deferredlocationupdatesavailable",
    "html": "Return Value\n\ntrue if the device supports deferred location updates or false if it does not.\n\nDiscussion\n\nDeferred location updates are a way for the location manager to avoid frequently waking up a background app to deliver location changes. Normally, when an app wants location updates in the background, the app must be woken up whenever a new event arrives. Waking up the app consumes power, which in some situations might be wasted if the app cannot do anything with the location information other than log it and go back to sleep anyway. Deferring location updates gives you the ability to wait until a time when your app can do something useful with the data and then process the updates all at once.\n\nDeferred location updates require the presence of GPS hardware and may not be supported on all iOS devices.\n\nSee Also\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "init(uuid:major:minor:identifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/3183027-init",
    "html": "Parameters\nuuid\n\nA UUID that identifies the beacons to target.\n\nmajor\n\nThe CLBeaconMajorValue that characterizes beacons for this region to target.\n\nminor\n\nThe CLBeaconMinorValue that characterizes beacons for this region to target.\n\nidentifier\n\nA unique identifier to associate with the returned region object. You use this identifier to differentiate regions within your app. This value can’t be nil.\n\nSee Also\nCreating a beacon region\ninit(beaconIdentityConstraint: CLBeaconIdentityConstraint, identifier: String)\nCreates and returns a region object that targets beacons that satisfy the specified beacon identity constraints.\nDeprecated\ninit(uuid: UUID, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID.\nDeprecated\ninit(uuid: UUID, major: CLBeaconMajorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID and major value.\nDeprecated\ntypealias CLBeaconMajorValue\nThe most significant value in a beacon.\ntypealias CLBeaconMinorValue\nThe least significant value in a beacon."
  },
  {
    "title": "CLBeaconMajorValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconmajorvalue",
    "html": "See Also\nCreating a beacon region\ninit(beaconIdentityConstraint: CLBeaconIdentityConstraint, identifier: String)\nCreates and returns a region object that targets beacons that satisfy the specified beacon identity constraints.\nDeprecated\ninit(uuid: UUID, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID.\nDeprecated\ninit(uuid: UUID, major: CLBeaconMajorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID and major value.\nDeprecated\ninit(uuid: UUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID, and major and minor values.\nDeprecated\ntypealias CLBeaconMinorValue\nThe least significant value in a beacon."
  },
  {
    "title": "major | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/1621536-major",
    "html": "Discussion\n\nIf you don’t specify a major value for the beacon, the value of this property is nil. Operations that compare a beacon’s identity characteristics with the constraint’s characteristics ignore the major value if this property is nil.\n\nSee Also\nGetting the beacon identity\nvar uuid: UUID\nThe UUID value from the beacon identity constraint that defines the beacon region.\nDeprecated\nvar minor: NSNumber?\nThe minor value from the beacon identity constraint that defines the beacon region.\nDeprecated\nvar beaconIdentityConstraint: CLBeaconIdentityConstraint\nThe beacon identity constraint that defines the beacon region.\nDeprecated"
  },
  {
    "title": "uuid | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/3183022-uuid",
    "html": "Discussion\n\nTypically, the UUID is unique to your company and is the same for all of the beacons that you install. Use the major and minor values to differentiate the beacons in your installation.\n\nSee Also\nGetting the beacon identity\nvar major: NSNumber?\nThe major value from the beacon identity constraint that defines the beacon region.\nDeprecated\nvar minor: NSNumber?\nThe minor value from the beacon identity constraint that defines the beacon region.\nDeprecated\nvar beaconIdentityConstraint: CLBeaconIdentityConstraint\nThe beacon identity constraint that defines the beacon region.\nDeprecated"
  },
  {
    "title": "CLActivityType.airborne | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clactivitytype/airborne",
    "html": "Discussion\n\nUse this activity type for activities such as flying in an airplane or helicopter, paragliding, flying on a drone, skydiving, and so on. This activity also includes runway taxiing.\n\nSee Also\nActivity types\ncase other\nThe value that indicates the app is using location manager for an unspecified activity.\ncase automotiveNavigation\nThe value that indicates positioning in an automobile following a road network.\ncase fitness\nThe value that indicates positioning during dedicated fitness sessions, such as walking workouts, running workouts, cycling workouts, and so on.\ncase otherNavigation\nThe value that indicates positioning for activities that don’t or may not adhere to roads such as cycling, scooters, trains, boats and off-road vehicles."
  },
  {
    "title": "beaconIdentityConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/3240604-beaconidentityconstraint",
    "html": "See Also\nGetting the beacon identity\nvar uuid: UUID\nThe UUID value from the beacon identity constraint that defines the beacon region.\nDeprecated\nvar major: NSNumber?\nThe major value from the beacon identity constraint that defines the beacon region.\nDeprecated\nvar minor: NSNumber?\nThe minor value from the beacon identity constraint that defines the beacon region.\nDeprecated"
  },
  {
    "title": "notifyEntryStateOnDisplay | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/1621552-notifyentrystateondisplay",
    "html": "Discussion\n\nWhen you set this to true, the location manager sends beacon notifications when the user turns on the display and the device is already inside the region. These are notifications the framework sends even if your app isn’t running. In that situation, the system launches your app into the background so that it can handle the notifications. In both situations, the location manager calls the locationManager(_:didDetermineState:for:) method of its delegate object.\n\nThe default value for this property is false."
  },
  {
    "title": "init(proximityUUID:identifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/1621534-init",
    "html": "Deprecated\n\nUse init(uuid:identifier:) instead.\n\nParameters\nproximityUUID\n\nThe unique ID of the beacons you’re targeting. This value can’t be nil.\n\nidentifier\n\nA unique identifier to associate with the returned region object. You use this identifier to differentiate regions within your app. This value can’t be nil.\n\nReturn Value\n\nAn initialized beacon region object.\n\nDiscussion\n\nThis method creates a region that results in the reporting of all beacons with the specified proximityUUID value. The system ignores the major and minor values of the beacons.\n\nSee Also\nDeprecated\ninit(proximityUUID: UUID, major: CLBeaconMajorValue, identifier: String)\nCreates and returns a region object that targets a beacon with the specified proximity ID and major value.\nDeprecated\ninit(proximityUUID: UUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\nCreates and returns a region object that targets a beacon with the specified proximity ID, major value, and minor value.\nDeprecated\nvar proximityUUID: UUID\nThe unique ID of the beacons you’re targeting.\nDeprecated\nRelated Documentation\nLocation and Maps Programming Guide"
  },
  {
    "title": "init(proximityUUID:major:identifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/1621475-init",
    "html": "Deprecated\n\nUse init(uuid:major:identifier:) instead.\n\nParameters\nproximityUUID\n\nThe unique ID of the beacons you’re targeting. This value can’t be nil.\n\nmajor\n\nThe major value that you use to identify one or more beacons.\n\nidentifier\n\nA unique identifier to associate with the returned region object. You use this identifier to differentiate regions within your app. This value can’t be nil.\n\nReturn Value\n\nAn initialized beacon region object.\n\nDiscussion\n\nThis method creates a region that reports all beacons with the specified proximityUUID and major values. The system ignores the beacon’s minor value.\n\nSee Also\nDeprecated\ninit(proximityUUID: UUID, identifier: String)\nCreates and returns a region object that targets a beacon with the specified UUID.\nDeprecated\ninit(proximityUUID: UUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\nCreates and returns a region object that targets a beacon with the specified proximity ID, major value, and minor value.\nDeprecated\nvar proximityUUID: UUID\nThe unique ID of the beacons you’re targeting.\nDeprecated"
  },
  {
    "title": "init(proximityUUID:major:minor:identifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/1621392-init",
    "html": "Deprecated\n\nUse init(uuid:major:minor:identifier:) instead.\n\nParameters\nproximityUUID\n\nThe proximity ID of the beacon you’re targeting. This value can’t be nil.\n\nmajor\n\nThe major value that you use to identify one or more beacons.\n\nminor\n\nThe minor value that you use to identify a specific beacon.\n\nidentifier\n\nA unique identifier to associate with the returned region object. You use this identifier to differentiate regions within your app. This value can’t be nil.\n\nReturn Value\n\nAn initialized beacon region object.\n\nDiscussion\n\nThis method creates a region that reports the beacon with the specified proximityUUID, major, and minor values.\n\nSee Also\nDeprecated\ninit(proximityUUID: UUID, identifier: String)\nCreates and returns a region object that targets a beacon with the specified UUID.\nDeprecated\ninit(proximityUUID: UUID, major: CLBeaconMajorValue, identifier: String)\nCreates and returns a region object that targets a beacon with the specified proximity ID and major value.\nDeprecated\nvar proximityUUID: UUID\nThe unique ID of the beacons you’re targeting.\nDeprecated"
  },
  {
    "title": "proximityUUID | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/1621556-proximityuuid",
    "html": "Deprecated\n\nUse uuid instead.\n\nDiscussion\n\nTypically, the UUID is unique to your company and is the same for all of the beacons that you install. Use the major and minor values to differentiate the beacons in your installation.\n\nSee Also\nDeprecated\ninit(proximityUUID: UUID, identifier: String)\nCreates and returns a region object that targets a beacon with the specified UUID.\nDeprecated\ninit(proximityUUID: UUID, major: CLBeaconMajorValue, identifier: String)\nCreates and returns a region object that targets a beacon with the specified proximity ID and major value.\nDeprecated\ninit(proximityUUID: UUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\nCreates and returns a region object that targets a beacon with the specified proximity ID, major value, and minor value.\nDeprecated"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155864-allsatisfy",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true.\n\nSee Also\nInstance methods\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155866-compactmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155882-flatmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155884-makeasynciterator",
    "html": "Relationships\nFrom Protocol\nAsyncSequence\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155887-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155889-max",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155893-prefix",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155891-min",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155897-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155895-prefix",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "CLMonitor.Events.AsyncIterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/asynciterator",
    "html": "See Also\nType aliases\ntypealias CLMonitor.Events.Element\nThe type that represents the event’s element."
  },
  {
    "title": "CLMonitor.Events.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/element",
    "html": "See Also\nType aliases\ntypealias CLMonitor.Events.AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence."
  },
  {
    "title": "denied | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320672-denied",
    "html": "See Also\nGetting general errors\nstatic var locationUnknown: CLError.Code\nA constant that indicates the location manager was unable to obtain a location value right now.\nstatic var promptDeclined: CLError.Code\nA constant that indicates the user didn’t grant the requested temporary authorization.\nstatic var network: CLError.Code\nA constant that indicates the network was unavailable or a network error occurred.\nstatic var headingFailure: CLError.Code\nA constant that indicates the location manager can’t determine the heading.\nstatic var rangingUnavailable: CLError.Code\nA constant that indicates ranging is disabled.\nstatic var rangingFailure: CLError.Code\nA constant that indicates a general ranging error occurred.\nenum CLError.Code\nError codes returned by the location manager object."
  },
  {
    "title": "promptDeclined | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/3565557-promptdeclined",
    "html": "Discussion\n\nIf the prompt was shown to the user, who declined, or if an error prevented the prompt from being displayed, then requestTemporaryPreciseLocationAuthorization(withPurposeKey:completion:) throws this error.\n\nSee Also\nGetting general errors\nstatic var locationUnknown: CLError.Code\nA constant that indicates the location manager was unable to obtain a location value right now.\nstatic var denied: CLError.Code\nA constant that indicates the user denied access to the location service.\nstatic var network: CLError.Code\nA constant that indicates the network was unavailable or a network error occurred.\nstatic var headingFailure: CLError.Code\nA constant that indicates the location manager can’t determine the heading.\nstatic var rangingUnavailable: CLError.Code\nA constant that indicates ranging is disabled.\nstatic var rangingFailure: CLError.Code\nA constant that indicates a general ranging error occurred.\nenum CLError.Code\nError codes returned by the location manager object."
  },
  {
    "title": "CLError.Code.locationUnknown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/locationunknown",
    "html": "See Also\nGetting general errors\ncase denied\nA constant that indicates the user denied access to the location service.\ncase promptDeclined\nA constant that indicates the user didn’t grant the requested temporary authorization.\ncase network\nA constant that indicates the network was unavailable or a network error occurred.\ncase headingFailure\nA constant that indicates the location manager can’t determine the heading.\ncase rangingUnavailable\nA constant that indicates ranging is disabled.\ncase rangingFailure\nA constant that indicates a general ranging error occurred."
  },
  {
    "title": "network | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320660-network",
    "html": "See Also\nGetting general errors\nstatic var locationUnknown: CLError.Code\nA constant that indicates the location manager was unable to obtain a location value right now.\nstatic var denied: CLError.Code\nA constant that indicates the user denied access to the location service.\nstatic var promptDeclined: CLError.Code\nA constant that indicates the user didn’t grant the requested temporary authorization.\nstatic var headingFailure: CLError.Code\nA constant that indicates the location manager can’t determine the heading.\nstatic var rangingUnavailable: CLError.Code\nA constant that indicates ranging is disabled.\nstatic var rangingFailure: CLError.Code\nA constant that indicates a general ranging error occurred.\nenum CLError.Code\nError codes returned by the location manager object."
  },
  {
    "title": "CLDeviceOrientation.faceDown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cldeviceorientation/facedown",
    "html": "See Also\nDevice Orientations\ncase unknown\nThe orientation is currently not known.\ncase portrait\nThe device is in portrait mode, with the device held upright and the home button at the bottom.\ncase portraitUpsideDown\nThe device is in portrait mode but upside down, with the device held upright and the home button at the top.\ncase landscapeLeft\nThe device is in landscape mode, with the device held upright and the home button on the right side.\ncase landscapeRight\nThe device is in landscape mode, with the device held upright and the home button on the left side.\ncase faceUp\nThe device is held parallel to the ground with the screen facing upwards."
  },
  {
    "title": "CLDeviceOrientation.unknown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cldeviceorientation/unknown",
    "html": "See Also\nDevice Orientations\ncase portrait\nThe device is in portrait mode, with the device held upright and the home button at the bottom.\ncase portraitUpsideDown\nThe device is in portrait mode but upside down, with the device held upright and the home button at the top.\ncase landscapeLeft\nThe device is in landscape mode, with the device held upright and the home button on the right side.\ncase landscapeRight\nThe device is in landscape mode, with the device held upright and the home button on the left side.\ncase faceUp\nThe device is held parallel to the ground with the screen facing upwards.\ncase faceDown\nThe device is held parallel to the ground with the screen facing downwards."
  },
  {
    "title": "CLDeviceOrientation.faceUp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cldeviceorientation/faceup",
    "html": "See Also\nDevice Orientations\ncase unknown\nThe orientation is currently not known.\ncase portrait\nThe device is in portrait mode, with the device held upright and the home button at the bottom.\ncase portraitUpsideDown\nThe device is in portrait mode but upside down, with the device held upright and the home button at the top.\ncase landscapeLeft\nThe device is in landscape mode, with the device held upright and the home button on the right side.\ncase landscapeRight\nThe device is in landscape mode, with the device held upright and the home button on the left side.\ncase faceDown\nThe device is held parallel to the ground with the screen facing downwards."
  },
  {
    "title": "radius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregion/1423730-radius",
    "html": "Deprecated\n\nUse radius in CLCircularRegion instead.\n\nDiscussion\n\nIn iOS, use a CLCircularRegion object to manage geographic regions.\n\nSee Also\nDeprecated\ninit(circularRegionWithCenter: CLLocationCoordinate2D, radius: CLLocationDistance, identifier: String)\nInitializes and returns a region object defining a circular area.\nDeprecated\nfunc contains(CLLocationCoordinate2D) -> Bool\nReturns a Boolean value indicating whether the region contains the specified coordinate.\nDeprecated\nvar center: CLLocationCoordinate2D\nThe center point of the region.\nDeprecated"
  },
  {
    "title": "rangingUnavailable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320671-rangingunavailable",
    "html": "Discussion\n\nThis error might occur if the device is in Airplane mode or if Bluetooth or location services are disabled.\n\nSee Also\nGetting general errors\nstatic var locationUnknown: CLError.Code\nA constant that indicates the location manager was unable to obtain a location value right now.\nstatic var denied: CLError.Code\nA constant that indicates the user denied access to the location service.\nstatic var promptDeclined: CLError.Code\nA constant that indicates the user didn’t grant the requested temporary authorization.\nstatic var network: CLError.Code\nA constant that indicates the network was unavailable or a network error occurred.\nstatic var headingFailure: CLError.Code\nA constant that indicates the location manager can’t determine the heading.\nstatic var rangingFailure: CLError.Code\nA constant that indicates a general ranging error occurred.\nenum CLError.Code\nError codes returned by the location manager object."
  },
  {
    "title": "notifyOnExit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregion/1423595-notifyonexit",
    "html": "Discussion\n\nWhen this property is true, a device crossing from inside the region to outside the region triggers the delivery of a notification. If the property is false, a notification is not generated. The default value of this property is true.\n\nIf the app is not running when a boundary crossing occurs, the system launches the app into the background to handle it. Upon launch, your app must configure new location manager and delegate objects to receive the notification. The notification is sent to your delegate’s locationManager(_:didExitRegion:) method.\n\nSee Also\nSpecifying the notification conditions\nvar notifyOnEntry: Bool\nA Boolean indicating that notifications are generated upon entry into the region."
  },
  {
    "title": "center | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregion/1423691-center",
    "html": "Deprecated\n\nUse center in CLCircularRegion instead.\n\nDiscussion\n\nIn iOS, use a CLCircularRegion object to manage geographic regions.\n\nSee Also\nDeprecated\ninit(circularRegionWithCenter: CLLocationCoordinate2D, radius: CLLocationDistance, identifier: String)\nInitializes and returns a region object defining a circular area.\nDeprecated\nfunc contains(CLLocationCoordinate2D) -> Bool\nReturns a Boolean value indicating whether the region contains the specified coordinate.\nDeprecated\nvar radius: CLLocationDistance\nThe radius (measured in meters) that defines the region’s outer boundary.\nDeprecated"
  },
  {
    "title": "CLError.Code | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code",
    "html": "Overview\n\nInstances of NSError object delivered to the delegate use these error codes for the code property of the error object.\n\nTopics\nGetting general errors\ncase locationUnknown\nA constant that indicates the location manager was unable to obtain a location value right now.\ncase denied\nA constant that indicates the user denied access to the location service.\ncase promptDeclined\nA constant that indicates the user didn’t grant the requested temporary authorization.\ncase network\nA constant that indicates the network was unavailable or a network error occurred.\ncase headingFailure\nA constant that indicates the location manager can’t determine the heading.\ncase rangingUnavailable\nA constant that indicates ranging is disabled.\ncase rangingFailure\nA constant that indicates a general ranging error occurred.\nGetting region monitoring errors\ncase regionMonitoringDenied\nA constant that indicates the user denied access to the region monitoring service.\ncase regionMonitoringFailure\nA constant that indicates the location manager failed to monitor a registered region.\ncase regionMonitoringSetupDelayed\nA constant that indicates Core Location failed to initialize the region monitoring feature.\ncase regionMonitoringResponseDelayed\nA constant that indicates Core Location will deliver events but they may be delayed.\nGetting geocoding errors\ncase geocodeCanceled\nA constant that indicates the geocode request was canceled.\ncase geocodeFoundNoResult\nA constant that indicates the geocode request yielded no result.\ncase geocodeFoundPartialResult\nA constant that indicates the geocode request yielded a partial result.\nGetting deffered location update errors\ncase deferredFailed\nA constant that indicates the location manager didn’t enter deferred mode for an unknown reason.\ncase deferredCanceled\nA constant that indicates your app or the location manager canceled the request for deferred updates.\ncase deferredAccuracyTooLow\nA constant that indicates deferred mode isn’t supported for the requested accuracy.\ncase deferredDistanceFiltered\nA constant that indicates deferred mode doesn’t support distance filters.\ncase deferredNotUpdatingLocation\nA constant that indicates the location manager didn’t enter deferred mode because location updates were already disabled or paused.\nEnumeration Cases\ncase historicalLocationError\nRelationships\nConforms To\nSendable\nSee Also\nGetting general errors\nstatic var locationUnknown: CLError.Code\nA constant that indicates the location manager was unable to obtain a location value right now.\nstatic var denied: CLError.Code\nA constant that indicates the user denied access to the location service.\nstatic var promptDeclined: CLError.Code\nA constant that indicates the user didn’t grant the requested temporary authorization.\nstatic var network: CLError.Code\nA constant that indicates the network was unavailable or a network error occurred.\nstatic var headingFailure: CLError.Code\nA constant that indicates the location manager can’t determine the heading.\nstatic var rangingUnavailable: CLError.Code\nA constant that indicates ranging is disabled.\nstatic var rangingFailure: CLError.Code\nA constant that indicates a general ranging error occurred."
  },
  {
    "title": "regionMonitoringFailure | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320674-regionmonitoringfailure",
    "html": "Discussion\n\nMonitoring can fail if the app exceeds the maximum number of regions that it can monitor simultaneously. Monitoring can also fail if the region’s radius distance is too large.\n\nSee Also\nGetting region monitoring errors\nstatic var regionMonitoringDenied: CLError.Code\nA constant that indicates the user denied access to the region monitoring service.\nstatic var regionMonitoringSetupDelayed: CLError.Code\nA constant that indicates Core Location couldn’t initialize the region monitoring feature immediately.\nstatic var regionMonitoringResponseDelayed: CLError.Code\nA constant that indicates Core Location will deliver events but they may be delayed."
  },
  {
    "title": "rangingFailure | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320669-rangingfailure",
    "html": "See Also\nGetting general errors\nstatic var locationUnknown: CLError.Code\nA constant that indicates the location manager was unable to obtain a location value right now.\nstatic var denied: CLError.Code\nA constant that indicates the user denied access to the location service.\nstatic var promptDeclined: CLError.Code\nA constant that indicates the user didn’t grant the requested temporary authorization.\nstatic var network: CLError.Code\nA constant that indicates the network was unavailable or a network error occurred.\nstatic var headingFailure: CLError.Code\nA constant that indicates the location manager can’t determine the heading.\nstatic var rangingUnavailable: CLError.Code\nA constant that indicates ranging is disabled.\nenum CLError.Code\nError codes returned by the location manager object."
  },
  {
    "title": "identifier | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregion/1423583-identifier",
    "html": "Discussion\n\nUse this value to identify this region inside your application."
  },
  {
    "title": "regionMonitoringDenied | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320670-regionmonitoringdenied",
    "html": "See Also\nGetting region monitoring errors\nstatic var regionMonitoringFailure: CLError.Code\nA constant that indicates the location manager failed to monitor a registered region.\nstatic var regionMonitoringSetupDelayed: CLError.Code\nA constant that indicates Core Location couldn’t initialize the region monitoring feature immediately.\nstatic var regionMonitoringResponseDelayed: CLError.Code\nA constant that indicates Core Location will deliver events but they may be delayed."
  },
  {
    "title": "geocodeAddressString(_:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder/1423509-geocodeaddressstring",
    "html": "Parameters\naddressString\n\nA string describing the location you want to look up. For example, you could specify the string “1 Infinite Loop, Cupertino, CA” to locate Apple headquarters.\n\ncompletionHandler\n\nThe handler block to execute with the results. The geocoder executes this handler regardless of whether the request was successful or unsuccessful. For more information on the format of this block, see CLGeocodeCompletionHandler.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc geocodeAddressString(_ addressString: String) async throws -> [CLPlacemark]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis method submits the specified location data to the geocoding server asynchronously and returns. Your completion handler block will be executed on the main thread.\n\nAfter initiating a forward-geocoding request, do not attempt to initiate another forward- or reverse-geocoding request. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. When the maximum rate is exceeded, the geocoder passes an error object with the value CLError.Code.network to your completion handler.\n\nSee Also\nGeocoding an address\nfunc geocodeAddressString(String, in: CLRegion?, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified address string and locale information.\nfunc geocodeAddressString(String, in: CLRegion?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string and region information.\nfunc geocodePostalAddress(CNPostalAddress, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified Contacts framework information.\nfunc geocodePostalAddress(CNPostalAddress, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified locale and Contacts framework information.\nfunc geocodeAddressDictionary([AnyHashable : Any], completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified address dictionary.\nDeprecated"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/circulargeographiccondition/4240072-encode",
    "html": "Parameters\nencoder\n\nAn encoder that implements the Encoder protocol.\n\nRelationships\nFrom Protocol\nEncodable"
  },
  {
    "title": "radius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/circulargeographiccondition/4240075-radius",
    "html": "See Also\nCondition characteristics\nlet center: CLLocationCoordinate2D\nThe center point of the condition’s area."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/beaconidentitycondition/4240065-encode",
    "html": "Parameters\nencoder\n\nAn encoder that implements the Encoder protocol.\n\nRelationships\nFrom Protocol\nEncodable"
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/beaconidentitycondition/4240066-init",
    "html": "Parameters\ndecoder\n\nThe decoder object.\n\nRelationships\nFrom Protocol\nDecodable\nSee Also\nCreating a beacon identity condition\ninit(uuid: UUID)\nCreates a beacon identity condition with the UUID characteristic only, and wildcard values for the major and minor characteristics.\ninit(uuid: UUID, major: UInt16)\nCreates a beacon identity condition with UUID and major characteristics, and a wildcard for the minor characteristic.\ninit(uuid: UUID, major: UInt16, minor: UInt16)\nCreates a beacon identity condition with UUID, and major and minor characteristics."
  },
  {
    "title": "init(uuid:major:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/beaconidentitycondition/4240068-init",
    "html": "Parameters\nuuid\n\nThe UUID that identifies the beacon.\n\nmajor\n\nThe CLBeaconMajorValue that represents the beacon’s major value.\n\nSee Also\nCreating a beacon identity condition\ninit(from: Decoder)\nCreates a beacon identity condition with values from a decoder you provide.\ninit(uuid: UUID)\nCreates a beacon identity condition with the UUID characteristic only, and wildcard values for the major and minor characteristics.\ninit(uuid: UUID, major: UInt16, minor: UInt16)\nCreates a beacon identity condition with UUID, and major and minor characteristics."
  },
  {
    "title": "init(uuid:major:minor:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/beaconidentitycondition/4240069-init",
    "html": "Parameters\nuuid\n\nThe UUID that identifies the beacon.\n\nmajor\n\nThe CLBeaconMajorValue that represents the beacon’s major value.\n\nminor\n\nThe CLBeaconMinorValue that represents the beacon’s minor value.\n\nSee Also\nCreating a beacon identity condition\ninit(from: Decoder)\nCreates a beacon identity condition with values from a decoder you provide.\ninit(uuid: UUID)\nCreates a beacon identity condition with the UUID characteristic only, and wildcard values for the major and minor characteristics.\ninit(uuid: UUID, major: UInt16)\nCreates a beacon identity condition with UUID and major characteristics, and a wildcard for the minor characteristic."
  },
  {
    "title": "init(uuid:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/beaconidentitycondition/4240067-init",
    "html": "Parameters\nuuid\n\nThe UUID that identifies the beacon.\n\nSee Also\nCreating a beacon identity condition\ninit(from: Decoder)\nCreates a beacon identity condition with values from a decoder you provide.\ninit(uuid: UUID, major: UInt16)\nCreates a beacon identity condition with UUID and major characteristics, and a wildcard for the minor characteristic.\ninit(uuid: UUID, major: UInt16, minor: UInt16)\nCreates a beacon identity condition with UUID, and major and minor characteristics."
  },
  {
    "title": "CLError.Code.promptDeclined | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/promptdeclined",
    "html": "Discussion\n\nIf the prompt was shown to the user, who declined, or if an error prevented the prompt from being displayed, then requestTemporaryPreciseLocationAuthorization(withPurposeKey:completion:) throws this error.\n\nSee Also\nGetting general errors\ncase locationUnknown\nA constant that indicates the location manager was unable to obtain a location value right now.\ncase denied\nA constant that indicates the user denied access to the location service.\ncase network\nA constant that indicates the network was unavailable or a network error occurred.\ncase headingFailure\nA constant that indicates the location manager can’t determine the heading.\ncase rangingUnavailable\nA constant that indicates ranging is disabled.\ncase rangingFailure\nA constant that indicates a general ranging error occurred."
  },
  {
    "title": "init(beaconIdentityConstraint:identifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/3240605-init",
    "html": "Parameters\nbeaconIdentityConstraint\n\nA CLBeaconIdentityConstraint that describes the characteristics of beacons for the framework to target.\n\nidentifier\n\nA unique identifier to associate with the returned region object. You use this identifier to differentiate regions within your app. This value can’t be nil.\n\nSee Also\nCreating a beacon region\ninit(uuid: UUID, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID.\nDeprecated\ninit(uuid: UUID, major: CLBeaconMajorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID and major value.\nDeprecated\ninit(uuid: UUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID, and major and minor values.\nDeprecated\ntypealias CLBeaconMajorValue\nThe most significant value in a beacon.\ntypealias CLBeaconMinorValue\nThe least significant value in a beacon."
  },
  {
    "title": "CLBeaconIdentityCondition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconidentitycondition",
    "html": "Overview\n\nCore Location defines a beacon identity by UUID, and major and minor values. You need to specify the UUID. If you only specify a UUID, the framework treats the major and minor values as wildcards and any beacons with the same UUID satisfy the condition. Similarly, if you specify only a UUID and a major value, the framework treats the minor value as a wildcard and any beacons with the same UUID and major value satisfy the condition.\n\nTopics\nCreating beacon identity conditions\n- initWithUUID:\nCreates a new beacon identity condition with the identifier you specify.\n- initWithUUID:major:\nCreates a new beacon identity condition with the identifier and major value you specify.\n- initWithUUID:major:minor:\nCreates a new beacon identity condition with the identifier, and major and minor values you specify.\nAccessing the beacon’s properties\nUUID\nA universally unique identifier that represent the beacon’s identifier.\nmajor\nThe most significant value associated with the beacon.\nminor\nThe least significant value associated with the beacon.\nRelationships\nInherits From\nCLCondition\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\niBeacon\nDetermining the proximity to an iBeacon device\nDetect beacons and determine the relative distance to them.\nTurning an iOS device into an iBeacon device\nBroadcast iBeacon signals from an iOS device.\nCLBeacon\nInformation about an observed iBeacon device and its relative distance to the user’s device.\nCLCondition\nThe abstract base class that all other conditions derive from.\nCLCircularGeographicCondition\nA circular geographic condition that a center point and radius define."
  },
  {
    "title": "minor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconidentityconstraint/3240603-minor",
    "html": "Discussion\n\nThe minor characteristic is optional. If it’s present, a beacon’s minor value needs to match the constraint’s minor value to represent a match. If the constraint has no minor value, it acts as a wildcard and matches any minor value.\n\nSee Also\nGetting the beacon identity\nvar major: UInt16?\nThe constraint’s value for the major identity characteristic."
  },
  {
    "title": "locationManager(_:didRangeBeacons:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1621501-locationmanager",
    "html": "Deprecated\n\nUse locationManager(_:didRange:satisfying:) instead.\n\nParameters\nmanager\n\nThe location manager object reporting the event.\n\nbeacons\n\nAn array of CLBeacon objects representing the beacons currently in range. If beacons is empty, you can assume that no beacons matching the specified region are in range. When a specific beacon is no longer in beacons, that beacon is no longer received by the device. You can use the information in the CLBeacon objects to determine the range of each beacon and its identifying information.\n\nregion\n\nThe region object containing the parameters that were used to locate the beacons.\n\nDiscussion\n\nThe location manager calls this method when a new set of beacons becomes available in the specified region or when a beacon goes out of range. The location manager also calls this method when the range of a beacon changes; for example, when a beacon gets closer.\n\nSee Also\nReceiving beacon-related updates\nfunc locationManager(CLLocationManager, didRange: [CLBeacon], satisfying: CLBeaconIdentityConstraint)\nTells the delegate that the location manager detected at least one beacon that satisfies the provided constraint.\nfunc locationManager(CLLocationManager, didFailRangingFor: CLBeaconIdentityConstraint, error: Error)\nTells the delegate that the location manager couldn’t detect any beacons that satisfy the provided constraint.\nfunc locationManager(CLLocationManager, rangingBeaconsDidFailFor: CLBeaconRegion, withError: Error)\nTells the delegate that an error occurred while gathering ranging information for a set of beacons.\nDeprecated"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211317-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211309-max",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211311-min",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "regionMonitoringSetupDelayed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320661-regionmonitoringsetupdelayed",
    "html": "See Also\nGetting region monitoring errors\nstatic var regionMonitoringDenied: CLError.Code\nA constant that indicates the user denied access to the region monitoring service.\nstatic var regionMonitoringFailure: CLError.Code\nA constant that indicates the location manager failed to monitor a registered region.\nstatic var regionMonitoringResponseDelayed: CLError.Code\nA constant that indicates Core Location will deliver events but they may be delayed."
  },
  {
    "title": "geocodeFoundNoResult | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320666-geocodefoundnoresult",
    "html": "See Also\nGetting geocoding errors\nstatic var geocodeCanceled: CLError.Code\nA constant that indicates the geocode request was canceled.\nstatic var geocodeFoundPartialResult: CLError.Code\nA constant that indicates the geocode request yielded a partial result."
  },
  {
    "title": "errorDomain | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2882749-errordomain",
    "html": "See Also\nGetting the error details\nvar errorCode: Int\nThe error code the framework returns when location services fail.\nvar code: Code\nThe error code the framework returns when location services fail.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar alternateRegion: CLRegion?\nA region that location services can monitor more effectively.\nvar localizedDescription: String\nA localized, human-readable explanation of the error."
  },
  {
    "title": "deferredNotUpdatingLocation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320663-deferrednotupdatinglocation",
    "html": "See Also\nGetting deferred location update errors\nstatic var deferredFailed: CLError.Code\nA constant that indicates the location manager didn’t enter deferred mode for an unknown reason.\nstatic var deferredCanceled: CLError.Code\nA constant that indicates your app or the location manager canceled the request for deferred updates.\nstatic var deferredAccuracyTooLow: CLError.Code\nA constant that indicates deferred mode isn’t supported for the requested accuracy.\nstatic var deferredDistanceFiltered: CLError.Code\nA constant that indicates deferred mode doesn’t support distance filters."
  },
  {
    "title": "errorCode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2882747-errorcode",
    "html": "See Also\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar code: Code\nThe error code the framework returns when location services fail.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar alternateRegion: CLRegion?\nA region that location services can monitor more effectively.\nvar localizedDescription: String\nA localized, human-readable explanation of the error."
  },
  {
    "title": "userInfo | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/3726357-userinfo",
    "html": "See Also\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar errorCode: Int\nThe error code the framework returns when location services fail.\nvar code: Code\nThe error code the framework returns when location services fail.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar alternateRegion: CLRegion?\nA region that location services can monitor more effectively.\nvar localizedDescription: String\nA localized, human-readable explanation of the error."
  },
  {
    "title": "alternateRegion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2305769-alternateregion",
    "html": "Discussion\n\nThis property has a value only for errors of type regionMonitoringResponseDelayed.\n\nSee Also\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar errorCode: Int\nThe error code the framework returns when location services fail.\nvar code: Code\nThe error code the framework returns when location services fail.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar localizedDescription: String\nA localized, human-readable explanation of the error."
  },
  {
    "title": "code | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/3726353-code",
    "html": "See Also\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar errorCode: Int\nThe error code the framework returns when location services fail.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar alternateRegion: CLRegion?\nA region that location services can monitor more effectively.\nvar localizedDescription: String\nA localized, human-readable explanation of the error."
  },
  {
    "title": "errorUserInfo | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2882748-erroruserinfo",
    "html": "See Also\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar errorCode: Int\nThe error code the framework returns when location services fail.\nvar code: Code\nThe error code the framework returns when location services fail.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar alternateRegion: CLRegion?\nA region that location services can monitor more effectively.\nvar localizedDescription: String\nA localized, human-readable explanation of the error."
  },
  {
    "title": "headingAvailable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620561-headingavailable",
    "html": "Deprecated\n\nUse the headingAvailable() class method instead.\n\nDiscussion\n\nHeading data may not be available on all iOS-based devices. You should check the value of this property before asking the location manager to deliver heading-related events.\n\nSee Also\nProperties\nvar locationServicesEnabled: Bool\nA Boolean value indicating whether location services are enabled on the device.\nDeprecated\nvar purpose: String?\nAn app-provided string that describes the reason for using location services.\nDeprecated\nvar rangedRegions: Set<CLRegion>\nThe set of regions currently being tracked using ranging.\nDeprecated"
  },
  {
    "title": "addConditionForMonitoring:identifier: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4240034-addconditionformonitoring",
    "html": "Parameters\ncondition\n\nA CLCondition to monitor for.\n\nidentifier\n\nA string you use to identify this condition.\n\nSee Also\nAdding and removing conditions\n- addConditionForMonitoring:identifier:assumedState:\nAdds a condition to monitor with the state and identifier you provide.\n- monitoringRecordForIdentifier:\nGets the monitoring record containing the condition and most recent monitoring event for the identifier you supply, if applicable.\n- removeConditionFromMonitoringWithIdentifier:\nRemoves the monitoring record with the identifier from monitoring."
  },
  {
    "title": "purpose | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423742-purpose",
    "html": "Deprecated\n\nSet the purpose string using the NSLocationWhenInUseUsageDescription key in the app’s Info.plist instead.\n\nDiscussion\n\nIf this property isn’t nil and the system needs to ask for the user’s consent to use location services, it displays the provided string. You can use this string to explain why your app is using location services.\n\nYou must set the value of this property prior to starting any location services. Because the string is ultimately displayed to the user, you should always load it from a localized strings file.\n\nSee Also\nProperties\nvar headingAvailable: Bool\nA Boolean value indicating whether the location manager is able to generate heading-related events.\nDeprecated\nvar locationServicesEnabled: Bool\nA Boolean value indicating whether location services are enabled on the device.\nDeprecated\nvar rangedRegions: Set<CLRegion>\nThe set of regions currently being tracked using ranging.\nDeprecated"
  },
  {
    "title": "regionMonitoringAvailable() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423564-regionmonitoringavailable",
    "html": "Deprecated\n\nUse isMonitoringAvailable(for:) instead.\n\nReturn Value\n\ntrue if region monitoring is available; false if it is not.\n\nDiscussion\n\nSupport for region monitoring may not be available on all devices and models. You should check the value of this property before attempting to set up any regions or initiate region monitoring.\n\nEven if region monitoring support is present on a device, it may still be unavailable because the user disabled it for the current app or for all apps.\n\nSpecial Considerations\n\nThis class is deprecated in iOS 7 and later but is still supported in macOS.\n\nSee Also\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "regionMonitoringEnabled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423585-regionmonitoringenabled",
    "html": "Deprecated\n\nUse isMonitoringAvailable(for:) instead.\n\nReturn Value\n\ntrue if region monitoring is available and is currently enabled; false if it is unavailable or not enabled.\n\nDiscussion\n\nIn iOS, the user can enable or disable location services (including region monitoring) using the controls in Settings > Location Services.\n\nYou should check the return value of this method before starting region monitoring updates to determine whether the user currently allows location services to be used at all. If this method returns false and you start region monitoring updates anyway, the Core Location framework prompts the user to confirm asking whether location services should be reenabled.\n\nThis method does not check to see if region monitoring capabilities are actually supported by the device. Therefore, you should also check the return value of the regionMonitoringAvailable() class method before attempting to start region monitoring services.\n\nSee Also\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "stopMonitoring(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423840-stopmonitoring",
    "html": "Deprecated\n\nUse removeConditionFromMonitoringWithIdentifier: instead.\n\nParameters\nregion\n\nThe region object currently being monitored. This parameter must not be nil.\n\nDiscussion\n\nIf the specified region object is not currently being monitored, this method has no effect. If a compatible iPad or iPhone app calls this method when running in visionOS, the method does nothing.\n\nSee Also\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "rangedRegions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620552-rangedregions",
    "html": "Deprecated\n\nUse rangedBeaconConstraints instead.\n\nDiscussion\n\nThe objects in the set are instances of the CLBeaconRegion class.\n\nSee Also\nProperties\nvar headingAvailable: Bool\nA Boolean value indicating whether the location manager is able to generate heading-related events.\nDeprecated\nvar locationServicesEnabled: Bool\nA Boolean value indicating whether location services are enabled on the device.\nDeprecated\nvar purpose: String?\nAn app-provided string that describes the reason for using location services.\nDeprecated\nRelated Documentation\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region."
  },
  {
    "title": "locationServicesEnabled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620566-locationservicesenabled",
    "html": "Deprecated\n\nUse the locationServicesEnabled() class method instead.\n\nDiscussion\n\nIn iOS, the user can enable or disable location services using the controls in Settings > Location Services. In macOS, the user can enable or disable location services from the Security & Privacy system preference.\n\nIf this property contains the value false and you start location updates anyway, the Core Location framework prompts the user with a confirmation alert asking whether location services should be reenabled.\n\nSpecial Considerations\n\nIn iOS, this property is declared as nonatomic. In macOS, it is declared as atomic.\n\nSee Also\nProperties\nvar headingAvailable: Bool\nA Boolean value indicating whether the location manager is able to generate heading-related events.\nDeprecated\nvar purpose: String?\nAn app-provided string that describes the reason for using location services.\nDeprecated\nvar rangedRegions: Set<CLRegion>\nThe set of regions currently being tracked using ranging.\nDeprecated"
  },
  {
    "title": "authorizationStatus() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423523-authorizationstatus",
    "html": "Deprecated\n\nUse the authorizationStatus instance property with locationManagerDidChangeAuthorization(_:) instead.\n\nReturn Value\n\nA value indicating whether the app is authorized to use location services.\n\nDiscussion\n\nThe system is guaranteed to call the delegate method with the app's initial authorization state and all authorization status changes.\n\nThe system manages the authorization status of a given app according to several factors. Users must authorize the app to use location services explicitly, and location services must be enabled in Settings > Privacy. See Choosing the Location Services Authorization to Request for more information.\n\nSee Also\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "startMonitoring(for:desiredAccuracy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620560-startmonitoring",
    "html": "Deprecated\n\nUse startMonitoring(for:) instead.\n\nParameters\nregion\n\nThe region object that defines the boundary to monitor. This parameter must not be nil.\n\naccuracy\n\nThe distance past the border (measured in meters) at which to generate notifications. You can use this value to prevent the delivery of multiple notifications when the user is close to the border’s edge.\n\nDiscussion\n\nYou must call this method separately for each region you want to monitor. If an existing region with the same identifier is already being monitored by the app, the old region is replaced by the new one. The regions you add using this method are shared by all location manager objects in your app and stored in the monitoredRegions property.\n\nIf you begin monitoring a region and your app is subsequently terminated, the system automatically relaunches it into the background if the region boundary is crossed. In such a case, the options dictionary passed to the application(_:didFinishLaunchingWithOptions:) method of your app delegate contains the key location to indicate that your app was launched because of a location-related event. In addition, creating a new location manager and assigning a delegate results in the delivery of the corresponding region messages. The newly created location manager’s location property also contains the current location even if location services are not enabled.\n\nRegion events are delivered to the locationManager(_:didEnterRegion:) and locationManager(_:didExitRegion:) methods of your delegate. If there is an error, the location manager calls the locationManager(_:monitoringDidFailFor:withError:) method of your delegate instead.\n\nSee Also\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "requestState(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423804-requeststate",
    "html": "Deprecated\n\nUse CLMonitor to track and query the state for monitored constraints.\n\nParameters\nregion\n\nThe region with the state you want to know. This object needs to be an instance of one of the standard region subclasses that Core Location provides, such as CLCircularRegion or CLBeaconRegion. You can’t use this method to determine the state of custom regions you define yourself.\n\nDiscussion\n\nThis method performs the request asynchronously and delivers the results to the location manager’s delegate. You must implement the locationManager(_:didDetermineState:for:) method in the delegate to receive the results.\n\nIf the region parameter contains an unknown type of region object, this method does nothing. If a compatible iPad or iPhone app calls this method when running in visionOS, the method does nothing.\n\nSee Also\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "stopRangingBeacons(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620559-stoprangingbeacons",
    "html": "Deprecated\n\nUse stopRangingBeacons(satisfying:) instead.\n\nParameters\nregion\n\nThe region that identifies the beacons. The object you specify need not be the exact same object that you registered but the beacon attributes should be the same.\n\nSee Also\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "disallowDeferredLocationUpdates() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620565-disallowdeferredlocationupdates",
    "html": "Discussion\n\nCall this method if you previously deferred location event delivery using the allowDeferredLocationUpdates(untilTraveled:timeout:) method and now want to resume the delivery of events at normal intervals.\n\nSee Also\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated"
  },
  {
    "title": "allowDeferredLocationUpdates(untilTraveled:timeout:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620547-allowdeferredlocationupdates",
    "html": "Parameters\ndistance\n\nThe distance (in meters) from the current location that must be travelled before event delivery resumes. To specify an unlimited distance, pass the CLLocationDistanceMax constant.\n\ntimeout\n\nThe amount of time (in seconds) from the current time that must pass before event delivery resumes. To specify an unlimited amount of time, pass the CLTimeIntervalMax constant.\n\nDiscussion\n\nCall this method in situations where you want location data with GPS accuracy but do not need to process that data right away. If your app is in the background and the system is able to optimize its power usage, the location manager tells the GPS hardware to store new locations internally until the specified distance or timeout conditions are met. When one or both criteria are met, the location manager ends deferred locations by calling the locationManager(_:didFinishDeferredUpdatesWithError:) method of its delegate and delivers the cached locations to the locationManager(_:didUpdateLocations:) method. If your app is in the foreground, the location manager does not defer the deliver of events but does monitor for the specified criteria. If your app moves to the background before the criteria are met, the location manager may begin deferring the delivery of events.\n\nImportant\n\nBecause deferred updates use the GPS to track location changes, the location manager allows deferred updates only when GPS hardware is available on the device and when the desired accuracy is set to kCLLocationAccuracyBest or kCLLocationAccuracyBestForNavigation. If the GPS hardware is not available, the location manager reports a CLError.Code.deferredFailed error. If the accuracy is not set to one of the supported values, the location manager reports a CLError.Code.deferredAccuracyTooLow error.\n\nIn addition, the distanceFilter property of the location manager must be set to kCLDistanceFilterNone. If it is set to any other value, the location manager reports a CLError.Code.deferredDistanceFiltered error.\n\nStart the delivery of location updates before calling this method. The most common place to call this method is in your delegate’s locationManager(_:didUpdateLocations:) method. After processing any new locations, call this method if you want to defer future updates until the distance or time criteria are met. If new events arrive and your app is in the background, the events are cached and their delivery is deferred appropriately.\n\nYour delegate’s locationManager(_:didFinishDeferredUpdatesWithError:) method is called exactly once for each time you call this method. If you call this method twice in succession, the location manager cancels the previous deferral before starting the new one. Therefore, you should keep track of whether updates are currently deferred and avoid calling this method multiple times in succession. If you want to change the deferral criteria for any reason, and therefore call this method again, be prepared to receive a CLError.Code.deferredCanceled error in your delegate’s locationManager(_:didFinishDeferredUpdatesWithError:) method.\n\nAfter calling this method, the location manager may deliver location updates even if the specified distance and timeout criteria are not met. For example, if the caches used to store deferred samples become full, the location manager may deliver the cached samples so it can collect new ones. The delivery of samples does not automatically end deferred mode for your app. The location manager resumes deferred mode when it is able to do so.\n\nDeferred updates are delivered only when the system enters a low power state. Deferred updates do not occur during debugging because Xcode prevents your app from sleeping and thus prevents the system from entering that low power state.\n\nSee Also\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "CLActivityType.otherNavigation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clactivitytype/othernavigation",
    "html": "Discussion\n\nUse this activity type to track a positioning session such as by boat, train, or for pedestrian navigation tracking that’s not tied to a road network, paths, or trails. You can also use it for positioning activities indoors and outdoors, such as walking, that isn’t tied to a dedicated fitness session.\n\nThis activity might cause the system to pause location updates when the vehicle doesn’t move a significant distance over a period of time.\n\nSee Also\nActivity types\ncase other\nThe value that indicates the app is using location manager for an unspecified activity.\ncase automotiveNavigation\nThe value that indicates positioning in an automobile following a road network.\ncase fitness\nThe value that indicates positioning during dedicated fitness sessions, such as walking workouts, running workouts, cycling workouts, and so on.\ncase airborne\nThe value that indicates activities in the air."
  },
  {
    "title": "CLActivityType.fitness | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clactivitytype/fitness",
    "html": "Discussion\n\nFor other positioning sessions that aren’t workouts, use CLActivityType.otherNavigation or CLActivityType.other. This activity might cause the system to pause location updates when the user doesn’t move a significant distance over a period of time.\n\nWhen activityType is CLActivityType.fitness, the system disables indoor positioning.\n\nSee Also\nActivity types\ncase other\nThe value that indicates the app is using location manager for an unspecified activity.\ncase automotiveNavigation\nThe value that indicates positioning in an automobile following a road network.\ncase otherNavigation\nThe value that indicates positioning for activities that don’t or may not adhere to roads such as cycling, scooters, trains, boats and off-road vehicles.\ncase airborne\nThe value that indicates activities in the air."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clcircularregion/1423697-contains",
    "html": "Parameters\ncoordinate\n\nThe coordinate to test against the region.\n\nReturn Value\n\nReturns true if the coordinate lies within the region’s boundaries, or false if it doesn’t."
  },
  {
    "title": "radius | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clcircularregion/1423734-radius",
    "html": "See Also\nGetting the circle’s center and radius\nvar center: CLLocationCoordinate2D\nThe center point of the geographic area.\nDeprecated"
  },
  {
    "title": "kCLLocationAccuracyHundredMeters | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kcllocationaccuracyhundredmeters",
    "html": "Discussion\n\nThis level of accurate is available only if isAuthorizedForPreciseLocation is true.\n\nSee Also\nDesired Accuracy Constants\nlet kCLLocationAccuracyBestForNavigation: CLLocationAccuracy\nThe highest possible accuracy that uses additional sensor data to facilitate navigation apps.\nlet kCLLocationAccuracyBest: CLLocationAccuracy\nThe best level of accuracy available.\nlet kCLLocationAccuracyNearestTenMeters: CLLocationAccuracy\nAccurate to within ten meters of the desired target.\nlet kCLLocationAccuracyKilometer: CLLocationAccuracy\nAccurate to the nearest kilometer.\nlet kCLLocationAccuracyThreeKilometers: CLLocationAccuracy\nAccurate to the nearest three kilometers.\nlet kCLLocationAccuracyReduced: CLLocationAccuracy\nThe level of accuracy used when an app isn’t authorized for full accuracy location data."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155880-flatmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155878-first",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155872-drop",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155876-filter",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155874-dropfirst",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events/4155870-contains",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "peripheralData(withMeasuredPower:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion/1621494-peripheraldata",
    "html": "Parameters\nmeasuredPower\n\nThe received signal strength indicator (RSSI) value, measured in decibels, for the device. This value represents the measured strength of the beacon from one meter away that Core Location uses during ranging. Specify nil to use the default value for the device.\n\nReturn Value\n\nA dictionary of data that you can use in conjunction with a CBPeripheralManager to advertise the current device as a beacon.\n\nDiscussion\n\nThe returned dictionary encodes the beacon’s identifying information, along with other information needed to advertise the beacon. You don’t need to access the dictionary contents directly. Pass the dictionary to the startAdvertising(_:) method of a CBPeripheralManager to begin advertising the beacon."
  },
  {
    "title": "notifyOnEntry | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregion/1423566-notifyonentry",
    "html": "Discussion\n\nWhen this property is true, a device crossing from outside the region to inside the region triggers the delivery of a notification. If the property is false, a notification is not generated. The default value of this property is true.\n\nIf the app is not running when a boundary crossing occurs, the system launches the app into the background to handle it. Upon launch, your app must configure new location manager and delegate objects to receive the notification. The notification is sent to your delegate’s locationManager(_:didEnterRegion:) method.\n\nSee Also\nSpecifying the notification conditions\nvar notifyOnExit: Bool\nA Boolean indicating that notifications are generated upon exit from the region."
  },
  {
    "title": "init(circularRegionWithCenter:radius:identifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregion/1423681-init",
    "html": "Deprecated\n\nUse init(center:radius:identifier:) in CLCircularRegion instead.\n\nParameters\ncenter\n\nThe center point of the region.\n\nradius\n\nThe distance (measured in meters) from the center point that marks the boundary of the region.\n\nidentifier\n\nA unique identifier to associate with the region object. You use this identifier to differentiate regions within your application. This value must not be nil.\n\nReturn Value\n\nAn initialized region object.\n\nDiscussion\n\nIn iOS, use a CLCircularRegion object to manage geographic regions.\n\nSee Also\nDeprecated\nfunc contains(CLLocationCoordinate2D) -> Bool\nReturns a Boolean value indicating whether the region contains the specified coordinate.\nDeprecated\nvar center: CLLocationCoordinate2D\nThe center point of the region.\nDeprecated\nvar radius: CLLocationDistance\nThe radius (measured in meters) that defines the region’s outer boundary.\nDeprecated"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregion/1423828-contains",
    "html": "Deprecated\n\nUse contains(_:) in CLCircularRegion instead.\n\nParameters\ncoordinate\n\nThe coordinate to test against the region.\n\nReturn Value\n\ntrue if the coordinate lies within the region’s boundaries or false if it does not.\n\nDiscussion\n\nIn iOS, use a CLCircularRegion object to manage geographic regions.\n\nSee Also\nDeprecated\ninit(circularRegionWithCenter: CLLocationCoordinate2D, radius: CLLocationDistance, identifier: String)\nInitializes and returns a region object defining a circular area.\nDeprecated\nvar center: CLLocationCoordinate2D\nThe center point of the region.\nDeprecated\nvar radius: CLLocationDistance\nThe radius (measured in meters) that defines the region’s outer boundary.\nDeprecated"
  },
  {
    "title": "CLProximity.unknown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clproximity/unknown",
    "html": "See Also\nProximity Values\ncase immediate\nThe beacon is in the user’s immediate vicinity.\ncase near\nThe beacon is relatively close to the user.\ncase far\nThe beacon is far away."
  },
  {
    "title": "geocodeAddressString(_:in:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder/1423591-geocodeaddressstring",
    "html": "Parameters\naddressString\n\nA string describing the location you want to look up. For example, you could specify the string “1 Infinite Loop, Cupertino, CA” to locate Apple headquarters.\n\nregion\n\nA geographical region to use as a hint when looking up the specified address. Specifying a region lets you prioritize the returned set of results to locations that are close to some specific geographical area, which is typically the user’s current location. If the application is authorized for location services and you specify nil for this parameter, the set of results is prioritized based on the user’s approximate location. Calling this method does not trigger a location services authorization request.\n\ncompletionHandler\n\nThe handler block to execute with the results. The geocoder executes this handler regardless of whether the request was successful or unsuccessful. For more information on the format of this block, see CLGeocodeCompletionHandler.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc geocodeAddressString(_ addressString: String, in region: CLRegion?) async throws -> [CLPlacemark]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis method submits the specified location data to the geocoding server asynchronously and returns. Your completion handler block will be executed on the main thread.\n\nAfter initiating a forward-geocoding request, do not attempt to initiate another forward- or reverse-geocoding request. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. When the maximum rate is exceeded, the geocoder passes an error object with the value CLError.Code.network to your completion handler.\n\nSee Also\nGeocoding an address\nfunc geocodeAddressString(String, in: CLRegion?, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified address string and locale information.\nfunc geocodeAddressString(String, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string.\nfunc geocodePostalAddress(CNPostalAddress, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified Contacts framework information.\nfunc geocodePostalAddress(CNPostalAddress, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified locale and Contacts framework information.\nfunc geocodeAddressDictionary([AnyHashable : Any], completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified address dictionary.\nDeprecated"
  },
  {
    "title": "CLProximity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clproximity",
    "html": "Topics\nProximity Values\ncase unknown\nThe proximity of the beacon could not be determined.\ncase immediate\nThe beacon is in the user’s immediate vicinity.\ncase near\nThe beacon is relatively close to the user.\ncase far\nThe beacon is far away.\nRelationships\nConforms To\nSendable\nSee Also\nDetermining the distance to the beacon\nvar proximity: CLProximity\nThe relative distance to the beacon.\nvar accuracy: CLLocationAccuracy\nThe accuracy of the proximity value, measured in meters from the beacon.\nvar rssi: Int\nThe received signal strength of the beacon, measured in decibels."
  },
  {
    "title": "locationManagerShouldDisplayHeadingCalibration(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1621457-locationmanagershoulddisplayhead",
    "html": "Parameters\nmanager\n\nThe location manager object coordinating the display of the heading calibration alert.\n\nReturn Value\n\ntrue if you want to allow the heading calibration alert to be displayed; false if you do not.\n\nDiscussion\n\nCore Location may call this method in an effort to calibrate the onboard hardware used to determine heading values. Typically, Core Location calls this method at the following times:\n\nThe first time heading updates are ever requested\n\nWhen Core Location observes a significant change in magnitude or inclination of the observed magnetic field\n\nIf you return true from this method, Core Location displays the heading calibration alert on top of the current window immediately. The calibration alert prompts the user to move the device in a particular pattern so that Core Location can distinguish between the Earth’s magnetic field and any local magnetic fields. The alert remains visible until calibration is complete or until you explicitly dismiss it by calling the dismissHeadingCalibrationDisplay() method. In the latter case, you can use this method to set up a timer and dismiss the interface after a specified amount of time has elapsed.\n\nNote\n\nThe calibration process is able to filter out only those magnetic fields that move with the device. To calibrate a device that is near other sources of magnetic interference, the user must either move the device away from the source or move the source in conjunction with the device during the calibration process.\n\nIf you return false from this method or do not provide an implementation for it in your delegate, Core Location does not display the heading calibration alert. Even if the alert is not displayed, calibration can still occur naturally when any interfering magnetic fields move away from the device. However, if the device is unable to calibrate itself for any reason, the value in the headingAccuracy property of any subsequent events will reflect the uncalibrated readings.\n\nSee Also\nReceiving heading updates\nfunc locationManager(CLLocationManager, didUpdateHeading: CLHeading)\nTells the delegate that the location manager received updated heading information."
  },
  {
    "title": "locationManager(_:didStartMonitoringFor:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423842-locationmanager",
    "html": "Parameters\nmanager\n\nThe location manager object reporting the event.\n\nregion\n\nThe region that is being monitored.\n\nSee Also\nReceiving region-related updates\nfunc locationManager(CLLocationManager, didEnterRegion: CLRegion)\nTells the delegate that the user entered the specified region.\nfunc locationManager(CLLocationManager, didExitRegion: CLRegion)\nTells the delegate that the user left the specified region.\nfunc locationManager(CLLocationManager, didDetermineState: CLRegionState, for: CLRegion)\nTells the delegate about the state of the specified region.\nfunc locationManager(CLLocationManager, monitoringDidFailFor: CLRegion?, withError: Error)\nTells the delegate that a region monitoring error occurred.\nenum CLRegionState\nConstants that reflect the relationship of the current location to the region boundaries."
  },
  {
    "title": "kCLLocationAccuracyReduced | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kcllocationaccuracyreduced",
    "html": "Discussion\n\nThe accuracy of location data is reduced in both space and time using approaches like selecting a nearby point of interest and updating the location at most a few times per hour. The approximate location preserves the user’s country or region, typically preserves the city, and is usually within 1–20 kilometers of the actual location.\n\nIf your app is authorized to access location information with full accuracy, you can use this constant to access location data as if the app didn’t have that authorization.\n\nSee Also\nDesired Accuracy Constants\nlet kCLLocationAccuracyBestForNavigation: CLLocationAccuracy\nThe highest possible accuracy that uses additional sensor data to facilitate navigation apps.\nlet kCLLocationAccuracyBest: CLLocationAccuracy\nThe best level of accuracy available.\nlet kCLLocationAccuracyNearestTenMeters: CLLocationAccuracy\nAccurate to within ten meters of the desired target.\nlet kCLLocationAccuracyHundredMeters: CLLocationAccuracy\nAccurate to within one hundred meters.\nlet kCLLocationAccuracyKilometer: CLLocationAccuracy\nAccurate to the nearest kilometer.\nlet kCLLocationAccuracyThreeKilometers: CLLocationAccuracy\nAccurate to the nearest three kilometers."
  },
  {
    "title": "kCLLocationAccuracyThreeKilometers | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kcllocationaccuracythreekilometers",
    "html": "Discussion\n\nThis level of accurate is available only if isAuthorizedForPreciseLocation is true.\n\nSee Also\nDesired Accuracy Constants\nlet kCLLocationAccuracyBestForNavigation: CLLocationAccuracy\nThe highest possible accuracy that uses additional sensor data to facilitate navigation apps.\nlet kCLLocationAccuracyBest: CLLocationAccuracy\nThe best level of accuracy available.\nlet kCLLocationAccuracyNearestTenMeters: CLLocationAccuracy\nAccurate to within ten meters of the desired target.\nlet kCLLocationAccuracyHundredMeters: CLLocationAccuracy\nAccurate to within one hundred meters.\nlet kCLLocationAccuracyKilometer: CLLocationAccuracy\nAccurate to the nearest kilometer.\nlet kCLLocationAccuracyReduced: CLLocationAccuracy\nThe level of accuracy used when an app isn’t authorized for full accuracy location data."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211319-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure."
  },
  {
    "title": "CLActivityType.other | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clactivitytype/other",
    "html": "Discussion\n\nUse this activity type to describe positioning in activities that aren’t covered by one of the other activity types. This includes activities without a specific user intention, for example, positioning while a user sits on a bench interacting with a device.\n\nSee Also\nActivity types\ncase automotiveNavigation\nThe value that indicates positioning in an automobile following a road network.\ncase fitness\nThe value that indicates positioning during dedicated fitness sessions, such as walking workouts, running workouts, cycling workouts, and so on.\ncase otherNavigation\nThe value that indicates positioning for activities that don’t or may not adhere to roads such as cycling, scooters, trains, boats and off-road vehicles.\ncase airborne\nThe value that indicates activities in the air."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211315-prefix",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211313-prefix",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211305-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211307-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211304-makeasynciterator",
    "html": "Relationships\nFrom Protocol\nAsyncSequence\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211302-flatmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211300-flatmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211298-first",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211286-compactmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/liveconfiguration/4211270",
    "html": "Parameters\na\n\nThe first CLLocationUpdate.LiveConfiguration.\n\nb\n\nThe second CLLocationUpdate.LiveConfiguration.\n\nReturn Value\n\nReturns true if the CLLocationUpdate.LiveConfiguration values are equal; otherwise, false.\n\nSee Also\nUtility methods\nvar hashValue: Int\nAn integer value that uniquely identifies the object.\nfunc hash(into: inout Hasher)\nComputes the essential components of a value by sending them into the given hasher.\nstatic func != (CLLocationUpdate.LiveConfiguration, CLLocationUpdate.LiveConfiguration) -> Bool\nReturns a Boolean value that indicates whether the live configurations are not equal."
  },
  {
    "title": "CLLocationUpdate.Updates.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/element",
    "html": "See Also\nType aliases\ntypealias CLLocationUpdate.Updates.AsyncIterator\nThe type of the update’s asynchronous iterator.\nstruct CLLocationUpdate.Updates.Iterator\nThe type of the update’s iterator."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/liveconfiguration/4211276-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nUtility methods\nfunc hash(into: inout Hasher)\nComputes the essential components of a value by sending them into the given hasher.\nstatic func != (CLLocationUpdate.LiveConfiguration, CLLocationUpdate.LiveConfiguration) -> Bool\nReturns a Boolean value that indicates whether the live configurations are not equal.\nstatic func == (CLLocationUpdate.LiveConfiguration, CLLocationUpdate.LiveConfiguration) -> Bool\nReturns a Boolean value that indicates whether the live configuration values are equal."
  },
  {
    "title": "CLLocationUpdate.Updates.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/iterator",
    "html": "Overview\n\nUse CLLocationUpdate.Updates.Iterator process events that CLLocationUpdate delivers.\n\nTopics\nRetreiving elements\nfunc next() -> CLLocationUpdate.Updates.Element?\nAdvances the iterator and returns the next value in the sequence.\nType aliases\ntypealias CLLocationUpdate.Updates.Iterator.Element\nA type that represents an element in an asynchronous sequence.\nRelationships\nConforms To\nAsyncIteratorProtocol\nSee Also\nType aliases\ntypealias CLLocationUpdate.Updates.AsyncIterator\nThe type of the update’s asynchronous iterator.\ntypealias CLLocationUpdate.Updates.Element\nThe type of the update’s asynchronous element."
  },
  {
    "title": "CLLocationUpdate.Updates.AsyncIterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/asynciterator",
    "html": "See Also\nType aliases\nstruct CLLocationUpdate.Updates.Iterator\nThe type of the update’s iterator.\ntypealias CLLocationUpdate.Updates.Element\nThe type of the update’s asynchronous element."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/liveconfiguration/4211269",
    "html": "Parameters\nlhs\n\nThe first CLLocationUpdate.LiveConfiguration.\n\nrhs\n\nThe second CLLocationUpdate.LiveConfiguration.\n\nReturn Value\n\nReturns true if the configurations are not equal; otherwise, false.\n\nSee Also\nUtility methods\nvar hashValue: Int\nAn integer value that uniquely identifies the object.\nfunc hash(into: inout Hasher)\nComputes the essential components of a value by sending them into the given hasher.\nstatic func == (CLLocationUpdate.LiveConfiguration, CLLocationUpdate.LiveConfiguration) -> Bool\nReturns a Boolean value that indicates whether the live configuration values are equal."
  },
  {
    "title": "locationManager(_:didFinishDeferredUpdatesWithError:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423537-locationmanager",
    "html": "Parameters\nmanager\n\nThe location manager object that generated the update event.\n\nerror\n\nThe error object containing the reason deferred location updates could not be delivered.\n\nDiscussion\n\nThe location manager object calls this method to let you know that it has stopped deferring the delivery of location events. The manager may call this method for any number of reasons. For example, it calls it when you stop location updates altogether, when you ask the location manager to disallow deferred updates, or when a condition for deferring updates (such as exceeding a timeout or distance parameter) is met.\n\nSee Also\nReceiving location updates\nfunc locationManager(CLLocationManager, didUpdateLocations: [CLLocation])\nTells the delegate that new location data is available.\nfunc locationManager(CLLocationManager, didUpdateTo: CLLocation, from: CLLocation)\nTells the delegate that a new location value is available."
  },
  {
    "title": "locationManager(_:didUpdateTo:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423716-locationmanager",
    "html": "Deprecated\n\nUse locationManager(_:didUpdateLocations:) instead.\n\nParameters\nmanager\n\nThe location manager object that generated the update event.\n\nnewLocation\n\nThe new location data.\n\noldLocation\n\nThe location data from the previous update. If this is the first update event delivered by this location manager, this parameter is nil.\n\nDiscussion\n\nBy the time this message is delivered to your delegate, the new location data is also available directly from the CLLocationManager object. The newLocation parameter may contain the data that was cached from a previous usage of the location service. You can use the timestamp property of the location object to determine how recent the location data is.\n\nSee Also\nReceiving location updates\nfunc locationManager(CLLocationManager, didUpdateLocations: [CLLocation])\nTells the delegate that new location data is available.\nfunc locationManager(CLLocationManager, didFinishDeferredUpdatesWithError: Error?)\nTells the delegate that updates will no longer be deferred."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/liveconfiguration/4211275-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nUtility methods\nvar hashValue: Int\nAn integer value that uniquely identifies the object.\nstatic func != (CLLocationUpdate.LiveConfiguration, CLLocationUpdate.LiveConfiguration) -> Bool\nReturns a Boolean value that indicates whether the live configurations are not equal.\nstatic func == (CLLocationUpdate.LiveConfiguration, CLLocationUpdate.LiveConfiguration) -> Bool\nReturns a Boolean value that indicates whether the live configuration values are equal."
  },
  {
    "title": "CLLocationUpdate.LiveConfiguration.airborne | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/liveconfiguration/airborne",
    "html": "See Also\nLocation types\ncase `default`\nThe value that configures positioning for activities that one of the other activity types doesn’t cover.\ncase automotiveNavigation\nThe value that configures positioning for an automobile following a road network.\ncase fitness\nThe value that configures positioning for dedicated fitness sessions.\ncase otherNavigation\nThe value that configures positioning for transportation that doesn’t, or may not, adhere to roads, such as cycling, scooters, trains, boats, and off-road vehicles."
  },
  {
    "title": "CLLocationUpdate.LiveConfiguration.fitness | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/liveconfiguration/fitness",
    "html": "See Also\nLocation types\ncase `default`\nThe value that configures positioning for activities that one of the other activity types doesn’t cover.\ncase airborne\nThe value that configures positioning for activities in the air.\ncase automotiveNavigation\nThe value that configures positioning for an automobile following a road network.\ncase otherNavigation\nThe value that configures positioning for transportation that doesn’t, or may not, adhere to roads, such as cycling, scooters, trains, boats, and off-road vehicles."
  },
  {
    "title": "CLLocationUpdate.LiveConfiguration.default | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/liveconfiguration/default",
    "html": "See Also\nLocation types\ncase airborne\nThe value that configures positioning for activities in the air.\ncase automotiveNavigation\nThe value that configures positioning for an automobile following a road network.\ncase fitness\nThe value that configures positioning for dedicated fitness sessions.\ncase otherNavigation\nThe value that configures positioning for transportation that doesn’t, or may not, adhere to roads, such as cycling, scooters, trains, boats, and off-road vehicles."
  },
  {
    "title": "CLLocationUpdate.LiveConfiguration.automotiveNavigation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/liveconfiguration/automotivenavigation",
    "html": "See Also\nLocation types\ncase `default`\nThe value that configures positioning for activities that one of the other activity types doesn’t cover.\ncase airborne\nThe value that configures positioning for activities in the air.\ncase fitness\nThe value that configures positioning for dedicated fitness sessions.\ncase otherNavigation\nThe value that configures positioning for transportation that doesn’t, or may not, adhere to roads, such as cycling, scooters, trains, boats, and off-road vehicles."
  },
  {
    "title": "ellipsoidalAltitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/3861801-ellipsoidalaltitude",
    "html": "Discussion\n\nThe ellipsoidalAltitude property represents the altitude above the WGS84 ellipsoid associated with a location. Use the ellipsoidalAltitude property when your geodetic application needs an altitude with respect to a standard reference frame. Use altitude if your application needs an altitude with respect to the approximate mean sea level.\n\nThe ellipsoidalAltitude value is valid if verticalAccuracy is greater than 0, and invalid if verticalAccuracy is 0 or below. If verticalAccuracy is 0 or below, ellipsoidalAltitude is invalid and contains the value 0.0.\n\nValid values for ellipsoidalAltitude can be positive or negative. Positive values indicate altitudes above the ellipsoid. Negative values indicate altitudes below the ellipsoid.\n\nSee Also\nGetting the location attributes\nvar coordinate: CLLocationCoordinate2D\nThe geographical coordinate information.\nvar altitude: CLLocationDistance\nThe altitude above mean sea level associated with a location, measured in meters.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar floor: CLFloor?\nThe logical floor of the building in which the user is located.\nvar timestamp: Date\nThe time at which this location was determined.\nvar sourceInformation: CLLocationSourceInformation?\nInformation about the source that provides the location."
  },
  {
    "title": "coordinate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1423504-coordinate",
    "html": "Discussion\n\nWhen running in the simulator, Core Location uses the values provided to it by the simulator. You must run your application on an iOS-based device to get the actual location of that device.\n\nSpecial Considerations\n\nIn iOS, this property is declared as nonatomic. In macOS, it is declared as atomic.\n\nSee Also\nGetting the location attributes\nvar altitude: CLLocationDistance\nThe altitude above mean sea level associated with a location, measured in meters.\nvar ellipsoidalAltitude: CLLocationDistance\nThe altitude as a height above the World Geodetic System 1984 (WGS84) ellipsoid, measured in meters.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar floor: CLFloor?\nThe logical floor of the building in which the user is located.\nvar timestamp: Date\nThe time at which this location was determined.\nvar sourceInformation: CLLocationSourceInformation?\nInformation about the source that provides the location."
  },
  {
    "title": "sourceInformation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/3861803-sourceinformation",
    "html": "Discussion\n\nThis property enables developers to make better-informed decisions as to whether to treat certain locations differently, or reject potentially simulated locations that they generate during testing. An app may choose to check this property and reject locations if, for example, the isSimulatedBySoftware property is true when the developer isn’t debugging or testing the app.\n\nUse the sourceInformation property when knowing the true location of the device (within a tolerance for estimation error and horizontal/vertical accuracy) is critical.\n\nSee Also\nGetting the location attributes\nvar coordinate: CLLocationCoordinate2D\nThe geographical coordinate information.\nvar altitude: CLLocationDistance\nThe altitude above mean sea level associated with a location, measured in meters.\nvar ellipsoidalAltitude: CLLocationDistance\nThe altitude as a height above the World Geodetic System 1984 (WGS84) ellipsoid, measured in meters.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar floor: CLFloor?\nThe logical floor of the building in which the user is located.\nvar timestamp: Date\nThe time at which this location was determined."
  },
  {
    "title": "horizontalAccuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1423599-horizontalaccuracy",
    "html": "Discussion\n\nThe location’s latitude and longitude identify the center of the circle, and this value indicates the radius of that circle. A negative value indicates that the latitude and longitude are invalid.\n\nSpecial Considerations\n\nIn iOS, this property is declared as nonatomic. In macOS, it is declared as atomic.\n\nSee Also\nGetting the location accuracy\nvar verticalAccuracy: CLLocationAccuracy\nThe validity of the altitude values, and their estimated uncertainty, measured in meters.\ntypealias CLLocationAccuracy\nThe accuracy of a geographical coordinate."
  },
  {
    "title": "altitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1423820-altitude",
    "html": "Discussion\n\nThe altitude property represents an orthometric height, which is the height above the approximate mean sea level. Positive values indicate altitudes above mean sea level. Negative values indicate altitudes below mean sea level.\n\nWhen verticalAccuracy contains 0 or a negative number, the value of altitude is invalid. The value of altitude is valid when verticalAccuracy contains a postive number.\n\nIn most cases, Core Location approximates mean sea level using the Earth Gravitational Model 2008 (EGM 2008) geoid associated with the World Geodetic System 1984 (WGS84) standard. In some rare cases, Core Location approximates mean sea level using the DMA 10x10 geoid grid. The discrepancy between these two geoids is typically less than 5 meters.\n\nSee ellipsoidalAltitude if your application uses an altitude with respect to the WGS84 reference frame.\n\nNote\n\nIn iOS, this property is declared as nonatomic. In macOS, it is declared as atomic.\n\nSee Also\nGetting the location attributes\nvar coordinate: CLLocationCoordinate2D\nThe geographical coordinate information.\nvar ellipsoidalAltitude: CLLocationDistance\nThe altitude as a height above the World Geodetic System 1984 (WGS84) ellipsoid, measured in meters.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar floor: CLFloor?\nThe logical floor of the building in which the user is located.\nvar timestamp: Date\nThe time at which this location was determined.\nvar sourceInformation: CLLocationSourceInformation?\nInformation about the source that provides the location."
  },
  {
    "title": "isMonitoringAvailable(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423654-ismonitoringavailable",
    "html": "Parameters\nregionClass\n\nA region monitoring class from the MapKit framework. This class must descend from the CLRegion class.\n\nReturn Value\n\ntrue if the device is capable of monitoring regions using the specified class or false if it is not.\n\nDiscussion\n\nThe availability of region monitoring support is dependent on the hardware present on the device. This method does not take into account the availability of location services or the fact that the user might have disabled them for the app or system; you must determine your app’s authorization status separately.\n\nSee Also\nDetermining the availability of services\nclass func significantLocationChangeMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether the significant-change location service is available on the device.\nclass func headingAvailable() -> Bool\nReturns a Boolean value indicating whether the location manager is able to generate heading-related events.\nvar isAuthorizedForWidgetUpdates: Bool\nA Boolean value that indicates whether a widget is eligible to receive location updates.\nvar accuracyAuthorization: CLAccuracyAuthorization\nA value that indicates the level of location accuracy the app has permission to use.\nclass func isRangingAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports ranging of beacons that use the iBeacon protocol.\nclass func locationServicesEnabled() -> Bool\nReturns a Boolean value indicating whether location services are enabled on the device."
  },
  {
    "title": "deferredAccuracyTooLow | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320662-deferredaccuracytoolow",
    "html": "Discussion\n\nThe accuracy must be set to kCLLocationAccuracyBest or kCLLocationAccuracyBestForNavigation.\n\nSee Also\nGetting deferred location update errors\nstatic var deferredFailed: CLError.Code\nA constant that indicates the location manager didn’t enter deferred mode for an unknown reason.\nstatic var deferredCanceled: CLError.Code\nA constant that indicates your app or the location manager canceled the request for deferred updates.\nstatic var deferredDistanceFiltered: CLError.Code\nA constant that indicates deferred mode doesn’t support distance filters.\nstatic var deferredNotUpdatingLocation: CLError.Code\nA constant that indicates the location manager didn’t enter deferred mode because location updates were already disabled or paused."
  },
  {
    "title": "geocodeFoundPartialResult | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320664-geocodefoundpartialresult",
    "html": "See Also\nGetting geocoding errors\nstatic var geocodeCanceled: CLError.Code\nA constant that indicates the geocode request was canceled.\nstatic var geocodeFoundNoResult: CLError.Code\nA constant that indicates the geocode request yielded no result."
  },
  {
    "title": "geocodeCanceled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320667-geocodecanceled",
    "html": "See Also\nGetting geocoding errors\nstatic var geocodeFoundNoResult: CLError.Code\nA constant that indicates the geocode request yielded no result.\nstatic var geocodeFoundPartialResult: CLError.Code\nA constant that indicates the geocode request yielded a partial result."
  },
  {
    "title": "deferredCanceled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320675-deferredcanceled",
    "html": "Discussion\n\nThis error is returned if you call the disallowDeferredLocationUpdates() method or schedule a new deferred update before the previous deferred update request is processed. The location manager may also report this error too. For example, if the app is in the foreground when a new location is determined, the location manager cancels deferred updates and delivers the location data to your app.\n\nSee Also\nGetting deferred location update errors\nstatic var deferredFailed: CLError.Code\nA constant that indicates the location manager didn’t enter deferred mode for an unknown reason.\nstatic var deferredAccuracyTooLow: CLError.Code\nA constant that indicates deferred mode isn’t supported for the requested accuracy.\nstatic var deferredDistanceFiltered: CLError.Code\nA constant that indicates deferred mode doesn’t support distance filters.\nstatic var deferredNotUpdatingLocation: CLError.Code\nA constant that indicates the location manager didn’t enter deferred mode because location updates were already disabled or paused."
  },
  {
    "title": "deferredFailed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320665-deferredfailed",
    "html": "Discussion\n\nThis error can occur if GPS is unavailable, not active, or is temporarily interrupted. If you get this error on a device that has GPS hardware, the solution is to try again.\n\nSee Also\nGetting deferred location update errors\nstatic var deferredCanceled: CLError.Code\nA constant that indicates your app or the location manager canceled the request for deferred updates.\nstatic var deferredAccuracyTooLow: CLError.Code\nA constant that indicates deferred mode isn’t supported for the requested accuracy.\nstatic var deferredDistanceFiltered: CLError.Code\nA constant that indicates deferred mode doesn’t support distance filters.\nstatic var deferredNotUpdatingLocation: CLError.Code\nA constant that indicates the location manager didn’t enter deferred mode because location updates were already disabled or paused."
  },
  {
    "title": "deferredDistanceFiltered | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320668-deferreddistancefiltered",
    "html": "Discussion\n\nSet the distance filter to kCLDistanceFilterNone.\n\nSee Also\nGetting deferred location update errors\nstatic var deferredFailed: CLError.Code\nA constant that indicates the location manager didn’t enter deferred mode for an unknown reason.\nstatic var deferredCanceled: CLError.Code\nA constant that indicates your app or the location manager canceled the request for deferred updates.\nstatic var deferredAccuracyTooLow: CLError.Code\nA constant that indicates deferred mode isn’t supported for the requested accuracy.\nstatic var deferredNotUpdatingLocation: CLError.Code\nA constant that indicates the location manager didn’t enter deferred mode because location updates were already disabled or paused."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/3726352",
    "html": "Parameters\nlhs\n\nThe first error to compare.\n\nrhs\n\nThe second error to compare.\n\nReturn Value\n\nA Boolean value that’s set to true if the two errors are equal.\n\nSee Also\nComparing errors\nstatic func != (CLError, CLError) -> Bool\nIndicates whether two errors aren’t equal.\nfunc hash(into: inout Hasher)\nvar hashValue: Int"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/3726354-hash",
    "html": "See Also\nComparing errors\nstatic func == (CLError, CLError) -> Bool\nIndicates whether two errors are equal.\nstatic func != (CLError, CLError) -> Bool\nIndicates whether two errors aren’t equal.\nvar hashValue: Int"
  },
  {
    "title": "localizedDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2882750-localizeddescription",
    "html": "See Also\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar errorCode: Int\nThe error code the framework returns when location services fail.\nvar code: Code\nThe error code the framework returns when location services fail.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar alternateRegion: CLRegion?\nA region that location services can monitor more effectively."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2947095",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\nA Boolean value that’s set to true if the two errors aren't equal.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing errors\nstatic func == (CLError, CLError) -> Bool\nIndicates whether two errors are equal.\nfunc hash(into: inout Hasher)\nvar hashValue: Int"
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/3726355-hashvalue",
    "html": "See Also\nComparing errors\nstatic func == (CLError, CLError) -> Bool\nIndicates whether two errors are equal.\nstatic func != (CLError, CLError) -> Bool\nIndicates whether two errors aren’t equal.\nfunc hash(into: inout Hasher)"
  },
  {
    "title": "init(center:radius:identifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clcircularregion/1423761-init",
    "html": "Parameters\ncenter\n\nThe center point of the geographic region to monitor.\n\nradius\n\nThe distance (measured in meters) from the center point of the geographic region to the edge of the circular boundary.\n\nidentifier\n\nA unique identifier to associate with the region object. You use this identifier to differentiate regions within your app. This value can’t be nil.\n\nReturn Value\n\nAn initialized region object.\n\nDiscussion\n\nWhen defining a geographic region, remember that the location manager doesn’t generate notifications immediately upon crossing a region boundary. Instead, it applies time and distance criteria to ensure that the crossing is intentional and needs to trigger a notification. So choose a center point and radius that are appropriate and give you enough time to alert the user. For more information, see the information about region monitoring in Location and Maps Programming Guide."
  },
  {
    "title": "center | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clcircularregion/1423601-center",
    "html": "See Also\nGetting the circle’s center and radius\nvar radius: CLLocationDistance\nThe radius (measured in meters) that defines the geographic area’s outer boundary.\nDeprecated"
  },
  {
    "title": "CLCircularGeographicCondition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clcirculargeographiccondition",
    "html": "Overview\n\nUse CLCircularGeographicCondition to monitor events that occur in a circular geographic condition that you describe.\n\nTopics\nCreating a circular geographic condition\n- initWithCenter:radius:\nCreates a new circular geographic condition with the center point and radius you provide.\nInstance properties\ncenter\nThe center of the circular geographic condition.\nradius\nThe radius of the circular geographic condition.\nRelationships\nInherits From\nCLCondition\nConforms To\nNSSecureCoding\nSee Also\niBeacon\nDetermining the proximity to an iBeacon device\nDetect beacons and determine the relative distance to them.\nTurning an iOS device into an iBeacon device\nBroadcast iBeacon signals from an iOS device.\nCLBeacon\nInformation about an observed iBeacon device and its relative distance to the user’s device.\nCLCondition\nThe abstract base class that all other conditions derive from.\nCLBeaconIdentityCondition\nA condition that describes the identity characteristics of a beacon."
  },
  {
    "title": "course | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1423832-course",
    "html": "Discussion\n\nCourse values are measured in degrees starting at due north and continue clockwise around the compass. Thus, north is 0 degrees, east is 90 degrees, south is 180 degrees, and so on. Course values may not be available on all devices. A negative value indicates that the course information is invalid.\n\nSpecial Considerations\n\nIn iOS, this property is declared as nonatomic. In macOS, it is declared as atomic.\n\nSee Also\nGetting speed and course information\nvar speed: CLLocationSpeed\nThe instantaneous speed of the device, measured in meters per second.\nvar speedAccuracy: CLLocationSpeedAccuracy\nThe accuracy of the speed value, measured in meters per second.\nvar courseAccuracy: CLLocationDirectionAccuracy\nThe accuracy of the course value, measured in degrees.\ntypealias CLLocationSpeed\nThe velocity (measured in meters per second) at which the device is moving.\ntypealias CLLocationDirection\nAn azimuth that is measured in degrees relative to true north.\ntypealias CLLocationSpeedAccuracy\nThe accuracy of a speed.\ntypealias CLLocationDirectionAccuracy\nThe accuracy of a compass heading."
  },
  {
    "title": "CLLocationDirection | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationdirection",
    "html": "Discussion\n\nDirection values are measured in degrees starting at due north and continue clockwise around the compass. Thus, north is 0 degrees, east is 90 degrees, south is 180 degrees, and so on. A negative value indicates an invalid direction.\n\nSee Also\nGetting speed and course information\nvar speed: CLLocationSpeed\nThe instantaneous speed of the device, measured in meters per second.\nvar speedAccuracy: CLLocationSpeedAccuracy\nThe accuracy of the speed value, measured in meters per second.\nvar course: CLLocationDirection\nThe direction in which the device is traveling, measured in degrees and relative to due north.\nvar courseAccuracy: CLLocationDirectionAccuracy\nThe accuracy of the course value, measured in degrees.\ntypealias CLLocationSpeed\nThe velocity (measured in meters per second) at which the device is moving.\ntypealias CLLocationSpeedAccuracy\nThe accuracy of a speed.\ntypealias CLLocationDirectionAccuracy\nThe accuracy of a compass heading."
  },
  {
    "title": "CLLocationSpeedAccuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationspeedaccuracy",
    "html": "See Also\nGetting speed and course information\nvar speed: CLLocationSpeed\nThe instantaneous speed of the device, measured in meters per second.\nvar speedAccuracy: CLLocationSpeedAccuracy\nThe accuracy of the speed value, measured in meters per second.\nvar course: CLLocationDirection\nThe direction in which the device is traveling, measured in degrees and relative to due north.\nvar courseAccuracy: CLLocationDirectionAccuracy\nThe accuracy of the course value, measured in degrees.\ntypealias CLLocationSpeed\nThe velocity (measured in meters per second) at which the device is moving.\ntypealias CLLocationDirection\nAn azimuth that is measured in degrees relative to true north.\ntypealias CLLocationDirectionAccuracy\nThe accuracy of a compass heading."
  },
  {
    "title": "startRangingBeacons(satisfying:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/3240607-startrangingbeacons",
    "html": "Parameters\nconstraint\n\nA CLBeaconIdentityConstraint constraint.\n\nSee Also\nPerforming beacon ranging\nfunc stopRangingBeacons(satisfying: CLBeaconIdentityConstraint)\nStops the delivery of notifications for the specified beacon constraints.\nvar rangedBeaconConstraints: Set<CLBeaconIdentityConstraint>\nThe set of beacon constraints currently being tracked using ranging."
  },
  {
    "title": "remove(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4155908-remove",
    "html": "Parameters\nidentifier\n\nA string that identifies the monitored condition.\n\nSee Also\nAdding and removing conditions\nfunc add(CLCondition, identifier: String)\nAdds the given condition for monitoring.\nfunc add(CLCondition, identifier: String, assuming: CLMonitor.Event.State)\nAdds the monitoring condition with the identifier and initial state you specify.\nfunc preconditionIsolated(() -> String, file: StaticString, line: UInt)\nUnconditionally if the current task is executing on the serial executor of the passed in actor, and if not crash the program offering information about the executor mismatch.\nfunc record(for: String) -> CLMonitor.Record?\nA record that contains a condition and the most recent event your app receives."
  },
  {
    "title": "preconditionIsolated(_:file:line:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4226440-preconditionisolated",
    "html": "Discussion\n\nThis function’s effect varies depending on the build flag used:\n\nIn playgrounds and -Onone builds (the default for Xcode’s Debug configuration), stops program execution in a debuggable state after printing message.\n\nIn -O builds (the default for Xcode’s Release configuration), stops program execution.\n\nIn -Ounchecked builds, the optimizer may assume that this function is never called. Failure to satisfy that assumption is a serious programming error.\n\nSee Also\nAdding and removing conditions\nfunc add(CLCondition, identifier: String)\nAdds the given condition for monitoring.\nfunc add(CLCondition, identifier: String, assuming: CLMonitor.Event.State)\nAdds the monitoring condition with the identifier and initial state you specify.\nfunc record(for: String) -> CLMonitor.Record?\nA record that contains a condition and the most recent event your app receives.\nfunc remove(String)\nRemoves the condition and its enclosed record associated with the identifier you provide."
  },
  {
    "title": "reverseGeocodeLocation(_:preferredLocale:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder/2908779-reversegeocodelocation",
    "html": "Parameters\nlocation\n\nThe location object containing the coordinate data to look up.\n\nlocale\n\nThe locale to use when returning the address information. You might specify a value for this parameter when you want the address returned in a locale that differs from the user's current language settings. Specify nil to use the user's default locale information.\n\ncompletionHandler\n\nThe handler block to execute with the results. The geocoder executes this handler regardless of whether the request was successful or unsuccessful. For more information on the format of this block, see CLGeocodeCompletionHandler.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc reverseGeocodeLocation(_ location: CLLocation, preferredLocale locale: Locale?) async throws -> [CLPlacemark]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis method submits the specified location data to the geocoding server asynchronously and returns. When the request completes, the geocoder executes the provided completion handler on the main thread.\n\nAfter initiating a reverse-geocoding request, do not attempt to initiate another reverse- or forward-geocoding request. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. When the maximum rate is exceeded, the geocoder passes an error object with the value network to your completion handler.\n\nSee Also\nReverse geocoding a location\nfunc reverseGeocodeLocation(CLLocation, completionHandler: CLGeocodeCompletionHandler)\nSubmits a reverse-geocoding request for the specified location.\ntypealias CLGeocodeCompletionHandler\nA block to be called when a geocoding request is complete."
  },
  {
    "title": "locationManager(_:didFailWithError:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423786-locationmanager",
    "html": "Parameters\nmanager\n\nThe location manager object that was unable to retrieve the location.\n\nerror\n\nThe error object containing the reason the location or heading could not be retrieved.\n\nDiscussion\n\nIf you do not implement this method, Core Location throws an exception when attempting to use location services.\n\nThe location manager calls this method when it encounters an error trying to get the location or heading data. If the location service is unable to retrieve a location right away, it reports a CLError.Code.locationUnknown error and keeps trying. In such a situation, you can simply ignore the error and wait for a new event. If a heading could not be determined because of strong interference from nearby magnetic fields, this method returns CLError.Code.headingFailure.\n\nIf the user denies your app's use of the location service, this method reports a CLError.Code.denied error. Upon receiving such an error, you should stop the location service."
  },
  {
    "title": "geocodeAddressString(_:in:preferredLocale:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder/2890753-geocodeaddressstring",
    "html": "Parameters\naddressString\n\nA string describing the location you want to look up. For example, you could specify the string “1 Infinite Loop, Cupertino, CA” to locate Apple headquarters.\n\nregion\n\nA geographical region to use as a hint when looking up the specified address. Specifying a region lets you prioritize the returned set of results to locations that are close to some specific geographical area, which is typically the user’s current location. If the application is authorized for location services and you specify nil for this parameter, the set of results is prioritized based on the user’s approximate location. Calling this method does not trigger a location services authorization request.\n\nlocale\n\nThe locale of the address string. Specify nil to use the current locale of the user.\n\ncompletionHandler\n\nThe handler block to execute with the results. The geocoder executes this handler regardless of whether the request was successful or unsuccessful. For more information on the format of this block, see CLGeocodeCompletionHandler.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc geocodeAddressString(_ addressString: String, in region: CLRegion?, preferredLocale locale: Locale?) async throws -> [CLPlacemark]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis method submits the specified location data to the geocoding server asynchronously and returns. When the request completes, the geocoder executes the provided completion handler on the main thread.\n\nAfter initiating a forward-geocoding request, do not attempt to initiate another reverse- or forward-geocoding request. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. When the maximum rate is exceeded, the geocoder passes an error object with the value network to your completion handler.\n\nSee Also\nGeocoding an address\nfunc geocodeAddressString(String, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string.\nfunc geocodeAddressString(String, in: CLRegion?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string and region information.\nfunc geocodePostalAddress(CNPostalAddress, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified Contacts framework information.\nfunc geocodePostalAddress(CNPostalAddress, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified locale and Contacts framework information.\nfunc geocodeAddressDictionary([AnyHashable : Any], completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified address dictionary.\nDeprecated"
  },
  {
    "title": "CLError.Code.network | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/code/network",
    "html": "See Also\nGetting general errors\ncase locationUnknown\nA constant that indicates the location manager was unable to obtain a location value right now.\ncase denied\nA constant that indicates the user denied access to the location service.\ncase promptDeclined\nA constant that indicates the user didn’t grant the requested temporary authorization.\ncase headingFailure\nA constant that indicates the location manager can’t determine the heading.\ncase rangingUnavailable\nA constant that indicates ranging is disabled.\ncase rangingFailure\nA constant that indicates a general ranging error occurred."
  },
  {
    "title": "geocodePostalAddress(_:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder/2890752-geocodepostaladdress",
    "html": "Parameters\npostalAddress\n\nA postal address from the Contacts framework. The address should be specified in the user's current locale.\n\ncompletionHandler\n\nThe handler block to execute with the results. The geocoder executes this handler regardless of whether the request was successful or unsuccessful. For more information on the format of this block, see CLGeocodeCompletionHandler.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc geocodePostalAddress(_ postalAddress: CNPostalAddress) async throws -> [CLPlacemark]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis method submits the specified location data to the geocoding server asynchronously and returns. When the request completes, the geocoder executes the provided completion handler on the main thread.\n\nAfter initiating a forward-geocoding request, do not attempt to initiate another reverse- or forward-geocoding request. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. When the maximum rate is exceeded, the geocoder passes an error object with the value network to your completion handler.\n\nSee Also\nGeocoding an address\nfunc geocodeAddressString(String, in: CLRegion?, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified address string and locale information.\nfunc geocodeAddressString(String, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string.\nfunc geocodeAddressString(String, in: CLRegion?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string and region information.\nfunc geocodePostalAddress(CNPostalAddress, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified locale and Contacts framework information.\nfunc geocodeAddressDictionary([AnyHashable : Any], completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified address dictionary.\nDeprecated"
  },
  {
    "title": "CLGeocodeCompletionHandler | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocodecompletionhandler",
    "html": "Discussion\n\nUpon completion of a geocoding request, a block of this form is called to give you a chance to process the results. The parameters of this block are as follows:\n\nplacemark\n\nContains an array of CLPlacemark objects. For most geocoding requests, this array should contain only one entry. However, forward-geocoding requests may return multiple placemark objects in situations where the specified address could not be resolved to a single location.\n\nIf the request was canceled or there was an error in obtaining the placemark information, this parameter is nil.\n\nerror\n\nContains nil or an error object indicating why the placemark data was not returned. For a list of possible error codes, see CLError.Code.\n\nSee Also\nReverse geocoding a location\nfunc reverseGeocodeLocation(CLLocation, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a reverse-geocoding request for the specified location and locale.\nfunc reverseGeocodeLocation(CLLocation, completionHandler: CLGeocodeCompletionHandler)\nSubmits a reverse-geocoding request for the specified location."
  },
  {
    "title": "isGeocoding | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder/1423765-isgeocoding",
    "html": "Discussion\n\nThis property contains the value true if the process is ongoing or false if the process is done or has not yet been initiated.\n\nSee Also\nManaging geocoding requests\nfunc cancelGeocode()\nCancels a pending geocoding request."
  },
  {
    "title": "cancelGeocode() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder/1423562-cancelgeocode",
    "html": "Discussion\n\nYou can use this method to cancel a pending request and free up the resources associated with that request. Canceling a pending request causes the completion handler block to be called.\n\nIf the request is not pending, because it has already returned or has not yet begun, this method does nothing.\n\nSee Also\nManaging geocoding requests\nvar isGeocoding: Bool\nA Boolean value indicating whether the receiver is in the middle of geocoding its value."
  },
  {
    "title": "geocodePostalAddress(_:preferredLocale:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder/2890750-geocodepostaladdress",
    "html": "Parameters\npostalAddress\n\nA postal address from the Contacts framework.\n\nlocale\n\nThe locale of the postal address. Specify nil to use the current locale of the user.\n\ncompletionHandler\n\nThe handler block to execute with the results. The geocoder executes this handler regardless of whether the request was successful or unsuccessful. For more information on the format of this block, see CLGeocodeCompletionHandler.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc geocodePostalAddress(_ postalAddress: CNPostalAddress, preferredLocale locale: Locale?) async throws -> [CLPlacemark]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis method submits the specified location data to the geocoding server asynchronously and returns. When the request completes, the geocoder executes the provided completion handler on the main thread.\n\nAfter initiating a forward-geocoding request, do not attempt to initiate another reverse- or forward-geocoding request. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. When the maximum rate is exceeded, the geocoder passes an error object with the value network to your completion handler.\n\nSee Also\nGeocoding an address\nfunc geocodeAddressString(String, in: CLRegion?, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified address string and locale information.\nfunc geocodeAddressString(String, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string.\nfunc geocodeAddressString(String, in: CLRegion?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string and region information.\nfunc geocodePostalAddress(CNPostalAddress, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified Contacts framework information.\nfunc geocodeAddressDictionary([AnyHashable : Any], completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified address dictionary.\nDeprecated"
  },
  {
    "title": "geocodeAddressDictionary(_:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder/1423693-geocodeaddressdictionary",
    "html": "Deprecated\n\nUse geocodePostalAddress(_:preferredLocale:completionHandler:) or geocodePostalAddress(_:completionHandler:) instead.\n\nParameters\naddressDictionary\n\nAn Address Book dictionary containing information about the address to look up.\n\ncompletionHandler\n\nA block object containing the code to execute at the end of the request. This code is called whether the request is successful or unsuccessful.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc geocodeAddressDictionary(_ addressDictionary: [AnyHashable : Any]) async throws -> [CLPlacemark]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis method submits the specified location data to the geocoding server asynchronously and returns. Your completion handler block will be executed on the main thread.\n\nAfter initiating a forward-geocoding request, do not attempt to initiate another forward- or reverse-geocoding request. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. When the maximum rate is exceeded, the geocoder passes an error object with the value CLError.Code.network to your completion handler.\n\nSee Also\nGeocoding an address\nfunc geocodeAddressString(String, in: CLRegion?, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified address string and locale information.\nfunc geocodeAddressString(String, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string.\nfunc geocodeAddressString(String, in: CLRegion?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string and region information.\nfunc geocodePostalAddress(CNPostalAddress, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified Contacts framework information.\nfunc geocodePostalAddress(CNPostalAddress, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified locale and Contacts framework information."
  },
  {
    "title": "startRangingBeacons(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620554-startrangingbeacons",
    "html": "Deprecated\n\nUse startRangingBeacons(satisfying:) instead.\n\nParameters\nregion\n\nThe region object that defines the identifying information for the targeted beacons. The number of beacons represented by this region object depends on which identifier values you use to initialize it. Beacons must match all of the identifiers you specify. This method copies the region information it needs from the object you provide.\n\nDiscussion\n\nOnce registered, the location manager reports any encountered beacons to its delegate by calling the locationManager(_:didRangeBeacons:in:) method. If there is an error registering the specified beacon region, the location manager calls its delegate’s locationManager(_:rangingBeaconsDidFailFor:withError:) method and provides the appropriate error information.\n\nSee Also\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "accuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeacon/1621551-accuracy",
    "html": "Discussion\n\nA beacon with a smaller value for accuracy is typically nearer than a beacon with a larger accuracy value.\n\nUse this property to differentiate between beacons with the same proximity value. Do not use it to identify a precise location for the beacon. Accuracy values may fluctuate due to RF interference.\n\nA negative value in this property signifies that the actual accuracy could not be determined.\n\nSee Also\nDetermining the distance to the beacon\nvar proximity: CLProximity\nThe relative distance to the beacon.\nenum CLProximity\nConstants that reflect the relative distance to a beacon.\nvar rssi: Int\nThe received signal strength of the beacon, measured in decibels."
  },
  {
    "title": "rssi | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeacon/1621557-rssi",
    "html": "Discussion\n\nThis value is the average signal strength of the samples received since Core Location last reported the range of the beacon to your app.\n\nUse this value for calibrating beacon transmission power.\n\nSee Also\nDetermining the distance to the beacon\nvar proximity: CLProximity\nThe relative distance to the beacon.\nenum CLProximity\nConstants that reflect the relative distance to a beacon.\nvar accuracy: CLLocationAccuracy\nThe accuracy of the proximity value, measured in meters from the beacon."
  },
  {
    "title": "locationManager(_:didUpdateHeading:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1621555-locationmanager",
    "html": "Parameters\nmanager\n\nThe location manager object that generated the update event.\n\nnewHeading\n\nThe new heading data.\n\nDiscussion\n\nImplementation of this method is optional but expected if you start heading updates using the startUpdatingHeading() method.\n\nThe location manager object calls this method after you initially start the heading service. Subsequent events are delivered when the previously reported value changes by more than the value specified in the headingFilter property of the location manager object.\n\nSee Also\nReceiving heading updates\nfunc locationManagerShouldDisplayHeadingCalibration(CLLocationManager) -> Bool\nAsks the delegate whether the heading calibration alert should be displayed."
  },
  {
    "title": "locationManagerDidPauseLocationUpdates(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1621553-locationmanagerdidpauselocationu",
    "html": "Parameters\nmanager\n\nThe location manager object that paused the delivery of events.\n\nDiscussion\n\nWhen the location manager detects that the device’s location is not changing, it can pause the delivery of updates in order to shut down the appropriate hardware and save power. When it does this, it calls this method to let your app know that this has happened.\n\nAfter a pause occurs, it is your responsibility to restart location services again at an appropriate time. You might use your implementation of this method to start region monitoring at the user's current location or enable the visits location service to determine when the user starts moving again. Another alternative is to restart location services immediately with a reduced accuracy (which can save power) and then return to a greater accuracy only after the user starts moving again.\n\nSee Also\nPausing location updates\nfunc locationManagerDidResumeLocationUpdates(CLLocationManager)\nTells the delegate that the delivery of location updates has resumed."
  },
  {
    "title": "locationManagerDidResumeLocationUpdates(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1621512-locationmanagerdidresumelocation",
    "html": "Parameters\nmanager\n\nThe location manager that resumed the delivery of events.\n\nDiscussion\n\nWhen you restart location services after an automatic pause, Core Location calls this method to notify your app that services have resumed. You are responsible for restarting location services in your app. Core Location does not resume updates automatically after it pauses them. For tips on how to restart location services when a pause occurs, see the discussion of the locationManagerDidPauseLocationUpdates(_:) method.\n\nSee Also\nPausing location updates\nfunc locationManagerDidPauseLocationUpdates(CLLocationManager)\nTells the delegate that location updates were paused."
  },
  {
    "title": "CLRegionState | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregionstate",
    "html": "Topics\nRegion States\ncase unknown\nIt is unknown whether the location is inside or outside of the region.\ncase inside\nThe location is inside of the given region.\ncase outside\nThe location is outside of the given region.\nRelationships\nConforms To\nSendable\nSee Also\nReceiving region-related updates\nfunc locationManager(CLLocationManager, didEnterRegion: CLRegion)\nTells the delegate that the user entered the specified region.\nfunc locationManager(CLLocationManager, didExitRegion: CLRegion)\nTells the delegate that the user left the specified region.\nfunc locationManager(CLLocationManager, didDetermineState: CLRegionState, for: CLRegion)\nTells the delegate about the state of the specified region.\nfunc locationManager(CLLocationManager, monitoringDidFailFor: CLRegion?, withError: Error)\nTells the delegate that a region monitoring error occurred.\nfunc locationManager(CLLocationManager, didStartMonitoringFor: CLRegion)\nTells the delegate that a new region is being monitored."
  },
  {
    "title": "locationManager(_:didVisit:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1621529-locationmanager",
    "html": "Parameters\nmanager\n\nThe location manager object reporting the event.\n\nvisit\n\nThe visit object that contains the information about the event.\n\nDiscussion\n\nThe location manager calls this method whenever it has new visit event to report to your app."
  },
  {
    "title": "locationManager(_:didFailRangingFor:error:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/3240609-locationmanager",
    "html": "Parameters\nmanager\n\nThe CLLocationManager that corresponds to this delegate.\n\nbeaconConstraint\n\nThe CLBeaconIdentityConstraint that describes the characteristics of the beacons the location manager is looking for.\n\nerror\n\nAn NSError object that describes the error.\n\nSee Also\nReceiving beacon-related updates\nfunc locationManager(CLLocationManager, didRange: [CLBeacon], satisfying: CLBeaconIdentityConstraint)\nTells the delegate that the location manager detected at least one beacon that satisfies the provided constraint.\nfunc locationManager(CLLocationManager, didRangeBeacons: [CLBeacon], in: CLBeaconRegion)\nTells the delegate that one or more beacons are in range.\nDeprecated\nfunc locationManager(CLLocationManager, rangingBeaconsDidFailFor: CLBeaconRegion, withError: Error)\nTells the delegate that an error occurred while gathering ranging information for a set of beacons.\nDeprecated"
  },
  {
    "title": "locationManager(_:didRange:satisfying:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/3240610-locationmanager",
    "html": "Parameters\nmanager\n\nThe CLLocationManager that corresponds to this delegate.\n\nbeacons\n\nAn array of CLBeacon objects.\n\nbeaconConstraint\n\nThe CLBeaconIdentityConstraint that describes the characteristics of the beacons the location manager is looking for.\n\nSee Also\nReceiving beacon-related updates\nfunc locationManager(CLLocationManager, didFailRangingFor: CLBeaconIdentityConstraint, error: Error)\nTells the delegate that the location manager couldn’t detect any beacons that satisfy the provided constraint.\nfunc locationManager(CLLocationManager, didRangeBeacons: [CLBeacon], in: CLBeaconRegion)\nTells the delegate that one or more beacons are in range.\nDeprecated\nfunc locationManager(CLLocationManager, rangingBeaconsDidFailFor: CLBeaconRegion, withError: Error)\nTells the delegate that an error occurred while gathering ranging information for a set of beacons.\nDeprecated"
  },
  {
    "title": "locationManager(_:rangingBeaconsDidFailFor:withError:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1621483-locationmanager",
    "html": "Deprecated\n\nUse locationManager(_:didFailRangingFor:error:) instead.\n\nParameters\nmanager\n\nThe location manager object reporting the event.\n\nregion\n\nThe region object that encountered the error.\n\nerror\n\nAn error object containing the error code that indicates why ranging failed.\n\nDiscussion\n\nErrors occur most often when registering a beacon region failed. If the region object itself is invalid or if it contains invalid data, the location manager calls this method to report the problem.\n\nSee Also\nReceiving beacon-related updates\nfunc locationManager(CLLocationManager, didRange: [CLBeacon], satisfying: CLBeaconIdentityConstraint)\nTells the delegate that the location manager detected at least one beacon that satisfies the provided constraint.\nfunc locationManager(CLLocationManager, didFailRangingFor: CLBeaconIdentityConstraint, error: Error)\nTells the delegate that the location manager couldn’t detect any beacons that satisfy the provided constraint.\nfunc locationManager(CLLocationManager, didRangeBeacons: [CLBeacon], in: CLBeaconRegion)\nTells the delegate that one or more beacons are in range.\nDeprecated"
  },
  {
    "title": "init(coordinate:altitude:horizontalAccuracy:verticalAccuracy:course:courseAccuracy:speed:speedAccuracy:timestamp:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/3524339-init",
    "html": "Parameters\ncoordinate\n\nA coordinate structure containing the latitude and longitude values.\n\naltitude\n\nThe altitude value for the location.\n\nhAccuracy\n\nThe radius of uncertainty for the geographical coordinate, measured in meters. Specify a negative number to indicate that the geographical coordinate is invalid.\n\nvAccuracy\n\nThe accuracy of the altitude value, measured in meters. Specify a negative number to indicate that the altitude is invalid.\n\ncourse\n\nThe direction of travel for the location, measured in degrees relative to due north and continuing clockwise around the compass.\n\ncourseAccuracy\n\nThe accuracy of the course value, measured in degrees. Specify a negative number to indicate that the course is invalid.\n\nspeed\n\nThe current speed associated with this location, measured in meters per second.\n\nspeedAccuracy\n\nThe accuracy of the speed value, measured in meters per second. Specify a negative number to indicate that the speed is invalid.\n\ntimestamp\n\nThe time to associate with the location object. Typically, you specify the current time.\n\nSee Also\nCreating a location object\ninit(latitude: CLLocationDegrees, longitude: CLLocationDegrees)\nCreates a location object with the specified latitude and longitude.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, timestamp: Date)\nCreates a location object with the specified coordinate and altitude information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, speed: CLLocationSpeed, timestamp: Date)\nCreates a location object with the specified coordinate, altitude, and course information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, courseAccuracy: CLLocationDirectionAccuracy, speed: CLLocationSpeed, speedAccuracy: CLLocationSpeedAccuracy, timestamp: Date, sourceInfo: CLLocationSourceInformation)"
  },
  {
    "title": "kCLLocationAccuracyKilometer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kcllocationaccuracykilometer",
    "html": "Discussion\n\nThis level of accurate is available only if isAuthorizedForPreciseLocation is true.\n\nSee Also\nDesired Accuracy Constants\nlet kCLLocationAccuracyBestForNavigation: CLLocationAccuracy\nThe highest possible accuracy that uses additional sensor data to facilitate navigation apps.\nlet kCLLocationAccuracyBest: CLLocationAccuracy\nThe best level of accuracy available.\nlet kCLLocationAccuracyNearestTenMeters: CLLocationAccuracy\nAccurate to within ten meters of the desired target.\nlet kCLLocationAccuracyHundredMeters: CLLocationAccuracy\nAccurate to within one hundred meters.\nlet kCLLocationAccuracyThreeKilometers: CLLocationAccuracy\nAccurate to the nearest three kilometers.\nlet kCLLocationAccuracyReduced: CLLocationAccuracy\nThe level of accuracy used when an app isn’t authorized for full accuracy location data."
  },
  {
    "title": "kCLLocationAccuracyBest | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kcllocationaccuracybest",
    "html": "Discussion\n\nSpecify this constant when you want very high accuracy but don’t need the same level of accuracy required for navigation apps.\n\nThis level of accurate is available only if isAuthorizedForPreciseLocation is true.\n\nSee Also\nDesired Accuracy Constants\nlet kCLLocationAccuracyBestForNavigation: CLLocationAccuracy\nThe highest possible accuracy that uses additional sensor data to facilitate navigation apps.\nlet kCLLocationAccuracyNearestTenMeters: CLLocationAccuracy\nAccurate to within ten meters of the desired target.\nlet kCLLocationAccuracyHundredMeters: CLLocationAccuracy\nAccurate to within one hundred meters.\nlet kCLLocationAccuracyKilometer: CLLocationAccuracy\nAccurate to the nearest kilometer.\nlet kCLLocationAccuracyThreeKilometers: CLLocationAccuracy\nAccurate to the nearest three kilometers.\nlet kCLLocationAccuracyReduced: CLLocationAccuracy\nThe level of accuracy used when an app isn’t authorized for full accuracy location data."
  },
  {
    "title": "init(latitude:longitude:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1423660-init",
    "html": "Parameters\nlatitude\n\nThe latitude of the geographical coordinate.\n\nlongitude\n\nThe longitude of the geographical coordinate.\n\nReturn Value\n\nA location object initialized with the specified geographical coordinate.\n\nDiscussion\n\nUse this method to create location objects that are not necessarily based on the user's current location. Typically, you acquire location objects from your CLLocationManager object, which returns the user's actual location. However, you might use this method when you want to represent any location on a map. For example, you might create an object to represent the user's intended destination.\n\nThis method records the latitude and longitude values you provide, and it initializes other properties to appropriate default values. Specifically, this method sets the altitude and horizontalAccuracy properties to 0, sets the verticalAccuracy property to -1 to indicate that the altitude is invalid, sets the speed and course values to -1, and sets the timestamp property to the time at which the returned object was created.\n\nSee Also\nCreating a location object\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, timestamp: Date)\nCreates a location object with the specified coordinate and altitude information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, speed: CLLocationSpeed, timestamp: Date)\nCreates a location object with the specified coordinate, altitude, and course information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, courseAccuracy: CLLocationDirectionAccuracy, speed: CLLocationSpeed, speedAccuracy: CLLocationSpeedAccuracy, timestamp: Date)\nCreates a location object with the specified coordinate, altitude, course, and accuracy information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, courseAccuracy: CLLocationDirectionAccuracy, speed: CLLocationSpeed, speedAccuracy: CLLocationSpeedAccuracy, timestamp: Date, sourceInfo: CLLocationSourceInformation)\nRelated Documentation\nLocation and Maps Programming Guide"
  },
  {
    "title": "init(coordinate:altitude:horizontalAccuracy:verticalAccuracy:timestamp:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1423666-init",
    "html": "Parameters\ncoordinate\n\nA coordinate structure containing the latitude and longitude values.\n\naltitude\n\nThe altitude value for the location.\n\nhAccuracy\n\nThe radius of uncertainty for the geographical coordinate, measured in meters. Specify a negative number to indicate that the geographical coordinate is invalid.\n\nvAccuracy\n\nThe accuracy of the altitude value, measured in meters. Specify a negative number to indicate that the altitude is invalid.\n\ntimestamp\n\nThe time to associate with the location object. Typically, you specify the current time.\n\nReturn Value\n\nA location object initialized with the specified geographical coordinate and altitude information.\n\nDiscussion\n\nUse this method to create location objects that are not necessarily based on the user's current location.Typically, you acquire location objects from your CLLocationManager object, which returns the user's actual location. However, you might use this method when you want to represent any location on a map. For example, you might create an object to represent the user's intended destination.\n\nThis method records the values you provide, and it initializes other properties to appropriate default values. Specifically, this method sets the speed and course values to -1.\n\nSee Also\nCreating a location object\ninit(latitude: CLLocationDegrees, longitude: CLLocationDegrees)\nCreates a location object with the specified latitude and longitude.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, speed: CLLocationSpeed, timestamp: Date)\nCreates a location object with the specified coordinate, altitude, and course information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, courseAccuracy: CLLocationDirectionAccuracy, speed: CLLocationSpeed, speedAccuracy: CLLocationSpeedAccuracy, timestamp: Date)\nCreates a location object with the specified coordinate, altitude, course, and accuracy information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, courseAccuracy: CLLocationDirectionAccuracy, speed: CLLocationSpeed, speedAccuracy: CLLocationSpeedAccuracy, timestamp: Date, sourceInfo: CLLocationSourceInformation)"
  },
  {
    "title": "init(coordinate:altitude:horizontalAccuracy:verticalAccuracy:course:speed:timestamp:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1423718-init",
    "html": "Parameters\ncoordinate\n\nA coordinate structure containing the latitude and longitude values.\n\naltitude\n\nThe altitude value for the location.\n\nhAccuracy\n\nThe radius of uncertainty for the geographical coordinate, measured in meters. Specify a negative number to indicate that the geographical coordinate is invalid.\n\nvAccuracy\n\nThe accuracy of the altitude value, measured in meters. Specify a negative number to indicate that the altitude is invalid.\n\ncourse\n\nThe direction of travel for the location, measured in degrees relative to due north and continuing clockwise around the compass.\n\nspeed\n\nThe current speed associated with this location, measured in meters per second.\n\ntimestamp\n\nThe time to associate with the location object. Typically, you specify the current time.\n\nReturn Value\n\nA location object initialized with the specified geographical coordinate, altitude, and course information.\n\nDiscussion\n\nUse this method to create location objects that aren’t necessarily based on the user’s current location.Typically, you acquire location objects from your CLLocationManager object, which returns the user’s actual location. However, you might use this method when you want to represent any location on a map. For example, you might create an object to represent the user’s intended destination.\n\nSee Also\nCreating a location object\ninit(latitude: CLLocationDegrees, longitude: CLLocationDegrees)\nCreates a location object with the specified latitude and longitude.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, timestamp: Date)\nCreates a location object with the specified coordinate and altitude information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, courseAccuracy: CLLocationDirectionAccuracy, speed: CLLocationSpeed, speedAccuracy: CLLocationSpeedAccuracy, timestamp: Date)\nCreates a location object with the specified coordinate, altitude, course, and accuracy information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, courseAccuracy: CLLocationDirectionAccuracy, speed: CLLocationSpeed, speedAccuracy: CLLocationSpeedAccuracy, timestamp: Date, sourceInfo: CLLocationSourceInformation)"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211288-compactmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211292-drop",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211284-allsatisfy",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true.\n\nSee Also\nInstance methods\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211296-filter",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211294-dropfirst",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates/4211290-contains",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "CLLocationUpdate.LiveConfiguration.otherNavigation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/liveconfiguration/othernavigation",
    "html": "See Also\nLocation types\ncase `default`\nThe value that configures positioning for activities that one of the other activity types doesn’t cover.\ncase airborne\nThe value that configures positioning for activities in the air.\ncase automotiveNavigation\nThe value that configures positioning for an automobile following a road network.\ncase fitness\nThe value that configures positioning for dedicated fitness sessions."
  },
  {
    "title": "CLActivityType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clactivitytype",
    "html": "Topics\nActivity types\ncase other\nThe value that indicates the app is using location manager for an unspecified activity.\ncase automotiveNavigation\nThe value that indicates positioning in an automobile following a road network.\ncase fitness\nThe value that indicates positioning during dedicated fitness sessions, such as walking workouts, running workouts, cycling workouts, and so on.\ncase otherNavigation\nThe value that indicates positioning for activities that don’t or may not adhere to roads such as cycling, scooters, trains, boats and off-road vehicles.\ncase airborne\nThe value that indicates activities in the air.\nRelationships\nConforms To\nSendable\nSee Also\nRunning the standard location service\nfunc startUpdatingLocation()\nStarts the generation of updates that report the user’s current location.\nfunc stopUpdatingLocation()\nStops the generation of location updates.\nfunc requestLocation()\nRequests the one-time delivery of the user’s current location.\nvar pausesLocationUpdatesAutomatically: Bool\nA Boolean value that indicates whether the location-manager object may pause location updates.\nvar allowsBackgroundLocationUpdates: Bool\nA Boolean value that indicates whether the app receives location updates when running in the background.\nvar showsBackgroundLocationIndicator: Bool\nA Boolean value that indicates whether the status bar changes its appearance when an app uses location services in the background.\nvar activityType: CLActivityType\nThe type of activity the app expects the user to typically perform while in the app’s location session."
  },
  {
    "title": "stopMonitoringVisits() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1618693-stopmonitoringvisits",
    "html": "Discussion\n\nCalling this method disables the delivery of visit-related events for your app. If a compatible iPad or iPhone app calls this method when running in visionOS, the method does nothing.\n\nSee Also\nRunning the visits location service\nfunc startMonitoringVisits()\nStarts the delivery of visit-related events."
  },
  {
    "title": "distance(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1423689-distance",
    "html": "Parameters\nlocation\n\nThe destination location.\n\nReturn Value\n\nThe distance (in meters) between the two locations.\n\nDiscussion\n\nThis method measures the distance between the location in the current object and the value in the location parameter. The distance is calculated by tracing a line between the two points that follows the curvature of the Earth, and measuring the length of the resulting arc. The arc is a smooth curve that doesn’t take into account altitude changes between the two locations.\n\nSee Also\nMeasuring the distance between coordinates\nfunc getDistanceFrom(CLLocation) -> CLLocationDistance\nReturns the distance (measured in meters) from the current object’s location to the specified location.\nDeprecated"
  },
  {
    "title": "init(coordinate:altitude:horizontalAccuracy:verticalAccuracy:course:courseAccuracy:speed:speedAccuracy:timestamp:sourceInfo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/3861802-init",
    "html": "See Also\nCreating a location object\ninit(latitude: CLLocationDegrees, longitude: CLLocationDegrees)\nCreates a location object with the specified latitude and longitude.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, timestamp: Date)\nCreates a location object with the specified coordinate and altitude information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, speed: CLLocationSpeed, timestamp: Date)\nCreates a location object with the specified coordinate, altitude, and course information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, courseAccuracy: CLLocationDirectionAccuracy, speed: CLLocationSpeed, speedAccuracy: CLLocationSpeedAccuracy, timestamp: Date)\nCreates a location object with the specified coordinate, altitude, course, and accuracy information."
  },
  {
    "title": "verticalAccuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1423550-verticalaccuracy",
    "html": "Discussion\n\nA positive verticalAccuracy value represents the estimated uncertainty associated with altitude and ellipsoidalAltitude. This value is available whenever altitude values are available.\n\nIf verticalAccuracy is 0 or a negative number, altitude and ellipsoidalAltitude values are invalid. If verticalAccuracy is a postive number, altitude and ellipsoidalAltitude values are valid.\n\nA positive verticalAccuracy value represents an uncertainty that’s approximately 68 percent, or one standard deviation, above and below the altitude values.\n\nNote\n\nIn iOS, this property is declared as nonatomic. In macOS, it’s declared as atomic.\n\nSee Also\nGetting the location accuracy\nvar horizontalAccuracy: CLLocationAccuracy\nThe radius of uncertainty for the location, measured in meters.\ntypealias CLLocationAccuracy\nThe accuracy of a geographical coordinate."
  },
  {
    "title": "timestamp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1423589-timestamp",
    "html": "Discussion\n\nIn iOS, this property is declared as nonatomic. In macOS, it is declared as atomic.\n\nSee Also\nGetting the location attributes\nvar coordinate: CLLocationCoordinate2D\nThe geographical coordinate information.\nvar altitude: CLLocationDistance\nThe altitude above mean sea level associated with a location, measured in meters.\nvar ellipsoidalAltitude: CLLocationDistance\nThe altitude as a height above the World Geodetic System 1984 (WGS84) ellipsoid, measured in meters.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar floor: CLFloor?\nThe logical floor of the building in which the user is located.\nvar sourceInformation: CLLocationSourceInformation?\nInformation about the source that provides the location."
  },
  {
    "title": "getDistanceFrom(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1616758-getdistancefrom",
    "html": "Deprecated\n\nUse the distance(from:) method instead.\n\nParameters\nlocation\n\nThe other location.\n\nReturn Value\n\nThe distance (in meters) between the two locations.\n\nDiscussion\n\nThis method measures the distance between the location in the current object and the value in the location parameter. The distance is calculated by tracing a line between the two points that follows the curvature of the Earth, and measuring the length of the resulting arc. The arc is a smooth curve that does not take into account altitude changes between the two locations.\n\nSee Also\nMeasuring the distance between coordinates\nfunc distance(from: CLLocation) -> CLLocationDistance\nReturns the distance (measured in meters) from the current object’s location to the specified location."
  },
  {
    "title": "CLLocationSpeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationspeed",
    "html": "See Also\nGetting speed and course information\nvar speed: CLLocationSpeed\nThe instantaneous speed of the device, measured in meters per second.\nvar speedAccuracy: CLLocationSpeedAccuracy\nThe accuracy of the speed value, measured in meters per second.\nvar course: CLLocationDirection\nThe direction in which the device is traveling, measured in degrees and relative to due north.\nvar courseAccuracy: CLLocationDirectionAccuracy\nThe accuracy of the course value, measured in degrees.\ntypealias CLLocationDirection\nAn azimuth that is measured in degrees relative to true north.\ntypealias CLLocationSpeedAccuracy\nThe accuracy of a speed.\ntypealias CLLocationDirectionAccuracy\nThe accuracy of a compass heading."
  },
  {
    "title": "CLLocationDirectionAccuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationdirectionaccuracy",
    "html": "See Also\nGetting speed and course information\nvar speed: CLLocationSpeed\nThe instantaneous speed of the device, measured in meters per second.\nvar speedAccuracy: CLLocationSpeedAccuracy\nThe accuracy of the speed value, measured in meters per second.\nvar course: CLLocationDirection\nThe direction in which the device is traveling, measured in degrees and relative to due north.\nvar courseAccuracy: CLLocationDirectionAccuracy\nThe accuracy of the course value, measured in degrees.\ntypealias CLLocationSpeed\nThe velocity (measured in meters per second) at which the device is moving.\ntypealias CLLocationDirection\nAn azimuth that is measured in degrees relative to true north.\ntypealias CLLocationSpeedAccuracy\nThe accuracy of a speed."
  },
  {
    "title": "CLMonitor.Record | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/record",
    "html": "Overview\n\nThe CLMonitor.Record contains a condition and most recent event that affects it.\n\nTopics\nRecord characteristics\nlet condition: CLCondition\nThe condition that the framework is monitoring for.\nlet lastEvent: CLMonitor.Event\nThe most recent event the monitor records.\nRelationships\nConforms To\nSendable\nSee Also\nMonitor events\nstruct CLMonitor.Event\nAn event object that the framework passes to the events sequence in the monitor.\nstruct CLMonitor.Events\nA type that represents an asynchronous sequence of events."
  },
  {
    "title": "CLMonitor.CircularGeographicCondition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/circulargeographiccondition",
    "html": "Overview\n\nUse CLMonitor.CircularGeographicCondition to monitor events that occur in a circular geographic condition that you describe.\n\nTopics\nCreating a circular geographic condition\ninit(center: CLLocationCoordinate2D, radius: CLLocationDistance)\nCreates a circular geographic condition with a center point and radius you specify.\ninit(from: Decoder)\nCreates a circular geographic condition from previously saved data.\nCondition characteristics\nlet center: CLLocationCoordinate2D\nThe center point of the condition’s area.\nlet radius: CLLocationDistance\nThe radius of the condition’s area, in meters.\nSaving the state a circular geographic condition\nfunc encode(to: Encoder)\nSaves the values that represent the condition using the specified encoder.\nRelationships\nConforms To\nCLCondition\nSendable\nSee Also\nMonitor conditions\nstruct CLMonitor.BeaconIdentityCondition\nA condition that describes the characteristics of a beacon."
  },
  {
    "title": "CLMonitor.BeaconIdentityCondition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/beaconidentitycondition",
    "html": "Overview\n\nUse CLMonitor.BeaconIdentityCondition to observe events from beacons based on any combination on their UUID, major, or minor characteristics.\n\nTopics\nCreating a beacon identity condition\ninit(from: Decoder)\nCreates a beacon identity condition with values from a decoder you provide.\ninit(uuid: UUID)\nCreates a beacon identity condition with the UUID characteristic only, and wildcard values for the major and minor characteristics.\ninit(uuid: UUID, major: UInt16)\nCreates a beacon identity condition with UUID and major characteristics, and a wildcard for the minor characteristic.\ninit(uuid: UUID, major: UInt16, minor: UInt16)\nCreates a beacon identity condition with UUID, and major and minor characteristics.\nSaving the state of a beacon identity condition\nfunc encode(to: Encoder)\nSaves the values that represent the beacon using the specified encoder.\nInstance Properties\nlet major: UInt16?\nlet minor: UInt16?\nlet uuid: UUID\nRelationships\nConforms To\nCLCondition\nSendable\nSee Also\nMonitor conditions\nstruct CLMonitor.CircularGeographicCondition\nA condition that describes a circular geographic area that a center point and radius define."
  },
  {
    "title": "record(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4155907-record",
    "html": "Parameters\nidentifier\n\nA string that identifies the monitored condition.\n\nReturn Value\n\nReturns a CLMonitor.Record, or nil if the system can’t find the identifier.\n\nSee Also\nAdding and removing conditions\nfunc add(CLCondition, identifier: String)\nAdds the given condition for monitoring.\nfunc add(CLCondition, identifier: String, assuming: CLMonitor.Event.State)\nAdds the monitoring condition with the identifier and initial state you specify.\nfunc preconditionIsolated(() -> String, file: StaticString, line: UInt)\nUnconditionally if the current task is executing on the serial executor of the passed in actor, and if not crash the program offering information about the executor mismatch.\nfunc remove(String)\nRemoves the condition and its enclosed record associated with the identifier you provide."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4240080-init",
    "html": "Parameters\nname\n\nThe name of the location monitor."
  },
  {
    "title": "add(_:identifier:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4240078-add",
    "html": "Parameters\nCondition\n\nThe condition to monitor.\n\nidentifier\n\nA string that identifies the monitored condition.\n\nDiscussion\n\nThe framework encapsulates the condition in an instance of CLMonitor.Record and then associates the record, along with the condition with the given identifier. The initial state is CLRegionState.unknown.\n\nSee Also\nAdding and removing conditions\nfunc add(CLCondition, identifier: String, assuming: CLMonitor.Event.State)\nAdds the monitoring condition with the identifier and initial state you specify.\nfunc preconditionIsolated(() -> String, file: StaticString, line: UInt)\nUnconditionally if the current task is executing on the serial executor of the passed in actor, and if not crash the program offering information about the executor mismatch.\nfunc record(for: String) -> CLMonitor.Record?\nA record that contains a condition and the most recent event your app receives.\nfunc remove(String)\nRemoves the condition and its enclosed record associated with the identifier you provide."
  },
  {
    "title": "add(_:identifier:assuming:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4240079-add",
    "html": "Parameters\ncondition\n\nThe condition to monitor.\n\nidentifier\n\nA string that identifies the monitored condition.\n\nstate\n\nThe monitoring state to initialize the condition with.\n\nSee Also\nAdding and removing conditions\nfunc add(CLCondition, identifier: String)\nAdds the given condition for monitoring.\nfunc preconditionIsolated(() -> String, file: StaticString, line: UInt)\nUnconditionally if the current task is executing on the serial executor of the passed in actor, and if not crash the program offering information about the executor mismatch.\nfunc record(for: String) -> CLMonitor.Record?\nA record that contains a condition and the most recent event your app receives.\nfunc remove(String)\nRemoves the condition and its enclosed record associated with the identifier you provide."
  },
  {
    "title": "locationManager(_:didChangeAuthorization:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423701-locationmanager",
    "html": "Deprecated\n\nUse locationManagerDidChangeAuthorization(_:) instead.\n\nParameters\nmanager\n\nThe location manager object reporting the event.\n\nstatus\n\nThe authorization status for the app.\n\nSee Also\nResponding to authorization changes\nfunc locationManagerDidChangeAuthorization(CLLocationManager)\nTells the delegate when the app creates the location manager and when the authorization status changes."
  },
  {
    "title": "authorized | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clauthorizationstatus/1423640-authorized",
    "html": "Deprecated\n\nFor iOS, use CLAuthorizationStatus.authorizedAlways or CLAuthorizationStatus.authorizedWhenInUse instead.\n\nSee Also\nGetting the authorization status\ncase notDetermined\nThe user has not chosen whether the app can use location services.\ncase restricted\nThe app is not authorized to use location services.\ncase denied\nThe user denied the use of location services for the app or they are disabled globally in Settings.\ncase authorizedAlways\nThe user authorized the app to start location services at any time.\ncase authorizedWhenInUse\nThe user authorized the app to start location services while it is in use."
  },
  {
    "title": "CLAuthorizationStatus.denied | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clauthorizationstatus/denied",
    "html": "Discussion\n\nWhen the authorization status is denied, your app can't use location services. The status can be denied when:\n\nThe user denied location permissions for your app.\n\nThe user turned off location services for the device in Settings.\n\nLocation services are unavailable because the device is in Airplane mode.\n\nIf the user re-enables location services in Settings, your app's authorization returns to its previous state. The status change is reported to your delegate's locationManager(_:didChangeAuthorization:) method.\n\nYou may call locationServicesEnabled() if you wish to determine whether location services are available globally on the device.\n\nSee Also\nGetting the authorization status\ncase notDetermined\nThe user has not chosen whether the app can use location services.\ncase restricted\nThe app is not authorized to use location services.\nstatic var authorized: CLAuthorizationStatus\nThe user authorized the app to use location services.\ncase authorizedAlways\nThe user authorized the app to start location services at any time.\ncase authorizedWhenInUse\nThe user authorized the app to start location services while it is in use."
  },
  {
    "title": "CLAuthorizationStatus.authorizedWhenInUse | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clauthorizationstatus/authorizedwheninuse",
    "html": "Discussion\n\nThis authorization allows you to use all location services and receive location events only when your app is in use. To continue using location services in the background, enable Continuous Background Location Updates and start the services while the app is in use.\n\nSee Also\nGetting the authorization status\ncase notDetermined\nThe user has not chosen whether the app can use location services.\ncase restricted\nThe app is not authorized to use location services.\ncase denied\nThe user denied the use of location services for the app or they are disabled globally in Settings.\nstatic var authorized: CLAuthorizationStatus\nThe user authorized the app to use location services.\ncase authorizedAlways\nThe user authorized the app to start location services at any time."
  },
  {
    "title": "requestHistoricalLocations(purposeKey:sampleCount:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/3955772-requesthistoricallocations",
    "html": "Discussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc historicalLocations(purposeKey: String, sampleCount: Int) async throws -> [CLLocation]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously."
  },
  {
    "title": "location | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423687-location",
    "html": "Discussion\n\nThe value of this property is nil if no location data has ever been retrieved.\n\nIn iOS 4.0 and later, this property may contain a more recent location object at launch time. Specifically, if significant location updates are running and your app is terminated, this property is updated with the most recent location data when your app is relaunched (and you create a new location manager object). This location data may be more recent than the last location event processed by your app.\n\nIt is always a good idea to check the timestamp of the location stored in this property. If the receiver is currently gathering location data, but the minimum distance filter is large, the returned location might be relatively old. If it is, you can stop the receiver and start it again to force an update.\n\nSee Also\nGetting recent location and heading data\nvar heading: CLHeading?\nThe most recently reported heading.\nRelated Documentation\nfunc startUpdatingLocation()\nStarts the generation of updates that report the user’s current location."
  },
  {
    "title": "stopRangingBeacons(satisfying:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/3240608-stoprangingbeacons",
    "html": "Parameters\nconstraint\n\nA CLBeaconIdentityConstraint constraint.\n\nSee Also\nPerforming beacon ranging\nfunc startRangingBeacons(satisfying: CLBeaconIdentityConstraint)\nStarts the delivery of notifications for the specified beacon constraints.\nvar rangedBeaconConstraints: Set<CLBeaconIdentityConstraint>\nThe set of beacon constraints currently being tracked using ranging."
  },
  {
    "title": "stopMonitoringLocationPushes() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/3746838-stopmonitoringlocationpushes",
    "html": "Discussion\n\nCall this method to stop the device from monitoring for APNs location pushes. If a compatible iPad or iPhone app calls this method when running in visionOS, the method does nothing.\n\nSee Also\nMonitoring location push notifications\nfunc startMonitoringLocationPushes(completion: ((Data?, Error?) -> Void)?)\nStarts monitoring for the delivery of Apple Push Notification service (APNs) location pushes, and provides a device-specific token for sending pushes."
  },
  {
    "title": "rangedBeaconConstraints | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/3240606-rangedbeaconconstraints",
    "html": "See Also\nPerforming beacon ranging\nfunc startRangingBeacons(satisfying: CLBeaconIdentityConstraint)\nStarts the delivery of notifications for the specified beacon constraints.\nfunc stopRangingBeacons(satisfying: CLBeaconIdentityConstraint)\nStops the delivery of notifications for the specified beacon constraints."
  },
  {
    "title": "maximumRegionMonitoringDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423740-maximumregionmonitoringdistance",
    "html": "Discussion\n\nThis property defines the largest boundary distance allowed from a region’s center point. Attempting to monitor a region with a distance larger than this value causes the location manager to send a CLError.Code.regionMonitoringFailure error to the delegate.\n\nIf region monitoring is unavailable or not supported, the value in this property is -1.\n\nSee Also\nRunning the region-monitoring service\nvar monitoredRegions: Set<CLRegion>\nThe set of shared regions monitored by all location-manager objects."
  },
  {
    "title": "CLAuthorizationStatus.restricted | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clauthorizationstatus/restricted",
    "html": "Discussion\n\nThe user cannot change this app’s status, possibly due to active restrictions such as parental controls being in place.\n\nSee Also\nGetting the authorization status\ncase notDetermined\nThe user has not chosen whether the app can use location services.\ncase denied\nThe user denied the use of location services for the app or they are disabled globally in Settings.\nstatic var authorized: CLAuthorizationStatus\nThe user authorized the app to use location services.\ncase authorizedAlways\nThe user authorized the app to start location services at any time.\ncase authorizedWhenInUse\nThe user authorized the app to start location services while it is in use."
  },
  {
    "title": "startMonitoringLocationPushes(completion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/3746837-startmonitoringlocationpushes",
    "html": "Parameters\ncompletion\n\nThe completion handler to call after you start monitoring location pushes. The completion handler takes the following parameters:\n\ntoken\n\nA globally unique token that identifies this device to APNs. Send this token to the server that you use to generate location pushes. Your server passes this token — unmodified — back to APNs when sending pushes. APNs device tokens are of variable length. Don't hard-code their size.\n\nIf an error occurs, token is nil.\n\nerror\n\nIf your app is unable to register for location pushes, the system sets this parameter to an error object that contains information about why it failed; otherwise it’s nil. Error types include CLLocationPushServiceError and CLLocationPushServiceError.Code.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc startMonitoringLocationPushes() async throws -> Data\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis function requests an Apple Push Notification service (APNs) token that the system uses to launch your Location Push Service Extension and deliver pushes. Devices need an Internet connection to receive the token. Your completion block receives the token if the call succeeds, otherwise it receives error information. If a compatible iPad or iPhone app calls this method when running in visionOS, the method does nothing.\n\nTo use location push notifications, your app must have the com.apple.developer.location.push entitlement. For more information about implementing location pushes in your app, see Creating a location push service extension.\n\nSee Also\nMonitoring location push notifications\nfunc stopMonitoringLocationPushes()\nStops monitoring for Apple Push Notification service (APNs) location pushes."
  },
  {
    "title": "unsupportedPlatform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/4104400-unsupportedplatform",
    "html": "See Also\nGetting the error code\nstatic var unknown: CLLocationPushServiceError.Code\nAn error code that indicates the app was unable to start the location push service for an unknown reason.\nstatic var missingPushServerEnvironment: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing an Apple Push Notification service (APNs) environment entitlement.\nstatic var missingPushExtension: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing a Location Push Service Extension.\nstatic var missingEntitlement: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing the entitlement it needs to use the location push service.\nenum CLLocationPushServiceError.Code\nError codes the location manager returns if starting to monitor for location push notifications fails."
  },
  {
    "title": "geocodeAddressString(_:inRegionCenteredAt:inRegionRadius:preferredLocale:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder/4131600-geocodeaddressstring",
    "html": "Discussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc geocodeAddressString(_ addressString: String, inRegionCenteredAt centroid: CLLocationCoordinate2D, inRegionRadius radius: CLLocationDistance, preferredLocale locale: Locale?) async throws -> [CLPlacemark]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously."
  },
  {
    "title": "major | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeacon/1621418-major",
    "html": "See Also\nGetting the beacon identity\nvar uuid: UUID\nThe UUID that the observed beacon transmitted.\nvar minor: NSNumber\nThe minor value that the observed beacon transmitted.\nvar proximityUUID: UUID\nThe proximity ID of the beacon.\nDeprecated"
  },
  {
    "title": "uuid | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeacon/3183017-uuid",
    "html": "Discussion\n\nThe UUID is the most significant beacon identity characteristic. Multiple beacon can transmit the same UUID.\n\nSee Also\nGetting the beacon identity\nvar major: NSNumber\nThe major value that the observed beacon transmitted.\nvar minor: NSNumber\nThe minor value that the observed beacon transmitted.\nvar proximityUUID: UUID\nThe proximity ID of the beacon.\nDeprecated"
  },
  {
    "title": "minor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeacon/1621558-minor",
    "html": "See Also\nGetting the beacon identity\nvar uuid: UUID\nThe UUID that the observed beacon transmitted.\nvar major: NSNumber\nThe major value that the observed beacon transmitted.\nvar proximityUUID: UUID\nThe proximity ID of the beacon.\nDeprecated"
  },
  {
    "title": "proximityUUID | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeacon/1621508-proximityuuid",
    "html": "Deprecated\n\nUse uuid instead.\n\nSee Also\nGetting the beacon identity\nvar uuid: UUID\nThe UUID that the observed beacon transmitted.\nvar major: NSNumber\nThe major value that the observed beacon transmitted.\nvar minor: NSNumber\nThe minor value that the observed beacon transmitted."
  },
  {
    "title": "proximity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeacon/1621554-proximity",
    "html": "Discussion\n\nThe value in this property gives a general sense of the relative distance to the beacon. Use it to quickly identify beacons that are nearer to the user rather than farther away.\n\nSee Also\nDetermining the distance to the beacon\nenum CLProximity\nConstants that reflect the relative distance to a beacon.\nvar accuracy: CLLocationAccuracy\nThe accuracy of the proximity value, measured in meters from the beacon.\nvar rssi: Int\nThe received signal strength of the beacon, measured in decibels."
  },
  {
    "title": "locationManager(_:didDetermineState:for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423570-locationmanager",
    "html": "Parameters\nmanager\n\nThe location manager object reporting the event.\n\nstate\n\nThe state of the specified region. For a list of possible values, see the CLRegionState type.\n\nregion\n\nThe region whose state was determined.\n\nDiscussion\n\nThe location manager calls this method whenever there is a boundary transition for a region. It calls this method in addition to calling the locationManager(_:didEnterRegion:) and locationManager(_:didExitRegion:) methods. The location manager also calls this method in response to a call to its requestState(for:) method, which runs asynchronously.\n\nSee Also\nReceiving region-related updates\nfunc locationManager(CLLocationManager, didEnterRegion: CLRegion)\nTells the delegate that the user entered the specified region.\nfunc locationManager(CLLocationManager, didExitRegion: CLRegion)\nTells the delegate that the user left the specified region.\nfunc locationManager(CLLocationManager, monitoringDidFailFor: CLRegion?, withError: Error)\nTells the delegate that a region monitoring error occurred.\nfunc locationManager(CLLocationManager, didStartMonitoringFor: CLRegion)\nTells the delegate that a new region is being monitored.\nenum CLRegionState\nConstants that reflect the relationship of the current location to the region boundaries."
  },
  {
    "title": "locationManager(_:monitoringDidFailFor:withError:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423720-locationmanager",
    "html": "Parameters\nmanager\n\nThe location manager object reporting the event.\n\nregion\n\nThe region for which the error occurred.\n\nerror\n\nAn error object containing the error code that indicates why region monitoring failed.\n\nDiscussion\n\nIf an error occurs while trying to monitor a given region, the location manager sends this message to its delegate. Region monitoring might fail because the region itself cannot be monitored or because there was a more general failure in configuring the region monitoring service.\n\nAlthough implementation of this method is optional, it is recommended that you implement it if you use region monitoring in your application.\n\nSee Also\nReceiving region-related updates\nfunc locationManager(CLLocationManager, didEnterRegion: CLRegion)\nTells the delegate that the user entered the specified region.\nfunc locationManager(CLLocationManager, didExitRegion: CLRegion)\nTells the delegate that the user left the specified region.\nfunc locationManager(CLLocationManager, didDetermineState: CLRegionState, for: CLRegion)\nTells the delegate about the state of the specified region.\nfunc locationManager(CLLocationManager, didStartMonitoringFor: CLRegion)\nTells the delegate that a new region is being monitored.\nenum CLRegionState\nConstants that reflect the relationship of the current location to the region boundaries."
  },
  {
    "title": "location | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423603-location",
    "html": "Discussion\n\nUse this object to initialize the placemark object.\n\nSee Also\nGetting the placemark’s location\nvar region: CLRegion?\nThe geographic region associated with the placemark."
  },
  {
    "title": "errorCode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747542-errorcode",
    "html": "See Also\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar code: Code\nThe error code the framework returns when location push service fails.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar localizedDescription: String\nA human readable, localized description of the error."
  },
  {
    "title": "addressDictionary | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423605-addressdictionary",
    "html": "Deprecated\n\nUse CLPlacemark instead of Address Book.\n\nDiscussion\n\nThe keys in this dictionary are those defined by the Address Book framework and used to access address information for a person. For a list of the strings that can be in this dictionary, see the “Address Property” constants in ABPerson.\n\nYou can format the contents of this dictionary to get a full address string as opposed to building the address yourself. To format the dictionary, use the ABCreateStringWithAddressDictionary(_:_:) function as described in AddressBookUI Functions.\n\nSee Also\nGetting the associated contact details\nvar postalAddress: CNPostalAddress?\nThe postal address associated with the location, formatted for use with the Contacts framework."
  },
  {
    "title": "CLDeviceOrientation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cldeviceorientation",
    "html": "Topics\nDevice Orientations\ncase unknown\nThe orientation is currently not known.\ncase portrait\nThe device is in portrait mode, with the device held upright and the home button at the bottom.\ncase portraitUpsideDown\nThe device is in portrait mode but upside down, with the device held upright and the home button at the top.\ncase landscapeLeft\nThe device is in landscape mode, with the device held upright and the home button on the right side.\ncase landscapeRight\nThe device is in landscape mode, with the device held upright and the home button on the left side.\ncase faceUp\nThe device is held parallel to the ground with the screen facing upwards.\ncase faceDown\nThe device is held parallel to the ground with the screen facing downwards.\nRelationships\nConforms To\nSendable\nSee Also\nRunning the heading service\nfunc startUpdatingHeading()\nStarts the generation of updates that report the user’s current heading.\nfunc stopUpdatingHeading()\nStops the generation of heading updates.\nfunc dismissHeadingCalibrationDisplay()\nDismisses the heading calibration view from the screen immediately.\nvar headingFilter: CLLocationDegrees\nThe minimum angular change in degrees required to generate new heading events.\nlet kCLHeadingFilterNone: CLLocationDegrees\nA constant indicating that all header values should be reported.\ntypealias CLLocationDegrees\nA latitude or longitude value specified in degrees.\nvar headingOrientation: CLDeviceOrientation\nThe device orientation to use when computing heading values."
  },
  {
    "title": "CLLocationDegrees | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationdegrees",
    "html": "See Also\nRunning the heading service\nfunc startUpdatingHeading()\nStarts the generation of updates that report the user’s current heading.\nfunc stopUpdatingHeading()\nStops the generation of heading updates.\nfunc dismissHeadingCalibrationDisplay()\nDismisses the heading calibration view from the screen immediately.\nvar headingFilter: CLLocationDegrees\nThe minimum angular change in degrees required to generate new heading events.\nlet kCLHeadingFilterNone: CLLocationDegrees\nA constant indicating that all header values should be reported.\nvar headingOrientation: CLDeviceOrientation\nThe device orientation to use when computing heading values.\nenum CLDeviceOrientation\nConstants indicating the physical orientation of the device."
  },
  {
    "title": "headingFilter | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620550-headingfilter",
    "html": "Discussion\n\nThe angular distance is measured relative to the last delivered heading event. Use the value kCLHeadingFilterNone to be notified of all movements. The default value of this property is 1 degree.\n\nSee Also\nRunning the heading service\nfunc startUpdatingHeading()\nStarts the generation of updates that report the user’s current heading.\nfunc stopUpdatingHeading()\nStops the generation of heading updates.\nfunc dismissHeadingCalibrationDisplay()\nDismisses the heading calibration view from the screen immediately.\nlet kCLHeadingFilterNone: CLLocationDegrees\nA constant indicating that all header values should be reported.\ntypealias CLLocationDegrees\nA latitude or longitude value specified in degrees.\nvar headingOrientation: CLDeviceOrientation\nThe device orientation to use when computing heading values.\nenum CLDeviceOrientation\nConstants indicating the physical orientation of the device."
  },
  {
    "title": "monitoredRegions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423790-monitoredregions",
    "html": "Discussion\n\nYou cannot add regions to this property directly. Instead, you must register regions by calling the startMonitoring(for:) method. The regions in this property are shared by all instances of the CLLocationManager class in your app.\n\nThe objects in this set may not necessarily be the same objects you specified at registration time. Only the region data itself is maintained by the system. Therefore, the only way to uniquely identify a registered region is using its identifier property.\n\nThe location manager persists region data between launches of your app. If your app is terminated and then relaunched, the contents of this property are repopulated with region objects that contain the previously registered data.\n\nIn a compatible iPad or iPhone app running in visionOS, the property contains an empty set.\n\nSee Also\nRunning the region-monitoring service\nvar maximumRegionMonitoringDistance: CLLocationDistance\nThe largest boundary distance that can be assigned to a region."
  },
  {
    "title": "dismissHeadingCalibrationDisplay() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620563-dismissheadingcalibrationdisplay",
    "html": "Discussion\n\nCore Location uses the heading calibration alert to calibrate the available heading hardware as needed. The display of this view is automatic, assuming your delegate supports displaying the view at all. If the view is displayed, you can use this method to dismiss it after an appropriate amount of time to ensure that your app’s user interface is not unduly disrupted.\n\nSee Also\nRunning the heading service\nfunc startUpdatingHeading()\nStarts the generation of updates that report the user’s current heading.\nfunc stopUpdatingHeading()\nStops the generation of heading updates.\nvar headingFilter: CLLocationDegrees\nThe minimum angular change in degrees required to generate new heading events.\nlet kCLHeadingFilterNone: CLLocationDegrees\nA constant indicating that all header values should be reported.\ntypealias CLLocationDegrees\nA latitude or longitude value specified in degrees.\nvar headingOrientation: CLDeviceOrientation\nThe device orientation to use when computing heading values.\nenum CLDeviceOrientation\nConstants indicating the physical orientation of the device."
  },
  {
    "title": "CLHeadingComponentValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clheadingcomponentvalue",
    "html": "See Also\nGetting the raw heading data\nvar x: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the x-axis.\nvar y: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the y-axis.\nvar z: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the z-axis."
  },
  {
    "title": "stopUpdatingLocation() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423695-stopupdatinglocation",
    "html": "Discussion\n\nCall this method whenever your code no longer needs to receive location-related events. Disabling event delivery gives the receiver the option of disabling the appropriate hardware (and thereby saving power) when no clients need location data. You can always restart the generation of location updates by calling the startUpdatingLocation() method again.\n\nSee Also\nRunning the standard location service\nfunc startUpdatingLocation()\nStarts the generation of updates that report the user’s current location.\nfunc requestLocation()\nRequests the one-time delivery of the user’s current location.\nvar pausesLocationUpdatesAutomatically: Bool\nA Boolean value that indicates whether the location-manager object may pause location updates.\nvar allowsBackgroundLocationUpdates: Bool\nA Boolean value that indicates whether the app receives location updates when running in the background.\nvar showsBackgroundLocationIndicator: Bool\nA Boolean value that indicates whether the status bar changes its appearance when an app uses location services in the background.\nvar activityType: CLActivityType\nThe type of activity the app expects the user to typically perform while in the app’s location session.\nenum CLActivityType\nConstants that indicate the type of activity associated with location updates."
  },
  {
    "title": "CLLocationAccuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationaccuracy",
    "html": "Discussion\n\nWhen reported in a CLLocation object, accuracy values are the number of meters from the original geographic coordinate that could yield the user’s actual location. When specifying values for the desiredAccuracy property of your CLLocationManager object, use one of the appropriate constants.\n\nTopics\nDesired Accuracy Constants\nlet kCLLocationAccuracyBestForNavigation: CLLocationAccuracy\nThe highest possible accuracy that uses additional sensor data to facilitate navigation apps.\nlet kCLLocationAccuracyBest: CLLocationAccuracy\nThe best level of accuracy available.\nlet kCLLocationAccuracyNearestTenMeters: CLLocationAccuracy\nAccurate to within ten meters of the desired target.\nlet kCLLocationAccuracyHundredMeters: CLLocationAccuracy\nAccurate to within one hundred meters.\nlet kCLLocationAccuracyKilometer: CLLocationAccuracy\nAccurate to the nearest kilometer.\nlet kCLLocationAccuracyThreeKilometers: CLLocationAccuracy\nAccurate to the nearest three kilometers.\nlet kCLLocationAccuracyReduced: CLLocationAccuracy\nThe level of accuracy used when an app isn’t authorized for full accuracy location data.\nSee Also\nSpecifying distance and accuracy\nvar distanceFilter: CLLocationDistance\nThe minimum distance in meters the device must move horizontally before an update event is generated.\nlet CLLocationDistanceMax: CLLocationDistance\nA constant indicating the maximum distance.\nlet kCLDistanceFilterNone: CLLocationDistance\nA constant indicating that all movement should be reported.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar desiredAccuracy: CLLocationAccuracy\nThe accuracy of the location data that your app wants to receive."
  },
  {
    "title": "CLLocationDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationdistance",
    "html": "See Also\nGetting the location attributes\nvar coordinate: CLLocationCoordinate2D\nThe geographical coordinate information.\nvar altitude: CLLocationDistance\nThe altitude above mean sea level associated with a location, measured in meters.\nvar ellipsoidalAltitude: CLLocationDistance\nThe altitude as a height above the World Geodetic System 1984 (WGS84) ellipsoid, measured in meters.\nvar floor: CLFloor?\nThe logical floor of the building in which the user is located.\nvar timestamp: Date\nThe time at which this location was determined.\nvar sourceInformation: CLLocationSourceInformation?\nInformation about the source that provides the location."
  },
  {
    "title": "missingEntitlement | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747549-missingentitlement",
    "html": "Discussion\n\nFor more information, see Creating a location push service extension.\n\nSee Also\nGetting the error code\nstatic var unknown: CLLocationPushServiceError.Code\nAn error code that indicates the app was unable to start the location push service for an unknown reason.\nstatic var missingPushServerEnvironment: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing an Apple Push Notification service (APNs) environment entitlement.\nstatic var missingPushExtension: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing a Location Push Service Extension.\nstatic var unsupportedPlatform: CLLocationPushServiceError.Code\nAn error code that indicates the location push service isn’t available on this platform.\nenum CLLocationPushServiceError.Code\nError codes the location manager returns if starting to monitor for location push notifications fails."
  },
  {
    "title": "kCLDistanceFilterNone | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kcldistancefilternone",
    "html": "Discussion\n\nUse this constant to specify that any change in location should trigger a new location update.\n\nSee Also\nSpecifying distance and accuracy\nvar distanceFilter: CLLocationDistance\nThe minimum distance in meters the device must move horizontally before an update event is generated.\nlet CLLocationDistanceMax: CLLocationDistance\nA constant indicating the maximum distance.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar desiredAccuracy: CLLocationAccuracy\nThe accuracy of the location data that your app wants to receive.\ntypealias CLLocationAccuracy\nThe accuracy of a geographical coordinate."
  },
  {
    "title": "CLBeaconIdentityConstraint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconidentityconstraint",
    "html": "Deprecated\n\nUse CLBeaconIdentityCondition instead,\n\nOverview\n\nA constraint specifies beacon identity characteristics. Use constraints to check for matching beacons by comparing the beacon’s identity characteristics (uuid, major, and minor) to those in the constraint.\n\nConstraints always specify a UUID value, but the major and minor values are optional. A beacon satisfies the constraint if all three identity characteristics of the beacon match the same characteristic of the constraint. Major and minor characteristics are wildcards if they have no value. A major or minor wildcard value matches any value in the beacon’s corresponding characteristic.\n\nTopics\nGetting the beacon identity\nvar major: UInt16?\nThe constraint’s value for the major identity characteristic.\nvar minor: UInt16?\nThe constraint’s value for the minor identity characteristic.\nRelationships\nConforms To\nNSCopying\nNSSecureCoding"
  },
  {
    "title": "CLLocationDistanceMax | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationdistancemax",
    "html": "Discussion\n\nWhen scheduling deferred updates, you can use this constant to indicate that a new update should be triggered only after the device moves a significantly large distance.\n\nSee Also\nSpecifying distance and accuracy\nvar distanceFilter: CLLocationDistance\nThe minimum distance in meters the device must move horizontally before an update event is generated.\nlet kCLDistanceFilterNone: CLLocationDistance\nA constant indicating that all movement should be reported.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar desiredAccuracy: CLLocationAccuracy\nThe accuracy of the location data that your app wants to receive.\ntypealias CLLocationAccuracy\nThe accuracy of a geographical coordinate."
  },
  {
    "title": "requestTemporaryFullAccuracyAuthorization(withPurposeKey:completion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/3600217-requesttemporaryfullaccuracyauth",
    "html": "Parameters\npurposeKey\n\nA key in the NSLocationTemporaryUsageDescriptionDictionary dictionary of the app’s Info.plist file. The value for this key is an app-provided string that describes the reason for accessing location data with full accuracy. To localize a usage description, add an entry to your InfoPlist.strings file with the same key you provide for this parameter.\n\ncompletion\n\nA closure to execute after authorization status changes. This closure takes a single error parameter, which is nil if the prompt was displayed to the user, or an error object describing why the prompt couldn’t be displayed.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc requestTemporaryFullAccuracyAuthorization(withPurposeKey purposeKey: String) async throws\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nAfter the user gives permission for your app to use location data with full accuracy, your app can access that data in the foreground or in the background, until its permission automatically expires. Expiration is postponed while your app is actively in use. For example, expiration is postponed while your app in the foreground, and while a Continuous Background Location session is active with the background location indicator enabled. This approach to expiration allows apps to provide experiences that require full accuracy, such as fitness and navigation apps, even if the user doesn’t grant persistent access for full accuracy.\n\nThe completion closure is guaranteed to be called after the request is completed, which includes the user granting access, the user declining, or an error that prevented displaying the prompt. The closure is always called in the same threading context as CLLocationManagerDelegate methods. If the prompt was successfully displayed to the user, the callback’s error parameter is nil.\n\nThe request always fails with a CLError.Code.promptDeclined error in the following cases:\n\nThe Info.plist file doesn’t have an entry for the given purposeKey value.\n\nThe app is already authorized for full accuracy.\n\nThe app is in the background.\n\nIf the closure is called with an error, log the error for debugging purposes, and retry the request again the next time the user performs the action that caused you to request precise location information.\n\nSee Also\nRequesting authorization for location services\nfunc requestWhenInUseAuthorization()\nRequests the user’s permission to use location services while the app is in use.\nfunc requestAlwaysAuthorization()\nRequests the user’s permission to use location services regardless of whether the app is in use.\nfunc requestTemporaryFullAccuracyAuthorization(withPurposeKey: String)\nRequests permission to temporarily use location services with full accuracy.\nvar authorizationStatus: CLAuthorizationStatus\nThe current authorization status for the app.\nenum CLAuthorizationStatus\nConstants indicating the app's authorization to use location services.\nproperty list key NSLocationDefaultAccuracyReduced\nA Boolean value that indicates whether the app requests reduced location accuracy by default.\nName: Privacy - Location Default Accuracy Reduced\nproperty list key NSLocationAlwaysAndWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information at all times.\nName: Privacy - Location Always and When In Use Usage Description"
  },
  {
    "title": "requestWhenInUseAuthorization() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620562-requestwheninuseauthorization",
    "html": "Discussion\n\nYou must call this method or requestAlwaysAuthorization() before you can receive location-related information. You may call requestWhenInUseAuthorization() whenever the current authorization status is not determined (CLAuthorizationStatus.notDetermined).\n\nImportant\n\nYour app must be in the foreground to show a location authorization prompt.\n\nThis method runs asynchronously and prompts the user to grant permission to the app to use location services. The user prompt contains the text from the NSLocationWhenInUseUsageDescription key in your app Info.plist file, and the presence of that key is required when calling this method. The user prompt displays the following options, which determine the authorization your app can receive.\n\nOption\n\n\t\n\nAuthorization\n\n\n\n\nAllow While Using App\n\n\t\n\nWhen In Use authorization that does not expire.\n\n\n\n\nAllow Once\n\n\t\n\nTemporary When In Use authorization that expires when the app is no longer in use.\n\n\n\n\nDon't Allow\n\n\t\n\nDenied; no further authorization requests are allowed.\n\nAfter the user makes a selection and determines the status, the location manager delivers the results to the delegate's locationManager(_:didChangeAuthorization:) method. If the initial authorization status is anything other than CLAuthorizationStatus.notDetermined, this method does nothing and doesn't call the locationManager(_:didChangeAuthorization:) method.\n\nIf the user's choice grants When In Use authorization to your app, your app can start any location service and is eligible to receive the results while it's in use. If the user's choice grants temporary When In Use authorization, the authorization expires when the app is no longer in use, reverting to Not Determined status (CLAuthorizationStatus.notDetermined). For information about when an app is considered to be in use, see Choosing the Location Services Authorization to Request.\n\nWhen your app starts standard location services in the foreground, they continue to run in the background if your app has enabled background location updates in the Capabilities tab of your Xcode project. Attempts to start location updates while your app runs in the background will fail. The system displays a location services indicator in the status bar when your app moves to the background with active location services.\n\nNote\n\nIn iOS 16 and later, apps that actively track a user’s location or that have recently enabled Core Location display an indicator in Control Center. Be mindful of battery use and user privacy by monitoring the device’s location only when necessary and when the user expects it.\n\nSee Also\nRequesting authorization for location services\nfunc requestAlwaysAuthorization()\nRequests the user’s permission to use location services regardless of whether the app is in use.\nfunc requestTemporaryFullAccuracyAuthorization(withPurposeKey: String, completion: ((Error?) -> Void)?)\nRequests permission to temporarily use location services with full accuracy and reports the results to the provided completion handler.\nfunc requestTemporaryFullAccuracyAuthorization(withPurposeKey: String)\nRequests permission to temporarily use location services with full accuracy.\nvar authorizationStatus: CLAuthorizationStatus\nThe current authorization status for the app.\nenum CLAuthorizationStatus\nConstants indicating the app's authorization to use location services.\nproperty list key NSLocationDefaultAccuracyReduced\nA Boolean value that indicates whether the app requests reduced location accuracy by default.\nName: Privacy - Location Default Accuracy Reduced\nproperty list key NSLocationAlwaysAndWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information at all times.\nName: Privacy - Location Always and When In Use Usage Description\nRelated Documentation\nHandling location updates in the background\nConfigure your app to receive location updates when it isn’t running in the foreground.\nproperty list key NSLocationWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information while the app is running in the foreground.\nLocation and Maps Programming Guide"
  },
  {
    "title": "delegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423792-delegate",
    "html": "Discussion\n\nIn iOS, this property is declared as nonatomic. In macOS, it is declared as atomic.\n\nSee Also\nReceiving data from location services\nprotocol CLLocationManagerDelegate\nThe methods that you use to receive events from an associated location-manager object."
  },
  {
    "title": "locationServicesEnabled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423648-locationservicesenabled",
    "html": "Return Value\n\ntrue if location services are enabled on the device; false if they are not.\n\nDiscussion\n\nUsers can enable or disable location services by toggling the Location Services switch in Settings > Privacy.\n\nWhen users disable the switch, the system calls your delegate's locationManager(_:didChangeAuthorization:) method with a denied authorization status (CLAuthorizationStatus.denied).\n\nWhen users enable the switch, the system returns your app's authorization to its previous state and calls your delegate's locationManager(_:didChangeAuthorization:) method.\n\nYou are not required to call locationServicesEnabled(). However, If you wish to display instructions about enabling location services, you may check the return value of this method to find out if the services are disabled for the entire device, or just for your app. If the result is true, provide instructions for enabling services for your app; otherwise, provide instructions for enabling the Location Services switch in Settings > Privacy.\n\nIf users disable or deny location services and you attempt to start location updates anyway, the location manager reports an error to its delegate. See locationManager(_:didFailWithError:) and locationManager(_:monitoringDidFailFor:withError:) for more information.\n\nSee Also\nDetermining the availability of services\nclass func significantLocationChangeMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether the significant-change location service is available on the device.\nclass func headingAvailable() -> Bool\nReturns a Boolean value indicating whether the location manager is able to generate heading-related events.\nvar isAuthorizedForWidgetUpdates: Bool\nA Boolean value that indicates whether a widget is eligible to receive location updates.\nvar accuracyAuthorization: CLAccuracyAuthorization\nA value that indicates the level of location accuracy the app has permission to use.\nclass func isMonitoringAvailable(for: AnyClass) -> Bool\nReturns a Boolean value indicating whether the device supports region monitoring using the specified class.\nclass func isRangingAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports ranging of beacons that use the iBeacon protocol.\nRelated Documentation\nfunc locationManager(CLLocationManager, didFailWithError: Error)\nTells the delegate that the location manager was unable to retrieve a location value.\nfunc locationManager(CLLocationManager, monitoringDidFailFor: CLRegion?, withError: Error)\nTells the delegate that a region monitoring error occurred."
  },
  {
    "title": "isRangingAvailable() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620549-israngingavailable",
    "html": "Return Value\n\ntrue if the device supports ranging or false if it does not.\n\nSee Also\nDetermining the availability of services\nclass func significantLocationChangeMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether the significant-change location service is available on the device.\nclass func headingAvailable() -> Bool\nReturns a Boolean value indicating whether the location manager is able to generate heading-related events.\nvar isAuthorizedForWidgetUpdates: Bool\nA Boolean value that indicates whether a widget is eligible to receive location updates.\nvar accuracyAuthorization: CLAccuracyAuthorization\nA value that indicates the level of location accuracy the app has permission to use.\nclass func isMonitoringAvailable(for: AnyClass) -> Bool\nReturns a Boolean value indicating whether the device supports region monitoring using the specified class.\nclass func locationServicesEnabled() -> Bool\nReturns a Boolean value indicating whether location services are enabled on the device."
  },
  {
    "title": "CLBeaconRegion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeaconregion",
    "html": "Deprecated\n\nUse CLBeaconIdentityCondition instead.\n\nOverview\n\nA CLBeaconRegion object defines a region that you use to detect Bluetooth beacons conforming to the iBeacon specification. In contrast to a CLCircularRegion that centers on a geographic location, a CLBeaconRegion focuses on an iBeacon with specific identifying characteristics, which you provide. When a matching device comes in range, Core Location notifies your app.\n\nYou monitor beacon regions in two ways. To detect when a beacon is in range, use the startMonitoring(for:) method of your location manager object. After detecting a beacon, call the startRangingBeacons(in:) method to determine the relative distance to that beacon.\n\nWhen detecting an iBeacon, you need to specify the proximityUUID, major, and minor values that you programmed into the beacon hardware. You use the values to identify your beacons uniquely, and you can specify a subset of values to detect multiple beacons. The proximityUUID property is typically the same for all of the beacons in your installation. Use the major and minor values to distinguish among different beacons in your installation.\n\nIf you want to configure the current iOS device as a Bluetooth beacon, create a beacon region with the appropriate identifying information. You can then call the peripheralData(withMeasuredPower:) method of the region to get a dictionary that you can use to advertise the device with the Core Bluetooth framework. For more information about using that framework to advertise the device as a beacon, see Turning an iOS device into an iBeacon device.\n\nFor information about how to detect beacons, see Determining the proximity to an iBeacon device.\n\nTopics\nCreating a beacon region\ninit(beaconIdentityConstraint: CLBeaconIdentityConstraint, identifier: String)\nCreates and returns a region object that targets beacons that satisfy the specified beacon identity constraints.\ninit(uuid: UUID, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID.\ninit(uuid: UUID, major: CLBeaconMajorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID and major value.\ninit(uuid: UUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\nCreates and returns a region object that targets beacons with the specified UUID, and major and minor values.\ntypealias CLBeaconMajorValue\nThe most significant value in a beacon.\ntypealias CLBeaconMinorValue\nThe least significant value in a beacon.\nGetting the beacon identity\nvar uuid: UUID\nThe UUID value from the beacon identity constraint that defines the beacon region.\nvar major: NSNumber?\nThe major value from the beacon identity constraint that defines the beacon region.\nvar minor: NSNumber?\nThe minor value from the beacon identity constraint that defines the beacon region.\nvar beaconIdentityConstraint: CLBeaconIdentityConstraint\nThe beacon identity constraint that defines the beacon region.\nSpecifying when to send notifications\nvar notifyEntryStateOnDisplay: Bool\nA Boolean value that indicates whether Core Location sends beacon notifications when the device’s display is on.\nGetting the beacon’s advertisement data\nfunc peripheralData(withMeasuredPower: NSNumber?) -> NSMutableDictionary\nRetrieves data that you can use to advertise the current device as a beacon.\nDeprecated\ninit(proximityUUID: UUID, identifier: String)\nCreates and returns a region object that targets a beacon with the specified UUID.\ninit(proximityUUID: UUID, major: CLBeaconMajorValue, identifier: String)\nCreates and returns a region object that targets a beacon with the specified proximity ID and major value.\ninit(proximityUUID: UUID, major: CLBeaconMajorValue, minor: CLBeaconMinorValue, identifier: String)\nCreates and returns a region object that targets a beacon with the specified proximity ID, major value, and minor value.\nvar proximityUUID: UUID\nThe unique ID of the beacons you’re targeting.\nRelationships\nInherits From\nCLRegion"
  },
  {
    "title": "departureDate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clvisit/1614685-departuredate",
    "html": "Discussion\n\nWhen the visit object does not include departure information, this property is set to the date returned by the distantFuture method of NSDate.\n\nSee Also\nGetting the visit duration\nvar arrivalDate: Date\nThe approximate time at which the user arrived at the specified location."
  },
  {
    "title": "CLLocationPushServiceError.Code.unsupportedPlatform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/code/unsupportedplatform",
    "html": "See Also\nGetting the error code\ncase unknown\nAn error code that indicates the app was unable to start the location push service for an unknown reason.\ncase missingPushExtension\nAn error code that indicates the app is missing a Location Push Service Extension.\ncase missingPushServerEnvironment\nAn error code that indicates the app is missing an Apple Push Notification service (APNs) environment entitlement.\ncase missingEntitlement\nAn error code that indicates the app is missing the entitlement it needs to use the location push service."
  },
  {
    "title": "isAuthorizedForWidgetUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/3675588-isauthorizedforwidgetupdates",
    "html": "Discussion\n\nThis property is true when either of the following is true:\n\nThe app’s authorization status is CLAuthorizationStatus.authorizedAlways.\n\nThe app’s authorization status is CLAuthorizationStatus.authorizedWhenInUse and the user agrees to extend the app’s authorization status to widgets.\n\nNote\n\nFor apps that use CLAuthorizationStatus.authorizedWhenInUse, after the user agrees to extend an app’s authorization status to widgets, the app’s Location Services settings indicate While Using the App or Widgets as the active access level.\n\nFor details about using location information in widgets with CLAuthorizationStatus.authorizedWhenInUse, see Accessing location information in widgets.\n\nSee Also\nDetermining the availability of services\nclass func significantLocationChangeMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether the significant-change location service is available on the device.\nclass func headingAvailable() -> Bool\nReturns a Boolean value indicating whether the location manager is able to generate heading-related events.\nvar accuracyAuthorization: CLAccuracyAuthorization\nA value that indicates the level of location accuracy the app has permission to use.\nclass func isMonitoringAvailable(for: AnyClass) -> Bool\nReturns a Boolean value indicating whether the device supports region monitoring using the specified class.\nclass func isRangingAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports ranging of beacons that use the iBeacon protocol.\nclass func locationServicesEnabled() -> Bool\nReturns a Boolean value indicating whether location services are enabled on the device."
  },
  {
    "title": "unknown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747552-unknown",
    "html": "See Also\nGetting the error code\nstatic var missingPushServerEnvironment: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing an Apple Push Notification service (APNs) environment entitlement.\nstatic var missingPushExtension: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing a Location Push Service Extension.\nstatic var missingEntitlement: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing the entitlement it needs to use the location push service.\nstatic var unsupportedPlatform: CLLocationPushServiceError.Code\nAn error code that indicates the location push service isn’t available on this platform.\nenum CLLocationPushServiceError.Code\nError codes the location manager returns if starting to monitor for location push notifications fails."
  },
  {
    "title": "missingPushServerEnvironment | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747551-missingpushserverenvironment",
    "html": "Discussion\n\nA Location Push Service Extension requires that your app has the APNs environment entitlement. For more information, see APS Environment Entitlement.\n\nSee Also\nGetting the error code\nstatic var unknown: CLLocationPushServiceError.Code\nAn error code that indicates the app was unable to start the location push service for an unknown reason.\nstatic var missingPushExtension: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing a Location Push Service Extension.\nstatic var missingEntitlement: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing the entitlement it needs to use the location push service.\nstatic var unsupportedPlatform: CLLocationPushServiceError.Code\nAn error code that indicates the location push service isn’t available on this platform.\nenum CLLocationPushServiceError.Code\nError codes the location manager returns if starting to monitor for location push notifications fails."
  },
  {
    "title": "missingPushExtension | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747550-missingpushextension",
    "html": "See Also\nGetting the error code\nstatic var unknown: CLLocationPushServiceError.Code\nAn error code that indicates the app was unable to start the location push service for an unknown reason.\nstatic var missingPushServerEnvironment: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing an Apple Push Notification service (APNs) environment entitlement.\nstatic var missingEntitlement: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing the entitlement it needs to use the location push service.\nstatic var unsupportedPlatform: CLLocationPushServiceError.Code\nAn error code that indicates the location push service isn’t available on this platform.\nenum CLLocationPushServiceError.Code\nError codes the location manager returns if starting to monitor for location push notifications fails."
  },
  {
    "title": "significantLocationChangeMonitoringAvailable() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423677-significantlocationchangemonitor",
    "html": "Return Value\n\ntrue if location change monitoring is available; false if it is not.\n\nDiscussion\n\nThis method indicates whether the device is able to report updates based on significant location changes only. This capability provides tremendous power savings for apps that want to track a user’s approximate location and don’t need highly accurate position information.\n\nSee Also\nDetermining the availability of services\nclass func headingAvailable() -> Bool\nReturns a Boolean value indicating whether the location manager is able to generate heading-related events.\nvar isAuthorizedForWidgetUpdates: Bool\nA Boolean value that indicates whether a widget is eligible to receive location updates.\nvar accuracyAuthorization: CLAccuracyAuthorization\nA value that indicates the level of location accuracy the app has permission to use.\nclass func isMonitoringAvailable(for: AnyClass) -> Bool\nReturns a Boolean value indicating whether the device supports region monitoring using the specified class.\nclass func isRangingAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports ranging of beacons that use the iBeacon protocol.\nclass func locationServicesEnabled() -> Bool\nReturns a Boolean value indicating whether location services are enabled on the device."
  },
  {
    "title": "floor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1616762-floor",
    "html": "Discussion\n\nIf floor information is not available for the current location, the value of this property is nil.\n\nSee Also\nGetting the location attributes\nvar coordinate: CLLocationCoordinate2D\nThe geographical coordinate information.\nvar altitude: CLLocationDistance\nThe altitude above mean sea level associated with a location, measured in meters.\nvar ellipsoidalAltitude: CLLocationDistance\nThe altitude as a height above the World Geodetic System 1984 (WGS84) ellipsoid, measured in meters.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar timestamp: Date\nThe time at which this location was determined.\nvar sourceInformation: CLLocationSourceInformation?\nInformation about the source that provides the location."
  },
  {
    "title": "speed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/1423798-speed",
    "html": "Discussion\n\nThis value reflects the instantaneous speed of the device as it moves in the direction of its current heading. A negative value indicates an invalid speed. Because the actual speed can change many times between the delivery of location events, use this property for informational purposes only.\n\nSpecial Considerations\n\nIn iOS, this property is declared as nonatomic. In macOS, it is declared as atomic.\n\nSee Also\nGetting speed and course information\nvar speedAccuracy: CLLocationSpeedAccuracy\nThe accuracy of the speed value, measured in meters per second.\nvar course: CLLocationDirection\nThe direction in which the device is traveling, measured in degrees and relative to due north.\nvar courseAccuracy: CLLocationDirectionAccuracy\nThe accuracy of the course value, measured in degrees.\ntypealias CLLocationSpeed\nThe velocity (measured in meters per second) at which the device is moving.\ntypealias CLLocationDirection\nAn azimuth that is measured in degrees relative to true north.\ntypealias CLLocationSpeedAccuracy\nThe accuracy of a speed.\ntypealias CLLocationDirectionAccuracy\nThe accuracy of a compass heading."
  },
  {
    "title": "speedAccuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation/3524340-speedaccuracy",
    "html": "Discussion\n\nWhen this property contains 0 or a positive number, the value in the speed property is plus or minus the specified number of meters per second. When this property contains a negative number, the value in the speed property is invalid.\n\nSee Also\nGetting speed and course information\nvar speed: CLLocationSpeed\nThe instantaneous speed of the device, measured in meters per second.\nvar course: CLLocationDirection\nThe direction in which the device is traveling, measured in degrees and relative to due north.\nvar courseAccuracy: CLLocationDirectionAccuracy\nThe accuracy of the course value, measured in degrees.\ntypealias CLLocationSpeed\nThe velocity (measured in meters per second) at which the device is moving.\ntypealias CLLocationDirection\nAn azimuth that is measured in degrees relative to true north.\ntypealias CLLocationSpeedAccuracy\nThe accuracy of a speed.\ntypealias CLLocationDirectionAccuracy\nThe accuracy of a compass heading."
  },
  {
    "title": "CLMonitor.Events | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/events",
    "html": "Overview\n\nUse this structure to access and iterate over the events the framework delivers.\n\nTopics\nInstance methods\nfunc allSatisfy((CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLMonitor.Event) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLMonitor.Events, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLMonitor.Event) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLMonitor.Event) -> Bool) -> AsyncDropWhileSequence<CLMonitor.Events>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLMonitor.Events>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLMonitor.Event) -> Bool) -> AsyncFilterSequence<CLMonitor.Events>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLMonitor.Event) -> SegmentOfResult) -> AsyncFlatMapSequence<CLMonitor.Events, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLMonitor.Events.Iterator\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLMonitor.Event) -> Transformed) -> AsyncThrowingMapSequence<CLMonitor.Events, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLMonitor.Event, CLMonitor.Event) -> Bool) -> CLMonitor.Event?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLMonitor.Events>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLMonitor.Event) -> Bool) -> AsyncPrefixWhileSequence<CLMonitor.Events>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLMonitor.Event) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLMonitor.Event) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.\nUtility methods\nstruct CLMonitor.Events.Iterator\nThe type that allows iteration over the elements of the sequence.\nType aliases\ntypealias CLMonitor.Events.AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\ntypealias CLMonitor.Events.Element\nThe type that represents the event’s element.\nRelationships\nConforms To\nAsyncSequence\nSendable\nSee Also\nMonitor events\nstruct CLMonitor.Event\nAn event object that the framework passes to the events sequence in the monitor.\nstruct CLMonitor.Record\nA structure that represents a condition and its associated event information that the framework is monitoring."
  },
  {
    "title": "unownedExecutor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4155909-unownedexecutor",
    "html": "Discussion\n\nThis is a type used internally by the core scheduling operations.\n\nRelationships\nFrom Protocol\nActor\nSee Also\nThe monitor’s context\nfunc assertIsolated(() -> String, file: StaticString, line: UInt)\nPerforms an executor check in debug builds.\nfunc assumeIsolated<T>((CLMonitor) -> T, file: StaticString, line: UInt) -> T\nA safe way to synchronously assume that the current execution context belongs to the passed in actor.\nRelated Documentation\nstruct UnownedSerialExecutor\nAn unowned reference to a serial executor (a value)."
  },
  {
    "title": "assumeIsolated(_:file:line:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4226439-assumeisolated",
    "html": "Discussion\n\nThis API should only be used as last resort, when it is not possible to express the current execution context definitely belongs to the specified actor in other ways. E.g. one may need to use this in a delegate style API, where a synchronous method is guaranteed to be called by the specified actor, however it is not possible to move this method as being declared on the specified actor.\n\nWarning\n\nIf the current executor is not the expected serial executor, this function will crash.\n\nNote that this check is performed against the passed in actor’s serial executor, meaning that if another actor uses the same serial executor–by using that actor’s Actor/unownedExecutor as its own Actor/unownedExecutor–this check will succeed, as from a concurrency safety perspective, the serial executor guarantees mutual exclusion of those two actors.\n\nSee Also\nThe monitor’s context\nvar unownedExecutor: UnownedSerialExecutor\nThe executor for this actor as an optimized, unowned reference.\nfunc assertIsolated(() -> String, file: StaticString, line: UInt)\nPerforms an executor check in debug builds."
  },
  {
    "title": "assertIsolated(_:file:line:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor/4226438-assertisolated",
    "html": "Discussion\n\nIn playgrounds and -Onone builds (the default for Xcode’s Debug configuration): If condition evaluates to false, stop program execution in a debuggable state after printing message.\n\nIn -O builds (the default for Xcode’s Release configuration), condition is not evaluated, and there are no effects.\n\nIn -Ounchecked builds, condition is not evaluated, but the optimizer may assume that it always evaluates to true. Failure to satisfy that assumption is a serious programming error.\n\nSee Also\nThe monitor’s context\nvar unownedExecutor: UnownedSerialExecutor\nThe executor for this actor as an optimized, unowned reference.\nfunc assumeIsolated<T>((CLMonitor) -> T, file: StaticString, line: UInt) -> T\nA safe way to synchronously assume that the current execution context belongs to the passed in actor."
  },
  {
    "title": "level | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clfloor/1616759-level",
    "html": "Discussion\n\nLevel values represent logical levels above or below ground level and are not intended to correspond to any numbering scheme in use by the building itself. The ground floor of a building is always represented by the value 0. Floors above the ground floor are represented by positive integers, so a value of 1 represents the floor above ground level, a value of 2 represents two floors above ground level, and so on. Floors below the ground floor are represented by corresponding negative integers, with a value of -1 representing the floor immediately below ground level and so on.\n\nIt is erroneous to use the user’s level in a building as an estimate of altitude."
  },
  {
    "title": "heading | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620555-heading",
    "html": "Discussion\n\nThe value of this property is nil if heading updates have never been initiated.\n\nSee Also\nGetting recent location and heading data\nvar location: CLLocation?\nThe most recently retrieved user location."
  },
  {
    "title": "Deprecated symbols | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/deprecated_symbols",
    "html": "Topics\nProperties\nvar headingAvailable: Bool\nA Boolean value indicating whether the location manager is able to generate heading-related events.\nDeprecated\nvar locationServicesEnabled: Bool\nA Boolean value indicating whether location services are enabled on the device.\nDeprecated\nvar purpose: String?\nAn app-provided string that describes the reason for using location services.\nDeprecated\nvar rangedRegions: Set<CLRegion>\nThe set of regions currently being tracked using ranging.\nDeprecated\nMethods\nfunc startMonitoring(for: CLRegion)\nStarts monitoring the specified region.\nDeprecated\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "CLTimeIntervalMax | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cltimeintervalmax",
    "html": "Discussion\n\nWhen scheduling deferred updates, you can use this constant to indicate that a new update should be triggered only after a large time interval has passed."
  },
  {
    "title": "init(latitude:longitude:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationcoordinate2d/1423703-init",
    "html": "Parameters\nlatitude\n\nThe latitude of the coordinate.\n\nlongitude\n\nThe longitude of the coordinate.\n\nSee Also\nCreating a location coordinate\ninit()\nCreates a location coordinate object.\nfunc CLLocationCoordinate2DMake(CLLocationDegrees, CLLocationDegrees) -> CLLocationCoordinate2D\nFormats a latitude and longitude value into a coordinate data structure format."
  },
  {
    "title": "startMonitoringSignificantLocationChanges() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423531-startmonitoringsignificantlocati",
    "html": "Discussion\n\nThis method initiates the delivery of location events asynchronously, returning shortly after you call it. Location events are delivered to your delegate’s locationManager(_:didUpdateLocations:) method. The first event to be delivered is usually the most recently cached location event (if any) but may be a newer event in some circumstances. Obtaining a current location fix may take several additional seconds, so be sure to check the timestamps on the location events in your delegate method.\n\nAfter returning a current location fix, the receiver generates update events only when a significant change in the user’s location is detected. It does not rely on the value in the distanceFilter property to generate events. Calling this method several times in succession does not automatically result in new events being generated. Calling stopMonitoringSignificantLocationChanges() in between, however, does cause a new initial event to be sent the next time you call this method.\n\nIf you start this service and your app is subsequently terminated, the system automatically relaunches the app into the background if a new event arrives. In such a case, the options dictionary passed to the application(_:willFinishLaunchingWithOptions:) and application(_:didFinishLaunchingWithOptions:) methods of your app delegate contains the key location to indicate that your app was launched because of a location event. Upon relaunch, you must still configure a location manager object and call this method to continue receiving location events. When you restart location services, the current event is delivered to your delegate immediately. In addition, the location property of your location manager object is populated with the most recent location object even before you start location services.\n\nIn addition to your delegate object implementing the locationManager(_:didUpdateLocations:) method, it should also implement the locationManager(_:didFailWithError:) method to respond to potential errors.\n\nNote\n\nApps can expect a notification as soon as the device moves 500 meters or more from its previous notification. It should not expect notifications more frequently than once every five minutes. If the device is able to retrieve data from the network, the location manager is much more likely to deliver notifications in a timely manner.\n\nIf a compatible iPad or iPhone app calls this method when running in visionOS, the method does nothing.\n\nSee Also\nRunning the significant change location service\nfunc stopMonitoringSignificantLocationChanges()\nStops the delivery of location events based on significant location changes."
  },
  {
    "title": "requestLocation() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620548-requestlocation",
    "html": "Discussion\n\nThis method returns immediately. Calling it causes the location manager to obtain a location fix (which may take several seconds) and call the delegate’s locationManager(_:didUpdateLocations:) method with the result. The location fix is obtained at the accuracy level indicated by the desiredAccuracy property. Only one location fix is reported to the delegate, after which location services are stopped. If a location fix cannot be determined in a timely manner, the location manager calls the delegate’s locationManager(_:didFailWithError:) method instead and reports a CLError.Code.locationUnknown error.\n\nUse this method when you want the user’s current location but do not need to leave location services running. This method starts location services long enough to return a result or report an error and then stops them again. Calling the startUpdatingLocation() or allowDeferredLocationUpdates(untilTraveled:timeout:) method cancels any pending request made using this method. Calling this method while location services are already running does nothing. To cancel a pending request, call the stopUpdatingLocation() method.\n\nIf obtaining the desired accuracy would take too long, the location manager delivers a less accurate location value rather than reporting an error.\n\nWhen using this method, the associated delegate must implement the locationManager(_:didUpdateLocations:) and locationManager(_:didFailWithError:) methods. Failure to do so is a programmer error.\n\nSee Also\nRunning the standard location service\nfunc startUpdatingLocation()\nStarts the generation of updates that report the user’s current location.\nfunc stopUpdatingLocation()\nStops the generation of location updates.\nvar pausesLocationUpdatesAutomatically: Bool\nA Boolean value that indicates whether the location-manager object may pause location updates.\nvar allowsBackgroundLocationUpdates: Bool\nA Boolean value that indicates whether the app receives location updates when running in the background.\nvar showsBackgroundLocationIndicator: Bool\nA Boolean value that indicates whether the status bar changes its appearance when an app uses location services in the background.\nvar activityType: CLActivityType\nThe type of activity the app expects the user to typically perform while in the app’s location session.\nenum CLActivityType\nConstants that indicate the type of activity associated with location updates."
  },
  {
    "title": "errorDomain | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747543-errordomain",
    "html": "See Also\nGetting the error details\nvar errorCode: Int\nThe error code the framework returns when location push service fails.\nvar code: Code\nThe error code the framework returns when location push service fails.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar localizedDescription: String\nA human readable, localized description of the error."
  },
  {
    "title": "code | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747541-code",
    "html": "See Also\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar errorCode: Int\nThe error code the framework returns when location push service fails.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar localizedDescription: String\nA human readable, localized description of the error."
  },
  {
    "title": "userInfo | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747553-userinfo",
    "html": "See Also\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar errorCode: Int\nThe error code the framework returns when location push service fails.\nvar code: Code\nThe error code the framework returns when location push service fails.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar localizedDescription: String\nA human readable, localized description of the error."
  },
  {
    "title": "errorUserInfo | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747544-erroruserinfo",
    "html": "See Also\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar errorCode: Int\nThe error code the framework returns when location push service fails.\nvar code: Code\nThe error code the framework returns when location push service fails.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar localizedDescription: String\nA human readable, localized description of the error."
  },
  {
    "title": "headingAvailable() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423502-headingavailable",
    "html": "Return Value\n\ntrue if heading data is available; false if it is not.\n\nDiscussion\n\nHeading data may not be available on all iOS-based devices. You should check the value returned by this method before asking the location manager to deliver heading-related events.\n\nSee Also\nDetermining the availability of services\nclass func significantLocationChangeMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether the significant-change location service is available on the device.\nvar isAuthorizedForWidgetUpdates: Bool\nA Boolean value that indicates whether a widget is eligible to receive location updates.\nvar accuracyAuthorization: CLAccuracyAuthorization\nA value that indicates the level of location accuracy the app has permission to use.\nclass func isMonitoringAvailable(for: AnyClass) -> Bool\nReturns a Boolean value indicating whether the device supports region monitoring using the specified class.\nclass func isRangingAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports ranging of beacons that use the iBeacon protocol.\nclass func locationServicesEnabled() -> Bool\nReturns a Boolean value indicating whether location services are enabled on the device."
  },
  {
    "title": "localizedDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747548-localizeddescription",
    "html": "See Also\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar errorCode: Int\nThe error code the framework returns when location push service fails.\nvar code: Code\nThe error code the framework returns when location push service fails.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747546-hashvalue",
    "html": "See Also\nComparing errors\nstatic func != (CLLocationPushServiceError, CLLocationPushServiceError) -> Bool\nIndicates whether two errors aren't equal.\nstatic func == (CLLocationPushServiceError, CLLocationPushServiceError) -> Bool\nIndicates whether two errors are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the error by feeding them into the given hash function."
  },
  {
    "title": "init(location:name:postalAddress:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/2132103-init",
    "html": "Parameters\nlocation\n\nThe geographic location to associate with the placemark. Use this value to set the location property of the placemark object.\n\nname\n\nThe name to associate with the placemark. Use this value to set the name property of the placemark object.\n\npostalAddress\n\nThe postal address to associate with the placemark. This parameter is optional but lets you provide a more specific location for the placemark. Use this parameter to populate additional properties of the returned object.\n\nReturn Value\n\nA new placemark object.\n\nDiscussion\n\nApp extensions built with the Intents framework can use this method to create a placemark from existing location and address data. For example, an app that offers a ride service might create a new placemark when resolving a user’s pickup or drop-off location. The returned placemark contains only the data that you provide.\n\nSee Also\nCreating a placemark object\ninit(placemark: CLPlacemark)\nInitializes and returns a placemark object from another placemark object."
  },
  {
    "title": "init(_:userInfo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747547-init",
    "html": "Parameters\ncode\n\nThe error code value.\n\nuserInfo\n\nA dictionary containing information about this error."
  },
  {
    "title": "region | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423808-region",
    "html": "See Also\nGetting the placemark’s location\nvar location: CLLocation?\nThe location object containing latitude and longitude information."
  },
  {
    "title": "typeDisplayRepresentation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/4048472-typedisplayrepresentation",
    "html": "Relationships\nFrom Protocol\nTypeDisplayRepresentable"
  },
  {
    "title": "init(placemark:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423818-init",
    "html": "Parameters\nplacemark\n\nThe placemark object to use as the source of the data for the new object.\n\nReturn Value\n\nAn initialized placemark object.\n\nDiscussion\n\nYou can use this method to transfer information from one placemark object to another placemark object.\n\nSee Also\nCreating a placemark object\ninit(location: CLLocation, name: String?, postalAddress: CNPostalAddress?)\nCreates and initializes a placemark object using the specified location and address information."
  },
  {
    "title": "subThoroughfare | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423782-subthoroughfare",
    "html": "Discussion\n\nSubthroughfares provide information such as the street number for the location. For example, if the placemark location is Apple’s headquarters (1 Apple Park Way), the value for this property would be the string “1”.\n\nSee Also\nGetting the placemark details\nvar thoroughfare: String?\nThe street address associated with the placemark.\nvar locality: String?\nThe city associated with the placemark.\nvar subLocality: String?\nAdditional city-level information for the placemark.\nvar administrativeArea: String?\nThe state or province associated with the placemark.\nvar subAdministrativeArea: String?\nAdditional administrative area information for the placemark.\nvar postalCode: String?\nThe postal code associated with the placemark."
  },
  {
    "title": "thoroughfare | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423814-thoroughfare",
    "html": "Discussion\n\nThe street address contains the street name. For example, if the placemark location is Apple’s headquarters, the value for this property would be the string “Apple Park Way”.\n\nSee Also\nGetting the placemark details\nvar subThoroughfare: String?\nAdditional street-level information for the placemark.\nvar locality: String?\nThe city associated with the placemark.\nvar subLocality: String?\nAdditional city-level information for the placemark.\nvar administrativeArea: String?\nThe state or province associated with the placemark.\nvar subAdministrativeArea: String?\nAdditional administrative area information for the placemark.\nvar postalCode: String?\nThe postal code associated with the placemark."
  },
  {
    "title": "subLocality | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423794-sublocality",
    "html": "Discussion\n\nThis property contains additional information, such as the name of the neighborhood or landmark associated with the placemark. It might also refer to a common name that’s associated with the location.\n\nSee Also\nGetting the placemark details\nvar thoroughfare: String?\nThe street address associated with the placemark.\nvar subThoroughfare: String?\nAdditional street-level information for the placemark.\nvar locality: String?\nThe city associated with the placemark.\nvar administrativeArea: String?\nThe state or province associated with the placemark.\nvar subAdministrativeArea: String?\nAdditional administrative area information for the placemark.\nvar postalCode: String?\nThe postal code associated with the placemark."
  },
  {
    "title": "administrativeArea | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423628-administrativearea",
    "html": "Discussion\n\nThe string in this property can be either the spelled out name of the administrative area or its designated abbreviation, if one exists. If the placemark location is Apple’s headquarters, for example, the value for this property would be the string “CA” or “California”.\n\nSee Also\nGetting the placemark details\nvar thoroughfare: String?\nThe street address associated with the placemark.\nvar subThoroughfare: String?\nAdditional street-level information for the placemark.\nvar locality: String?\nThe city associated with the placemark.\nvar subLocality: String?\nAdditional city-level information for the placemark.\nvar subAdministrativeArea: String?\nAdditional administrative area information for the placemark.\nvar postalCode: String?\nThe postal code associated with the placemark."
  },
  {
    "title": "inlandWater | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423738-inlandwater",
    "html": "Discussion\n\nFor coordinates that lie over an inland body of water, this property contains the name of that water body—the name of a lake, stream, river, or other waterway.\n\nSee Also\nGetting landscape information\nvar ocean: String?\nThe name of the ocean associated with the placemark."
  },
  {
    "title": "ocean | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423619-ocean",
    "html": "Discussion\n\nFor coordinates that lie over an ocean, this property contains the name of the ocean.\n\nSee Also\nGetting landscape information\nvar inlandWater: String?\nThe name of the inland water body associated with the placemark."
  },
  {
    "title": "areasOfInterest | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423673-areasofinterest",
    "html": "Discussion\n\nExamples of an area of interest are the name of a military base, large national park, or an attraction such as the Eiffel Tower, Disneyland, or Golden Gate Park."
  },
  {
    "title": "CLError | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror",
    "html": "Overview\n\nInstances of NSError object delivered to the delegate use these error codes for the code property of the error object.\n\nTopics\nGetting general errors\nstatic var locationUnknown: CLError.Code\nA constant that indicates the location manager was unable to obtain a location value right now.\nstatic var denied: CLError.Code\nA constant that indicates the user denied access to the location service.\nstatic var promptDeclined: CLError.Code\nA constant that indicates the user didn’t grant the requested temporary authorization.\nstatic var network: CLError.Code\nA constant that indicates the network was unavailable or a network error occurred.\nstatic var headingFailure: CLError.Code\nA constant that indicates the location manager can’t determine the heading.\nstatic var rangingUnavailable: CLError.Code\nA constant that indicates ranging is disabled.\nstatic var rangingFailure: CLError.Code\nA constant that indicates a general ranging error occurred.\nenum CLError.Code\nError codes returned by the location manager object.\nGetting region monitoring errors\nstatic var regionMonitoringDenied: CLError.Code\nA constant that indicates the user denied access to the region monitoring service.\nstatic var regionMonitoringFailure: CLError.Code\nA constant that indicates the location manager failed to monitor a registered region.\nstatic var regionMonitoringSetupDelayed: CLError.Code\nA constant that indicates Core Location couldn’t initialize the region monitoring feature immediately.\nstatic var regionMonitoringResponseDelayed: CLError.Code\nA constant that indicates Core Location will deliver events but they may be delayed.\nGetting geocoding errors\nstatic var geocodeCanceled: CLError.Code\nA constant that indicates the geocode request was canceled.\nstatic var geocodeFoundNoResult: CLError.Code\nA constant that indicates the geocode request yielded no result.\nstatic var geocodeFoundPartialResult: CLError.Code\nA constant that indicates the geocode request yielded a partial result.\nGetting deferred location update errors\nstatic var deferredFailed: CLError.Code\nA constant that indicates the location manager didn’t enter deferred mode for an unknown reason.\nstatic var deferredCanceled: CLError.Code\nA constant that indicates your app or the location manager canceled the request for deferred updates.\nstatic var deferredAccuracyTooLow: CLError.Code\nA constant that indicates deferred mode isn’t supported for the requested accuracy.\nstatic var deferredDistanceFiltered: CLError.Code\nA constant that indicates deferred mode doesn’t support distance filters.\nstatic var deferredNotUpdatingLocation: CLError.Code\nA constant that indicates the location manager didn’t enter deferred mode because location updates were already disabled or paused.\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar errorCode: Int\nThe error code the framework returns when location services fail.\nvar code: Code\nThe error code the framework returns when location services fail.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar alternateRegion: CLRegion?\nA region that location services can monitor more effectively.\nvar localizedDescription: String\nA localized, human-readable explanation of the error.\nComparing errors\nstatic func == (CLError, CLError) -> Bool\nIndicates whether two errors are equal.\nstatic func != (CLError, CLError) -> Bool\nIndicates whether two errors aren’t equal.\nfunc hash(into: inout Hasher)\nvar hashValue: Int\nCreating an error structure\ninit(Code, userInfo: [String : Any])\nCreates a Core Location error.\nType Properties\nstatic var historicalLocationError: CLError.Code\nSee Also\nErrors\nlet kCLErrorDomain: String\nThe domain for Core Location errors.\nlet kCLErrorUserInfoAlternateRegionKey: String\nA key in the user information dictionary of an error relating to a delayed region monitoring response."
  },
  {
    "title": "displayRepresentation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/4018557-displayrepresentation",
    "html": "Relationships\nFrom Protocol\nInstanceDisplayRepresentable"
  },
  {
    "title": "startUpdatingHeading() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620558-startupdatingheading",
    "html": "Discussion\n\nThis method returns immediately. Calling this method when the receiver is stopped causes it to obtain an initial heading and notify your delegate. After that, the receiver generates update events when the value in the headingFilter property is exceeded.\n\nBefore calling this method, you should always check the headingAvailable property to see whether heading information is supported on the current device. If heading information is not supported, calling this method has no effect and does not result in the delivery of events to your delegate.\n\nCalling this method several times in succession does not automatically result in new events being generated. Calling stopUpdatingHeading() in between, however, does cause a new initial event to be sent the next time you call this method.\n\nIf you start this service and your app is suspended, the system stops the delivery of events until your app starts running again (either in the foreground or background). If your app is terminated, the delivery of new heading events stops altogether and must be restarted by your code when the app is relaunched.\n\nHeading events are delivered to the locationManager(_:didUpdateHeading:) method of your delegate. If there is an error, the location manager calls the locationManager(_:didFailWithError:) method of your delegate instead.\n\nIf a compatible iPad or iPhone app calls this method when running in visionOS, the method does nothing.\n\nSee Also\nRunning the heading service\nfunc stopUpdatingHeading()\nStops the generation of heading updates.\nfunc dismissHeadingCalibrationDisplay()\nDismisses the heading calibration view from the screen immediately.\nvar headingFilter: CLLocationDegrees\nThe minimum angular change in degrees required to generate new heading events.\nlet kCLHeadingFilterNone: CLLocationDegrees\nA constant indicating that all header values should be reported.\ntypealias CLLocationDegrees\nA latitude or longitude value specified in degrees.\nvar headingOrientation: CLDeviceOrientation\nThe device orientation to use when computing heading values.\nenum CLDeviceOrientation\nConstants indicating the physical orientation of the device.\nRelated Documentation\nvar headingAvailable: Bool\nA Boolean value indicating whether the location manager is able to generate heading-related events."
  },
  {
    "title": "serviceExtensionWillTerminate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceextension/3746847-serviceextensionwillterminate",
    "html": "Discussion\n\nIf your didReceiveLocationPushPayload(_:completion:) method takes too long to collect a location and call its completion block, the system calls this method on the main thread. Use this method to execute the completion block from didReceiveLocationPushPayload(_:completion:) as quickly as possible."
  },
  {
    "title": "magneticHeading | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clheading/1423763-magneticheading",
    "html": "Discussion\n\nThe value in this property represents the heading relative to the magnetic North Pole, which is different from the geographic North Pole. The value 0 means the device is pointed toward magnetic north, 90 means it is pointed east, 180 means it is pointed south, and so on. The value in this property should always be valid.\n\nIn iOS 3.x and earlier, the value in this property is always measured relative to the top of the device in a portrait orientation, regardless of the device’s actual physical or interface orientation. In iOS 4.0 and later, the value is measured relative to the heading orientation specified by the location manager. For more information, see the headingOrientation property in CLLocationManager.\n\nIf the headingAccuracy property contains a negative value, the value in this property should be considered unreliable.\n\nSee Also\nGetting the heading values\nvar trueHeading: CLLocationDirection\nThe heading (measured in degrees) relative to true north.\nvar headingAccuracy: CLLocationDirection\nThe maximum deviation (measured in degrees) between the reported heading and the true geomagnetic heading."
  },
  {
    "title": "trueHeading | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clheading/1423568-trueheading",
    "html": "Discussion\n\nThe value in this property represents the heading relative to the geographic North Pole. The value 0 means the device is pointed toward true north, 90 means it is pointed due east, 180 means it is pointed due south, and so on. A negative value indicates that the heading could not be determined.\n\nIn iOS 3.x and earlier, the value in this property is always measured relative to the top of the device in a portrait orientation, regardless of the device’s actual physical or interface orientation. In iOS 4.0 and later, the value is measured relative to the heading orientation specified by the location manager. For more information, see the headingOrientation property in CLLocationManager.\n\nImportant\n\nThis property contains a valid value only if location updates are also enabled for the corresponding location manager object. Because the position of true north is different from the position of magnetic north on the Earth’s surface, Core Location needs the current location of the device to compute the value of this property.\n\nSee Also\nGetting the heading values\nvar magneticHeading: CLLocationDirection\nThe heading (measured in degrees) relative to magnetic north.\nvar headingAccuracy: CLLocationDirection\nThe maximum deviation (measured in degrees) between the reported heading and the true geomagnetic heading."
  },
  {
    "title": "stopUpdatingHeading() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620569-stopupdatingheading",
    "html": "Discussion\n\nCall this method whenever your code no longer needs to receive heading-related events. Disabling event delivery gives the receiver the option of disabling the appropriate hardware (and thereby saving power) when no clients need location data. You can always restart the generation of heading updates by calling the startUpdatingHeading() method again.\n\nIf a compatible iPad or iPhone app calls this method when running in visionOS, the method does nothing.\n\nSee Also\nRunning the heading service\nfunc startUpdatingHeading()\nStarts the generation of updates that report the user’s current heading.\nfunc dismissHeadingCalibrationDisplay()\nDismisses the heading calibration view from the screen immediately.\nvar headingFilter: CLLocationDegrees\nThe minimum angular change in degrees required to generate new heading events.\nlet kCLHeadingFilterNone: CLLocationDegrees\nA constant indicating that all header values should be reported.\ntypealias CLLocationDegrees\nA latitude or longitude value specified in degrees.\nvar headingOrientation: CLDeviceOrientation\nThe device orientation to use when computing heading values.\nenum CLDeviceOrientation\nConstants indicating the physical orientation of the device."
  },
  {
    "title": "headingOrientation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620556-headingorientation",
    "html": "Discussion\n\nWhen computing heading values, the location manager assumes that the top of the device in portrait mode represents due north (0 degrees) by default. For apps that run in other orientations, this may not always be the most convenient orientation. This property allows you to specify which device orientation you want the location manager to use as the reference point for due north.\n\nAlthough you can set the value of this property to CLDeviceOrientation.unknown, CLDeviceOrientation.faceUp, or CLDeviceOrientation.faceDown, doing so has no effect on the orientation reference point. The original reference point is retained instead.\n\nChanging the value in this property affects only those heading values reported after the change is made.\n\nSee Also\nRunning the heading service\nfunc startUpdatingHeading()\nStarts the generation of updates that report the user’s current heading.\nfunc stopUpdatingHeading()\nStops the generation of heading updates.\nfunc dismissHeadingCalibrationDisplay()\nDismisses the heading calibration view from the screen immediately.\nvar headingFilter: CLLocationDegrees\nThe minimum angular change in degrees required to generate new heading events.\nlet kCLHeadingFilterNone: CLLocationDegrees\nA constant indicating that all header values should be reported.\ntypealias CLLocationDegrees\nA latitude or longitude value specified in degrees.\nenum CLDeviceOrientation\nConstants indicating the physical orientation of the device."
  },
  {
    "title": "kCLHeadingFilterNone | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kclheadingfilternone",
    "html": "Discussion\n\nUse this constant to indicate that any change to the heading, regardless of how small, should be reported.\n\nSee Also\nRunning the heading service\nfunc startUpdatingHeading()\nStarts the generation of updates that report the user’s current heading.\nfunc stopUpdatingHeading()\nStops the generation of heading updates.\nfunc dismissHeadingCalibrationDisplay()\nDismisses the heading calibration view from the screen immediately.\nvar headingFilter: CLLocationDegrees\nThe minimum angular change in degrees required to generate new heading events.\ntypealias CLLocationDegrees\nA latitude or longitude value specified in degrees.\nvar headingOrientation: CLDeviceOrientation\nThe device orientation to use when computing heading values.\nenum CLDeviceOrientation\nConstants indicating the physical orientation of the device."
  },
  {
    "title": "locality | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423507-locality",
    "html": "Discussion\n\nIf the placemark location is Apple’s headquarters, for example, the value for this property would be the string “Cupertino”.\n\nSee Also\nGetting the placemark details\nvar thoroughfare: String?\nThe street address associated with the placemark.\nvar subThoroughfare: String?\nAdditional street-level information for the placemark.\nvar subLocality: String?\nAdditional city-level information for the placemark.\nvar administrativeArea: String?\nThe state or province associated with the placemark.\nvar subAdministrativeArea: String?\nAdditional administrative area information for the placemark.\nvar postalCode: String?\nThe postal code associated with the placemark."
  },
  {
    "title": "headingAccuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clheading/1423705-headingaccuracy",
    "html": "Discussion\n\nA positive value in this property represents the potential error between the value reported by the magneticHeading property and the actual direction of magnetic north. Thus, the lower the value of this property, the more accurate the heading. A negative value means that the reported heading is invalid, which can occur when the device is uncalibrated or there is strong interference from local magnetic fields.\n\nSee Also\nGetting the heading values\nvar magneticHeading: CLLocationDirection\nThe heading (measured in degrees) relative to magnetic north.\nvar trueHeading: CLLocationDirection\nThe heading (measured in degrees) relative to true north."
  },
  {
    "title": "x | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clheading/1423685-x",
    "html": "Discussion\n\nThis value represents the x-axis deviation from the magnetic field lines being tracked by the device.\n\nSee Also\nGetting the raw heading data\nvar y: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the y-axis.\nvar z: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the z-axis.\ntypealias CLHeadingComponentValue\nA type used to report magnetic differences reported by the onboard hardware."
  },
  {
    "title": "y | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clheading/1423617-y",
    "html": "Discussion\n\nThis value represents the y-axis deviation from the magnetic field lines being tracked by the device.\n\nSee Also\nGetting the raw heading data\nvar x: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the x-axis.\nvar z: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the z-axis.\ntypealias CLHeadingComponentValue\nA type used to report magnetic differences reported by the onboard hardware."
  },
  {
    "title": "z | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clheading/1423609-z",
    "html": "Discussion\n\nThis value represents the z-axis deviation from the magnetic field lines being tracked by the device.\n\nSee Also\nGetting the raw heading data\nvar x: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the x-axis.\nvar y: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the y-axis.\ntypealias CLHeadingComponentValue\nA type used to report magnetic differences reported by the onboard hardware."
  },
  {
    "title": "reverseGeocodeLocation(_:completionHandler:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder/1423621-reversegeocodelocation",
    "html": "Parameters\nlocation\n\nThe location object containing the coordinate data to look up.\n\ncompletionHandler\n\nThe handler block to execute with the results. The geocoder executes this handler regardless of whether the request was successful or unsuccessful. For more information on the format of this block, see CLGeocodeCompletionHandler.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc reverseGeocodeLocation(_ location: CLLocation) async throws -> [CLPlacemark]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis method submits the specified location data to the geocoding server asynchronously and returns. When the request completes, the geocoder executes the provided completion handler on the main thread.\n\nAfter initiating a reverse-geocoding request, do not attempt to initiate another reverse- or forward-geocoding request. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. When the maximum rate is exceeded, the geocoder passes an error object with the value CLError.Code.network to your completion handler.\n\nSee Also\nReverse geocoding a location\nfunc reverseGeocodeLocation(CLLocation, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a reverse-geocoding request for the specified location and locale.\ntypealias CLGeocodeCompletionHandler\nA block to be called when a geocoding request is complete."
  },
  {
    "title": "Turning an iOS device into an iBeacon device | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/turning_an_ios_device_into_an_ibeacon_device",
    "html": "Overview\n\nAny iOS device that supports sharing data using Bluetooth low energy can be turned into an iBeacon. Apps that use their underlying iOS device as an iBeacon must run in the foreground. As a result, use this feature for point-of-sale apps or for apps that are meant to run in the foreground anyway. For other types of iBeacon implementations, use dedicated beacon hardware from third-party manufacturers. To use an iOS device as an iBeacon, you do the following:\n\nObtain or generate a 128-bit UUID for your device.\n\nCreate a CLBeaconRegion object containing the UUID value along with appropriate major and minor values for your beacon.\n\nAdvertise the beacon information using the Core Bluetooth framework.\n\nGet a UUID for your device\n\nThe primary way to identify an iBeacon is from its UUID. When deploying one or more beacons, you assign a UUID to each one that conveys the beacon’s purpose to clients. The exact purpose of a beacon is something you define. For example, a department store chain might use the same UUID for all of its deployed beacons, or each store might be assigned a different UUID. Because detection involves using region monitoring to look for beacons with specific UUIDs, using fewer UUIDs is easier to manage.\n\nTo create a new UUID for your iBeacon deployment, use the uuidgen command-line tool. Open Terminal and type uuidgen on the command line and press Return. This tool generates a unique 128-bit value and formats it as an ASCII string that is punctuated by hyphens, as shown in Listing 1.\n\nListing 1 Generating a UUID from the command line\n$ uuidgen\n39ED98FF-2900-441A-802F-9C398FC199D2 \n\n\nConfigure the beacon region\n\nUse a CLBeaconRegion object to configure your beacon’s identity. You use the beacon region to generate a dictionary of information that you can advertise later over Bluetooth. Listing 2 shows how to create a beacon region object and fill it with information.\n\nListing 2 Configuring your beacon's identity\nfunc createBeaconRegion() -> CLBeaconRegion? {\n    let proximityUUID = UUID(uuidString:\n                \"39ED98FF-2900-441A-802F-9C398FC199D2\")\n    let major : CLBeaconMajorValue = 100\n    let minor : CLBeaconMinorValue = 1\n    let beaconID = \"com.example.myDeviceRegion\"\n        \n    return CLBeaconRegion(proximityUUID: proximityUUID!, \n                major: major, minor: minor, identifier: beaconID)\n}\n\n\nThe UUID, major, and minor values are specific to your iBeacon implementation. You decide the meaning of these values and decide how apps that detect your beacons interpret those values.\n\nAdvertise your beacon over bluetooth\n\nTo broadcast your beacon’s identity from an iOS device, use the Core Bluetooth framework to configure the iOS device as a Bluetooth peripheral. When configured as a peripheral, your iOS device broadcasts its beacon information out to other devices using the Bluetooth hardware. Other devices use that information to perform ranging and detect their proximity to your iOS device.\n\nAdd the Core Bluetooth framework to your Xcode project. In your code, create a CBPeripheralManager object and call its startAdvertising(_:) method to begin broadcasting your beacon data. The startAdvertising(_:) method takes a dictionary parameter that contains your beacon information. Call the peripheralData(withMeasuredPower:) method of the CLBeaconRegion that you created previously to get a dictionary containing the data associated with your beacon.\n\nListing 3 Advertising your device over Bluetooth\nfunc advertiseDevice(region : CLBeaconRegion) {\n    let peripheral = CBPeripheralManager(delegate: self, queue: nil)\n    let peripheralData = region.peripheralData(withMeasuredPower: nil)\n        \n    peripheral.startAdvertising(((peripheralData as NSDictionary) as! [String : Any]))\n}\n\n\nWhen calling the peripheralData(withMeasuredPower:) method to obtain your data dictionary, you typically pass nil to specify the default received signal strength indicator (RSSI) value associated with the iOS device. This parameter represents the signal strength (in decibels) measured from one meter away from the device. You can specify custom values if you need to calibrate the device for better ranging performance in certain environments.\n\nWhen you create a peripheral manager object, it calls the peripheralManagerDidUpdateState(_:) method of its delegate object. You must implement this delegate method to ensure that Bluetooth low energy is supported and available to use on the iOS device.\n\nImportant\n\nAfter advertising your app as a beacon, your app must continue running in the foreground to broadcast the needed Bluetooth signals. If the user quits the app, the system stops advertising the device as a peripheral over Bluetooth.\n\nDuring ranging, there may be a brief period in which Core Location creates two CLBeacon objects for the same iOS device. This behavior occurs because iOS changes the device’s Bluetooth identifier periodically to protect the user’s privacy, and one beacon represents the old identifier and one beacon represents the new identifier. Within 2 seconds of the identifier change, the beacon with the old identifier has its proximity property set to CLProximity.unknown. Within 10 seconds, the beacon with the old identifier is no longer reported.\n\nSee Also\niBeacon\nRanging for Beacons\nConfigure a device to act as a beacon and to detect surrounding beacons.\nDetermining the proximity to an iBeacon device\nDetect beacons and determine the relative distance to them.\nclass CLBeacon\nInformation about an observed iBeacon device and its relative distance to the user’s device.\nprotocol CLCondition\nThe abstract base class for all other monitor conditions."
  },
  {
    "title": "CLRegion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clregion",
    "html": "Overview\n\nThis is an abstract base class. Instantiate one of the provided subclasses that define specific types of regions. After you create a region, register it with a CLLocationManager object with the startMonitoring(for:) method. The location manager generates appropriate events whenever the user crosses the boundaries of the region.\n\nTopics\nGetting the region identifier\nvar identifier: String\nThe identifier for the region object.\nSpecifying the notification conditions\nvar notifyOnEntry: Bool\nA Boolean indicating that notifications are generated upon entry into the region.\nvar notifyOnExit: Bool\nA Boolean indicating that notifications are generated upon exit from the region.\nDeprecated\ninit(circularRegionWithCenter: CLLocationCoordinate2D, radius: CLLocationDistance, identifier: String)\nInitializes and returns a region object defining a circular area.\nDeprecated\nfunc contains(CLLocationCoordinate2D) -> Bool\nReturns a Boolean value indicating whether the region contains the specified coordinate.\nDeprecated\nvar center: CLLocationCoordinate2D\nThe center point of the region.\nDeprecated\nvar radius: CLLocationDistance\nThe radius (measured in meters) that defines the region’s outer boundary.\nDeprecated\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nRegion monitoring\nMonitoring the user's proximity to geographic regions\nUse region monitoring to determine when the user enters or leaves a geographic region."
  },
  {
    "title": "stopMonitoringSignificantLocationChanges() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423679-stopmonitoringsignificantlocatio",
    "html": "Discussion\n\nUse this method to stop the delivery of location events that was started using the startMonitoringSignificantLocationChanges() method. If a compatible iPad or iPhone app calls this method when running in visionOS, the method does nothing.\n\nSee Also\nRunning the significant change location service\nfunc startMonitoringSignificantLocationChanges()\nStarts the generation of updates based on significant location changes."
  },
  {
    "title": "requestTemporaryFullAccuracyAuthorization(withPurposeKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/3600216-requesttemporaryfullaccuracyauth",
    "html": "Parameters\npurposeKey\n\nA key in the NSLocationTemporaryUsageDescriptionDictionary dictionary of the app’s Info.plist file. The value for this key is an app-provided string that describes the reason for accessing location data with full accuracy. To localize a usage description, add an entry to your InfoPlist.strings file with the same key you provide for this parameter.\n\nDiscussion\n\nThis method behaves the same as calling the requestTemporaryFullAccuracyAuthorization(withPurposeKey:completion:) method, passing nil as the completion closure. Use this method if your app’s logic to respond to changes in location data accuracy is already handled by the locationManagerDidChangeAuthorization(_:) delegate method, and your app doesn’t have any work to do in the closure.\n\nSee Also\nRequesting authorization for location services\nfunc requestWhenInUseAuthorization()\nRequests the user’s permission to use location services while the app is in use.\nfunc requestAlwaysAuthorization()\nRequests the user’s permission to use location services regardless of whether the app is in use.\nfunc requestTemporaryFullAccuracyAuthorization(withPurposeKey: String, completion: ((Error?) -> Void)?)\nRequests permission to temporarily use location services with full accuracy and reports the results to the provided completion handler.\nvar authorizationStatus: CLAuthorizationStatus\nThe current authorization status for the app.\nenum CLAuthorizationStatus\nConstants indicating the app's authorization to use location services.\nproperty list key NSLocationDefaultAccuracyReduced\nA Boolean value that indicates whether the app requests reduced location accuracy by default.\nName: Privacy - Location Default Accuracy Reduced\nproperty list key NSLocationAlwaysAndWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information at all times.\nName: Privacy - Location Always and When In Use Usage Description"
  },
  {
    "title": "regionMonitoringResponseDelayed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clerror/2320677-regionmonitoringresponsedelayed",
    "html": "Discussion\n\nThe user information dictionary might contain an alternate region that you can monitor instead. Use the alternateRegion property to retrieve the CLRegion object.\n\nSee Also\nGetting region monitoring errors\nstatic var regionMonitoringDenied: CLError.Code\nA constant that indicates the user denied access to the region monitoring service.\nstatic var regionMonitoringFailure: CLError.Code\nA constant that indicates the location manager failed to monitor a registered region.\nstatic var regionMonitoringSetupDelayed: CLError.Code\nA constant that indicates Core Location couldn’t initialize the region monitoring feature immediately."
  },
  {
    "title": "CLLocationPushServiceError.Code.unknown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/code/unknown",
    "html": "See Also\nGetting the error code\ncase missingPushExtension\nAn error code that indicates the app is missing a Location Push Service Extension.\ncase missingPushServerEnvironment\nAn error code that indicates the app is missing an Apple Push Notification service (APNs) environment entitlement.\ncase missingEntitlement\nAn error code that indicates the app is missing the entitlement it needs to use the location push service.\ncase unsupportedPlatform\nAn error code that indicates the location push service isn’t available on this platform."
  },
  {
    "title": "CLLocationPushServiceError.Code.missingPushServerEnvironment | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/code/missingpushserverenvironment",
    "html": "Discussion\n\nA Location Push Service Extension requires that your app has the APNs environment entitlement. For more information, see APS Environment Entitlement.\n\nSee Also\nGetting the error code\ncase unknown\nAn error code that indicates the app was unable to start the location push service for an unknown reason.\ncase missingPushExtension\nAn error code that indicates the app is missing a Location Push Service Extension.\ncase missingEntitlement\nAn error code that indicates the app is missing the entitlement it needs to use the location push service.\ncase unsupportedPlatform\nAn error code that indicates the location push service isn’t available on this platform."
  },
  {
    "title": "CLLocationPushServiceError.Code.missingEntitlement | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/code/missingentitlement",
    "html": "Discussion\n\nFor more information, see Creating a location push service extension.\n\nSee Also\nGetting the error code\ncase unknown\nAn error code that indicates the app was unable to start the location push service for an unknown reason.\ncase missingPushExtension\nAn error code that indicates the app is missing a Location Push Service Extension.\ncase missingPushServerEnvironment\nAn error code that indicates the app is missing an Apple Push Notification service (APNs) environment entitlement.\ncase unsupportedPlatform\nAn error code that indicates the location push service isn’t available on this platform."
  },
  {
    "title": "CLLocationPushServiceError.Code.missingPushExtension | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/code/missingpushextension",
    "html": "Discussion\n\nFor more information, see Creating a location push service extension.\n\nSee Also\nGetting the error code\ncase unknown\nAn error code that indicates the app was unable to start the location push service for an unknown reason.\ncase missingPushServerEnvironment\nAn error code that indicates the app is missing an Apple Push Notification service (APNs) environment entitlement.\ncase missingEntitlement\nAn error code that indicates the app is missing the entitlement it needs to use the location push service.\ncase unsupportedPlatform\nAn error code that indicates the location push service isn’t available on this platform."
  },
  {
    "title": "accuracyAuthorization | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/3600215-accuracyauthorization",
    "html": "Discussion\n\nIf the value of this property is CLAccuracyAuthorization.fullAccuracy, you can set the desiredAccuracy property to any value. If the value is CLAccuracyAuthorization.reducedAccuracy, setting desiredAccuracy to a value other than kCLLocationAccuracyReduced has no effect on the location information, and your app can’t use region monitoring or beacon ranging.\n\nNote\n\nBecause reduced accuracy isn’t available prior to watchOS 7, when the user chooses reduced accuracy on the paired iPhone, watch apps running with this older software don’t receive any location data. This occurs because watchOS apps must adhere to the permissions granted on the paired iPhone.\n\nSee Also\nDetermining the availability of services\nclass func significantLocationChangeMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether the significant-change location service is available on the device.\nclass func headingAvailable() -> Bool\nReturns a Boolean value indicating whether the location manager is able to generate heading-related events.\nvar isAuthorizedForWidgetUpdates: Bool\nA Boolean value that indicates whether a widget is eligible to receive location updates.\nclass func isMonitoringAvailable(for: AnyClass) -> Bool\nReturns a Boolean value indicating whether the device supports region monitoring using the specified class.\nclass func isRangingAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports ranging of beacons that use the iBeacon protocol.\nclass func locationServicesEnabled() -> Bool\nReturns a Boolean value indicating whether location services are enabled on the device."
  },
  {
    "title": "init(softwareSimulationState:andExternalAccessoryState:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationsourceinformation/3861805-init",
    "html": "Parameters\nisSoftware\n\nA Boolean value that indicates software is generating or simulating the location information.\n\nisAccessory\n\nA Boolean value that indicates an external device is providing the location information."
  },
  {
    "title": "startMonitoring(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423656-startmonitoring",
    "html": "Deprecated\n\nUse addConditionForMonitoring:identifier: instead.\n\nParameters\nregion\n\nThe region object that defines the boundary to monitor. This parameter must not be nil.\n\nDiscussion\n\nYou must call this method once for each region you want to monitor. If an existing region with the same identifier is already being monitored by the app, the old region is replaced by the new one. The regions you add using this method are shared by all location manager objects in your app and stored in the monitoredRegions property.\n\nRegion events are delivered to the locationManager(_:didEnterRegion:) and locationManager(_:didExitRegion:) methods of your delegate. If there is an error, the location manager calls the locationManager(_:monitoringDidFailFor:withError:) method of your delegate instead.\n\nAn app can register up to 20 regions at a time. In order to report region changes in a timely manner, the region monitoring service requires network connectivity.\n\nIn iOS 6, regions with a radius between 1 and 400 meters work better on iPhone 4S or later devices. (In iOS 5, regions with a radius between 1 and 150 meters work better on iPhone 4S and later devices.) On these devices, an app can expect to receive the appropriate region entered or region exited notification within 3 to 5 minutes on average, if not sooner.\n\nIf a compatible iPad or iPhone app calls this method when running in visionOS, the method does nothing.\n\nSee Also\nMethods\nfunc stopMonitoring(for: CLRegion)\nStops monitoring the specified region.\nDeprecated\nclass func regionMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether region monitoring is supported on the current device.\nDeprecated\nclass func regionMonitoringEnabled() -> Bool\nReturns a Boolean value indicating whether region monitoring is currently enabled.\nDeprecated\nclass func authorizationStatus() -> CLAuthorizationStatus\nReturns the app’s authorization status for using location services.\nDeprecated\nfunc startMonitoring(for: CLRegion, desiredAccuracy: CLLocationAccuracy)\nStarts monitoring the specified region for boundary crossings.\nDeprecated\nfunc requestState(for: CLRegion)\nRetrieves the state of a region asynchronously.\nDeprecated\nfunc startRangingBeacons(in: CLBeaconRegion)\nStarts the delivery of notifications for the specified beacon region.\nDeprecated\nfunc stopRangingBeacons(in: CLBeaconRegion)\nStops the delivery of notifications for the specified beacon region.\nDeprecated\nclass func deferredLocationUpdatesAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports deferred location updates.\nDeprecated\nfunc allowDeferredLocationUpdates(untilTraveled: CLLocationDistance, timeout: TimeInterval)\nAsks the location manager to defer the delivery of location updates until the specified criteria are met.\nDeprecated\nfunc disallowDeferredLocationUpdates()\nCancels the deferral of location updates for this app.\nDeprecated"
  },
  {
    "title": "isProducedByAccessory | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationsourceinformation/3861806-isproducedbyaccessory",
    "html": "Discussion\n\nCore Location sets isProducedByAccessory to true if the system retrieved the location from an external accessory attached to the device, such as a Made for iPhone GPS dongle or CarPlay. Otherwise, the default value is false.\n\nSee Also\nIdentifying the source of location data\nvar isSimulatedBySoftware: Bool\nA Boolean value that indicates whether the system generates the location using on-device software simulation."
  },
  {
    "title": "isSimulatedBySoftware | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationsourceinformation/3861807-issimulatedbysoftware",
    "html": "Discussion\n\nCore Location sets isSimulatedBySoftware to true if the system generated the location using on-device software simulation. You can simulate locations by loading GPX files using the Xcode debugger. The default value is false.\n\nSee Also\nIdentifying the source of location data\nvar isProducedByAccessory: Bool\nA Boolean value that indicates whether the system receives the location from an external accessory."
  },
  {
    "title": "CLCircularRegion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clcircularregion",
    "html": "Deprecated\n\nUse CLCircularGeographicCondition instead.\n\nOverview\n\nThe CLCircularRegion class defines the location and boundaries for a circular geographic region. You can use instances of this class to define geofences for a specific location. The crossing of a geofence’s boundary causes the location manager to notify its delegate.\n\nTopics\nCreating a circular region\ninit(center: CLLocationCoordinate2D, radius: CLLocationDistance, identifier: String)\nCreates and returns a region object defining a circular geographic area.\nGetting the circle’s center and radius\nvar center: CLLocationCoordinate2D\nThe center point of the geographic area.\nvar radius: CLLocationDistance\nThe radius (measured in meters) that defines the geographic area’s outer boundary.\nPerforming hit testing in the region\nfunc contains(CLLocationCoordinate2D) -> Bool\nReturns a Boolean value indicating whether the geographic area contains the specified coordinate.\nRelationships\nInherits From\nCLRegion"
  },
  {
    "title": "coordinate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clvisit/1614677-coordinate",
    "html": "See Also\nGetting the location\nvar horizontalAccuracy: CLLocationAccuracy\nThe horizontal accuracy (in meters) of the specified coordinate."
  },
  {
    "title": "arrivalDate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clvisit/1614681-arrivaldate",
    "html": "Discussion\n\nWhen the visit object does not include arrival information, this property is set to the date returned by the distantPast method of NSDate.\n\nSee Also\nGetting the visit duration\nvar departureDate: Date\nThe approximate time at which the user left the specified location."
  },
  {
    "title": "horizontalAccuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clvisit/1614679-horizontalaccuracy",
    "html": "Discussion\n\nThe latitude and longitude specified by the coordinate property identify the center of the circle, and this value indicates the radius of that circle.\n\nSee Also\nGetting the location\nvar coordinate: CLLocationCoordinate2D\nThe geographical coordinate information."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationcoordinate2d/1423652-init",
    "html": "See Also\nCreating a location coordinate\ninit(latitude: CLLocationDegrees, longitude: CLLocationDegrees)\nCreates a location coordination object with the specified latitude and longitude values.\nfunc CLLocationCoordinate2DMake(CLLocationDegrees, CLLocationDegrees) -> CLLocationCoordinate2D\nFormats a latitude and longitude value into a coordinate data structure format."
  },
  {
    "title": "latitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationcoordinate2d/1423513-latitude",
    "html": "Discussion\n\nPositive values indicate latitudes north of the equator. Negative values indicate latitudes south of the equator.\n\nSee Also\nGetting the geographic coordinates\nvar longitude: CLLocationDegrees\nThe longitude in degrees.\nvar animatableData: AnimatablePair<CLLocationDegrees, CLLocationDegrees>\nA pair of locations you can use to configure an animation."
  },
  {
    "title": "CLLocationCoordinate2DMake(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/1423838-cllocationcoordinate2dmake",
    "html": "Parameters\nlatitude\n\nThe latitude for the new coordinate.\n\nlongitude\n\nThe longitude for the new coordinate.\n\nReturn Value\n\nA coordinate structure encompassing the latitude and longitude values.\n\nSee Also\nCreating a location coordinate\ninit()\nCreates a location coordinate object.\ninit(latitude: CLLocationDegrees, longitude: CLLocationDegrees)\nCreates a location coordination object with the specified latitude and longitude values."
  },
  {
    "title": "didReceiveLocationPushPayload(_:completion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceextension/3746846-didreceivelocationpushpayload",
    "html": "Required\n\nParameters\npayload\n\nThe payload containing the location push.\n\ncompletion\n\nThe block to execute after you receive and process the device’s location. This block has no return value and no parameters.\n\nExecute this block as quickly as possible after you finish the location-related task. If you take too long to execute this block, the system calls the serviceExtensionWillTerminate() method as a warning. If you still don’t call the block in a timely manner, the system terminates your app extension.\n\nDiscussion\n\nConcurrency Note\n\nYou can implement this delegate method as a synchronous method that takes a completion handler, as shown on this page, or as an asynchronous method that has the following declaration:\n\nfunc didReceiveLocationPushPayload(_ payload: [String : Any]) async\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nWhen the system receives a location push notification that targets your app, it runs your app extension and calls this method. Use your implementation of this method to request the device’s current location and do something with that information. For example, a location-sharing app might send the location back to a server to update the person’s current location.\n\nWhen you add a location push service app extension to your project, the Xcode template includes an implementation of this method for you to modify. The template uses this method to store the completion block and initialize a CLLocationManager instance. Process the result of your location query in the CLLocationManagerDelegate methods.\n\nImportant\n\nProtecting user privacy is important when handling location data. End-to-end encryption provides enhanced security if your app moves location data off the user’s device, including transmitting it to a server or to another user. For more information, see Protecting the User’s Privacy.\n\nStore the completion block and call it after you finish processing the location request. Also call the completion block when the system calls serviceExtensionWillTerminate()."
  },
  {
    "title": "CLActivityType.automotiveNavigation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clactivitytype/automotivenavigation",
    "html": "Discussion\n\nUse this activity type when your app is using the location manager specifically during a vehicular positioning session to track location changes to the automobile.\n\nThis activity might cause the system to pause location updates when the vehicle doesn’t move for an extended period of time.\n\nSee Also\nActivity types\ncase other\nThe value that indicates the app is using location manager for an unspecified activity.\ncase fitness\nThe value that indicates positioning during dedicated fitness sessions, such as walking workouts, running workouts, cycling workouts, and so on.\ncase otherNavigation\nThe value that indicates positioning for activities that don’t or may not adhere to roads such as cycling, scooters, trains, boats and off-road vehicles.\ncase airborne\nThe value that indicates activities in the air."
  },
  {
    "title": "CLAuthorizationStatus.authorizedAlways | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clauthorizationstatus/authorizedalways",
    "html": "Discussion\n\nThis authorization allows you to use all location services and receive location events whether or not your app is in use.\n\nSee Also\nGetting the authorization status\ncase notDetermined\nThe user has not chosen whether the app can use location services.\ncase restricted\nThe app is not authorized to use location services.\ncase denied\nThe user denied the use of location services for the app or they are disabled globally in Settings.\nstatic var authorized: CLAuthorizationStatus\nThe user authorized the app to use location services.\ncase authorizedWhenInUse\nThe user authorized the app to start location services while it is in use."
  },
  {
    "title": "desiredAccuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423836-desiredaccuracy",
    "html": "Discussion\n\nThe location service does its best to achieve the requested accuracy; however, apps must be prepared to use less accurate data. If your app isn’t authorized to access precise location information (isAuthorizedForPreciseLocation is false), changes to this property’s value have no effect; the accuracy is always kCLLocationAccuracyReduced.\n\nTo reduce your app’s impact on battery life, assign a value to this property that’s appropriate for your usage. For example, if you need the current location only within a kilometer, specify kCLLocationAccuracyKilometer. More accurate location data also takes more time to become available.\n\nAfter you request high-accuracy location data, your app might still get data with a lower accuracy for a period of time. During the time it takes to determine the location within the requested accuracy, the location service keeps providing the data that’s available, even though that data isn’t as accurate as your app requested. Your app receives more accurate location data as that data becomes available.\n\nFor iOS, the default value of this property is kCLLocationAccuracyBest. For macOS, watchOS, and tvOS, the default value is kCLLocationAccuracyHundredMeters.\n\nThis property effects only the standard location services, not for monitoring significant location changes.\n\nSpecial Considerations\n\nIn iOS, this property is declared as nonatomic. In macOS, it is declared as atomic.\n\nSee Also\nSpecifying distance and accuracy\nvar distanceFilter: CLLocationDistance\nThe minimum distance in meters the device must move horizontally before an update event is generated.\nlet CLLocationDistanceMax: CLLocationDistance\nA constant indicating the maximum distance.\nlet kCLDistanceFilterNone: CLLocationDistance\nA constant indicating that all movement should be reported.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\ntypealias CLLocationAccuracy\nThe accuracy of a geographical coordinate."
  },
  {
    "title": "pausesLocationUpdatesAutomatically | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620553-pauseslocationupdatesautomatical",
    "html": "Discussion\n\nAllowing the location manager to pause updates can improve battery life on the target device without sacrificing location data. Setting this property to true causes the location manager to pause updates (and powers down the appropriate hardware) at times when the location data is unlikely to change. For example, if the user stops for food while using a navigation app, the location manager might pause updates for a period of time. You can help the determination of when to pause location updates by assigning a value to the activityType property.\n\nAfter a pause occurs, it’s your responsibility to restart location services again when you determine that they’re needed. Core Location calls the locationManagerDidPauseLocationUpdates(_:) method of your location manager’s delegate to let you know that a pause has occurred. In that method configure a local notification that has a UNLocationNotificationTrigger to notify when the user exits the current region. The message for the local notification should prompt the user to launch your app again so that it can resume updates.\n\nImportant\n\nFor apps that have in-use authorization, a pause to location updates ends access to location changes until the app launches again and is able to restart those updates. To prevent location updates from stopping entirely, consider disabling this property and changing location accuracy to kCLLocationAccuracyThreeKilometers when your app moves to the background. This allows your app to continue receiving location updates in a power-friendly manner.\n\nOn supported platforms the default value of this property is true; otherwise the default value is false and is immutable.\n\nSee Also\nRunning the standard location service\nfunc startUpdatingLocation()\nStarts the generation of updates that report the user’s current location.\nfunc stopUpdatingLocation()\nStops the generation of location updates.\nfunc requestLocation()\nRequests the one-time delivery of the user’s current location.\nvar allowsBackgroundLocationUpdates: Bool\nA Boolean value that indicates whether the app receives location updates when running in the background.\nvar showsBackgroundLocationIndicator: Bool\nA Boolean value that indicates whether the status bar changes its appearance when an app uses location services in the background.\nvar activityType: CLActivityType\nThe type of activity the app expects the user to typically perform while in the app’s location session.\nenum CLActivityType\nConstants that indicate the type of activity associated with location updates."
  },
  {
    "title": "activityType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620567-activitytype",
    "html": "Discussion\n\nAn app should use activityType to communicate to Core Location algorithms the type of activity the app’s users typically perform while using the app. The location manager uses the information in this property as a cue to determine when the system may pause location updates. Pausing updates gives the system the opportunity to save power in situations where the user’s location isn’t likely to be changing. For example, if the activity type is CLActivityType.automotiveNavigation and no location changes have occurred recently, the system might power down radios until the system detects movement again.\n\nAfter a pause occurs, it’s your responsibility to restart location services again when you determine that they’re needed. For more information on ways to restart location services after a pause, see the discussion of the pausesLocationUpdatesAutomatically property.\n\nThe default value of this property is CLActivityType.other.\n\nIf your app allows the user to change the type activity they’re performing, for example in a navigation app that allows the user to switch between driving or walking modes, you should also update the activityType as well.\n\nSee Also\nRunning the standard location service\nfunc startUpdatingLocation()\nStarts the generation of updates that report the user’s current location.\nfunc stopUpdatingLocation()\nStops the generation of location updates.\nfunc requestLocation()\nRequests the one-time delivery of the user’s current location.\nvar pausesLocationUpdatesAutomatically: Bool\nA Boolean value that indicates whether the location-manager object may pause location updates.\nvar allowsBackgroundLocationUpdates: Bool\nA Boolean value that indicates whether the app receives location updates when running in the background.\nvar showsBackgroundLocationIndicator: Bool\nA Boolean value that indicates whether the status bar changes its appearance when an app uses location services in the background.\nenum CLActivityType\nConstants that indicate the type of activity associated with location updates."
  },
  {
    "title": "startMonitoringVisits() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1618692-startmonitoringvisits",
    "html": "Discussion\n\nCalling this method begins the delivery of visit-related events to your app. Enabling visit events for one location manager enables visit events for all other location manager objects in your app. When a new visit event arrives, the location manager object delivers the event to the locationManager(_:didVisit:) method of its delegate.\n\nYour app can monitor for visit events without calling requestTemporaryPreciseLocationAuthorization(withPurposeKey:). In that case, the visit events use reduced accuracy, as reflected by the horizontalAccuracy property of CLVisit.\n\nIf your app is terminated while this service is active, the system relaunches your app when new visit events are ready to be delivered. Upon relaunch, recreate your location manager object and assign a delegate to begin receiving visit events. You don’t need to call this method again to restart the delivery of visit events, but calling it does no harm.\n\nIf a compatible iPad or iPhone app calls this method when running in visionOS, the method does nothing.\n\nSee Also\nRunning the visits location service\nfunc stopMonitoringVisits()\nStops the delivery of visit-related events."
  },
  {
    "title": "requestAlwaysAuthorization() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620551-requestalwaysauthorization",
    "html": "Discussion\n\nYou must call this or the requestWhenInUseAuthorization() method before your app can receive location information. To call this method, you must have both NSLocationAlwaysUsageDescription and NSLocationWhenInUseUsageDescription keys in your app’s Info.plist file. You may call requestAlwaysAuthorization() when the current authorization state is either:\n\nNot Determined — CLAuthorizationStatus.notDetermined\n\nWhen In Use — CLAuthorizationStatus.authorizedWhenInUse\n\nUse the locationManager(_:didUpdateLocations:) method on the CLLocationManager delegate to receive updates when the user makes permission choices.\n\nCore Location limits calls to requestAlwaysAuthorization(). After your app calls this method, further calls have no effect. If a compatible iPad or iPhone app calls this method when running in visionOS, the method treats it as a request for When in Use authorization instead.\n\nRequest Always Authorization After Getting When In Use\n\nTo obtain Always authorization, your app must first request When In Use permission followed by requesting Always authorization.\n\nIf the user grants When In Use permission after your app calls requestWhenInUseAuthorization(), then calling requestAlwaysAuthorization() immediately prompts the user to request Always permission. If the user responded to requestWhenInUseAuthorization() with Allow Once, then Core Location ignores further calls to requestAlwaysAuthorization() due to the temporary authorization.\n\nNote\n\nIn iOS 16 and later, apps that actively track a user’s location or that have recently enabled Core Location display an indicator in Control Center. Be mindful of battery use and user privacy by monitoring the device’s location only when necessary and when the user expects it.\n\nCore Location prompts the user to grant permission with the string from NSLocationAlwaysUsageDescription. The user prompt displays the following options, which determine the authorization your app can receive:\n\nOption\n\n\t\n\nAuthorization\n\n\n\n\nKeep Only While Using\n\n\t\n\nCore Location leaves the authorization as When In Use. The delegate doesn’t receive any updates.\n\n\n\n\nChange to Always Allow\n\n\t\n\nCore Location grants your app Always authorization. The delegate receives CLAuthorizationStatus.authorizedAlways.\n\nRequest Always Authorization Directly\n\nIf your app’s current state is CLAuthorizationStatus.notDetermined and you call requestAlwaysAuthorization(), Core Location uses two prompts before it fully enables Always authorization.\n\nThe first prompt displays immediately with the string from NSLocationWhenInUseUsageDescription. The user prompt displays the following options, which determine the authorization your app receives:\n\nOption\n\n\t\n\nAuthorization\n\n\n\n\nAllow While Using App\n\n\t\n\nCore Location grants your app a Provisional Always authorization. The delegate receives CLAuthorizationStatus.authorizedAlways.\n\n\n\n\nAllow Once\n\n\t\n\nCore Location grants your app a Temporary When in Use authorization. The delegate receives CLAuthorizationStatus.authorizedWhenInUse. This authorization expires when your app is no longer in use, reverting to CLAuthorizationStatus.notDetermined.\n\n\n\n\nDon’t Allow\n\n\t\n\nCore Location marks your app with Denied authorization. The delegate receives CLAuthorizationStatus.denied.\n\nThe second prompt displays when Core Location prepares to deliver an event to your app requiring CLAuthorizationStatus.authorizedAlways. If the app is in the Provisional Always state, the system displays the second prompt with the string from NSLocationAlwaysUsageDescription. Core Location will typically display the second prompt when your app isn’t running.\n\nYour app receives permanent Always authorization if the user chooses to grant permission when the second prompt appears while in the Provisional Always state. When the user responds, your app receives either the location event or a call to your delegate with the modified authorization.\n\nWhen displaying the second prompt, the user sees one of the following options:\n\nOption\n\n\t\n\nAuthorization\n\n\n\n\nKeep Only While Using\n\n\t\n\nCore Location changes the authorization to When In Use. The delegate receives CLAuthorizationStatus.authorizedWhenInUse.\n\n\n\n\nChange to Always Allow\n\n\t\n\nCore Location removes the provisional status, making the Always authorization permanent. The delegate doesn’t receive a callback.\n\nIf the user responds to the prompt near the time it was delivered and chooses to allow the Always permission, the location event will be delivered to your app.\n\nSee Also\nRequesting authorization for location services\nfunc requestWhenInUseAuthorization()\nRequests the user’s permission to use location services while the app is in use.\nfunc requestTemporaryFullAccuracyAuthorization(withPurposeKey: String, completion: ((Error?) -> Void)?)\nRequests permission to temporarily use location services with full accuracy and reports the results to the provided completion handler.\nfunc requestTemporaryFullAccuracyAuthorization(withPurposeKey: String)\nRequests permission to temporarily use location services with full accuracy.\nvar authorizationStatus: CLAuthorizationStatus\nThe current authorization status for the app.\nenum CLAuthorizationStatus\nConstants indicating the app's authorization to use location services.\nproperty list key NSLocationDefaultAccuracyReduced\nA Boolean value that indicates whether the app requests reduced location accuracy by default.\nName: Privacy - Location Default Accuracy Reduced\nproperty list key NSLocationAlwaysAndWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information at all times.\nName: Privacy - Location Always and When In Use Usage Description\nRelated Documentation\nproperty list key NSLocationAlwaysUsageDescription\nA message that tells the user why the app is requesting access to the user's location at all times."
  },
  {
    "title": "locationManager(_:didUpdateLocations:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423615-locationmanager",
    "html": "Parameters\nmanager\n\nThe location manager object that generated the update event.\n\nlocations\n\nAn array of CLLocation objects containing the location data. This array always contains at least one object representing the current location. If updates were deferred or if multiple locations arrived before they could be delivered, the array may contain additional entries. The objects in the array are organized in the order in which they occurred. Therefore, the most recent location update is at the end of the array.\n\nDiscussion\n\nImplementation of this method is optional but recommended.\n\nSee Also\nReceiving location updates\nfunc locationManager(CLLocationManager, didUpdateTo: CLLocation, from: CLLocation)\nTells the delegate that a new location value is available.\nfunc locationManager(CLLocationManager, didFinishDeferredUpdatesWithError: Error?)\nTells the delegate that updates will no longer be deferred.\nRelated Documentation\nMapKit\nDisplay map or satellite imagery within your app, call out points of interest, and determine placemark information for map coordinates.\nMapKit JS\nEmbed interactive Apple Maps on your website, annotate points of interest, and perform georelated searches.\nLocation and Maps Programming Guide"
  },
  {
    "title": "showsBackgroundLocationIndicator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/2923541-showsbackgroundlocationindicator",
    "html": "Discussion\n\nThe default value of this property is false. The background location usage indicator is a blue bar or a blue pill in the status bar on iOS; on watchOS the indicator is a small icon. Users can tap the indicator to return to your app.\n\nThis property affects only apps that received Always authorization. When such an app moves to the background, the system uses this property to determine whether to change the status bar appearance to indicate that location services are in use. Set this value to true to maintain transparency with the user.\n\nFor apps with When In Use authorization, the system changes the appearance of the status bar when the app uses location services in the background.\n\nFor more information, see Handling location updates in the background.\n\nSee Also\nRunning the standard location service\nfunc startUpdatingLocation()\nStarts the generation of updates that report the user’s current location.\nfunc stopUpdatingLocation()\nStops the generation of location updates.\nfunc requestLocation()\nRequests the one-time delivery of the user’s current location.\nvar pausesLocationUpdatesAutomatically: Bool\nA Boolean value that indicates whether the location-manager object may pause location updates.\nvar allowsBackgroundLocationUpdates: Bool\nA Boolean value that indicates whether the app receives location updates when running in the background.\nvar activityType: CLActivityType\nThe type of activity the app expects the user to typically perform while in the app’s location session.\nenum CLActivityType\nConstants that indicate the type of activity associated with location updates."
  },
  {
    "title": "allowsBackgroundLocationUpdates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1620568-allowsbackgroundlocationupdates",
    "html": "Discussion\n\nApps that receive location updates when running in the background must include the UIBackgroundModes key (with the location value) in their app’s Info.plist file. After including the UIBackgroundModes key, set the value of allowsBackgroundLocationUpdates to true. Use this property to enable and disable background updates programmatically. For example, you might set this property to true only after the user enables features in your app that require background location updates.\n\nWhen the value of this property is true and you start location updates while the app is in the foreground, Core Location configures the system to keep the app running to receive continuous background location updates, and arranges to show the background location indicator (blue bar or pill) if needed. Updates continue even if the app subsequently enters the background.\n\nWhen the value of this property is false, location updates may or may not continue in the background depending on other factors, including other background modes. In this configuration Core Location doesn’t configure the system to keep the app running for delivery, or display the background location indicator to extend the effectiveness of the CLAuthorizationStatus.authorizedWhenInUse authorization while the app is running in the background.\n\nThe default value of this property is false.\n\nImportant\n\nSetting the value to true but omitting the UIBackgroundModes key and location value in your app’s Info.plist file is a fatal error that terminates the app.\n\nSee Also\nRunning the standard location service\nfunc startUpdatingLocation()\nStarts the generation of updates that report the user’s current location.\nfunc stopUpdatingLocation()\nStops the generation of location updates.\nfunc requestLocation()\nRequests the one-time delivery of the user’s current location.\nvar pausesLocationUpdatesAutomatically: Bool\nA Boolean value that indicates whether the location-manager object may pause location updates.\nvar showsBackgroundLocationIndicator: Bool\nA Boolean value that indicates whether the status bar changes its appearance when an app uses location services in the background.\nvar activityType: CLActivityType\nThe type of activity the app expects the user to typically perform while in the app’s location session.\nenum CLActivityType\nConstants that indicate the type of activity associated with location updates."
  },
  {
    "title": "CLAccuracyAuthorization.reducedAccuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/claccuracyauthorization/reducedaccuracy",
    "html": "See Also\nGetting the location accuracy\ncase fullAccuracy\nThe user authorized the app to access location data with full accuracy.\nRelated Documentation\nvar accuracyAuthorization: CLAccuracyAuthorization\nA value that indicates the level of location accuracy the app has permission to use."
  },
  {
    "title": "authorizationStatus | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/3563952-authorizationstatus",
    "html": "Return Value\n\nA value indicating whether the app is authorized to use location services.\n\nDiscussion\n\nCheck this value when the locationManagerDidChangeAuthorization(_:) delegate callback indicates that the authorization status has changed.\n\nThe system is guaranteed to call the delegate method with the app’s initial authorization state and all authorization status changes.\n\nThe system manages the authorization status of a given app according to several factors. Users must authorize the app to use location services explicitly, and location services must be enabled in Settings > Privacy. See Choosing the Location Services Authorization to Request for more information.\n\nSee Also\nRequesting authorization for location services\nfunc requestWhenInUseAuthorization()\nRequests the user’s permission to use location services while the app is in use.\nfunc requestAlwaysAuthorization()\nRequests the user’s permission to use location services regardless of whether the app is in use.\nfunc requestTemporaryFullAccuracyAuthorization(withPurposeKey: String, completion: ((Error?) -> Void)?)\nRequests permission to temporarily use location services with full accuracy and reports the results to the provided completion handler.\nfunc requestTemporaryFullAccuracyAuthorization(withPurposeKey: String)\nRequests permission to temporarily use location services with full accuracy.\nenum CLAuthorizationStatus\nConstants indicating the app's authorization to use location services.\nproperty list key NSLocationDefaultAccuracyReduced\nA Boolean value that indicates whether the app requests reduced location accuracy by default.\nName: Privacy - Location Default Accuracy Reduced\nproperty list key NSLocationAlwaysAndWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information at all times.\nName: Privacy - Location Always and When In Use Usage Description"
  },
  {
    "title": "CLLocationUpdate.Updates | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/updates",
    "html": "Overview\n\nCLLocationUpdate uses this structure to asynchronously deliver a stream of location updates to your app when you call liveUpdates(_:).\n\nTopics\nType aliases\ntypealias CLLocationUpdate.Updates.AsyncIterator\nThe type of the update’s asynchronous iterator.\nstruct CLLocationUpdate.Updates.Iterator\nThe type of the update’s iterator.\ntypealias CLLocationUpdate.Updates.Element\nThe type of the update’s asynchronous element.\nInstance methods\nfunc allSatisfy((CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((CLLocationUpdate) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<CLLocationUpdate.Updates, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (CLLocationUpdate) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (CLLocationUpdate) -> Bool) -> AsyncDropWhileSequence<CLLocationUpdate.Updates>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<CLLocationUpdate.Updates>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((CLLocationUpdate) -> Bool) -> AsyncFilterSequence<CLLocationUpdate.Updates>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((CLLocationUpdate) -> SegmentOfResult) -> AsyncFlatMapSequence<CLLocationUpdate.Updates, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc makeAsyncIterator() -> CLLocationUpdate.Updates.Iterator\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((CLLocationUpdate) -> Transformed) -> AsyncThrowingMapSequence<CLLocationUpdate.Updates, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (CLLocationUpdate, CLLocationUpdate) -> Bool) -> CLLocationUpdate?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (CLLocationUpdate) -> Bool) -> AsyncPrefixWhileSequence<CLLocationUpdate.Updates>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, CLLocationUpdate) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, CLLocationUpdate) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.\nRelationships\nConforms To\nAsyncSequence\nSendable\nSee Also\nReceiving location updates\nstatic func liveUpdates(CLLocationUpdate.LiveConfiguration) -> CLLocationUpdate.Updates\nTells Core Location to start delivering the location updates it produces for the configuration you specify.\nenum CLLocationUpdate.LiveConfiguration\nValues for indicating the kind of updates the framework delivers."
  },
  {
    "title": "CLLocationUpdate.LiveConfiguration | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/liveconfiguration",
    "html": "Topics\nLocation types\ncase `default`\nThe value that configures positioning for activities that one of the other activity types doesn’t cover.\ncase airborne\nThe value that configures positioning for activities in the air.\ncase automotiveNavigation\nThe value that configures positioning for an automobile following a road network.\ncase fitness\nThe value that configures positioning for dedicated fitness sessions.\ncase otherNavigation\nThe value that configures positioning for transportation that doesn’t, or may not, adhere to roads, such as cycling, scooters, trains, boats, and off-road vehicles.\nUtility methods\nvar hashValue: Int\nAn integer value that uniquely identifies the object.\nfunc hash(into: inout Hasher)\nComputes the essential components of a value by sending them into the given hasher.\nstatic func != (CLLocationUpdate.LiveConfiguration, CLLocationUpdate.LiveConfiguration) -> Bool\nReturns a Boolean value that indicates whether the live configurations are not equal.\nstatic func == (CLLocationUpdate.LiveConfiguration, CLLocationUpdate.LiveConfiguration) -> Bool\nReturns a Boolean value that indicates whether the live configuration values are equal.\nSee Also\nReceiving location updates\nstatic func liveUpdates(CLLocationUpdate.LiveConfiguration) -> CLLocationUpdate.Updates\nTells Core Location to start delivering the location updates it produces for the configuration you specify.\nstruct CLLocationUpdate.Updates\nA structure that represents an asynchronous sequence of location updates."
  },
  {
    "title": "CLAccuracyAuthorization.fullAccuracy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/claccuracyauthorization/fullaccuracy",
    "html": "See Also\nGetting the location accuracy\ncase reducedAccuracy\nThe user authorized the app to access location data with reduced accuracy.\nRelated Documentation\nvar accuracyAuthorization: CLAccuracyAuthorization\nA value that indicates the level of location accuracy the app has permission to use."
  },
  {
    "title": "liveUpdates(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/4211321-liveupdates",
    "html": "Parameters\nconfiguration\n\nA configuration that describes the updates for the framework to deliver.\n\nReturn Value\n\nCLLocationUpdate.Updates that meet the criteria you specify.\n\nSee Also\nReceiving location updates\nenum CLLocationUpdate.LiveConfiguration\nValues for indicating the kind of updates the framework delivers.\nstruct CLLocationUpdate.Updates\nA structure that represents an asynchronous sequence of location updates."
  },
  {
    "title": "location | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/4211322-location",
    "html": "See Also\nDetermining movement and location\nlet isStationary: Bool\nA Boolean value that indicates whether the user is stationary."
  },
  {
    "title": "isStationary | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate/4211320-isstationary",
    "html": "Discussion\n\nUpdates may stop flowing temporarily for several reasons including if the app is no longer authorized to receive location updates or if its location becomes unknown. If Core Location stops delivering updates because the device is stationary, then it sets isStationary to true; otherwise, it’s false.\n\nIf isStationary is true, the framework can suspend updates until the person starts moving, or their location becomes unknown.\n\nSee Also\nDetermining movement and location\nlet location: CLLocation?\nThe user’s location, if available."
  },
  {
    "title": "CLAuthorizationStatus.notDetermined | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clauthorizationstatus/notdetermined",
    "html": "Discussion\n\nWhen the authorization status is Not Determined, request authorization causes the location manager to prompt the user for permission if the app is in the foreground. See requestWhenInUseAuthorization() and requestAlwaysAuthorization() for more information.\n\nSee Also\nGetting the authorization status\ncase restricted\nThe app is not authorized to use location services.\ncase denied\nThe user denied the use of location services for the app or they are disabled globally in Settings.\nstatic var authorized: CLAuthorizationStatus\nThe user authorized the app to use location services.\ncase authorizedAlways\nThe user authorized the app to start location services at any time.\ncase authorizedWhenInUse\nThe user authorized the app to start location services while it is in use."
  },
  {
    "title": "invalidate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbackgroundactivitysession/4172818-invalidate",
    "html": "Discussion\n\nThis method ends the session immediately. The system terminates any UI that displays a visual indication to this background session. After you invalidate a session, it can’t become active again and you need to create a new session to begin receiving updates again."
  },
  {
    "title": "locationManagerDidChangeAuthorization(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/3563956-locationmanagerdidchangeauthoriz",
    "html": "Parameters\nmanager\n\nThe location manager object reporting the event.\n\nDiscussion\n\nThe system calls this method when the app creates the related object’s CLLocationManager instance, and when the app’s authorization status changes. The status informs the app whether it can access the user’s location.\n\nUse this delegate method to manage your app’s state changes in response to its ability to use location information. For example, you may wish to enable or disable your app’s location-related features, as appropriate. To determine the app’s current authorization, read the new value of the authorizationStatus and accuracyAuthorization properties of the location manager.\n\nImportant\n\nCore Location always calls locationManagerDidChangeAuthorization(_:) when the user’s action results in an authorization status change, and when your app creates an instance of CLLocationManager, whether your app runs in the foreground or in the background.\n\nIf the user’s choice doesn’t change the authorization status after you call the requestWhenInUseAuthorization() or requestAlwaysAuthorization() method, the location manager doesn’t report the current authorization status to this method—the location manager only reports changes. For example, the location manager calls this method when the status changes from CLAuthorizationStatus.notDetermined to CLAuthorizationStatus.authorizedWhenInUse.\n\nEvents that Cause Authorization Status Changes\n\nAn app's authorization status changes in response to users’ actions. Users can change permission for apps to use location information at any time. The user can:\n\nChange an app’s location authorization in Settings > Privacy > Location Services, or in Settings > (the app) > Location Services.\n\nTurn location services on or off globally in Settings > Privacy > Location Services.\n\nChoose Reset Location & Privacy in Settings > General > Reset.\n\nA user's response to location manager prompts can also change authorization status. For instance, users may change the authorization status by responding to the prompts initiated by calls to requestWhenInUseAuthorization() or requestAlwaysAuthorization() methods. For apps with Always authorization, users may change the authorization status to When In Use when responding to the location usage reminder alert.\n\nWhen an app has temporary authorization, the authorization changes when the user ceases to use the app.\n\nSee Also\nResponding to authorization changes\nfunc locationManager(CLLocationManager, didChangeAuthorization: CLAuthorizationStatus)\nTells the delegate its authorization status when the app creates the location manager and when the authorization status changes.\nDeprecated"
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747539",
    "html": "Parameters\nlhs\n\nThe first error to compare.\n\nrhs\n\nThe second error to compare.\n\nReturn Value\n\nA Boolean value that’s set to true if the two errors aren't equal.\n\nSee Also\nComparing errors\nstatic func == (CLLocationPushServiceError, CLLocationPushServiceError) -> Bool\nIndicates whether two errors are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the error by feeding them into the given hash function.\nvar hashValue: Int\nThe hashed value of the error."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747540",
    "html": "Parameters\nlhs\n\nThe first error to compare.\n\nrhs\n\nThe second error to compare\n\nReturn Value\n\nA Boolean value that’s set to true if the two errors are equal.\n\nSee Also\nComparing errors\nstatic func != (CLLocationPushServiceError, CLLocationPushServiceError) -> Bool\nIndicates whether two errors aren't equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the error by feeding them into the given hash function.\nvar hashValue: Int\nThe hashed value of the error."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/3747545-hash",
    "html": "Parameters\nhasher\n\nThe hash function to use when combining the components of the error.\n\nSee Also\nComparing errors\nstatic func != (CLLocationPushServiceError, CLLocationPushServiceError) -> Bool\nIndicates whether two errors aren't equal.\nstatic func == (CLLocationPushServiceError, CLLocationPushServiceError) -> Bool\nIndicates whether two errors are equal.\nvar hashValue: Int\nThe hashed value of the error."
  },
  {
    "title": "postalAddress | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/2890749-postaladdress",
    "html": "See Also\nGetting the associated contact details\nvar addressDictionary: [AnyHashable : Any]?\nA dictionary containing the Address Book keys and values for the placemark.\nDeprecated"
  },
  {
    "title": "isoCountryCode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423796-isocountrycode",
    "html": "Discussion\n\nThis string is the standard abbreviation used to refer to the country or region. For example, if the placemark location is Apple’s headquarters, the value for this property would be the string “US”.\n\nSee Also\nGetting the placemark’s country\nvar country: String?\nThe name of the country or region associated with the placemark."
  },
  {
    "title": "country | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423800-country",
    "html": "Discussion\n\nIf the placemark location is Apple’s headquarters, for example, the value for this property would be the string “United States”.\n\nSee Also\nGetting the placemark’s country\nvar isoCountryCode: String?\nThe abbreviated country or region name."
  },
  {
    "title": "postalCode | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423851-postalcode",
    "html": "Discussion\n\nIf the placemark location is Apple’s headquarters, for example, the value for this property would be the string “95014”.\n\nSee Also\nGetting the placemark details\nvar thoroughfare: String?\nThe street address associated with the placemark.\nvar subThoroughfare: String?\nAdditional street-level information for the placemark.\nvar locality: String?\nThe city associated with the placemark.\nvar subLocality: String?\nAdditional city-level information for the placemark.\nvar administrativeArea: String?\nThe state or province associated with the placemark.\nvar subAdministrativeArea: String?\nAdditional administrative area information for the placemark."
  },
  {
    "title": "subAdministrativeArea | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark/1423776-subadministrativearea",
    "html": "Discussion\n\nSubadministrative areas typically correspond to counties or other regions that are then organized into a larger administrative area or state. For example, if the placemark location is Apple’s headquarters, the value for this property would be the string “Santa Clara”, which is the county in California that contains the city of Cupertino.\n\nSee Also\nGetting the placemark details\nvar thoroughfare: String?\nThe street address associated with the placemark.\nvar subThoroughfare: String?\nAdditional street-level information for the placemark.\nvar locality: String?\nThe city associated with the placemark.\nvar subLocality: String?\nAdditional city-level information for the placemark.\nvar administrativeArea: String?\nThe state or province associated with the placemark.\nvar postalCode: String?\nThe postal code associated with the placemark."
  },
  {
    "title": "CLGeocoder | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clgeocoder",
    "html": "Overview\n\nThe CLGeocoder class provides services for converting between a coordinate (specified as a latitude and longitude) and the user-friendly representation of that coordinate. A user-friendly representation of the coordinate typically consists of the street, city, state, and country or region information corresponding to the given location, but it may also contain a relevant point of interest, landmarks, or other identifying information. A geocoder object is a single-shot object that works with a network-based service to look up placemark information for its specified coordinate value.\n\nTo use a geocoder object, you create it and call one of its forward- or reverse-geocoding methods to begin the request. Reverse-geocoding requests take a latitude and longitude value and find a user-readable address. Forward-geocoding requests take a user-readable address and find the corresponding latitude and longitude value. Forward-geocoding requests may also return additional information about the specified location, such as a point of interest or building at that location. For both types of request, the results are returned using a CLPlacemark object. In the case of forward-geocoding requests, multiple placemark objects may be returned if the provided information yielded multiple possible locations.\n\nTo make smart decisions about what types of information to return, the geocoder server uses all the information provided to it when processing the request. For example, if the user is moving quickly along a highway, it might return the name of the overall region, and not the name of a small park that the user is passing through.\n\nTips for Using a Geocoder Object\n\nApps must be conscious of how they use geocoding. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. (When the maximum rate is exceeded, the geocoder returns an error object with the CLError.Code.network error to the associated completion handler.) Here are some rules of thumb for using this class effectively:\n\nSend at most one geocoding request for any one user action.\n\nIf the user performs multiple actions that involve geocoding the same location, reuse the results from the initial geocoding request instead of starting individual requests for each action.\n\nWhen you want to update the user’s current location automatically (such as when the user is moving), issue new geocoding requests only when the user has moved a significant distance and after a reasonable amount of time has passed. For example, in a typical situation, you should not send more than one geocoding request per minute.\n\nDo not start a geocoding request at a time when the user will not see the results immediately. For example, do not start a request if your application is inactive or in the background.\n\nThe computer or device must have access to the network in order for the geocoder object to return detailed placemark information. Although, the geocoder stores enough information locally to report the localized country or region name and ISO country code for many locations. If this information isn’t available for a specific location, the geocoder may still report an error to your completion block.\n\nYou can use geocoder objects either in conjunction with, or independent of, the classes of the MapKit framework.\n\nTopics\nReverse geocoding a location\nfunc reverseGeocodeLocation(CLLocation, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a reverse-geocoding request for the specified location and locale.\nfunc reverseGeocodeLocation(CLLocation, completionHandler: CLGeocodeCompletionHandler)\nSubmits a reverse-geocoding request for the specified location.\ntypealias CLGeocodeCompletionHandler\nA block to be called when a geocoding request is complete.\nGeocoding an address\nfunc geocodeAddressString(String, in: CLRegion?, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified address string and locale information.\nfunc geocodeAddressString(String, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string.\nfunc geocodeAddressString(String, in: CLRegion?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified string and region information.\nfunc geocodePostalAddress(CNPostalAddress, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified Contacts framework information.\nfunc geocodePostalAddress(CNPostalAddress, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding requesting using the specified locale and Contacts framework information.\nfunc geocodeAddressDictionary([AnyHashable : Any], completionHandler: CLGeocodeCompletionHandler)\nSubmits a forward-geocoding request using the specified address dictionary.\nDeprecated\nManaging geocoding requests\nfunc cancelGeocode()\nCancels a pending geocoding request.\nvar isGeocoding: Bool\nA Boolean value indicating whether the receiver is in the middle of geocoding its value.\nInstance Methods\nfunc geocodeAddressString(String, inRegionCenteredAt: CLLocationCoordinate2D, inRegionRadius: CLLocationDistance, preferredLocale: Locale?, completionHandler: CLGeocodeCompletionHandler)\nBeta\nRelationships\nInherits From\nNSObject\nSee Also\nGeocoding\nConverting between coordinates and user-friendly place names\nConvert between a latitude/longitude pair and a more user-friendly description of that location.\nConverting a user's location to a descriptive placemark\nTransform the user’s location that displays on a map into an informative textual description by reverse geocoding.\nclass CLPlacemark\nA user-friendly description of a geographic coordinate, often containing the name of the place, its address, and other relevant information."
  },
  {
    "title": "Getting heading and course information | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/getting_heading_and_course_information",
    "html": "Overview\n\nHeading and course information are commonly used by navigation apps to help guide the user to a destination. The heading of a user’s device is its current orientation relative to magnetic or true north. Devices with GPS can report course information, which represents the direction in which the device is moving. The Compass app in iOS uses heading information to implement a magnetic compass interface, as shown in Figure 1. Augmented reality apps might use this information to determine which direction the user is facing.\n\nFigure 1 Heading information in the Compass app\n\nGet the current heading\n\nYou use heading information to determine the current orientation of the user’s device. For example, an augmented reality app might use the current heading to help determine what information to show on the user’s screen. Headings are usually reported relative to the top of the device, but you can configure how values are reported using the headingOrientation property of your CLLocationManager object.\n\nAfter determining whether heading information is available, call the startUpdatingHeading() method of your CLLocationManager object to begin the delivery of heading updates. The location manager delivers updates to the locationManager(_:didUpdateHeading:) method of its delegate whenever the heading information changes.\n\nNote\n\nHeading information is available only on devices with a built-in magnetometer; it’s not available in iOS Simulator. The magnetometer determines a device’s orientation relative to magnetic north. When location data is available, Core Location also reports the device’s orientation relative to true north.\n\nGet course information\n\nCourse information reflects the speed and direction in which a device is moving and is available only on devices with GPS hardware. Don’t confuse course information with heading information. Course direction reflects the direction in which the device is moving and is independent of the device’s physical orientation. The most common use of course information is in navigation apps.\n\nCourse information is included automatically in CLLocation objects delivered to your app as part of its location updates. When enough location data has been gathered to compute a course, the location manager fills in the speed and course properties of the location object with the appropriate values.\n\nSee Also\nCompass headings\nclass CLHeading\nThe azimuth (orientation) of the user’s device, relative to true or magnetic north."
  },
  {
    "title": "Determining the proximity to an iBeacon device | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/determining_the_proximity_to_an_ibeacon_device",
    "html": "Overview\n\nAn iBeacon is a device that emits a Bluetooth signal that can be detected by your devices. Companies can deploy iBeacon devices in environments where proximity detection is a benefit to users, and apps can use the proximity of beacons to determine an appropriate course of action. You decide what actions to take based on the proximity of nearby beacons. For example, a department store might deploy beacons identifying each section of the store, and the corresponding app might point out sale items when the user is near each section.\n\nAdding iBeacon support to your app involves detecting beacons in two different stages:\n\nUse region monitoring to detect the presence of an iBeacon.\n\nUse beacon ranging to determine the proximity to a detected iBeacon.\n\nUsing a two-step process for detecting beacons significantly reduces power consumption. Ranging requires taking frequent measurements of the strength of Bluetooth signals and computing the distance to the associated beacons. By contrast, region monitoring involves only passive listening for nearby beacons, which consumes far less power.\n\nDeploy your iBeacon hardware\n\nWhen deploying your iBeacon hardware, you must program each iBeacon with an appropriate proximity UUID, major value, and minor value. These values identify each of your beacons uniquely and make it possible for your app to differentiate between those beacons later.\n\nThe uuid (universally unique identifier) is a 128-bit value that uniquely identifies your app’s beacons.\n\nThe major value is a 16-bit unsigned integer that you use to differentiate groups of beacons with the same UUID.\n\nThe minor value is a 16-bit unsigned integer that you use to differentiate groups of beacons with the same UUID and major value.\n\nOnly the UUID is required, but it is recommended that you program all three values into your iBeacon hardware. In your app, you can look for related groups of beacons by specifying only a subset of values.\n\nDetect the presence of beacons using region monitoring\n\nUse region monitoring to alert your app when an iBeacon is nearby. To monitor for beacons, create a CLBeaconRegion object and register it with the startMonitoring(for:) method of your CLLocationManager object. The beacon region contains the proximity UUID, major value, and minor value of the beacons that you want to detect. Only beacons with matching values trigger a call to your delegate object.\n\nListing 1 shows an example of how to set up region monitoring for a company's beacons. Because you typically define a UUID for your company once and do not change it later, the example includes a hard-coded version of that value. Prior to calling this method, you must have created a CLLocationManager object and assigned a delegate to it.\n\nListing 1 Setting up region monitoring for beacons\nfunc monitorBeacons() {\n    if CLLocationManager.isMonitoringAvailable(for: \n                  CLBeaconRegion.self) {\n        // Match all beacons with the specified UUID\n        let proximityUUID = UUID(uuidString: \n               \"39ED98FF-2900-441A-802F-9C398FC199D2\")\n        let beaconID = \"com.example.myBeaconRegion\"\n            \n        // Create the region and begin monitoring it.\n        let region = CLBeaconRegion(proximityUUID: proximityUUID!,\n               identifier: beaconID)\n        self.locationManager.startMonitoring(for: region)\n    }\n}\n\n\nWhen a matching iBeacon is detected, the CLLocationManager object notifies its delegate by calling the locationManager(_:didEnterRegion:) method. Similarly, when a detected beacon moves out of range, the location manager calls the locationManager(_:didExitRegion:) method. Use your delegate methods to start and stop beacon ranging.\n\nIf your app is not running when a beacon is detected, the system tries to launch your app.\n\nImportant\n\nApps must have authorization to use region monitoring, and they must be configured with the Location updates background mode to be launched. For more information, see Requesting authorization to use location services.\n\nDetermine the proximity to beacons using ranging\n\nAfter detecting an iBeacon, use ranging to determine the relative distance between the beacon and the user’s device. Ranging reports when the two devices are far apart, near to each other, or in the immediate vicinity of each other; it does not offer a precise distance, nor should you rely on the strength of a beacon's signal to compute that information yourself. Use the relative values to determine an appropriate course of action. For example, an app for an art museum might wait until the user is in the immediate vicinity of an iBeacon before offering information about the corresponding artwork.\n\nFigure 1 Determining the relative proximity to an iBeacon\n\nThe most logical place to start ranging is in your location manager delegate's locationManager(_:didEnterRegion:) method when a beacon is first detected. (The place to stop ranging is in your delegate's locationManager(_:didExitRegion:) method.) To begin ranging, pass the same CLBeaconRegion object you used for region monitoring to your location manager's startRangingBeacons(in:) method.\n\nListing 2 shows an implementation of this delegate method that turns on ranging for a detected beacon. The method also adds the beacon to an internal array so that the app can stop and restart ranging at any time. For example, you might stop ranging when your app is in the background to save power.\n\nListing 2 Ranging for beacons\nfunc locationManager(_ manager: CLLocationManager, \n            didEnterRegion region: CLRegion) {\n    if region is CLBeaconRegion {\n        // Start ranging only if the devices supports this service.\n        if CLLocationManager.isRangingAvailable() {\n            manager.startRangingBeacons(in: region as! CLBeaconRegion)\n\n\n            // Store the beacon so that ranging can be stopped on demand.\n            beaconsToRange.append(region as! CLBeaconRegion)        \n        }\n    }\n}\n\n\nWhen ranging is active, the location manager object calls the locationManager(_:didRangeBeacons:in:) method of its delegate whenever there is a change to report. Use this method to take action based on the proximity of nearby beacons. Listing 3 shows how a museum app might use the proximity value to display information about the closest exhibit. In this example, the museum uses the major and minor values to identify each exhibit.\n\nListing 3 Acting on the nearest beacon\nfunc locationManager(_ manager: CLLocationManager, \n            didRangeBeacons beacons: [CLBeacon], \n            in region: CLBeaconRegion) {\n    if beacons.count > 0 {\n        let nearestBeacon = beacons.first!\n        let major = CLBeaconMajorValue(nearestBeacon.major)\n        let minor = CLBeaconMinorValue(nearestBeacon.minor)\n            \n        switch nearestBeacon.proximity {\n        case .near, .immediate:\n            // Display information about the relevant exhibit.\n            displayInformationAboutExhibit(major: major, minor: minor)\n            break\n                \n        default:\n           // Dismiss exhibit information, if it is displayed.\n           dismissExhibit(major: major, minor: minor)\n           break\n           }\n        }\n    }\n\n\nTip\n\nWhen deploying beacons, consider giving each one a unique combination of UUID, major, and minor values so that you can distinguish among them. If multiple beacons use the same UUID, major, and minor values, the array of beacons delivered to the locationManager(_:didRangeBeacons:in:) method might be differentiated only by their proximity and accuracy values.\n\nSee Also\niBeacon\nRanging for Beacons\nConfigure a device to act as a beacon and to detect surrounding beacons.\nTurning an iOS device into an iBeacon device\nBroadcast iBeacon signals from an iOS device.\nclass CLBeacon\nInformation about an observed iBeacon device and its relative distance to the user’s device.\nprotocol CLCondition\nThe abstract base class for all other monitor conditions."
  },
  {
    "title": "CLCondition | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clcondition",
    "html": "Relationships\nInherits From\nDecodable\nEncodable\nSendable\nConforming Types\nCLMonitor.BeaconIdentityCondition\nCLMonitor.CircularGeographicCondition\nSee Also\niBeacon\nRanging for Beacons\nConfigure a device to act as a beacon and to detect surrounding beacons.\nDetermining the proximity to an iBeacon device\nDetect beacons and determine the relative distance to them.\nTurning an iOS device into an iBeacon device\nBroadcast iBeacon signals from an iOS device.\nclass CLBeacon\nInformation about an observed iBeacon device and its relative distance to the user’s device."
  },
  {
    "title": "CLBeacon | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbeacon",
    "html": "Overview\n\nThe CLBeacon class represents a beacon that was observed during beacon ranging. You do not create instances of this class directly. The location manager (CLLocationManager) object reports observed beacons to its associated delegate object.\n\nThe identity of a beacon is defined by its uuid, major, and minor properties. These values are coded into the beacon itself. For a more thorough description of the meaning of those values, see CLBeaconRegion.\n\nTopics\nGetting the beacon identity\nvar uuid: UUID\nThe UUID that the observed beacon transmitted.\nvar major: NSNumber\nThe major value that the observed beacon transmitted.\nvar minor: NSNumber\nThe minor value that the observed beacon transmitted.\nvar proximityUUID: UUID\nThe proximity ID of the beacon.\nDeprecated\nDetermining the distance to the beacon\nvar proximity: CLProximity\nThe relative distance to the beacon.\nenum CLProximity\nConstants that reflect the relative distance to a beacon.\nvar accuracy: CLLocationAccuracy\nThe accuracy of the proximity value, measured in meters from the beacon.\nvar rssi: Int\nThe received signal strength of the beacon, measured in decibels.\nGetting the observation timestamp\nvar timestamp: Date\nA timestamp representing when the beacon was observed.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\niBeacon\nRanging for Beacons\nConfigure a device to act as a beacon and to detect surrounding beacons.\nDetermining the proximity to an iBeacon device\nDetect beacons and determine the relative distance to them.\nTurning an iOS device into an iBeacon device\nBroadcast iBeacon signals from an iOS device.\nprotocol CLCondition\nThe abstract base class for all other monitor conditions."
  },
  {
    "title": "locationManager(_:didExitRegion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423630-locationmanager",
    "html": "Parameters\nmanager\n\nThe location manager object reporting the event.\n\nregion\n\nAn object containing information about the region that was exited.\n\nDiscussion\n\nBecause regions are a shared application resource, every active location manager object delivers this message to its associated delegate. It doesn't matter which location manager actually registered the specified region. If multiple location managers share a delegate object, that delegate receives the message multiple times.\n\nThe region object provided may not be the same one that was registered. As a result, you should never perform pointer-level comparisons to determine equality. Instead, use the region’s identifier string to determine if your delegate should respond.\n\nSee Also\nReceiving region-related updates\nfunc locationManager(CLLocationManager, didEnterRegion: CLRegion)\nTells the delegate that the user entered the specified region.\nfunc locationManager(CLLocationManager, didDetermineState: CLRegionState, for: CLRegion)\nTells the delegate about the state of the specified region.\nfunc locationManager(CLLocationManager, monitoringDidFailFor: CLRegion?, withError: Error)\nTells the delegate that a region monitoring error occurred.\nfunc locationManager(CLLocationManager, didStartMonitoringFor: CLRegion)\nTells the delegate that a new region is being monitored.\nenum CLRegionState\nConstants that reflect the relationship of the current location to the region boundaries."
  },
  {
    "title": "locationManager(_:didEnterRegion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanagerdelegate/1423560-locationmanager",
    "html": "Parameters\nmanager\n\nThe location manager object reporting the event.\n\nregion\n\nAn object containing information about the region that was entered.\n\nDiscussion\n\nBecause regions are a shared application resource, every active location manager object delivers this message to its associated delegate. It doesn’t matter which location manager actually registered the specified region. If multiple location managers share a delegate object, that delegate receives the message multiple times.\n\nThe region object provided may not be the same one that was registered. As a result, you should never perform pointer-level comparisons to determine equality. Instead, use the region’s identifier string to determine if your delegate should respond.\n\nSee Also\nReceiving region-related updates\nfunc locationManager(CLLocationManager, didExitRegion: CLRegion)\nTells the delegate that the user left the specified region.\nfunc locationManager(CLLocationManager, didDetermineState: CLRegionState, for: CLRegion)\nTells the delegate about the state of the specified region.\nfunc locationManager(CLLocationManager, monitoringDidFailFor: CLRegion?, withError: Error)\nTells the delegate that a region monitoring error occurred.\nfunc locationManager(CLLocationManager, didStartMonitoringFor: CLRegion)\nTells the delegate that a new region is being monitored.\nenum CLRegionState\nConstants that reflect the relationship of the current location to the region boundaries."
  },
  {
    "title": "animatableData | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationcoordinate2d/4231047-animatabledata",
    "html": "Relationships\nFrom Protocol\nAnimatable\nSee Also\nGetting the geographic coordinates\nvar latitude: CLLocationDegrees\nThe latitude in degrees.\nvar longitude: CLLocationDegrees\nThe longitude in degrees."
  },
  {
    "title": "CLLocationCoordinate2DIsValid(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/1423806-cllocationcoordinate2disvalid",
    "html": "Parameters\ncoord\n\nA coordinate containing latitude and longitude values.\n\nReturn Value\n\ntrue if the coordinate is valid or false if it is not.\n\nDiscussion\n\nA coordinate is considered invalid if it meets at least one of the following criteria:\n\nIts latitude is greater than 90 degrees or less than -90 degrees.\n\nIts longitude is greater than 180 degrees or less than -180 degrees.\n\nSee Also\nValidating a coordinate\nlet kCLLocationCoordinate2DInvalid: CLLocationCoordinate2D\nAn invalid coordinate value."
  },
  {
    "title": "kCLLocationCoordinate2DInvalid | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kcllocationcoordinate2dinvalid",
    "html": "Discussion\n\nUse this constant when you want to indicate that a coordinate is invalid.\n\nSee Also\nValidating a coordinate\nfunc CLLocationCoordinate2DIsValid(CLLocationCoordinate2D) -> Bool\nReturns a Boolean value indicating whether the specified coordinate is valid."
  },
  {
    "title": "longitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationcoordinate2d/1423552-longitude",
    "html": "Discussion\n\nMeasurements are relative to the zero meridian, with positive values extending east of the meridian and negative values extending west of the meridian.\n\nSee Also\nGetting the geographic coordinates\nvar latitude: CLLocationDegrees\nThe latitude in degrees.\nvar animatableData: AnimatablePair<CLLocationDegrees, CLLocationDegrees>\nA pair of locations you can use to configure an animation."
  },
  {
    "title": "CLLocation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocation",
    "html": "Overview\n\nA CLLocation object contains the geographical location and altitude of a device, along with values indicating the accuracy of those measurements and when they were collected. In iOS, a location object also contains course information — that is, the speed and heading in which the device was moving.\n\nTypically, you don’t create location objects yourself. After you request location updates from your CLLocationManager object, the system uses onboard sensors to gather location data and report that data to your app. Some services also return previously collected location data, which you can use as context to improve your services. You can always retrieve the most recently collected location from the location property of your CLLocationManager object. You may create location objects yourself when you want to cache custom location data or calculate the distance between two geographical coordinates.\n\nUse CLLocation objects as-is, and don’t subclass them.\n\nTopics\nCreating a location object\ninit(latitude: CLLocationDegrees, longitude: CLLocationDegrees)\nCreates a location object with the specified latitude and longitude.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, timestamp: Date)\nCreates a location object with the specified coordinate and altitude information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, speed: CLLocationSpeed, timestamp: Date)\nCreates a location object with the specified coordinate, altitude, and course information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, courseAccuracy: CLLocationDirectionAccuracy, speed: CLLocationSpeed, speedAccuracy: CLLocationSpeedAccuracy, timestamp: Date)\nCreates a location object with the specified coordinate, altitude, course, and accuracy information.\ninit(coordinate: CLLocationCoordinate2D, altitude: CLLocationDistance, horizontalAccuracy: CLLocationAccuracy, verticalAccuracy: CLLocationAccuracy, course: CLLocationDirection, courseAccuracy: CLLocationDirectionAccuracy, speed: CLLocationSpeed, speedAccuracy: CLLocationSpeedAccuracy, timestamp: Date, sourceInfo: CLLocationSourceInformation)\nGetting the location attributes\nvar coordinate: CLLocationCoordinate2D\nThe geographical coordinate information.\nvar altitude: CLLocationDistance\nThe altitude above mean sea level associated with a location, measured in meters.\nvar ellipsoidalAltitude: CLLocationDistance\nThe altitude as a height above the World Geodetic System 1984 (WGS84) ellipsoid, measured in meters.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar floor: CLFloor?\nThe logical floor of the building in which the user is located.\nvar timestamp: Date\nThe time at which this location was determined.\nvar sourceInformation: CLLocationSourceInformation?\nInformation about the source that provides the location.\nGetting the location accuracy\nvar horizontalAccuracy: CLLocationAccuracy\nThe radius of uncertainty for the location, measured in meters.\nvar verticalAccuracy: CLLocationAccuracy\nThe validity of the altitude values, and their estimated uncertainty, measured in meters.\ntypealias CLLocationAccuracy\nThe accuracy of a geographical coordinate.\nMeasuring the distance between coordinates\nfunc distance(from: CLLocation) -> CLLocationDistance\nReturns the distance (measured in meters) from the current object’s location to the specified location.\nfunc getDistanceFrom(CLLocation) -> CLLocationDistance\nReturns the distance (measured in meters) from the current object’s location to the specified location.\nDeprecated\nGetting speed and course information\nvar speed: CLLocationSpeed\nThe instantaneous speed of the device, measured in meters per second.\nvar speedAccuracy: CLLocationSpeedAccuracy\nThe accuracy of the speed value, measured in meters per second.\nvar course: CLLocationDirection\nThe direction in which the device is traveling, measured in degrees and relative to due north.\nvar courseAccuracy: CLLocationDirectionAccuracy\nThe accuracy of the course value, measured in degrees.\ntypealias CLLocationSpeed\nThe velocity (measured in meters per second) at which the device is moving.\ntypealias CLLocationDirection\nAn azimuth that is measured in degrees relative to true north.\ntypealias CLLocationSpeedAccuracy\nThe accuracy of a speed.\ntypealias CLLocationDirectionAccuracy\nThe accuracy of a compass heading.\nRelationships\nInherits From\nNSObject\nConforms To\nCKRecordValueProtocol\nNSCopying\nNSSecureCoding\nSendable\nSee Also\nLocation updates\nGetting the current location of a device\nStart location services and provide information the system needs to optimize power usage for those services.\nHandling location updates in the background\nConfigure your app to receive location updates when it isn’t running in the foreground.\nCreating a location push service extension\nAdd and configure an extension to enable your location sharing app to access a user’s location in response to a request from another user.\nstruct CLLocationCoordinate2D\nThe latitude and longitude associated with a location, specified using the WGS 84 reference frame.\nclass CLFloor\nThe floor of a building on which the user's device is located.\nclass CLVisit\nInformation about the user's location during a specific period of time.\nclass CLLocationSourceInformation\nInformation about the source that provides a location."
  },
  {
    "title": "CLFloor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clfloor",
    "html": "Overview\n\nA CLFloor object specifies the floor of the building on which the device is located. In places where floor information can be determined, a CLLocation object may include a floor object along with the regular location data.\n\nYou do not create instances of this class directly, nor should you subclass it.\n\nTopics\nGetting the floor level\nvar level: Int\nThe logical floor of the building.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nLocation updates\nGetting the current location of a device\nStart location services and provide information the system needs to optimize power usage for those services.\nHandling location updates in the background\nConfigure your app to receive location updates when it isn’t running in the foreground.\nCreating a location push service extension\nAdd and configure an extension to enable your location sharing app to access a user’s location in response to a request from another user.\nclass CLLocation\nThe latitude, longitude, and course information reported by the system.\nstruct CLLocationCoordinate2D\nThe latitude and longitude associated with a location, specified using the WGS 84 reference frame.\nclass CLVisit\nInformation about the user's location during a specific period of time.\nclass CLLocationSourceInformation\nInformation about the source that provides a location."
  },
  {
    "title": "CLMonitor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clmonitor",
    "html": "Overview\n\nUse CLMonitor to monitor for and observe events such as the entry to a specific geographic area or proximity to a beacon with characteristics that you specify.\n\nThis service is unavailable in a compatible iPad or iPhone app running in visionOS.\n\nTopics\nCreating a monitor\ninit(String)\nCreates a location monitor with the name you specify.\nAdding and removing conditions\nfunc add(CLCondition, identifier: String)\nAdds the given condition for monitoring.\nfunc add(CLCondition, identifier: String, assuming: CLMonitor.Event.State)\nAdds the monitoring condition with the identifier and initial state you specify.\nfunc preconditionIsolated(() -> String, file: StaticString, line: UInt)\nUnconditionally if the current task is executing on the serial executor of the passed in actor, and if not crash the program offering information about the executor mismatch.\nfunc record(for: String) -> CLMonitor.Record?\nA record that contains a condition and the most recent event your app receives.\nfunc remove(String)\nRemoves the condition and its enclosed record associated with the identifier you provide.\nAccessing the location monitor’s identifiers\nvar identifiers: [String]\nAn array that contains the identifiers of the conditions the framework is monitoring.\nAccessing the monitor’s events\nlet events: CLMonitor.Events\nAn asynchronous sequence of events that represent the conditions the monitor object observes.\nMonitor conditions\nstruct CLMonitor.BeaconIdentityCondition\nA condition that describes the characteristics of a beacon.\nstruct CLMonitor.CircularGeographicCondition\nA condition that describes a circular geographic area that a center point and radius define.\nMonitor events\nstruct CLMonitor.Event\nAn event object that the framework passes to the events sequence in the monitor.\nstruct CLMonitor.Record\nA structure that represents a condition and its associated event information that the framework is monitoring.\nstruct CLMonitor.Events\nA type that represents an asynchronous sequence of events.\nThe monitor’s context\nvar unownedExecutor: UnownedSerialExecutor\nThe executor for this actor as an optimized, unowned reference.\nfunc assertIsolated(() -> String, file: StaticString, line: UInt)\nPerforms an executor check in debug builds.\nfunc assumeIsolated<T>((CLMonitor) -> T, file: StaticString, line: UInt) -> T\nA safe way to synchronously assume that the current execution context belongs to the passed in actor."
  },
  {
    "title": "CLAuthorizationStatus | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clauthorizationstatus",
    "html": "Overview\n\nHandle changes to authorization status in your location manager's delegate method, locationManager(_:didChangeAuthorization:).\n\nTopics\nGetting the authorization status\ncase notDetermined\nThe user has not chosen whether the app can use location services.\ncase restricted\nThe app is not authorized to use location services.\ncase denied\nThe user denied the use of location services for the app or they are disabled globally in Settings.\nstatic var authorized: CLAuthorizationStatus\nThe user authorized the app to use location services.\ncase authorizedAlways\nThe user authorized the app to start location services at any time.\ncase authorizedWhenInUse\nThe user authorized the app to start location services while it is in use.\nRelationships\nConforms To\nSendable\nSee Also\nAuthorization\nRequesting authorization to use location services\nObtain authorization to use location services and manage changes to your app’s authorization status.\nenum CLAccuracyAuthorization\nConstants indicating the level of location accuracy the app has authorization to use.\nproperty list key NSLocationAlwaysAndWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information at all times.\nName: Privacy - Location Always and When In Use Usage Description\nproperty list key NSLocationWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information while the app is running in the foreground.\nName: Privacy - Location When In Use Usage Description\nproperty list key NSLocationUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information.\nName: Privacy - Location Usage Description\nproperty list key NSLocationDefaultAccuracyReduced\nA Boolean value that indicates whether the app requests reduced location accuracy by default.\nName: Privacy - Location Default Accuracy Reduced\nproperty list key NSLocationAlwaysUsageDescription\nA message that tells the user why the app is requesting access to the user's location at all times.\nName: Privacy - Location Always Usage Description\nDeprecated"
  },
  {
    "title": "startUpdatingLocation() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423750-startupdatinglocation",
    "html": "Discussion\n\nThis method returns immediately. Calling this method causes the location manager to obtain an initial location fix (which may take several seconds) and notify your delegate by calling its locationManager(_:didUpdateLocations:) method. After that, the receiver generates update events primarily when the value in the distanceFilter property is exceeded. Updates may be delivered in other situations though. For example, the receiver may send another notification if the hardware gathers a more accurate location reading.\n\nCalling this method several times in succession does not automatically result in new events being generated. Calling stopUpdatingLocation() in between, however, does cause a new initial event to be sent the next time you call this method.\n\nIf you start this service and your app is suspended, the system stops the delivery of events until your app starts running again (either in the foreground or background). If your app is terminated, the delivery of new location events stops altogether. Therefore, if your app needs to receive location events while in the background, it must include the UIBackgroundModes key (with the location value) in its Info.plist file.\n\nIn addition to your delegate object implementing the locationManager(_:didUpdateLocations:) method, it should also implement the locationManager(_:didFailWithError:) method to respond to potential errors.\n\nSee Also\nRunning the standard location service\nfunc stopUpdatingLocation()\nStops the generation of location updates.\nfunc requestLocation()\nRequests the one-time delivery of the user’s current location.\nvar pausesLocationUpdatesAutomatically: Bool\nA Boolean value that indicates whether the location-manager object may pause location updates.\nvar allowsBackgroundLocationUpdates: Bool\nA Boolean value that indicates whether the app receives location updates when running in the background.\nvar showsBackgroundLocationIndicator: Bool\nA Boolean value that indicates whether the status bar changes its appearance when an app uses location services in the background.\nvar activityType: CLActivityType\nThe type of activity the app expects the user to typically perform while in the app’s location session.\nenum CLActivityType\nConstants that indicate the type of activity associated with location updates."
  },
  {
    "title": "distanceFilter | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager/1423500-distancefilter",
    "html": "Discussion\n\nThis location manager measures this relative to the previously delivered location. Specify the value kCLDistanceFilterNone to receive notifications for all movements. The default value of this property is kCLDistanceFilterNone.\n\nUse this property only in conjunction with the Standard location services and not with the Significant-change or Visits services.\n\nSpecial Considerations\n\nIn iOS, this property is declared as nonatomic. In macOS, it is declared as atomic.\n\nSee Also\nSpecifying distance and accuracy\nlet CLLocationDistanceMax: CLLocationDistance\nA constant indicating the maximum distance.\nlet kCLDistanceFilterNone: CLLocationDistance\nA constant indicating that all movement should be reported.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar desiredAccuracy: CLLocationAccuracy\nThe accuracy of the location data that your app wants to receive.\ntypealias CLLocationAccuracy\nThe accuracy of a geographical coordinate."
  },
  {
    "title": "CLLocationManager | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationmanager",
    "html": "Overview\n\nA CLLocationManager object is the central place to manage your app’s location-related behaviors. Use a location-manager object to configure, start, and stop location services. You might use these services to:\n\nTrack large or small changes in the user’s current location with a configurable degree of accuracy.\n\nReport heading changes from the onboard compass.\n\nMonitor geographical regions of interest and generate events when someone enters or leaves those regions.\n\nReport the range to nearby Bluetooth beacons.\n\nCreate one or more location-manager objects in your app and use them where you need location data. After you create a location-manager object, configure it so that Core Location knows how often to report location changes. In particular, configure the distanceFilter and desiredAccuracy properties with values that reflect your app’s needs.\n\nA CLLocationManager object reports all location-related updates to its delegate object, which is an object that conforms to the CLLocationManagerDelegate protocol. Assign the delegate immediately when you configure your location manager, because the system reports the app’s authorization status to the delegate’s locationManagerDidChangeAuthorization(_:) method after the location manager finishes initializing itself. Core Location calls the methods of your delegate object using the RunLoop of the thread on which you initialized the CLLocationManager object. That thread must itself have an active RunLoop, like the one found in your app’s main thread.\n\nFor more information, see Configuring your app to use location services.\n\nTopics\nDetermining the availability of services\nclass func significantLocationChangeMonitoringAvailable() -> Bool\nReturns a Boolean value indicating whether the significant-change location service is available on the device.\nclass func headingAvailable() -> Bool\nReturns a Boolean value indicating whether the location manager is able to generate heading-related events.\nvar isAuthorizedForWidgetUpdates: Bool\nA Boolean value that indicates whether a widget is eligible to receive location updates.\nvar accuracyAuthorization: CLAccuracyAuthorization\nA value that indicates the level of location accuracy the app has permission to use.\nclass func isMonitoringAvailable(for: AnyClass) -> Bool\nReturns a Boolean value indicating whether the device supports region monitoring using the specified class.\nclass func isRangingAvailable() -> Bool\nReturns a Boolean value indicating whether the device supports ranging of beacons that use the iBeacon protocol.\nclass func locationServicesEnabled() -> Bool\nReturns a Boolean value indicating whether location services are enabled on the device.\nReceiving data from location services\nvar delegate: CLLocationManagerDelegate?\nThe delegate object to receive update events.\nprotocol CLLocationManagerDelegate\nThe methods that you use to receive events from an associated location-manager object.\nRequesting authorization for location services\nfunc requestWhenInUseAuthorization()\nRequests the user’s permission to use location services while the app is in use.\nfunc requestAlwaysAuthorization()\nRequests the user’s permission to use location services regardless of whether the app is in use.\nfunc requestTemporaryFullAccuracyAuthorization(withPurposeKey: String, completion: ((Error?) -> Void)?)\nRequests permission to temporarily use location services with full accuracy and reports the results to the provided completion handler.\nfunc requestTemporaryFullAccuracyAuthorization(withPurposeKey: String)\nRequests permission to temporarily use location services with full accuracy.\nvar authorizationStatus: CLAuthorizationStatus\nThe current authorization status for the app.\nenum CLAuthorizationStatus\nConstants indicating the app's authorization to use location services.\nproperty list key NSLocationDefaultAccuracyReduced\nA Boolean value that indicates whether the app requests reduced location accuracy by default.\nName: Privacy - Location Default Accuracy Reduced\nproperty list key NSLocationAlwaysAndWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information at all times.\nName: Privacy - Location Always and When In Use Usage Description\nSpecifying distance and accuracy\nvar distanceFilter: CLLocationDistance\nThe minimum distance in meters the device must move horizontally before an update event is generated.\nlet CLLocationDistanceMax: CLLocationDistance\nA constant indicating the maximum distance.\nlet kCLDistanceFilterNone: CLLocationDistance\nA constant indicating that all movement should be reported.\ntypealias CLLocationDistance\nA distance in meters from an existing location.\nvar desiredAccuracy: CLLocationAccuracy\nThe accuracy of the location data that your app wants to receive.\ntypealias CLLocationAccuracy\nThe accuracy of a geographical coordinate.\nRunning the standard location service\nfunc startUpdatingLocation()\nStarts the generation of updates that report the user’s current location.\nfunc stopUpdatingLocation()\nStops the generation of location updates.\nfunc requestLocation()\nRequests the one-time delivery of the user’s current location.\nvar pausesLocationUpdatesAutomatically: Bool\nA Boolean value that indicates whether the location-manager object may pause location updates.\nvar allowsBackgroundLocationUpdates: Bool\nA Boolean value that indicates whether the app receives location updates when running in the background.\nvar showsBackgroundLocationIndicator: Bool\nA Boolean value that indicates whether the status bar changes its appearance when an app uses location services in the background.\nvar activityType: CLActivityType\nThe type of activity the app expects the user to typically perform while in the app’s location session.\nenum CLActivityType\nConstants that indicate the type of activity associated with location updates.\nRunning the significant change location service\nfunc startMonitoringSignificantLocationChanges()\nStarts the generation of updates based on significant location changes.\nfunc stopMonitoringSignificantLocationChanges()\nStops the delivery of location events based on significant location changes.\nRunning the visits location service\nfunc startMonitoringVisits()\nStarts the delivery of visit-related events.\nfunc stopMonitoringVisits()\nStops the delivery of visit-related events.\nRunning the heading service\nfunc startUpdatingHeading()\nStarts the generation of updates that report the user’s current heading.\nfunc stopUpdatingHeading()\nStops the generation of heading updates.\nfunc dismissHeadingCalibrationDisplay()\nDismisses the heading calibration view from the screen immediately.\nvar headingFilter: CLLocationDegrees\nThe minimum angular change in degrees required to generate new heading events.\nlet kCLHeadingFilterNone: CLLocationDegrees\nA constant indicating that all header values should be reported.\ntypealias CLLocationDegrees\nA latitude or longitude value specified in degrees.\nvar headingOrientation: CLDeviceOrientation\nThe device orientation to use when computing heading values.\nenum CLDeviceOrientation\nConstants indicating the physical orientation of the device.\nRunning the region-monitoring service\nvar monitoredRegions: Set<CLRegion>\nThe set of shared regions monitored by all location-manager objects.\nvar maximumRegionMonitoringDistance: CLLocationDistance\nThe largest boundary distance that can be assigned to a region.\nPerforming beacon ranging\nfunc startRangingBeacons(satisfying: CLBeaconIdentityConstraint)\nStarts the delivery of notifications for the specified beacon constraints.\nfunc stopRangingBeacons(satisfying: CLBeaconIdentityConstraint)\nStops the delivery of notifications for the specified beacon constraints.\nvar rangedBeaconConstraints: Set<CLBeaconIdentityConstraint>\nThe set of beacon constraints currently being tracked using ranging.\nMonitoring location push notifications\nfunc startMonitoringLocationPushes(completion: ((Data?, Error?) -> Void)?)\nStarts monitoring for the delivery of Apple Push Notification service (APNs) location pushes, and provides a device-specific token for sending pushes.\nfunc stopMonitoringLocationPushes()\nStops monitoring for Apple Push Notification service (APNs) location pushes.\nGetting recent location and heading data\nvar location: CLLocation?\nThe most recently retrieved user location.\nvar heading: CLHeading?\nThe most recently reported heading.\nDeferring location updates\nlet CLTimeIntervalMax: TimeInterval\nA value representing an unlimited amount of time.\nDeprecated\nDeprecated symbols\nReview unsupported symbols and their replacements.\nInstance Methods\nfunc requestHistoricalLocations(purposeKey: String, sampleCount: Int, completionHandler: ([CLLocation], Error?) -> Void)\nRelationships\nInherits From\nNSObject\nSee Also\nEssentials\nConfiguring your app to use location services\nVerify that location services are available and configure your app before you start collecting location data.\nSupporting live updates in SwiftUI and Mac Catalyst apps\nEnable background events by adding lifecycle event support.\nclass CLBackgroundActivitySession\nAn object that manages a visual indicator that keeps your app in use in the background, allowing it to receive updates or events.\nstruct CLLocationUpdate\nA structure that contains the location information the framework delivers with each update.\nprotocol CLLocationManagerDelegate\nThe methods that you use to receive events from an associated location-manager object.\nAdopting live updates in Core Location\nSimplify location delivery using asynchronous events in Swift.\nMonitoring location changes with Core Location\nDefine boundaries and act on user location updates."
  },
  {
    "title": "Core Location Functions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/core_location_functions",
    "html": "Overview\n\nThe Core Location framework provides functions to help you work with coordinate values.\n\nTopics\nFunctions\nfunc CLLocationCoordinate2DMake(CLLocationDegrees, CLLocationDegrees) -> CLLocationCoordinate2D\nFormats a latitude and longitude value into a coordinate data structure format.\nSee Also\nRelated Documentation\nLocation and Maps Programming Guide"
  },
  {
    "title": "Deprecated | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/deprecated",
    "html": "Topics\nClasses\nclass CLBeaconRegion\nA region for detecting the presence of iBeacon devices.\nDeprecated\nclass CLBeaconIdentityConstraint\nIdentity characteristics that can match one or more beacons.\nDeprecated\nclass CLCircularRegion\nA circular geographic region that a center point and radius deine.\nDeprecated"
  },
  {
    "title": "Core Location Constants | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/core_location_constants",
    "html": "Overview\n\nThis document describes the constants found in the Core Location framework.\n\nTopics\nConstants\nvar CL_TARGET_SUPPORTS_CONDITIONS: Int32"
  },
  {
    "title": "kCLErrorUserInfoAlternateRegionKey | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kclerroruserinfoalternateregionkey",
    "html": "Discussion\n\nThis key is included in an error of type regionMonitoringResponseDelayed. The value is a CLRegion object containing the region that location services can monitor more effectively.\n\nSee Also\nErrors\nstruct CLError\nA Core Location error.\nlet kCLErrorDomain: String\nThe domain for Core Location errors."
  },
  {
    "title": "CLLocationPushServiceError.Code | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror/code",
    "html": "Overview\n\nThese error codes are returned from startMonitoringLocationPushes(completion:).\n\nTopics\nGetting the error code\ncase unknown\nAn error code that indicates the app was unable to start the location push service for an unknown reason.\ncase missingPushExtension\nAn error code that indicates the app is missing a Location Push Service Extension.\ncase missingPushServerEnvironment\nAn error code that indicates the app is missing an Apple Push Notification service (APNs) environment entitlement.\ncase missingEntitlement\nAn error code that indicates the app is missing the entitlement it needs to use the location push service.\ncase unsupportedPlatform\nAn error code that indicates the location push service isn’t available on this platform.\nRelationships\nConforms To\nSendable\nSee Also\nGetting the error code\nstatic var unknown: CLLocationPushServiceError.Code\nAn error code that indicates the app was unable to start the location push service for an unknown reason.\nstatic var missingPushServerEnvironment: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing an Apple Push Notification service (APNs) environment entitlement.\nstatic var missingPushExtension: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing a Location Push Service Extension.\nstatic var missingEntitlement: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing the entitlement it needs to use the location push service.\nstatic var unsupportedPlatform: CLLocationPushServiceError.Code\nAn error code that indicates the location push service isn’t available on this platform."
  },
  {
    "title": "kCLErrorDomain | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/kclerrordomain",
    "html": "Discussion\n\nThis value is used in the NSError class.\n\nSee Also\nErrors\nstruct CLError\nA Core Location error.\nlet kCLErrorUserInfoAlternateRegionKey: String\nA key in the user information dictionary of an error relating to a delayed region monitoring response."
  },
  {
    "title": "CLLocationPushServiceErrorDomain | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerrordomain",
    "html": "See Also\nLocation push service extension\ncom.apple.developer.location.push\nAn entitlement to enable a location sharing app to query someone’s location in response to a push notification.\nprotocol CLLocationPushServiceExtension\nThe interface you adopt in the type that acts as the main entry point for a Location Push Service Extension.\nstruct CLLocationPushServiceError\nError codes the location manager returns if starting to monitor for location push notifications fails.\nenum CLLocationPushServiceError.Code\nError codes the location manager returns if starting to monitor for location push notifications fails."
  },
  {
    "title": "CLLocationPushServiceError | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceerror",
    "html": "Topics\nGetting the error code\nstatic var unknown: CLLocationPushServiceError.Code\nAn error code that indicates the app was unable to start the location push service for an unknown reason.\nstatic var missingPushServerEnvironment: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing an Apple Push Notification service (APNs) environment entitlement.\nstatic var missingPushExtension: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing a Location Push Service Extension.\nstatic var missingEntitlement: CLLocationPushServiceError.Code\nAn error code that indicates the app is missing the entitlement it needs to use the location push service.\nstatic var unsupportedPlatform: CLLocationPushServiceError.Code\nAn error code that indicates the location push service isn’t available on this platform.\nenum CLLocationPushServiceError.Code\nError codes the location manager returns if starting to monitor for location push notifications fails.\nGetting the error details\nstatic var errorDomain: String\nThe error domain that the framework uses when issuing errors.\nvar errorCode: Int\nThe error code the framework returns when location push service fails.\nvar code: Code\nThe error code the framework returns when location push service fails.\nvar errorUserInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar userInfo: [String : Any]\nA dictionary the framework uses to provide information about an error.\nvar localizedDescription: String\nA human readable, localized description of the error.\nComparing errors\nstatic func != (CLLocationPushServiceError, CLLocationPushServiceError) -> Bool\nIndicates whether two errors aren't equal.\nstatic func == (CLLocationPushServiceError, CLLocationPushServiceError) -> Bool\nIndicates whether two errors are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the error by feeding them into the given hash function.\nvar hashValue: Int\nThe hashed value of the error.\nCreating an error structure\ninit(Code, userInfo: [String : Any])\nCreates a Location Push Service error.\nSee Also\nLocation push service extension\ncom.apple.developer.location.push\nAn entitlement to enable a location sharing app to query someone’s location in response to a push notification.\nprotocol CLLocationPushServiceExtension\nThe interface you adopt in the type that acts as the main entry point for a Location Push Service Extension.\nlet CLLocationPushServiceErrorDomain: String\nThe domain for Location Push Service Extension errors.\nenum CLLocationPushServiceError.Code\nError codes the location manager returns if starting to monitor for location push notifications fails."
  },
  {
    "title": "CLPlacemark | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clplacemark",
    "html": "Overview\n\nA CLPlacemark object stores placemark data for a given latitude and longitude. Placemark data includes information such as the country or region, state, city, and street address associated with the specified coordinate. It can also include points of interest and geographically related data.\n\nWhen you reverse geocode a geographic coordinate using a CLGeocoder object, you receive a CLPlacemark object containing the descriptive information for that location. You can also create CLPlacemark object and fill it with address information yourself, which you might do when you want to determine the geographic coordinate associated with the location.\n\nTopics\nCreating a placemark object\ninit(placemark: CLPlacemark)\nInitializes and returns a placemark object from another placemark object.\ninit(location: CLLocation, name: String?, postalAddress: CNPostalAddress?)\nCreates and initializes a placemark object using the specified location and address information.\nGetting the placemark’s location\nvar location: CLLocation?\nThe location object containing latitude and longitude information.\nvar region: CLRegion?\nThe geographic region associated with the placemark.\nGetting the placemark name\nvar name: String?\nThe name of the placemark.\nGetting the placemark details\nvar thoroughfare: String?\nThe street address associated with the placemark.\nvar subThoroughfare: String?\nAdditional street-level information for the placemark.\nvar locality: String?\nThe city associated with the placemark.\nvar subLocality: String?\nAdditional city-level information for the placemark.\nvar administrativeArea: String?\nThe state or province associated with the placemark.\nvar subAdministrativeArea: String?\nAdditional administrative area information for the placemark.\nvar postalCode: String?\nThe postal code associated with the placemark.\nGetting the placemark’s country\nvar isoCountryCode: String?\nThe abbreviated country or region name.\nvar country: String?\nThe name of the country or region associated with the placemark.\nGetting the associated contact details\nvar postalAddress: CNPostalAddress?\nThe postal address associated with the location, formatted for use with the Contacts framework.\nvar addressDictionary: [AnyHashable : Any]?\nA dictionary containing the Address Book keys and values for the placemark.\nDeprecated\nGetting landscape information\nvar inlandWater: String?\nThe name of the inland water body associated with the placemark.\nvar ocean: String?\nThe name of the ocean associated with the placemark.\nGetting points of interest\nvar areasOfInterest: [String]?\nThe relevant areas of interest associated with the placemark.\nGetting the placemark’s time zone\nvar timeZone: TimeZone?\nThe time zone associated with the placemark.\nType Aliases\ntypealias CLPlacemark.Specification\ntypealias CLPlacemark.UnwrappedType\ntypealias CLPlacemark.ValueType\nInstance Properties\nvar displayRepresentation: DisplayRepresentation\nType Properties\nstatic var defaultResolverSpecification: EmptyResolverSpecification<CLPlacemark>\nstatic var typeDisplayRepresentation: TypeDisplayRepresentation\nRelationships\nInherits From\nNSObject\nConforms To\nDisplayRepresentable\nNSCopying\nNSSecureCoding\nSendable\nSee Also\nGeocoding\nConverting between coordinates and user-friendly place names\nConvert between a latitude/longitude pair and a more user-friendly description of that location.\nConverting a user's location to a descriptive placemark\nTransform the user’s location that displays on a map into an informative textual description by reverse geocoding.\nclass CLGeocoder\nAn interface for converting between geographic coordinates and place names."
  },
  {
    "title": "CLLocationPushServiceExtension | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationpushserviceextension",
    "html": "Overview\n\nA type that adopts the CLLocationPushServiceExtension protocol acts as the entry point to a Location Push Service Extension. You use this type to respond to incoming location push notifications and perform app-specific tasks. For example, you use it to get someone’s current location and send it to your server.\n\nDon’t adopt this protocol in your own custom types. Instead, add a Location Push Service Extension target to your project and modify the type that Xcode provides. To start the delivery of location push notifications, call the startMonitoringLocationPushes(completion:) method to request a unique token from the device. Send that token to your server and use it to generate HTTP requests for APNs to deliver to the device.\n\nWhen the device receives a location push notification that your server generated, the system loads your app extension and calls its didReceiveLocationPushPayload(_:completion:) method. Use that method to configure a CLLocationManager object and request the person’s current location. Collect the location, encrypt it, and send it back to your server using a custom connection.\n\nImportant\n\nIn order for your app extension to receive push notifications, the app that contains the app extension must have Always authorization for location services. For information about how to request this access, see Requesting authorization to use location services.\n\nLocation Push Service Extensions aren’t supported in visionOS. If a compatible iPad or iPhone app contains an app extension of this type, the system doesn’t load it.\n\nFor more information about adding the extension to your app, see Creating a location push service extension. For information about how to generate push notifications from your server, see Setting up a remote notification server.\n\nTopics\nGetting the push notification payload\nfunc didReceiveLocationPushPayload([String : Any], completion: () -> Void)\nDelivers a location push notification for your app extension to process.\n\nRequired\n\nHandling the extension termination\nfunc serviceExtensionWillTerminate()\nNotifies your app extension that the system is about to terminate the extension because it’s taking too long to complete its task.\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nLocation push service extension\ncom.apple.developer.location.push\nAn entitlement to enable a location sharing app to query someone’s location in response to a push notification.\nstruct CLLocationPushServiceError\nError codes the location manager returns if starting to monitor for location push notifications fails.\nlet CLLocationPushServiceErrorDomain: String\nThe domain for Location Push Service Extension errors.\nenum CLLocationPushServiceError.Code\nError codes the location manager returns if starting to monitor for location push notifications fails."
  },
  {
    "title": "CLHeading | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clheading",
    "html": "Overview\n\nA CLHeading object contains computed values for the device’s azimuth (orientation) relative to true or magnetic north. It also includes the raw data for the three-dimensional vector used to compute those values. A navigation app might use the information to rotate a map so that it reflects the direction that the user is facing.\n\nTypically, you don’t create instances of this class yourself, nor do you subclass it. Instead, you receive instances of this class through the delegate assigned to the CLLocationManager object whose startUpdatingHeading() method you called.\n\nNote\n\nIf you want heading objects to contain valid data for the trueHeading property, configure your location manager object to deliver location updates. You can start the delivery of these updates by calling the location manager object’s startUpdatingLocation() method.\n\nTopics\nGetting the heading values\nvar magneticHeading: CLLocationDirection\nThe heading (measured in degrees) relative to magnetic north.\nvar trueHeading: CLLocationDirection\nThe heading (measured in degrees) relative to true north.\nvar headingAccuracy: CLLocationDirection\nThe maximum deviation (measured in degrees) between the reported heading and the true geomagnetic heading.\nGetting the raw heading data\nvar x: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the x-axis.\nvar y: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the y-axis.\nvar z: CLHeadingComponentValue\nThe geomagnetic data (measured in microteslas) for the z-axis.\ntypealias CLHeadingComponentValue\nA type used to report magnetic differences reported by the onboard hardware.\nGetting the event timestamp\nvar timestamp: Date\nThe time at which this heading was determined.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nCompass headings\nGetting heading and course information\nUse a device’s orientation and course information for navigation."
  },
  {
    "title": "Converting a user's location to a descriptive placemark | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/converting_a_user_s_location_to_a_descriptive_placemark",
    "html": "Overview\n\nYou can show a user’s location on a map in order to orient them to elements of your app that use map content. For instance, a user’s current location can be a point of reference for retrieving search results or calculating directions. Additionally, you can display location information outside of the map, such as a search field pre-filled with the user’s current city or street address. To provide this information in your app, configure your map view to display the user’s location, and then translate the location to informative, user-friendly data.\n\nDisplay the user location annotation\n\nTo provide user-friendly place information, configure your map view to display the user’s current location by enabling showsUserLocation. After enabling this property, the map delegate begins receiving updates to the user’s location, represented with a MKUserLocation object, through mapView(_:didUpdate:).\n\nGeocode the user location annotation\n\nCLPlacemark objects represent user place names, and include properties for street name, city name, country or region name, and many other location identifiers. When mapView(_:didUpdate:) receives updates on the user’s location, convert the MKUserLocation object to a CLPlacemark by reverse geocoding the location property with a CLGeocoder. Readable descriptions of the user’s location are available as properties on the placemark, such as the city information stored in the locality property.\n\nImportant\n\nGeocoding requests are rate-limited for each app. Issue new geocoding requests only when the user has moved a significant distance and after a reasonable amount of time has passed.\n\nfunc mapView(_ mapView: MKMapView, didUpdate userLocation: MKUserLocation) {\n        guard let newLocation = userLocation.location else { return }\n        \n        let currentTime = Date()\n        let lastLocation = self.currentLocation\n        self.currentLocation = newLocation\n        \n        // Only get new placemark information if you don't have a previous location,\n        // if the user has moved a meaningful distance from the previous location, such as 1000 meters,\n        // and if it's been 60 seconds since the last geocode request.\n        if let lastLocation = lastLocation,\n            newLocation.distance(from: lastLocation) <= 1000,\n            let lastTime = lastGeocodeTime,\n            currentTime.timeIntervalSince(lastTime) < 60 {\n            return\n        }\n        \n        // Convert the user's location to a user-friendly place name by reverse geocoding the location.\n        lastGeocodeTime = currentTime\n        geocoder.reverseGeocodeLocation(newLocation) { (placemarks, error) in\n            guard error == nil else {\n                self.handleError(error)\n                return\n            }\n            \n            // Most geocoding requests contain only one result.\n            if let firstPlacemark = placemarks?.first {\n                self.mostRecentPlacemark = firstPlacemark\n                self.currentCity = firstPlacemark.locality\n            }\n        }\n    }\n\n\nSee Also\nDisplaying the user’s location\nvar showsUserLocation: Bool\nA Boolean value that indicates whether the map tries to display the user’s location.\nvar isUserLocationVisible: Bool\nA Boolean value that indicates whether the user’s location is visible in the map view.\nvar userLocation: MKUserLocation\nThe annotation object that represents the user’s location.\nvar userTrackingMode: MKUserTrackingMode\nThe mode to use for tracking the user’s location.\nfunc setUserTrackingMode(MKUserTrackingMode, animated: Bool)\nSets the mode to use for tracking the user’s location, with optional animation.\nenum MKUserTrackingMode\nThe mode to use for tracking the user’s location on the map.\nRelated Documentation\nConverting between coordinates and user-friendly place names\nConvert between a latitude/longitude pair and a more user-friendly description of that location."
  },
  {
    "title": "Converting between coordinates and user-friendly place names | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/converting_between_coordinates_and_user-friendly_place_names",
    "html": "Overview\n\nThe CLLocationManager object reports locations as a latitude/longitude pair. While these values uniquely represent any location on the planet, they are not values that users immediately associate with the location. Users are more familiar with names that describe a location, such as street names or city names. The CLGeocoder class lets you convert between geographic coordinates and the user-friendly names associated with that location. You can convert from either a latitude/longitude pair to a user friendly place name, or the other way around.\n\nFigure 1 Converting between coordinates and user-friendly descriptions\n\nUser place names are represented by a CLPlacemark object, which contains properties for specifying the street name, city name, country or region name, postal code, and many others. Placemarks also contain properties describing relevant geographic features or points of interest at the location, such as the names of mountains, rivers, businesses, or landmarks.\n\nGeocoder objects are one-shot objects—that is, you use each object to make a single conversion. You can create multiple geocoder objects and perform multiple conversions, but Apple rate limits the number of conversions you can perform. Making too many requests in a short period of time may cause some of those requests to fail. For tips on how to manage any conversions, see the overview of CLGeocoder.\n\nConvert a coordinate into a placemark\n\nIf you have a CLLocation object, call the reverseGeocodeLocation(_:completionHandler:) method of your geocoder object to retrieve a CLPlacemark object for that location. Typically, you convert coordinates into placemarks when you want to display information about the location to the user. For example, if the user selects a location on a map, you might want to show the address at that location.\n\nListing 1 shows how to obtain placemark information for the last location reported by the CLLocationManager object. Because calls to the geocoder object are asynchronous, the caller of this method passes in a completion handler, which is executed with the results.\n\nListing 1 Reverse geocoding a coordinate\nfunc lookUpCurrentLocation(completionHandler: @escaping (CLPlacemark?)\n                -> Void ) {\n    // Use the last reported location.\n    if let lastLocation = self.locationManager.location {\n        let geocoder = CLGeocoder()\n            \n        // Look up the location and pass it to the completion handler\n        geocoder.reverseGeocodeLocation(lastLocation, \n                    completionHandler: { (placemarks, error) in\n            if error == nil {\n                let firstLocation = placemarks?[0]\n                completionHandler(firstLocation)\n            }\n            else {\n\t         // An error occurred during geocoding.\n                completionHandler(nil)\n            }\n        })\n    }\n    else {\n        // No location was available.\n        completionHandler(nil)\n    }\n}\n\n\nConvert a placemark into a coordinate\n\nIf you have user-provided address information, call the methods of CLGeocoder to obtain the corresponding location data. The CLGeocoder class provides options for converting a user-typed string or for converting a dictionary of address-related information. That information is forwarded to Apple servers, which interpret the information and return the results.\n\nDepending on the precision of the user-provided information, you may receive one result or multiple results. For example, passing a string of \"100 Main St., USA\" may return many results unless you also specify a search region or additional details. To help you decide which result is correct, the geocoder actually returns CLPlacemark objects, which contain both the coordinate and the original information that you provided.\n\nListing 2 shows how you might obtain a coordinate value from a user-provided string. The example calls the provided completion handler with only the first result. If the string does not correspond to any location, the method calls the completion handler with an error and an invalid coordinate.\n\nListing 2 Getting a coordinate from an address string\nfunc getCoordinate( addressString : String, \n        completionHandler: @escaping(CLLocationCoordinate2D, NSError?) -> Void ) {\n    let geocoder = CLGeocoder()\n    geocoder.geocodeAddressString(addressString) { (placemarks, error) in\n        if error == nil {\n            if let placemark = placemarks?[0] {\n                let location = placemark.location!\n                    \n                completionHandler(location.coordinate, nil)\n                return\n            }\n        }\n            \n        completionHandler(kCLLocationCoordinate2DInvalid, error as NSError?)\n    }\n}\n\n\nSee Also\nGeocoding\nConverting a user's location to a descriptive placemark\nTransform the user’s location that displays on a map into an informative textual description by reverse geocoding.\nclass CLGeocoder\nAn interface for converting between geographic coordinates and place names.\nclass CLPlacemark\nA user-friendly description of a geographic coordinate, often containing the name of the place, its address, and other relevant information."
  },
  {
    "title": "Ranging for Beacons | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/ranging_for_beacons",
    "html": "Overview\n\nBeacons make location-based products and services available to users by broadcasting information to your device. Ranging is the process of reading the characteristics of a beacon region, such as signal strength, advertising interval, and measured power.\n\nThis sample code project configures a device to act as a beacon, and configures a device to use ranging to find surrounding beacons. Use two iOS devices to run the sample, with one acting as a beacon, and the other ranging for the beacon.\n\nNote\n\nThis project is associated with WWDC 2019 session 705: What’s New in Location.\n\nConfigure a Device to Act as a Beacon\n\nRun the sample app on the first iOS device. Select the option to Configure a Beacon. The project hard-codes a default value for the UUID that can be changed in ConfigureBeaconViewController.swift.\n\nlet beaconUUID = UUID(uuidString: \"E2C56DB5-DFFB-48D2-B060-D0F5A71096E0\")\n\n\nOptionally, modify the major and minor value for the beacon, then select the Enabled switch on the configuration screen to start advertising.\n\nConfigureBeaconViewController.swift contains a view controller object that configures the iOS device running this app to act as a beacon. The configureBeaconRegion() method sets up the region and starts advertising itself.\n\nif peripheralManager.state == .poweredOn {\n    peripheralManager.stopAdvertising()\n    if enabled {\n        let bundleURL = Bundle.main.bundleIdentifier!\n        \n        // Defines the beacon identity characteristics the device broadcasts.\n        let constraint = CLBeaconIdentityConstraint(uuid: beaconUUID!, major: major, minor: minor)\n        region = CLBeaconRegion(beaconIdentityConstraint: constraint, identifier: bundleURL)\n        \n        let peripheralData = region.peripheralData(withMeasuredPower: nil) as? [String: Any]\n        \n        // Start broadcasting the beacon identity characteristics.\n        peripheralManager.startAdvertising(peripheralData)\n    }\n\nConfigure a Device to Range for Beacons\n\nUsing a second iOS device, run the sample app and tap Range for Beacons to scan for beacons. Add a UUID to range for by tapping the Add button in the upper corner of the screen. The hard-coded UUID appears by default.\n\nRangeBeaconViewController.swift contains a view controller object that scans for nearby beacon regions that the user adds. As in any location-based service, first request authorization. Use a CLLocationManager instance to request that authorization, set up the constraint based on the hard-coded UUID, and tell the instance to start monitoring.\n\nself.locationManager.requestWhenInUseAuthorization()\n\n\n// Create a new constraint and add it to the dictionary.\nlet constraint = CLBeaconIdentityConstraint(uuid: uuid)\nself.beaconConstraints[constraint] = []\n\n\n/*\nBy monitoring for the beacon before ranging, the app is more\nenergy efficient if the beacon is not immediately observable.\n*/\nlet beaconRegion = CLBeaconRegion(beaconIdentityConstraint: constraint, identifier: uuid.uuidString)\nself.locationManager.startMonitoring(for: beaconRegion)\n\n\nWhen the device enters the specified region, the locationManager(_ manager: CLLocationManager, didDetermineState state: CLRegionState, for region: CLRegion) delegate method receives the region state and starts ranging beacons.\n\nWhile one or more beacons are in range, the locationManager(_ manager: CLLocationManager, didRange beacons: [CLBeacon], satisfying beaconConstraint: CLBeaconIdentityConstraint) delegate method receives their characteristics in the passed array.\n\nSee Also\niBeacon\nDetermining the proximity to an iBeacon device\nDetect beacons and determine the relative distance to them.\nTurning an iOS device into an iBeacon device\nBroadcast iBeacon signals from an iOS device.\nclass CLBeacon\nInformation about an observed iBeacon device and its relative distance to the user’s device.\nprotocol CLCondition\nThe abstract base class for all other monitor conditions."
  },
  {
    "title": "CLLocationSourceInformation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationsourceinformation",
    "html": "Overview\n\nCLLocationSourceInformation contains information about the source that provides a CLLocation instance, such as instances that locationManager(_:didUpdateLocations:) delivers. For example, an app may choose to check the source information and reject locations if the isSimulatedBySoftware property is true when the developer isn’t debugging or testing the app.\n\nTopics\nCreating a location source information object\ninit(softwareSimulationState: Bool, andExternalAccessoryState: Bool)\nCreates an instance of location source information.\nIdentifying the source of location data\nvar isProducedByAccessory: Bool\nA Boolean value that indicates whether the system receives the location from an external accessory.\nvar isSimulatedBySoftware: Bool\nA Boolean value that indicates whether the system generates the location using on-device software simulation.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nLocation updates\nGetting the current location of a device\nStart location services and provide information the system needs to optimize power usage for those services.\nHandling location updates in the background\nConfigure your app to receive location updates when it isn’t running in the foreground.\nCreating a location push service extension\nAdd and configure an extension to enable your location sharing app to access a user’s location in response to a request from another user.\nclass CLLocation\nThe latitude, longitude, and course information reported by the system.\nstruct CLLocationCoordinate2D\nThe latitude and longitude associated with a location, specified using the WGS 84 reference frame.\nclass CLFloor\nThe floor of a building on which the user's device is located.\nclass CLVisit\nInformation about the user's location during a specific period of time."
  },
  {
    "title": "Monitoring the user's proximity to geographic regions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/monitoring_the_user_s_proximity_to_geographic_regions",
    "html": "Overview\n\nRegion monitoring (also known as geofencing) is a way for your app to be alerted when the user enters or exits a geographical region. You might use region monitoring to perform location-related tasks. For example, the Reminders app uses them to trigger reminders when the user arrives at or leaves a specified location, as shown in Figure 1.\n\nFigure 1 Notifying the user upon leaving a geographic region\n\nIn iOS, the system monitors regions, which wakes up your app as needed when the user crosses a defined region boundary. In macOS, region monitoring works only while the app is running (either in the foreground or background) and the user’s system is awake. The system doesn’t launch Mac apps to deliver region-related notifications.\n\nDefine and monitor a geographic region\n\nA region is a circular area centered on a geographic coordinate, and you define one using a CLCircularRegion object. The radius of the region object defines its boundary. You define the regions you want to monitor and register them with the system by calling the startMonitoring(for:) method of your CLLocationManager object. The system monitors your regions until you explicitly ask it to stop or until the device reboots.\n\nListing 1 shows how to configure and register a region centered around a point provided by the caller of the method. The method uses the largest allowed radius to define the boundaries of the region and asks that the system deliver notifications only when the user enters the region.\n\nListing 1 Monitoring a region around the specified coordinate\nfunc monitorRegionAtLocation(center: CLLocationCoordinate2D, identifier: String ) {    \n    // Make sure the devices supports region monitoring.\n    if CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) {\n        // Register the region.\n        let maxDistance = locationManager.maximumRegionMonitoringDistance\n        let region = CLCircularRegion(center: center, \n             radius: maxDistance, identifier: identifier)\n        region.notifyOnEntry = true\n        region.notifyOnExit = false\n   \n        locationManager.startMonitoring(for: region)\n        \n    }\n}\n\n\nTip\n\nRegions are shared resources that rely on specific hardware capabilities. To ensure that all apps can participate in region monitoring, Core Location prevents any single app from monitoring more than 20 regions simultaneously. To work around this limitation, monitor only regions that are close to the user’s current location. As the user moves, update the list based on the user’s new location.\n\nHandle a region-related notification\n\nWhenever the user crosses the boundary of one of your app’s registered regions, the system notifies your app. If an iOS app isn’t running when the boundary crossing occurs, the system tries to launch it.\n\nBoundary crossing notifications are delivered to your location manager’s delegate object. Specifically, the location manager calls the locationManager(_:didEnterRegion:) or locationManager(_:didExitRegion:) methods of its delegate. If your app was launched, you must configure a CLLocationManager object and delegate object right away so that you can receive these notifications. To determine whether your app was launched for a location event, look for the UIApplication.LaunchOptionsKey in the launch options dictionary.\n\nWhen determining whether a boundary crossing happened, the system waits to be sure before sending the notification. Specifically, the user must travel a minimum distance over the boundary and remain on the same side of the boundary for at least 20 seconds. These conditions help eliminate spurious calls to your delegate object’s methods.\n\nListing 2 shows a delegate method that is called when the user enters a registered region. Regions have an associated identifier, which this method uses to look up information related to the region and perform the associated action.\n\nListing 2 Handling a region-entered notification\nfunc locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {\n    if let region = region as? CLCircularRegion {\n        let identifier = region.identifier   \n        triggerTaskAssociatedWithRegionIdentifier(regionID: identifier)\n    }\n}\n\n\nTermination of your app (by the user or the system) does not prevent it from being relaunched to handle region boundary crossings. However, when Background App Refresh is disabled, either for your app or for all apps, the user must explicitly launch your app to resume the delivery of all location-related events.\n\nSee Also\nRegion monitoring\nclass CLRegion\nA base class representing an area that can be monitored."
  },
  {
    "title": "CLVisit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clvisit",
    "html": "Overview\n\nA CLVisit object encapsulates information about places that the user has been. Visit objects are created by the system and delivered by the CLLocationManager object to its delegate after you start the delivery of events. The visit includes the location where the visit occurred and information about the arrival and departure times as relevant. You do not create visit objects directly, nor should you subclass CLVisit.\n\nVisit objects contain as much information about the visit as possible but may not always include both the arrival and departure times. For example, when the user arrives at a location, the system may send an event with only an arrival time. When the user departs a location, the event can contain both the arrival time (if your app was monitoring visits prior to the user’s arrival) and the departure time.\n\nTopics\nGetting the location\nvar coordinate: CLLocationCoordinate2D\nThe geographical coordinate information.\nvar horizontalAccuracy: CLLocationAccuracy\nThe horizontal accuracy (in meters) of the specified coordinate.\nGetting the visit duration\nvar arrivalDate: Date\nThe approximate time at which the user arrived at the specified location.\nvar departureDate: Date\nThe approximate time at which the user left the specified location.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding\nSee Also\nLocation updates\nGetting the current location of a device\nStart location services and provide information the system needs to optimize power usage for those services.\nHandling location updates in the background\nConfigure your app to receive location updates when it isn’t running in the foreground.\nCreating a location push service extension\nAdd and configure an extension to enable your location sharing app to access a user’s location in response to a request from another user.\nclass CLLocation\nThe latitude, longitude, and course information reported by the system.\nstruct CLLocationCoordinate2D\nThe latitude and longitude associated with a location, specified using the WGS 84 reference frame.\nclass CLFloor\nThe floor of a building on which the user's device is located.\nclass CLLocationSourceInformation\nInformation about the source that provides a location."
  },
  {
    "title": "CLLocationCoordinate2D | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationcoordinate2d",
    "html": "Topics\nCreating a location coordinate\ninit()\nCreates a location coordinate object.\ninit(latitude: CLLocationDegrees, longitude: CLLocationDegrees)\nCreates a location coordination object with the specified latitude and longitude values.\nfunc CLLocationCoordinate2DMake(CLLocationDegrees, CLLocationDegrees) -> CLLocationCoordinate2D\nFormats a latitude and longitude value into a coordinate data structure format.\nGetting the geographic coordinates\nvar latitude: CLLocationDegrees\nThe latitude in degrees.\nvar longitude: CLLocationDegrees\nThe longitude in degrees.\nvar animatableData: AnimatablePair<CLLocationDegrees, CLLocationDegrees>\nA pair of locations you can use to configure an animation.\nValidating a coordinate\nfunc CLLocationCoordinate2DIsValid(CLLocationCoordinate2D) -> Bool\nReturns a Boolean value indicating whether the specified coordinate is valid.\nlet kCLLocationCoordinate2DInvalid: CLLocationCoordinate2D\nAn invalid coordinate value.\nType aliases\ntypealias CLLocationCoordinate2D.AnimatableData\nThe type representing the animatable data of this structure.\nRelationships\nConforms To\nAnimatable\nSee Also\nLocation updates\nGetting the current location of a device\nStart location services and provide information the system needs to optimize power usage for those services.\nHandling location updates in the background\nConfigure your app to receive location updates when it isn’t running in the foreground.\nCreating a location push service extension\nAdd and configure an extension to enable your location sharing app to access a user’s location in response to a request from another user.\nclass CLLocation\nThe latitude, longitude, and course information reported by the system.\nclass CLFloor\nThe floor of a building on which the user's device is located.\nclass CLVisit\nInformation about the user's location during a specific period of time.\nclass CLLocationSourceInformation\nInformation about the source that provides a location."
  },
  {
    "title": "Creating a location push service extension | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/creating_a_location_push_service_extension",
    "html": "Overview\n\nThe Location Push Service Extension, available starting in iOS 15, is a power efficient way to query locations on iOS or iPadOS devices, even when your app isn’t running.\n\nWhen your app includes a Location Push Service Extension, the system activates the extension when it receives an Apple Push Notification service (APNs) location push from your server. Your app must ask for and receive Always authorization (CLAuthorizationStatus.authorizedAlways) from the user before the extension can function. For more information about requesting Always authorization, see Requesting authorization to use location services and requestAlwaysAuthorization().\n\nWith the user’s authorization, the extension can query the user’s location and process it according to your app’s purpose. Your server sends requests with the location push type to APNs. For more information about sending requests to APNs, see Sending notification requests to APNs.\n\nImportant\n\nTo use the Location Push Service Extension, your app must have the com.apple.developer.location.push entitlement. Request this entitlement before implementing this service extension. To apply for the entitlement, log in to your developer account with an Account Holder role and fill out the request form.\n\nConfigure Your Xcode Project\n\nTo include Location Push Service Extension in your app, use Xcode 13 or later. Configure the following entitlements, capabilities, and keys for your Xcode project:\n\nSet the Location Push Server Extension entitlement key (com.apple.developer.location.push).\n\nEnable your app to receive Apple Push Notification service (APNs) pushes by adding the Push Notifications capability. For more information, see Registering your app with APNs.\n\nConfigure the purpose strings your app provides for the location service authorization prompts. For more information, see Requesting authorization to use location services.\n\nAdd a Location Push Service Extension Target\n\nAdd a new target using the Location Push Service Extension template.\n\nOpen your iOS app project in Xcode.\n\nChoose File > New > Target.\n\nSelect Location Push Service Extension from the iOS Application Extension group.\n\nClick Next.\n\nSpecify the name of your extension and configure the language and other options.\n\nClick Finish.\n\nXcode creates a subclass of CLLocationPushServiceExtension to get you started.\n\nImplement Location Push Functionality\n\nTo support location push functionality, implement the following code in your extension, app, and server:\n\nIn your service extension, implement the CLLocationPushServiceExtension protocol.\n\nIn your service extension, implement the locationManager(_:didUpdateLocations:) method to handle the result of the location request, and process the location data received.\n\nIn your app, call startMonitoringLocationPushes(completion:) to receive an APNs token as Data, and send it to your server. Your server uses this token when it creates APNs pushes.\n\nFrom your server, request location information by sending a location push request to APNs.\n\nIf the user authorized your app with Always authorization (CLAuthorizationStatus.authorizedAlways), the system activates the service extension when it receives a location push, and calls didReceiveLocationPushPayload(_:completion:). Your app should ask the user for Always authorization at an appropriate time.\n\nImportant\n\nProtecting user privacy is important when handling location data. End-to-end encryption provides enhanced security if your app moves location data off the user’s device, including transmitting it to a server or to another user. For more information, see Protecting the User’s Privacy.\n\nSend Location Push Requests From Your Server\n\nWhen a user requests the location of another user, your app sends the request to your server, which sends a location push request to APNs. Ensure that your APNs POST request contains the following fields for a location push type:\n\nmethod\n\n(Required) The value is POST.\n\npath\n\n(Required) The path to the device token. The value of this header is /3/device/<device_token>, where <device_token> is the hexadecimal identifier of the user’s device. Your app receives the token when it calls startMonitoringLocationPushes(completion:) to start monitoring location pushes.\n\nauthorization\n\n(Required for token-based authentication) The value of this header is bearer <provider_token>, where <provider_token> is the encrypted token that authorizes you to send notifications for the specified topic. For more information, see Establishing a token-based connection to APNs.\n\napns-topic\n\nThe topic is your app’s bundle ID with the suffix \".location-query\".\n\napns-push-type\n\n(Recommended) The value of this header is location.\n\napns-priority\n\nThe priority of the notification. If you omit this header, APNs sets the notification priority to 10. If a user initiates the location query, set this header to 10. If your app’s server initiates the location query (for example, on a periodic interval) set this header to 5 to send the notification based on power considerations on the user’s device.\n\nFor more information about sending APNs requests and using command-line tools to do so, see Sending notification requests to APNs and Sending push notifications using command-line tools.\n\nSee Also\nLocation updates\nGetting the current location of a device\nStart location services and provide information the system needs to optimize power usage for those services.\nHandling location updates in the background\nConfigure your app to receive location updates when it isn’t running in the foreground.\nclass CLLocation\nThe latitude, longitude, and course information reported by the system.\nstruct CLLocationCoordinate2D\nThe latitude and longitude associated with a location, specified using the WGS 84 reference frame.\nclass CLFloor\nThe floor of a building on which the user's device is located.\nclass CLVisit\nInformation about the user's location during a specific period of time.\nclass CLLocationSourceInformation\nInformation about the source that provides a location."
  },
  {
    "title": "Getting the current location of a device | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/getting_the_current_location_of_a_device",
    "html": "Overview\n\nCore Location offers many different services for getting location-related data, but the most common services return the device’s current location. You might use this information to:\n\nFacilitate navigation, either by foot, car, or other modes of transportation.\n\nIdentify nearby points of interest.\n\nFilter search results based on proximity to the person.\n\nDisplay the person’s location on a map.\n\nShare the person’s location with a friend.\n\nTag the location of a photo.\n\nCheck in with social media.\n\nTrack the path someone takes during a workout or hike.\n\nCore Location can determine the current location using many different types of hardware, including Wi-Fi, cellular, and GPS radios. Core Location doesn’t need every one of these radios to determine the location. Instead, it selectively enables radios to get the required location data in the most power-efficient way possible. The configuration of your CLLocationManager object affects which radios the system uses and your app’s power consumption.\n\nStart the service that delivers the location data you need\n\nAlways choose the most power-efficient location service that meets the needs of your app. Core Location provides the following services for getting location data:\n\nThe Visits location service provides the most power-efficient way to get location data. The system monitors the places someone visits and the time they spend there, and delivers that data at a later time. Call startMonitoringVisits() to start the service.\n\nThe Significant-change location service offers a low-power way to get location updates. This service uses the cellular and Wi-Fi radios (not GPS) to report only location changes that exceed a significantly large distance. Call startMonitoringSignificantLocationChanges() to start the service.\n\nThe Standard location service provides the most precise and regular location data, but uses more power than the other services. Use it primarily if your app provides turn-by-turn navigation or needs a greater precision or frequency of events. This location service is the only one available to apps running in visionOS. Call startUpdatingLocation() to start the service, or call requestLocation() to get a single location event.\n\nFew apps need to start location services right away, and fewer still need to keep those services running for extended periods of time. Delay the start of location services until someone interacts with your app in a way that requires that information. Then, as soon as you have the location data you need, stop services to preserve battery life. For example, stop services if you only need the current location to filter search results once.\n\nWhen adding support for a location service, make sure to implement all of the service’s relevant methods in your delegate object. The Standard and Significant-change location services use the same set of delegate methods, but the Visits service has a separate method to receive visit-specific data.\n\nFor information about the behavior of individual services and how to start and stop them, see CLLocationManager.\n\nEnable power-saving features\n\nCore Location optimizes power usage as much as possible, but you can still help. The best optimization is to turn off location services when your app doesn’t need new location data. Other optimizations require you to adjust the configuration of your location manager object:\n\nSet the distanceFilter property to the largest possible value that gives you the information you need. Higher values let the system turn off radio hardware more frequently.\n\nSet the desiredAccuracy property to the lowest possible value that gives you the information you need. Lower accuracy values let the system use more power-efficient hardware. Lower values also let the system turn off hardware sooner.\n\nConfigure the activityType property to an appropriate value, and set the pausesLocationUpdatesAutomatically property to true. Core Location uses your activity type to turn off hardware automatically when conditions allow it. For example, if the activity type is CLActivityType.automotiveNavigation and someone’s location isn’t changing, the system might turn off radio hardware until it detects new movement.\n\nSet the allowsBackgroundLocationUpdates property to false when you don’t actually need background location updates.\n\nAnother way to improve power usage is to add the NSLocationDefaultAccuracyReduced key with the value true to your app’s Info.plist file. Include this key if lower-accuracy location data is sufficient for your needs. For example, an app that returns a list of restaurants within driving distance doesn’t need someone’s precise location. As needed, you can always use your location manager to request more accurate data later. However, the system displays a prompt to the device owner to grant each request you make.\n\nSee Also\nLocation updates\nHandling location updates in the background\nConfigure your app to receive location updates when it isn’t running in the foreground.\nCreating a location push service extension\nAdd and configure an extension to enable your location sharing app to access a user’s location in response to a request from another user.\nclass CLLocation\nThe latitude, longitude, and course information reported by the system.\nstruct CLLocationCoordinate2D\nThe latitude and longitude associated with a location, specified using the WGS 84 reference frame.\nclass CLFloor\nThe floor of a building on which the user's device is located.\nclass CLVisit\nInformation about the user's location during a specific period of time.\nclass CLLocationSourceInformation\nInformation about the source that provides a location."
  },
  {
    "title": "Handling location updates in the background | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/handling_location_updates_in_the_background",
    "html": "Overview\n\nOn some Apple devices, the operating system preserves battery life by suspending the execution of background apps. For example, on iOS, iPadOS, and watchOS, the system suspends the execution of most apps shortly after they move to the background. In this suspended state, apps don’t run and don’t receive location updates from the system. Instead, the system enqueues location updates and delivers them when the app runs again, either in the foreground or background. If your app needs updates in a more timely manner, you can ask the system to not suspend your app while location services are active.\n\nConsider carefully whether your app really needs background location updates. Most apps need location data only while someone actively uses the app. Consider background updates only when your app needs to receive those updates in real time, perhaps to:\n\nTrack the precise path taken during a hike or fitness workout.\n\nProvide navigation instructions in real time.\n\nGenerate time-sensitive notifications or updates.\n\nTake immediate action when someone enters or exits a particular geographic region.\n\nIf you need background location updates for an iOS, iPadOS, or watchOS app, update your project to support those updates. On macOS, you don’t need to add support for background updates because the system doesn’t suspend apps when they move to the background. Apps running in visionOS don’t receive background updates.\n\nNote\n\nThe system allows background updates for apps with either When in Use or Always authorization. If an app isn’t running when an update occurs, the system launches the app only if it has Always authorization and uses the significant location change, visits, or region monitoring services.\n\nAdd the background mode capability\n\nThe background modes capability lets the system know whether your app uses background updates. To add this capability, navigate to the Signing & Capabilities tab of your app target and enable the Location updates option. When you enable this capability, Xcode updates your app’s Info.plist file with the keys needed to indicate your app supports background updates.\n\nTell the system you want background updates\n\nThe system doesn’t automatically deliver location updates when an app enters the background. Instead, you must programmatically enable the delivery of those updates:\n\nSet the allowsBackgroundLocationUpdates property of your location manager to true to enable background updates.\n\nSet the showsBackgroundLocationIndicator property to true if your app has Always access to let people know when you’re using location services in the background.\n\nWhen an app with When in Use authorization runs in the background, the system automatically displays the background location indicator to let people know your app is receiving location data. For apps with Always authorization, the system displays the indicator only if you set the showsBackgroundLocationIndicator property to true.\n\nApps continue to run in the background while location services are active and the allowsBackgroundLocationUpdates property is true. If you stop location services or set the allowsBackgroundLocationUpdates property to false while your app is in the background, the system suspends your app. If that happens, you must wait until the person uses your app to start location services again.\n\nImportant\n\nTurn off background updates when your app isn’t using them to save power.\n\nProcess location updates after an app launch\n\nThe system can terminate apps at any time to free up memory or other system resources. The system relaunches a terminated app only if the app has Always authorization and if it was running the significant change, visits, or region monitoring location service at the time of its termination. The system doesn’t launch apps running the standard location or heading services, or if the app was performing iBeacon ranging at the time of its termination.\n\nIf your app uses the significant change, visits, or region monitoring services, restart those services at launch if your app is already authorized to use them. When you start those services, the system automatically delivers any queued location updates to your location manager’s delegate object. Don’t start these services at launch time if your app’s authorization status is undetermined.\n\nSee Also\nLocation updates\nGetting the current location of a device\nStart location services and provide information the system needs to optimize power usage for those services.\nCreating a location push service extension\nAdd and configure an extension to enable your location sharing app to access a user’s location in response to a request from another user.\nclass CLLocation\nThe latitude, longitude, and course information reported by the system.\nstruct CLLocationCoordinate2D\nThe latitude and longitude associated with a location, specified using the WGS 84 reference frame.\nclass CLFloor\nThe floor of a building on which the user's device is located.\nclass CLVisit\nInformation about the user's location during a specific period of time.\nclass CLLocationSourceInformation\nInformation about the source that provides a location."
  },
  {
    "title": "Requesting authorization to use location services | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/requesting_authorization_to_use_location_services",
    "html": "Overview\n\nLocation data is sensitive information, and the use of location data has privacy implications for the people who use your app. To ensure that people maintain control over their own information, the system prevents apps from using location data until they obtain authorization to do so. This authorization process involves a one-time interruption, during which the system prompts the device owner to grant or deny your app’s request for location data. After the initial interruption, the system stores your app’s authorization status and doesn’t prompt again.\n\nTo help people understand why you need location data, make authorization requests only when someone engages a part of your app that requires that data. Making the request immediately before it’s needed increases the likelihood of the person granting the request. If you make a request immediately at app launch, or in a part of your app that doesn’t clearly use location data, the person might misinterpret your intent and deny the request.\n\nChoose the access level you need\n\nBefore you place an authorization request, choose the level of access your app needs. Core Location supports two authorization levels:\n\nWhen in Use authorization makes location updates available only when someone uses your app. This authorization is the preferred choice, because it has better privacy and battery life implications.\n\nAlways authorization makes location updates available at any time, and lets the system launch your app quietly to handle some updates. Request this access level only when necessary on other platforms. For example, request it if your app delivers time-sensitive responses to location changes automatically, or implements a location push service app extension. This access level isn’t available when running in visionOS.\n\nThe definition of when an app is in use depends on the platform:\n\nOn iOS, an app is in use when it’s in the foreground and for a short time when it transitions from the foreground to the background. If you enable background location updates, an app with When in Use authorization continues to run in the background when location services are active; if location services aren’t running, the normal suspension rules apply. If the system terminates the app or the app isn’t running, the system doesn’t launch an app with When in Use authorization to deliver new updates; it does launch an app with Always authorization for some types of location updates.\n\nOn macOS, When in Use and Always authorizations are functionally equivalent. Because macOS apps continue to run in the background after their initial launch, they are always in use. If you create your Mac app using Mac Catalyst, request authorization based on the needs of your iOS app.\n\nOn watchOS, complications can receive location updates, but the watchOS app must run at least once so it can request authorization to access location data. If an app’s complication is on the current watch face, the system treats that complication as if it’s in use and delivers location updates to it. The system doesn’t launch watchOS apps, even if they have Always access.\n\nOn visionOS, an app is in use when someone is looking at it, and for a short time after the person stops looking at it.\n\nNote\n\nIf your app already has When in Use authorization, you can make a separate request for Always authorization later. However, you can make the request only once.\n\nRegardless of which access level you choose, you can start any location services available on the current device and achieve the same results. Access levels primarily determine how your app receives updates when it isn’t running. The following table summarizes the differences between access levels.\n\nCapability\n\n\t\n\nWhen in Use\n\n\t\n\nAlways\n\n\n\n\nSupported platforms\n\n\t\n\nAll\n\n\t\n\nAll platforms except tvOS and visionOS\n\n\n\n\nSupported location services\n\n\t\n\nAll\n\n\t\n\nAll\n\n\n\n\nLaunches a terminated app automatically\n\n\t\n\nNo. The user must launch the app.\n\n\t\n\nYes for significant location change, visits, and region monitoring services; no for others\n\nFor information about how to handle location updates in the background, see Handling location updates in the background.\n\nProvide descriptions of how you use location services\n\nThe first time you make an authorization request, the system displays an alert asking the person to grant or deny the request. The alert includes a usage description string that explains why you want access to location data. You provide this string in your app’s Info.plist file and use it to inform people about how your app uses location data.\n\nCore Location supports different usage strings for each access level. You must include a usage description string for When in Use access. If your app supports Always access, provide an additional string explaining why you want the elevated privileges. The following table lists the keys to include in your Info.plist and when to include them.\n\nUsage key\n\n\t\n\nRequired when:\n\n\n\n\nNSLocationWhenInUseUsageDescription\n\n\t\n\nThe app requests When in Use or Always authorization.\n\n\n\n\nNSLocationAlwaysAndWhenInUseUsageDescription\n\n\t\n\nThe app requests Always authorization.\n\n\n\n\nNSLocationUsageDescription\n\n\t\n\n(macOS only) Your macOS app uses location services.\n\nAdd all usage description keys to your app’s Info.plist file before you make any authorization requests. Authorization requests fail immediately if the required keys aren’t present.\n\nMake authorization requests and respond to status changes\n\nBefore you start any location services, check your app’s current authorization status and place an authorization request if needed. You can get your app’s current authorization from the authorizationStatus property of your location-manager object. However, a newly configured CLLocationManager object also reports your app’s current authorization status to its delegate’s locationManagerDidChangeAuthorization(_:) method automatically. You might use that method to place an authorization request when the current status is CLAuthorizationStatus.notDetermined. In the following example, the delegate method enables or disables location features when the status is known and requests authorization when the status is undetermined.\n\nfunc locationManagerDidChangeAuthorization(_ manager: CLLocationManager) { \n    switch manager.authorizationStatus {\n    case .authorizedWhenInUse:  // Location services are available.\n        enableLocationFeatures()\n        break\n        \n    case .restricted, .denied:  // Location services currently unavailable.\n        disableLocationFeatures()\n        break\n        \n    case .notDetermined:        // Authorization not determined yet.\n       manager.requestWhenInUseAuthorization()\n        break\n        \n    default:\n        break\n    }\n}\n\n\n\n\nThe locationManagerDidChangeAuthorization(_:) method offers a central place to process any authorization-related changes. People can change your app’s authorization status at any time in system settings. If your app is running when the change happens, each of your app’s CLLocationManager objects reports the change to that delegate method. The location manager also reports your app’s current authorization at other times. For example, the location manager also calls the method when a suspended iOS app starts running again.\n\nSee Also\nAuthorization\nenum CLAuthorizationStatus\nConstants indicating the app's authorization to use location services.\nenum CLAccuracyAuthorization\nConstants indicating the level of location accuracy the app has authorization to use.\nproperty list key NSLocationAlwaysAndWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information at all times.\nName: Privacy - Location Always and When In Use Usage Description\nproperty list key NSLocationWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information while the app is running in the foreground.\nName: Privacy - Location When In Use Usage Description\nproperty list key NSLocationUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information.\nName: Privacy - Location Usage Description\nproperty list key NSLocationDefaultAccuracyReduced\nA Boolean value that indicates whether the app requests reduced location accuracy by default.\nName: Privacy - Location Default Accuracy Reduced\nproperty list key NSLocationAlwaysUsageDescription\nA message that tells the user why the app is requesting access to the user's location at all times.\nName: Privacy - Location Always Usage Description\nDeprecated"
  },
  {
    "title": "CLAccuracyAuthorization | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/claccuracyauthorization",
    "html": "Topics\nGetting the location accuracy\ncase fullAccuracy\nThe user authorized the app to access location data with full accuracy.\ncase reducedAccuracy\nThe user authorized the app to access location data with reduced accuracy.\nRelationships\nConforms To\nSendable\nSee Also\nAuthorization\nRequesting authorization to use location services\nObtain authorization to use location services and manage changes to your app’s authorization status.\nenum CLAuthorizationStatus\nConstants indicating the app's authorization to use location services.\nproperty list key NSLocationAlwaysAndWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information at all times.\nName: Privacy - Location Always and When In Use Usage Description\nproperty list key NSLocationWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information while the app is running in the foreground.\nName: Privacy - Location When In Use Usage Description\nproperty list key NSLocationUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information.\nName: Privacy - Location Usage Description\nproperty list key NSLocationDefaultAccuracyReduced\nA Boolean value that indicates whether the app requests reduced location accuracy by default.\nName: Privacy - Location Default Accuracy Reduced\nproperty list key NSLocationAlwaysUsageDescription\nA message that tells the user why the app is requesting access to the user's location at all times.\nName: Privacy - Location Always Usage Description\nDeprecated"
  },
  {
    "title": "Adopting live updates in Core Location | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/adopting_live_updates_in_core_location",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC23 session 10180: Discover streamlined location updates.\n\nConfigure the sample code project\n\nThe live updates sample requires Xcode 15 or later and iOS 17 or later.\n\nSee Also\nEssentials\nConfiguring your app to use location services\nVerify that location services are available and configure your app before you start collecting location data.\nSupporting live updates in SwiftUI and Mac Catalyst apps\nEnable background events by adding lifecycle event support.\nclass CLLocationManager\nThe object that you use to start and stop the delivery of location-related events to your app.\nclass CLBackgroundActivitySession\nAn object that manages a visual indicator that keeps your app in use in the background, allowing it to receive updates or events.\nstruct CLLocationUpdate\nA structure that contains the location information the framework delivers with each update.\nprotocol CLLocationManagerDelegate\nThe methods that you use to receive events from an associated location-manager object.\nMonitoring location changes with Core Location\nDefine boundaries and act on user location updates."
  },
  {
    "title": "Monitoring location changes with Core Location | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/monitoring_location_changes_with_core_location",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC23 session 10147: Meet Core Location Monitor.\n\nConfigure the sample code project\n\nBefore you run the sample code project in Xcode, ensure that you’re using Xcode 15 or later and iOS 17 or later.\n\nSee Also\nEssentials\nConfiguring your app to use location services\nVerify that location services are available and configure your app before you start collecting location data.\nSupporting live updates in SwiftUI and Mac Catalyst apps\nEnable background events by adding lifecycle event support.\nclass CLLocationManager\nThe object that you use to start and stop the delivery of location-related events to your app.\nclass CLBackgroundActivitySession\nAn object that manages a visual indicator that keeps your app in use in the background, allowing it to receive updates or events.\nstruct CLLocationUpdate\nA structure that contains the location information the framework delivers with each update.\nprotocol CLLocationManagerDelegate\nThe methods that you use to receive events from an associated location-manager object.\nAdopting live updates in Core Location\nSimplify location delivery using asynchronous events in Swift."
  },
  {
    "title": "CLLocationUpdate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/cllocationupdate",
    "html": "Overview\n\nYou use CLLocationUpate events to observe changes in the device’s location, and to determine the activity type.\n\nTopics\nDetermining movement and location\nlet isStationary: Bool\nA Boolean value that indicates whether the user is stationary.\nlet location: CLLocation?\nThe user’s location, if available.\nReceiving location updates\nstatic func liveUpdates(CLLocationUpdate.LiveConfiguration) -> CLLocationUpdate.Updates\nTells Core Location to start delivering the location updates it produces for the configuration you specify.\nenum CLLocationUpdate.LiveConfiguration\nValues for indicating the kind of updates the framework delivers.\nstruct CLLocationUpdate.Updates\nA structure that represents an asynchronous sequence of location updates.\nRelationships\nConforms To\nSendable\nSee Also\nEssentials\nConfiguring your app to use location services\nVerify that location services are available and configure your app before you start collecting location data.\nSupporting live updates in SwiftUI and Mac Catalyst apps\nEnable background events by adding lifecycle event support.\nclass CLLocationManager\nThe object that you use to start and stop the delivery of location-related events to your app.\nclass CLBackgroundActivitySession\nAn object that manages a visual indicator that keeps your app in use in the background, allowing it to receive updates or events.\nprotocol CLLocationManagerDelegate\nThe methods that you use to receive events from an associated location-manager object.\nAdopting live updates in Core Location\nSimplify location delivery using asynchronous events in Swift.\nMonitoring location changes with Core Location\nDefine boundaries and act on user location updates."
  },
  {
    "title": "CLBackgroundActivitySession | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/clbackgroundactivitysession",
    "html": "Overview\n\nUse CLBackgroundActivitySession to start a background activity session that allows a when-in-use authorized app to receive location updates or monitoring events.\n\nTopics\nCreating a background activity session\ninit()\nCreates a new background activity session.\nEnding the session\nfunc invalidate()\nInvalidates the background activity session.\nRelationships\nConforms To\nSendable\nSee Also\nEssentials\nConfiguring your app to use location services\nVerify that location services are available and configure your app before you start collecting location data.\nSupporting live updates in SwiftUI and Mac Catalyst apps\nEnable background events by adding lifecycle event support.\nclass CLLocationManager\nThe object that you use to start and stop the delivery of location-related events to your app.\nstruct CLLocationUpdate\nA structure that contains the location information the framework delivers with each update.\nprotocol CLLocationManagerDelegate\nThe methods that you use to receive events from an associated location-manager object.\nAdopting live updates in Core Location\nSimplify location delivery using asynchronous events in Swift.\nMonitoring location changes with Core Location\nDefine boundaries and act on user location updates."
  },
  {
    "title": "Configuring your app to use location services | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/configuring_your_app_to_use_location_services",
    "html": "Overview\n\nThe location data available on most Apple devices gives you additional context and information to incorporate into your app’s content. You might use that data to show someone’s physical location on a map and help them navigate their environment. You might apply location data to a list of restaurants and shops to eliminate choices that aren’t nearby. You might also use location data to alert someone when they’re near a particular device or geographic region. For all of these use cases and more, the Core Location framework provides access to the location data you need.\n\nWhen you add code to support Core Location, plan for situations where location data isn’t available. A device in Airplane Mode can’t deliver location updates because the required hardware is off. The system also requires apps to gain permission to use location data, and prevents apps from acquiring locations without permission. To ensure a trouble-free experience, always do the following before you try to retrieve any location data:\n\nVerify that the location services you want to use are available.\n\nVerify your app has permission to access location data.\n\nIf location data is unavailable for any reason, make the best app experience you can without it. Disable features that rely on location data or provide alternatives to get the behavior you need.\n\nImportant\n\nLocation data is sensitive information, and it’s important for you to secure any location data you collect. Encrypt any location data you store on disk or send over the network. In addition, provide a clear privacy policy that explains how you use someone’s location data.\n\nCheck the availability of each service your app uses\n\nAlways verify that location services are available before you attempt to use them. Services might be unavailable for many different reasons, including:\n\nThe device is in Airplane mode.\n\nThe device doesn’t have the required hardware.\n\nThe device doesn’t support a specific service.\n\nYour app doesn’t have authorization to use the service.\n\nIf a service isn’t available, disable any app-specific features that rely on that service. Disabling features in advance is a more reliable approach than using a service and responding to errors.\n\nThe CLLocationManager class provides methods to determine the availability of each service. Call the appropriate method for a given service immediately before you try to use that service. For example, an app that offers compass heading information might call the headingAvailable() method before starting the service. If your app uses multiple services, call the appropriate method for each service.\n\nif (CLLocationManager.headingAvailable()) {\n   // Enable the app’s compass features.\n} else {\n   // Disable compass features.\n}\n\n\nIf your app can’t function without specific location services, declare those requirements in advance using your app’s Info.plist file. For more information, see Declare any location services your app requires.\n\nSet up your app’s location-manager object\n\nA CLLocationManager object serves as a central access point to all location services. Create one or more of these objects close to where you use the corresponding service, and store a strong reference to each object you create. For example, create it in the view controller that displays location-related data. Configure the object with the appropriate parameters and use it to start and stop the services you use.\n\nGathering location data takes time, so most location services run asynchronously and report results to a delegate object you provide. Delegate objects adopt the CLLocationManagerDelegate protocol, and you use the methods of that protocol to receive location values and handle errors. Add this protocol to one of your app’s existing objects, or add it to a custom object you use specifically to handle location updates. Each location manager object delivers updates only to its associated delegate object.\n\nAfter you create a location manager object, assign your delegate to it right away. The delegate must be in place before you start any services. The following example shows a custom object that creates a location-manager object and configures it immediately.\n\nclass LocationDataManager : NSObject, CLLocationManagerDelegate {\n   var locationManager = CLLocationManager()\n\n\n   override init() {\n      super.init()\n      locationManager.delegate = self\n   }\n\n\n   // Location-related properties and delegate methods.\n}\n\n\nIn your delegate object, implement all the methods you need to handle a relevant service, including those that report errors. If a service is unable to deliver location data for any reason, it calls an appropriate error-related method.\n\nRequest permission to access location services\n\nBefore you start any location services, you must request authorization from the owner of the device. Location data is sensitive personal information and the owner of a device controls which apps have access. They can grant or deny access to apps separately, and can change an app’s access at any time in system settings.\n\nBefore you request access, check your app’s current authorization status to see if a request is necessary. When you assign a delegate object to your location manager, the location-manager object calls the delegate’s locationManagerDidChangeAuthorization(_:) method to report your app’s current authorization status. If your app’s authorization status is CLAuthorizationStatus.notDetermined, request authorization before you start any location services.\n\nTip\n\nMake authorization requests where your app uses location data, such as from the view controller that displays location-related data. Don’t make requests at launch time or from a part of your app that isn’t connected to location unless absolutely necessary. Someone might not fully understand why your app is asking for authorization and deny the request.\n\nCore Location offers different levels of authorization, and you must choose which level you want and provide some additional information to the system. For detailed information, see Requesting authorization to use location services.\n\nDeclare any location services your app requires\n\nCore Location generates location updates using a combination of Wi-Fi, cellular, and GPS hardware, and it generates compass updates using magnetometer hardware. For location updates, Core Location doesn’t use every piece of hardware every time. You specify the level of precision you want in your CLLocationManager object, and Core Location turns on the hardware it needs to deliver that data in the most power-efficient way.\n\nIf your app can’t function without a particular piece of hardware, add the UIRequiredDeviceCapabilities key to your app’s Info.plist file. The presence of this key tells the App Store to prevent the installation of your app on devices without the specified hardware or capabilities. The value of the key is an array of strings, and you can include one of the following strings for location-related requirements:\n\nlocation-services\n\ngps\n\nmagnetometer\n\nInclude the gps key only if you require the highest level of precision for location data. Typically, only navigation apps require that kind of precision, but other apps might also need it to ensure precise location is available when needed. If your app requires heading information, include the magnetometer key.\n\nDon’t include the UIRequiredDeviceCapabilities key if people can still use your app without location data. For example, don’t include the key if your app uses location data to filter search results for nearby restaurants. When location data isn’t available, you can find alternatives to get you what you need or work without that data. For example, if you want to filter search results by location, you might prompt someone to enter a postal code or other geographic information explicitly.\n\nStart the location services you need\n\nAfter you perform the initial checks and verify the authorization status of your app, start the location services you need. Core Location offers several different ways to access location-related information:\n\nGet the current location. Offer navigation instructions, filter data sets based on location, share someone’s location with friends, or perform other tasks that use someone’s current location. See Getting the current location of a device.\n\nDetect when the device enters or exits a geographical region. Alert someone to points-of-interest, deliver location-sensitive reminders, and more. See Monitoring the user's proximity to geographic regions.\n\nDetermine the current compass heading. Offer course-based navigation or display an onscreen compass. See Getting heading and course information.\n\nDetect nearby iBeacon hardware. Determine someone’s proximity to Bluetooth devices. See Determining the proximity to an iBeacon device.\n\nSee Also\nEssentials\nSupporting live updates in SwiftUI and Mac Catalyst apps\nEnable background events by adding lifecycle event support.\nclass CLLocationManager\nThe object that you use to start and stop the delivery of location-related events to your app.\nclass CLBackgroundActivitySession\nAn object that manages a visual indicator that keeps your app in use in the background, allowing it to receive updates or events.\nstruct CLLocationUpdate\nA structure that contains the location information the framework delivers with each update.\nprotocol CLLocationManagerDelegate\nThe methods that you use to receive events from an associated location-manager object.\nAdopting live updates in Core Location\nSimplify location delivery using asynchronous events in Swift.\nMonitoring location changes with Core Location\nDefine boundaries and act on user location updates."
  },
  {
    "title": "Supporting live updates in SwiftUI and Mac Catalyst apps | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/corelocation/supporting_live_updates_in_swiftui_and_mac_catalyst_apps",
    "html": "Overview\n\nIn iOS 17 and later, Core Location supports live updates using Swift concurrency’s async/await capability. In order to adopt live updates, SwiftUI and Mac Catalyst apps need to implement lifecycle event support that enables an app’s @main app to have explicit support for the creation and resumption of background run-loops. This enables the system to deliver Core Location events to the app and allows the delivery of events to resume in the event of return from background, launch of the app, or relaunch after a crash.\n\nAdding lifecycle events to SwiftUI\n\nTo add support for life cycle events, you need to add three components to your app:\n\nA shared state using an ObservableObject that maintains instances of CLLocationManager and CLBackgroundActivitySession\n\nAn AppDelegate object that provides the application(_:didFinishLaunchingWithOptions:) method that handles resuming background activities on return from background or an app relaunch\n\nAn AppDelegate object in the SwiftUI or Mac Catalyst app’s @main structure\n\nIn your SwiftUI or Mac Catalyst App, add support for the AppDelegate by adding a shared state through an ObservableObject, and a UIApplicationDelegateAdaptor as an object the app’s @main structure maintains, as shown in the following example:\n\n    import SwiftUI\n\n\n    // Shared state that manages the `CLLocationManager` and `CLBackgroundActivitySession`.\n    @MainActor class LocationsHandler: ObservableObject {\n    \n        static let shared = LocationsHandler()  // Create a single, shared instance of the object.\n        private let manager: CLLocationManager\n        private var background: CLBackgroundActivitySession?\n\n\n        @Published var lastLocation = CLLocation()\n        @Published var isStationary = false\n        @Published var count = 0\n    \n        @Published\n        var updatesStarted: Bool = UserDefaults.standard.bool(forKey: \"liveUpdatesStarted\") {\n            didSet { UserDefaults.standard.set(updatesStarted, forKey: \"liveUpdatesStarted\") }\n        }\n    \n        @Published\n        var backgroundActivity: Bool = UserDefaults.standard.bool(forKey: \"BGActivitySessionStarted\") {\n            didSet {\n                backgroundActivity ? self.background = CLBackgroundActivitySession() : self.background?.invalidate()\n                UserDefaults.standard.set(backgroundActivity, forKey: \"BGActivitySessionStarted\")\n            }\n        }\n    \n    \n        private init() {\n            self.manager = CLLocationManager()  // Creating a location manager instance is safe to call here in `MainActor`.\n        }\n    \n        func startLocationUpdates() {\n            if self.manager.authorizationStatus == .notDetermined {\n                self.manager.requestWhenInUseAuthorization()\n            }\n            self.logger.info(\"Starting location updates\")\n            Task() {\n                do {\n                    self.updatesStarted = true\n                    let updates = CLLocationUpdate.liveUpdates()\n                    for try await update in updates {\n                        if !self.updatesStarted { break }  // End location updates by breaking out of the loop.\n                        if let loc = update.location {\n                            self.lastLocation = loc\n                            self.isStationary = update.isStationary\n                            self.count += 1\n                            print(\"Location \\(self.count): \\(self.lastLocation)\")\n                        }\n                    }\n                } catch {\n                    print(\"Could not start location updates\")\n                }\n                return\n            }\n        }\n    \n        func stopLocationUpdates() {\n            print(\"Stopping location updates\")\n            self.updatesStarted = false\n            self.updatesStarted = false\n        } \n    }\n\n\nNext, create an instance of a UIKit AppDelegate class that conforms to SwiftUI’s ObservableObject protocol; this enables the AppDelegate to participate in the SwiftUI’s app-level shared state and manages the resumption of Core Location activities when needed.\n\n    import Foundation\n    import UIKit\n\n\n    class AppDelegate: NSObject, UIApplicationDelegate, ObservableObject {   \n    \n        func application(_ application: UIApplication, didFinishLaunchingWithOptions\n                         launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {\n            let locationsHandler = LocationsHandler.shared\n        \n            // If location updates were previously active, restart them after the background launch.\n            if locationsHandler.updatesStarted {\n                locationsHandler.startLocationUpdates()\n            }\n            // If a background activity session was previously active, reinstantiate it after the background launch.\n            if locationsHandler.backgroundActivity {\n                locationsHandler.backgroundActivity = true\n            }\n            return true\n        }\n    }\n\n\nFinally, include the AppDelegate functionality in your app’s @main structure using a UIApplicationDelegateAdaptor:\n\n    @main\n    struct MyApp: App {\n        @UIApplicationDelegateAdaptor private var appDelegate: AppDelegate\n        var body: some Scene {\n            WindowGroup {\n                ContentView()\n            }\n        }\n    }\n\n\nSee Also\nEssentials\nConfiguring your app to use location services\nVerify that location services are available and configure your app before you start collecting location data.\nclass CLLocationManager\nThe object that you use to start and stop the delivery of location-related events to your app.\nclass CLBackgroundActivitySession\nAn object that manages a visual indicator that keeps your app in use in the background, allowing it to receive updates or events.\nstruct CLLocationUpdate\nA structure that contains the location information the framework delivers with each update.\nprotocol CLLocationManagerDelegate\nThe methods that you use to receive events from an associated location-manager object.\nAdopting live updates in Core Location\nSimplify location delivery using asynchronous events in Swift.\nMonitoring location changes with Core Location\nDefine boundaries and act on user location updates."
  },
  {
    "title": "Core Location | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/CoreLocation",
    "html": "Overview\n\nCore Location provides services that determine a device’s geographic location, altitude, and orientation, or its position relative to a nearby iBeacon device. The framework gathers data using all available components on the device, including the Wi-Fi, GPS, Bluetooth, magnetometer, barometer, and cellular hardware.\n\nYou use instances of the CLLocationManager class to configure, start, and stop the Core Location services. A location manager object supports the following location-related activities:\n\nStandard and significant location updates. Track large or small changes in the user’s current location with a configurable degree of accuracy.\n\nRegion monitoring. Monitor distinct regions of interest and generate location events when the user enters or leaves those regions.\n\nBeacon ranging. Detect and locate nearby beacons.\n\nCompass headings. Report heading changes from the onboard compass.\n\nTo use location services, your app requests authorization and the system prompts the user to grant or deny the request. An initial prompt is shown in Figure 1.\n\nOn iOS devices, users can change location service settings at any time in the Settings app, affecting individual apps or the device as a whole. Your app receives events, including authorization changes, in your location manager's delegate object, which conforms to the CLLocationManagerDelegate protocol.\n\nTopics\nEssentials\nConfiguring your app to use location services\nVerify that location services are available and configure your app before you start collecting location data.\nSupporting live updates in SwiftUI and Mac Catalyst apps\nEnable background events by adding lifecycle event support.\nclass CLLocationManager\nThe object that you use to start and stop the delivery of location-related events to your app.\nclass CLBackgroundActivitySession\nAn object that manages a visual indicator that keeps your app in use in the background, allowing it to receive updates or events.\nstruct CLLocationUpdate\nA structure that contains the location information the framework delivers with each update.\nprotocol CLLocationManagerDelegate\nThe methods that you use to receive events from an associated location-manager object.\nAdopting live updates in Core Location\nSimplify location delivery using asynchronous events in Swift.\nMonitoring location changes with Core Location\nDefine boundaries and act on user location updates.\nAuthorization\nRequesting authorization to use location services\nObtain authorization to use location services and manage changes to your app’s authorization status.\nenum CLAuthorizationStatus\nConstants indicating the app's authorization to use location services.\nenum CLAccuracyAuthorization\nConstants indicating the level of location accuracy the app has authorization to use.\nproperty list key NSLocationAlwaysAndWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information at all times.\nName: Privacy - Location Always and When In Use Usage Description\nproperty list key NSLocationWhenInUseUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information while the app is running in the foreground.\nName: Privacy - Location When In Use Usage Description\nproperty list key NSLocationUsageDescription\nA message that tells the user why the app is requesting access to the user’s location information.\nName: Privacy - Location Usage Description\nproperty list key NSLocationDefaultAccuracyReduced\nA Boolean value that indicates whether the app requests reduced location accuracy by default.\nName: Privacy - Location Default Accuracy Reduced\nproperty list key NSLocationAlwaysUsageDescription\nA message that tells the user why the app is requesting access to the user's location at all times.\nName: Privacy - Location Always Usage Description\nDeprecated\nMonitoring\nclass CLMonitor\nAn object that monitors the conditions you add to it.\nLocation updates\nGetting the current location of a device\nStart location services and provide information the system needs to optimize power usage for those services.\nHandling location updates in the background\nConfigure your app to receive location updates when it isn’t running in the foreground.\nCreating a location push service extension\nAdd and configure an extension to enable your location sharing app to access a user’s location in response to a request from another user.\nclass CLLocation\nThe latitude, longitude, and course information reported by the system.\nstruct CLLocationCoordinate2D\nThe latitude and longitude associated with a location, specified using the WGS 84 reference frame.\nclass CLFloor\nThe floor of a building on which the user's device is located.\nclass CLVisit\nInformation about the user's location during a specific period of time.\nclass CLLocationSourceInformation\nInformation about the source that provides a location.\nRegion monitoring\nConfigure geofences and receive notifications when the user's device crosses the fence's boundaries.\nMonitoring the user's proximity to geographic regions\nUse region monitoring to determine when the user enters or leaves a geographic region.\nclass CLRegion\nA base class representing an area that can be monitored.\niBeacon\nRanging for Beacons\nConfigure a device to act as a beacon and to detect surrounding beacons.\nDetermining the proximity to an iBeacon device\nDetect beacons and determine the relative distance to them.\nTurning an iOS device into an iBeacon device\nBroadcast iBeacon signals from an iOS device.\nclass CLBeacon\nInformation about an observed iBeacon device and its relative distance to the user’s device.\nprotocol CLCondition\nThe abstract base class for all other monitor conditions.\nCompass headings\nDetermine the device’s orientation relative to magnetic or true north.\nGetting heading and course information\nUse a device’s orientation and course information for navigation.\nclass CLHeading\nThe azimuth (orientation) of the user’s device, relative to true or magnetic north.\nGeocoding\nConverting between coordinates and user-friendly place names\nConvert between a latitude/longitude pair and a more user-friendly description of that location.\nConverting a user's location to a descriptive placemark\nTransform the user’s location that displays on a map into an informative textual description by reverse geocoding.\nclass CLGeocoder\nAn interface for converting between geographic coordinates and place names.\nclass CLPlacemark\nA user-friendly description of a geographic coordinate, often containing the name of the place, its address, and other relevant information.\nLocation push service extension\ncom.apple.developer.location.push\nAn entitlement to enable a location sharing app to query someone’s location in response to a push notification.\nprotocol CLLocationPushServiceExtension\nThe interface you adopt in the type that acts as the main entry point for a Location Push Service Extension.\nstruct CLLocationPushServiceError\nError codes the location manager returns if starting to monitor for location push notifications fails.\nlet CLLocationPushServiceErrorDomain: String\nThe domain for Location Push Service Extension errors.\nenum CLLocationPushServiceError.Code\nError codes the location manager returns if starting to monitor for location push notifications fails.\nErrors\nstruct CLError\nA Core Location error.\nlet kCLErrorDomain: String\nThe domain for Core Location errors.\nlet kCLErrorUserInfoAlternateRegionKey: String\nA key in the user information dictionary of an error relating to a delayed region monitoring response.\nDeprecated\nDeprecated\nReference\nCore Location Constants\nCore Location Functions\nSee Also\nRelated Documentation\nLocation and Maps Programming Guide"
  }
]