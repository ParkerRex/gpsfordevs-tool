[
  {
    "title": "formSymmetricDifference(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/formsymmetricdifference(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a ^ (bitwise XOR) operation on the two sets’ raw values."
  },
  {
    "title": "update(with:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/update(with:)",
    "html": "Return Value\n\nThe intersection of [newMember] and the set if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIf newMember is not contained in the set but subsumes current members of the set, the subsumed members are returned.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet replaced = options.update(with: .express)\nprint(replaced == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "formUnion(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/formunion(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a | (bitwise OR) operation on the two sets’ raw values."
  },
  {
    "title": "symmetricDifference(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/symmetricdifference(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in either this set or other, but not in both."
  },
  {
    "title": "remove(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/remove(_:)",
    "html": "Parameters\nmember\n\nThe element of the set to remove.\n\nReturn Value\n\nThe intersection of [member] and the set, if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIn the following example, the .priority shipping option is removed from the options option set. Attempting to remove the same shipping option a second time results in nil, because options no longer contains .priority as a member.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet priorityOption = options.remove(.priority)\nprint(priorityOption == .priority)\n// Prints \"true\"\n\n\nprint(options.remove(.priority))\n// Prints \"nil\"\n\n\nIn the next example, the .express element is passed to remove(_:). Although .express is not a member of options, .express subsumes the remaining .secondDay element of the option set. Therefore, options is emptied and the intersection between .express and options is returned.\n\nlet expressOption = options.remove(.express)\nprint(expressOption == .express)\n// Prints \"false\"\nprint(expressOption == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "formIntersection(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/formintersection(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a & (bitwise AND) operation on the two sets’ raw values."
  },
  {
    "title": "formIntersection(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/formintersection(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a & (bitwise AND) operation on the two sets’ raw values."
  },
  {
    "title": "union(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/union(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set made up of the elements contained in this set, in other, or in both.\n\nDiscussion\n\nThis example uses the union(_:) method to add two more shipping options to the default set.\n\nlet defaultShipping = ShippingOptions.standard\nlet memberShipping = defaultShipping.union([.secondDay, .priority])\nprint(memberShipping.contains(.priority))\n// Prints \"true\"\n"
  },
  {
    "title": "intersection(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/intersection(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in both this set and other.\n\nDiscussion\n\nThis example uses the intersection(_:) method to limit the available shipping options to what can be used with a PO Box destination.\n\n// Can only ship standard or priority to PO Boxes\nlet poboxShipping: ShippingOptions = [.standard, .priority]\nlet memberShipping: ShippingOptions =\n        [.standard, .priority, .secondDay]\n\n\nlet availableOptions = memberShipping.intersection(poboxShipping)\nprint(availableOptions.contains(.priority))\n// Prints \"true\"\nprint(availableOptions.contains(.secondDay))\n// Prints \"false\"\n"
  },
  {
    "title": "insert(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/insert(_:)",
    "html": "Parameters\nnewMember\n\nThe element to insert.\n\nReturn Value\n\n(true, newMember) if newMember was not contained in self. Otherwise, returns (false, oldMember), where oldMember is the member of the set equal to newMember.\n\nDiscussion\n\nIn the following example, the .secondDay shipping option is added to the freeOptions option set if purchasePrice is greater than 50.0. For the ShippingOptions declaration, see the OptionSet protocol discussion.\n\nlet purchasePrice = 87.55\n\n\nvar freeOptions: ShippingOptions = [.standard, .priority]\nif purchasePrice > 50 {\n    freeOptions.insert(.secondDay)\n}\nprint(freeOptions.contains(.secondDay))\n// Prints \"true\"\n"
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/contains(_:)",
    "html": "Parameters\nmember\n\nThe element to look for in the option set.\n\nReturn Value\n\ntrue if the option set contains member; otherwise, false.\n\nDiscussion\n\nThis example uses the contains(_:) method to check whether next-day shipping is in the availableOptions instance.\n\nlet availableOptions = ShippingOptions.express\nif availableOptions.contains(.nextDay) {\n    print(\"Next day shipping available\")\n}\n// Prints \"Next day shipping available\"\n"
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/init()",
    "html": "Discussion\n\nThis initializer creates an option set with a raw value of zero."
  },
  {
    "title": "formUnion(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/formunion(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a | (bitwise OR) operation on the two sets’ raw values."
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/init()",
    "html": "Discussion\n\nThis initializer creates an option set with a raw value of zero."
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/contains(_:)",
    "html": "Parameters\nmember\n\nThe element to look for in the option set.\n\nReturn Value\n\ntrue if the option set contains member; otherwise, false.\n\nDiscussion\n\nThis example uses the contains(_:) method to check whether next-day shipping is in the availableOptions instance.\n\nlet availableOptions = ShippingOptions.express\nif availableOptions.contains(.nextDay) {\n    print(\"Next day shipping available\")\n}\n// Prints \"Next day shipping available\"\n"
  },
  {
    "title": "insert(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/insert(_:)",
    "html": "Parameters\nnewMember\n\nThe element to insert.\n\nReturn Value\n\n(true, newMember) if newMember was not contained in self. Otherwise, returns (false, oldMember), where oldMember is the member of the set equal to newMember.\n\nDiscussion\n\nIn the following example, the .secondDay shipping option is added to the freeOptions option set if purchasePrice is greater than 50.0. For the ShippingOptions declaration, see the OptionSet protocol discussion.\n\nlet purchasePrice = 87.55\n\n\nvar freeOptions: ShippingOptions = [.standard, .priority]\nif purchasePrice > 50 {\n    freeOptions.insert(.secondDay)\n}\nprint(freeOptions.contains(.secondDay))\n// Prints \"true\"\n"
  },
  {
    "title": "formSymmetricDifference(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/formsymmetricdifference(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a ^ (bitwise XOR) operation on the two sets’ raw values."
  },
  {
    "title": "symmetricDifference(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/symmetricdifference(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in either this set or other, but not in both."
  },
  {
    "title": "isStrictSubset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/isstrictsubset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict subset of another set B if every member of A is also a member of B and B contains at least one element that is not a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isStrictSubset(of: employees))\n// Prints \"true\"\n\n\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints \"false\"\n"
  },
  {
    "title": "subtract(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/subtract(_:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nDiscussion\n\nIn the following example, the elements of the employees set that are also members of the neighbors set are removed. In particular, the names \"Bethany\" and \"Eric\" are removed from employees.\n\nvar employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "subtracting(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/subtracting(_:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\nA new set.\n\nDiscussion\n\nIn the following example, the nonNeighbors set is made up of the elements of the employees set that are not elements of neighbors:\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "isDisjoint(with:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/isdisjoint(with:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set has no elements in common with other; otherwise, false.\n\nDiscussion\n\nIn the following example, the employees set is disjoint with the visitors set because no name appears in both sets.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet visitors: Set = [\"Marcia\", \"Nathaniel\", \"Olivia\"]\nprint(employees.isDisjoint(with: visitors))\n// Prints \"true\"\n"
  },
  {
    "title": "isSubset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/issubset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a subset of another set B if every member of A is also a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isSubset(of: employees))\n// Prints \"true\"\n"
  },
  {
    "title": "subtracting(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/subtracting(_:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\nA new set.\n\nDiscussion\n\nIn the following example, the nonNeighbors set is made up of the elements of the employees set that are not elements of neighbors:\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "init(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/init(_:)",
    "html": "Parameters\nsequence\n\nThe elements to use as members of the new set.\n\nDiscussion\n\nUse this initializer to create a new set from an existing sequence, like an array or a range:\n\nlet validIndices = Set(0..<7).subtracting([2, 4, 5])\nprint(validIndices)\n// Prints \"[6, 0, 1, 3]\"\n"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "init(arrayLiteral:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/init(arrayliteral:)",
    "html": "Parameters\narrayLiteral\n\nA list of elements of the new set.\n\nDiscussion\n\nDo not call this initializer directly. It is used by the compiler when you use an array literal. Instead, create a new set using an array literal as its value by enclosing a comma-separated list of values in square brackets. You can use an array literal anywhere a set is expected by the type context.\n\nHere, a set of strings is created from an array literal holding only strings:\n\nlet ingredients: Set = [\"cocoa beans\", \"sugar\", \"cocoa butter\", \"salt\"]\nif ingredients.isSuperset(of: [\"sugar\", \"salt\"]) {\n    print(\"Whatever it is, it's bound to be delicious!\")\n}\n// Prints \"Whatever it is, it's bound to be delicious!\"\n"
  },
  {
    "title": "remove(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/remove(_:)",
    "html": "Parameters\nmember\n\nThe element of the set to remove.\n\nReturn Value\n\nThe intersection of [member] and the set, if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIn the following example, the .priority shipping option is removed from the options option set. Attempting to remove the same shipping option a second time results in nil, because options no longer contains .priority as a member.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet priorityOption = options.remove(.priority)\nprint(priorityOption == .priority)\n// Prints \"true\"\n\n\nprint(options.remove(.priority))\n// Prints \"nil\"\n\n\nIn the next example, the .express element is passed to remove(_:). Although .express is not a member of options, .express subsumes the remaining .secondDay element of the option set. Therefore, options is emptied and the intersection between .express and options is returned.\n\nlet expressOption = options.remove(.express)\nprint(expressOption == .express)\n// Prints \"false\"\nprint(expressOption == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "update(with:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/update(with:)",
    "html": "Return Value\n\nThe intersection of [newMember] and the set if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIf newMember is not contained in the set but subsumes current members of the set, the subsumed members are returned.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet replaced = options.update(with: .express)\nprint(replaced == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "union(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/union(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set made up of the elements contained in this set, in other, or in both.\n\nDiscussion\n\nThis example uses the union(_:) method to add two more shipping options to the default set.\n\nlet defaultShipping = ShippingOptions.standard\nlet memberShipping = defaultShipping.union([.secondDay, .priority])\nprint(memberShipping.contains(.priority))\n// Prints \"true\"\n"
  },
  {
    "title": "isSuperset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/issuperset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a superset of another set B if every member of B is also a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isSuperset(of: attendees))\n// Prints \"true\"\n"
  },
  {
    "title": "init(arrayLiteral:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/init(arrayliteral:)",
    "html": "Parameters\narrayLiteral\n\nA list of elements of the new set.\n\nDiscussion\n\nDo not call this initializer directly. It is used by the compiler when you use an array literal. Instead, create a new set using an array literal as its value by enclosing a comma-separated list of values in square brackets. You can use an array literal anywhere a set is expected by the type context.\n\nHere, a set of strings is created from an array literal holding only strings:\n\nlet ingredients: Set = [\"cocoa beans\", \"sugar\", \"cocoa butter\", \"salt\"]\nif ingredients.isSuperset(of: [\"sugar\", \"salt\"]) {\n    print(\"Whatever it is, it's bound to be delicious!\")\n}\n// Prints \"Whatever it is, it's bound to be delicious!\"\n"
  },
  {
    "title": "isSuperset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/issuperset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a superset of another set B if every member of B is also a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isSuperset(of: attendees))\n// Prints \"true\"\n"
  },
  {
    "title": "isStrictSuperset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/isstrictsuperset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict superset of another set B if every member of B is also a member of A and A contains at least one element that is not a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints \"true\"\n\n\n// A set is never a strict superset of itself:\nprint(employees.isStrictSuperset(of: employees))\n// Prints \"false\"\n"
  },
  {
    "title": "OptionSet Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/optionset-implementations",
    "html": "Topics\nInitializers\ninit()\nCreates an empty option set.\nAvailable when RawValue conforms to FixedWidthInteger.\nInstance Methods\nfunc contains(Self) -> Bool\nReturns a Boolean value that indicates whether a given element is a member of the option set.\nAvailable when Self is Self.Element.\nfunc formIntersection(Self)\nRemoves all elements of this option set that are not also present in the given set.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc formSymmetricDifference(Self)\nReplaces this set with a new set containing all elements contained in either this set or the given set, but not in both.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc formUnion(Self)\nInserts the elements of another set into this option set.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc insert(Self.Element) -> (inserted: Bool, memberAfterInsert: Self.Element)\nAdds the given element to the option set if it is not already a member.\nAvailable when Self is Self.Element.\nfunc intersection(Self) -> Self\nReturns a new option set with only the elements contained in both this set and the given set.\nfunc remove(Self.Element) -> Self.Element?\nRemoves the given element and all elements subsumed by it.\nAvailable when Self is Self.Element.\nfunc symmetricDifference(Self) -> Self\nReturns a new option set with the elements contained in this set or in the given set, but not in both.\nfunc union(Self) -> Self\nReturns a new option set of the elements contained in this set, in the given set, or in both.\nfunc update(with: Self.Element) -> Self.Element?\nInserts the given element into the set.\nAvailable when Self is Self.Element."
  },
  {
    "title": "allowAnnouncement",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/allowannouncement",
    "html": "Discussion\n\nWhen Siri reads an incoming message to the user, Siri reads the message locally on the userʼs device. Siri doesn’t send the message’s contents or sender to Apple servers. For more information about Siri’s on-device processing, visit Apple’s Privacy Page.\n\nSee Also\nCustomizing a category\nstatic var allowInCarPlay: UNNotificationCategoryOptions\nAllow CarPlay to display notifications of this type."
  },
  {
    "title": "formSymmetricDifference(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/formsymmetricdifference(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a ^ (bitwise XOR) operation on the two sets’ raw values."
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/contains(_:)",
    "html": "Parameters\nmember\n\nThe element to look for in the option set.\n\nReturn Value\n\ntrue if the option set contains member; otherwise, false.\n\nDiscussion\n\nThis example uses the contains(_:) method to check whether next-day shipping is in the availableOptions instance.\n\nlet availableOptions = ShippingOptions.express\nif availableOptions.contains(.nextDay) {\n    print(\"Next day shipping available\")\n}\n// Prints \"Next day shipping available\"\n"
  },
  {
    "title": "formUnion(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/formunion(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a | (bitwise OR) operation on the two sets’ raw values."
  },
  {
    "title": "intersection(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/intersection(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in both this set and other.\n\nDiscussion\n\nThis example uses the intersection(_:) method to limit the available shipping options to what can be used with a PO Box destination.\n\n// Can only ship standard or priority to PO Boxes\nlet poboxShipping: ShippingOptions = [.standard, .priority]\nlet memberShipping: ShippingOptions =\n        [.standard, .priority, .secondDay]\n\n\nlet availableOptions = memberShipping.intersection(poboxShipping)\nprint(availableOptions.contains(.priority))\n// Prints \"true\"\nprint(availableOptions.contains(.secondDay))\n// Prints \"false\"\n"
  },
  {
    "title": "formIntersection(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/formintersection(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a & (bitwise AND) operation on the two sets’ raw values."
  },
  {
    "title": "isSuperset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/issuperset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a superset of another set B if every member of B is also a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isSuperset(of: attendees))\n// Prints \"true\"\n"
  },
  {
    "title": "subtract(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/subtract(_:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nDiscussion\n\nIn the following example, the elements of the employees set that are also members of the neighbors set are removed. In particular, the names \"Bethany\" and \"Eric\" are removed from employees.\n\nvar employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "symmetricDifference(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/symmetricdifference(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in either this set or other, but not in both."
  },
  {
    "title": "isSubset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/issubset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a subset of another set B if every member of A is also a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isSubset(of: employees))\n// Prints \"true\"\n"
  },
  {
    "title": "isStrictSubset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/isstrictsubset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict subset of another set B if every member of A is also a member of B and B contains at least one element that is not a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isStrictSubset(of: employees))\n// Prints \"true\"\n\n\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints \"false\"\n"
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/init()",
    "html": "Discussion\n\nThis initializer creates an option set with a raw value of zero."
  },
  {
    "title": "isStrictSuperset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/isstrictsuperset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict superset of another set B if every member of B is also a member of A and A contains at least one element that is not a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints \"true\"\n\n\n// A set is never a strict superset of itself:\nprint(employees.isStrictSuperset(of: employees))\n// Prints \"false\"\n"
  },
  {
    "title": "isDisjoint(with:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/isdisjoint(with:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set has no elements in common with other; otherwise, false.\n\nDiscussion\n\nIn the following example, the employees set is disjoint with the visitors set because no name appears in both sets.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet visitors: Set = [\"Marcia\", \"Nathaniel\", \"Olivia\"]\nprint(employees.isDisjoint(with: visitors))\n// Prints \"true\"\n"
  },
  {
    "title": "update(with:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/update(with:)",
    "html": "Return Value\n\nThe intersection of [newMember] and the set if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIf newMember is not contained in the set but subsumes current members of the set, the subsumed members are returned.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet replaced = options.update(with: .express)\nprint(replaced == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "init(arrayLiteral:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/init(arrayliteral:)",
    "html": "Parameters\narrayLiteral\n\nA list of elements of the new set.\n\nDiscussion\n\nDo not call this initializer directly. It is used by the compiler when you use an array literal. Instead, create a new set using an array literal as its value by enclosing a comma-separated list of values in square brackets. You can use an array literal anywhere a set is expected by the type context.\n\nHere, a set of strings is created from an array literal holding only strings:\n\nlet ingredients: Set = [\"cocoa beans\", \"sugar\", \"cocoa butter\", \"salt\"]\nif ingredients.isSuperset(of: [\"sugar\", \"salt\"]) {\n    print(\"Whatever it is, it's bound to be delicious!\")\n}\n// Prints \"Whatever it is, it's bound to be delicious!\"\n"
  },
  {
    "title": "union(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/union(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set made up of the elements contained in this set, in other, or in both.\n\nDiscussion\n\nThis example uses the union(_:) method to add two more shipping options to the default set.\n\nlet defaultShipping = ShippingOptions.standard\nlet memberShipping = defaultShipping.union([.secondDay, .priority])\nprint(memberShipping.contains(.priority))\n// Prints \"true\"\n"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "insert(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/insert(_:)",
    "html": "Parameters\nnewMember\n\nThe element to insert.\n\nReturn Value\n\n(true, newMember) if newMember was not contained in self. Otherwise, returns (false, oldMember), where oldMember is the member of the set equal to newMember.\n\nDiscussion\n\nIn the following example, the .secondDay shipping option is added to the freeOptions option set if purchasePrice is greater than 50.0. For the ShippingOptions declaration, see the OptionSet protocol discussion.\n\nlet purchasePrice = 87.55\n\n\nvar freeOptions: ShippingOptions = [.standard, .priority]\nif purchasePrice > 50 {\n    freeOptions.insert(.secondDay)\n}\nprint(freeOptions.contains(.secondDay))\n// Prints \"true\"\n"
  },
  {
    "title": "remove(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/remove(_:)",
    "html": "Parameters\nmember\n\nThe element of the set to remove.\n\nReturn Value\n\nThe intersection of [member] and the set, if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIn the following example, the .priority shipping option is removed from the options option set. Attempting to remove the same shipping option a second time results in nil, because options no longer contains .priority as a member.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet priorityOption = options.remove(.priority)\nprint(priorityOption == .priority)\n// Prints \"true\"\n\n\nprint(options.remove(.priority))\n// Prints \"nil\"\n\n\nIn the next example, the .express element is passed to remove(_:). Although .express is not a member of options, .express subsumes the remaining .secondDay element of the option set. Therefore, options is emptied and the intersection between .express and options is returned.\n\nlet expressOption = options.remove(.express)\nprint(expressOption == .express)\n// Prints \"false\"\nprint(expressOption == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "intersection(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/intersection(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in both this set and other.\n\nDiscussion\n\nThis example uses the intersection(_:) method to limit the available shipping options to what can be used with a PO Box destination.\n\n// Can only ship standard or priority to PO Boxes\nlet poboxShipping: ShippingOptions = [.standard, .priority]\nlet memberShipping: ShippingOptions =\n        [.standard, .priority, .secondDay]\n\n\nlet availableOptions = memberShipping.intersection(poboxShipping)\nprint(availableOptions.contains(.priority))\n// Prints \"true\"\nprint(availableOptions.contains(.secondDay))\n// Prints \"false\"\n"
  },
  {
    "title": "UNError.Code.notificationInvalidNoDate",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/notificationinvalidnodate",
    "html": "See Also\nConstants\ncase notificationsNotAllowed\nNotifications aren’t allowed.\ncase attachmentInvalidURL\nThe URL for an attachment was invalid.\ncase attachmentUnrecognizedType\nThe file type of an attachment isn’t supported.\ncase attachmentInvalidFileSize\nAn attachment is too large.\ncase attachmentNotInDataStore\nThe specified attachment isn’t in the system data store.\ncase attachmentMoveIntoDataStoreFailed\nAn error occurred when trying to move an attachment to the system data store.\ncase attachmentCorrupt\nThe file for an attachment is corrupt.\ncase notificationInvalidNoContent\nThe notification has no user-facing content, but should.\ncase contentProvidingInvalid\ncase contentProvidingObjectNotAllowed"
  },
  {
    "title": "init(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/init(_:)",
    "html": "Parameters\nsequence\n\nThe elements to use as members of the new set.\n\nDiscussion\n\nUse this initializer to create a new set from an existing sequence, like an array or a range:\n\nlet validIndices = Set(0..<7).subtracting([2, 4, 5])\nprint(validIndices)\n// Prints \"[6, 0, 1, 3]\"\n"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "intersection(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/intersection(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in both this set and other.\n\nDiscussion\n\nThis example uses the intersection(_:) method to limit the available shipping options to what can be used with a PO Box destination.\n\n// Can only ship standard or priority to PO Boxes\nlet poboxShipping: ShippingOptions = [.standard, .priority]\nlet memberShipping: ShippingOptions =\n        [.standard, .priority, .secondDay]\n\n\nlet availableOptions = memberShipping.intersection(poboxShipping)\nprint(availableOptions.contains(.priority))\n// Prints \"true\"\nprint(availableOptions.contains(.secondDay))\n// Prints \"false\"\n"
  },
  {
    "title": "formUnion(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/formunion(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a | (bitwise OR) operation on the two sets’ raw values."
  },
  {
    "title": "formSymmetricDifference(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/formsymmetricdifference(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a ^ (bitwise XOR) operation on the two sets’ raw values."
  },
  {
    "title": "formIntersection(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/formintersection(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a & (bitwise AND) operation on the two sets’ raw values."
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/contains(_:)",
    "html": "Parameters\nmember\n\nThe element to look for in the option set.\n\nReturn Value\n\ntrue if the option set contains member; otherwise, false.\n\nDiscussion\n\nThis example uses the contains(_:) method to check whether next-day shipping is in the availableOptions instance.\n\nlet availableOptions = ShippingOptions.express\nif availableOptions.contains(.nextDay) {\n    print(\"Next day shipping available\")\n}\n// Prints \"Next day shipping available\"\n"
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/init()",
    "html": "Discussion\n\nThis initializer creates an option set with a raw value of zero."
  },
  {
    "title": "subtracting(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/subtracting(_:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\nA new set.\n\nDiscussion\n\nIn the following example, the nonNeighbors set is made up of the elements of the employees set that are not elements of neighbors:\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "subtract(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/subtract(_:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nDiscussion\n\nIn the following example, the elements of the employees set that are also members of the neighbors set are removed. In particular, the names \"Bethany\" and \"Eric\" are removed from employees.\n\nvar employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "isSubset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/issubset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a subset of another set B if every member of A is also a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isSubset(of: employees))\n// Prints \"true\"\n"
  },
  {
    "title": "isStrictSuperset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/isstrictsuperset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict superset of another set B if every member of B is also a member of A and A contains at least one element that is not a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints \"true\"\n\n\n// A set is never a strict superset of itself:\nprint(employees.isStrictSuperset(of: employees))\n// Prints \"false\"\n"
  },
  {
    "title": "isStrictSubset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/isstrictsubset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict subset of another set B if every member of A is also a member of B and B contains at least one element that is not a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isStrictSubset(of: employees))\n// Prints \"true\"\n\n\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints \"false\"\n"
  },
  {
    "title": "isDisjoint(with:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/isdisjoint(with:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set has no elements in common with other; otherwise, false.\n\nDiscussion\n\nIn the following example, the employees set is disjoint with the visitors set because no name appears in both sets.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet visitors: Set = [\"Marcia\", \"Nathaniel\", \"Olivia\"]\nprint(employees.isDisjoint(with: visitors))\n// Prints \"true\"\n"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "init(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/init(_:)",
    "html": "Parameters\nsequence\n\nThe elements to use as members of the new set.\n\nDiscussion\n\nUse this initializer to create a new set from an existing sequence, like an array or a range:\n\nlet validIndices = Set(0..<7).subtracting([2, 4, 5])\nprint(validIndices)\n// Prints \"[6, 0, 1, 3]\"\n"
  },
  {
    "title": "init(dateMatching:repeats:)",
    "url": "https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger/init(datematching:repeats:)",
    "html": "Parameters\ndateComponents\n\nThe temporal information to use when constructing the trigger. Provide only the date components that are relevant for your trigger.\n\nrepeats\n\nSpecify false to deliver the notification one time. Specify true to reschedule the notification request each time the system delivers the notification.\n\nReturn Value\n\nA new calendar trigger based on the specified temporal information.\n\nDiscussion\n\nIf you specify true for the repeats parameter, you must explicitly remove the notification request to stop the delivery of the associated notification. Use the methods of UNUserNotificationCenter to remove notification requests that are no longer needed."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsetting/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unalertstyle/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationstatus/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "SetAlgebra Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/setalgebra-implementations",
    "html": "Topics\nInitializers\ninit<S>(S)\nCreates a new set from a finite sequence of items.\ninit(arrayLiteral: Self.Element...)\nCreates a set containing the elements of the given array literal.\nAvailable when ArrayLiteralElement is Self.Element.\nInstance Properties\nvar isEmpty: Bool\nA Boolean value that indicates whether the set has no elements.\nInstance Methods\nfunc isDisjoint(with: Self) -> Bool\nReturns a Boolean value that indicates whether the set has no members in common with the given set.\nfunc isStrictSubset(of: Self) -> Bool\nReturns a Boolean value that indicates whether this set is a strict subset of the given set.\nfunc isStrictSuperset(of: Self) -> Bool\nReturns a Boolean value that indicates whether this set is a strict superset of the given set.\nfunc isSubset(of: Self) -> Bool\nReturns a Boolean value that indicates whether the set is a subset of another set.\nfunc isSuperset(of: Self) -> Bool\nReturns a Boolean value that indicates whether the set is a superset of the given set.\nfunc subtract(Self)\nRemoves the elements of the given set from this set.\nfunc subtracting(Self) -> Self\nReturns a new set containing the elements of this set that do not occur in the given set."
  },
  {
    "title": "allowInCarPlay",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/allowincarplay",
    "html": "Discussion\n\nApps must be approved for CarPlay overall and then you must enable CarPlay for the notification types you want displayed. If a category doesn’t explicitly contain this option, notifications of that type aren’t displayed in a CarPlay environment.\n\nSee Also\nCustomizing a category\nstatic var allowAnnouncement: UNNotificationCategoryOptions\nAn option that grants Siri permission to read incoming messages out loud when the user has a compatible audio output device connected."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/init(rawvalue:)",
    "html": "Parameters\nrawValue\n\nThe raw unsigned integer value for the notification category options."
  },
  {
    "title": "hiddenPreviewsShowTitle",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/hiddenpreviewsshowtitle",
    "html": "See Also\nManaging hidden preview behavior\nstatic var hiddenPreviewsShowSubtitle: UNNotificationCategoryOptions\nShow the notification’s subtitle, even if the user has disabled notification previews for the app."
  },
  {
    "title": "hiddenPreviewsShowSubtitle",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions/hiddenpreviewsshowsubtitle",
    "html": "See Also\nManaging hidden preview behavior\nstatic var hiddenPreviewsShowTitle: UNNotificationCategoryOptions\nShow the notification’s title, even if the user has disabled notification previews for the app."
  },
  {
    "title": "UNNotificationSetting.notSupported",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsetting/notsupported",
    "html": "See Also\nConstants\ncase disabled\nThe setting is disabled.\ncase enabled\nThe setting is enabled."
  },
  {
    "title": "isSuperset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/issuperset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a superset of another set B if every member of B is also a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isSuperset(of: attendees))\n// Prints \"true\"\n"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unshowpreviewssetting/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "init(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/init(_:)",
    "html": "Parameters\nsequence\n\nThe elements to use as members of the new set.\n\nDiscussion\n\nUse this initializer to create a new set from an existing sequence, like an array or a range:\n\nlet validIndices = Set(0..<7).subtracting([2, 4, 5])\nprint(validIndices)\n// Prints \"[6, 0, 1, 3]\"\n"
  },
  {
    "title": "subtracting(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/subtracting(_:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\nA new set.\n\nDiscussion\n\nIn the following example, the nonNeighbors set is made up of the elements of the employees set that are not elements of neighbors:\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "subtract(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/subtract(_:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nDiscussion\n\nIn the following example, the elements of the employees set that are also members of the neighbors set are removed. In particular, the names \"Bethany\" and \"Eric\" are removed from employees.\n\nvar employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "Error Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/error-implementations",
    "html": "Topics\nInstance Properties\nvar localizedDescription: String\nRetrieve the localized description for this error."
  },
  {
    "title": "insert(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/insert(_:)",
    "html": "Parameters\nnewMember\n\nThe element to insert.\n\nReturn Value\n\n(true, newMember) if newMember was not contained in self. Otherwise, returns (false, oldMember), where oldMember is the member of the set equal to newMember.\n\nDiscussion\n\nIn the following example, the .secondDay shipping option is added to the freeOptions option set if purchasePrice is greater than 50.0. For the ShippingOptions declaration, see the OptionSet protocol discussion.\n\nlet purchasePrice = 87.55\n\n\nvar freeOptions: ShippingOptions = [.standard, .priority]\nif purchasePrice > 50 {\n    freeOptions.insert(.secondDay)\n}\nprint(freeOptions.contains(.secondDay))\n// Prints \"true\"\n"
  },
  {
    "title": "remove(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/remove(_:)",
    "html": "Parameters\nmember\n\nThe element of the set to remove.\n\nReturn Value\n\nThe intersection of [member] and the set, if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIn the following example, the .priority shipping option is removed from the options option set. Attempting to remove the same shipping option a second time results in nil, because options no longer contains .priority as a member.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet priorityOption = options.remove(.priority)\nprint(priorityOption == .priority)\n// Prints \"true\"\n\n\nprint(options.remove(.priority))\n// Prints \"nil\"\n\n\nIn the next example, the .express element is passed to remove(_:). Although .express is not a member of options, .express subsumes the remaining .secondDay element of the option set. Therefore, options is emptied and the intersection between .express and options is returned.\n\nlet expressOption = options.remove(.express)\nprint(expressOption == .express)\n// Prints \"false\"\nprint(expressOption == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "update(with:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/update(with:)",
    "html": "Return Value\n\nThe intersection of [newMember] and the set if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIf newMember is not contained in the set but subsumes current members of the set, the subsumed members are returned.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet replaced = options.update(with: .express)\nprint(replaced == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "union(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/union(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set made up of the elements contained in this set, in other, or in both.\n\nDiscussion\n\nThis example uses the union(_:) method to add two more shipping options to the default set.\n\nlet defaultShipping = ShippingOptions.standard\nlet memberShipping = defaultShipping.union([.secondDay, .priority])\nprint(memberShipping.contains(.priority))\n// Prints \"true\"\n"
  },
  {
    "title": "symmetricDifference(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/symmetricdifference(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in either this set or other, but not in both."
  },
  {
    "title": "dateComponents",
    "url": "https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger/datecomponents",
    "html": "Discussion\n\nUse this property to review the date components associated with this trigger.\n\nSee Also\nGetting the Trigger Information\nfunc nextTriggerDate() -> Date?\nThe next date at which the trigger conditions are met."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsoundname/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "OptionSet Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/optionset-implementations",
    "html": "Topics\nInitializers\ninit()\nCreates an empty option set.\nAvailable when RawValue conforms to FixedWidthInteger.\nInstance Methods\nfunc contains(Self) -> Bool\nReturns a Boolean value that indicates whether a given element is a member of the option set.\nAvailable when Self is Self.Element.\nfunc formIntersection(Self)\nRemoves all elements of this option set that are not also present in the given set.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc formSymmetricDifference(Self)\nReplaces this set with a new set containing all elements contained in either this set or the given set, but not in both.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc formUnion(Self)\nInserts the elements of another set into this option set.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc insert(Self.Element) -> (inserted: Bool, memberAfterInsert: Self.Element)\nAdds the given element to the option set if it is not already a member.\nAvailable when Self is Self.Element.\nfunc intersection(Self) -> Self\nReturns a new option set with only the elements contained in both this set and the given set.\nfunc remove(Self.Element) -> Self.Element?\nRemoves the given element and all elements subsumed by it.\nAvailable when Self is Self.Element.\nfunc symmetricDifference(Self) -> Self\nReturns a new option set with the elements contained in this set or in the given set, but not in both.\nfunc union(Self) -> Self\nReturns a new option set of the elements contained in this set, in the given set, or in both.\nfunc update(with: Self.Element) -> Self.Element?\nInserts the given element into the set.\nAvailable when Self is Self.Element."
  },
  {
    "title": "foreground",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/foreground",
    "html": "Discussion\n\nWhen the user selects an action containing this option, the system brings the app to the foreground, asking the user to unlock the device as needed. Use this option for actions that require the user to interact further with your app. Do not use this option simply to bring your app to the foreground.\n\nSee Also\nConstants\nstatic var authenticationRequired: UNNotificationActionOptions\nThe action can be performed only on an unlocked device.\nstatic var destructive: UNNotificationActionOptions\nThe action performs a destructive task."
  },
  {
    "title": "badgeInputInvalid",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/badgeinputinvalid",
    "html": "See Also\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var contentProvidingObjectNotAllowed: UNError.Code"
  },
  {
    "title": "CustomNSError Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/customnserror-implementations",
    "html": "Topics\nType Properties\nstatic var errorDomain: String\nDefault domain of the error."
  },
  {
    "title": "attachmentMoveIntoDataStoreFailed",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/attachmentmoveintodatastorefailed",
    "html": "See Also\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var contentProvidingObjectNotAllowed: UNError.Code\nstatic var badgeInputInvalid: UNError.Code"
  },
  {
    "title": "contentProvidingObjectNotAllowed",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/contentprovidingobjectnotallowed",
    "html": "See Also\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var badgeInputInvalid: UNError.Code"
  },
  {
    "title": "attachmentCorrupt",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/attachmentcorrupt",
    "html": "See Also\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var contentProvidingObjectNotAllowed: UNError.Code\nstatic var badgeInputInvalid: UNError.Code"
  },
  {
    "title": "notificationInvalidNoContent",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/notificationinvalidnocontent",
    "html": "See Also\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var contentProvidingObjectNotAllowed: UNError.Code\nstatic var badgeInputInvalid: UNError.Code"
  },
  {
    "title": "notificationInvalidNoDate",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/notificationinvalidnodate",
    "html": "See Also\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var contentProvidingObjectNotAllowed: UNError.Code\nstatic var badgeInputInvalid: UNError.Code"
  },
  {
    "title": "contentProvidingInvalid",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/contentprovidinginvalid",
    "html": "See Also\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingObjectNotAllowed: UNError.Code\nstatic var badgeInputInvalid: UNError.Code"
  },
  {
    "title": "localizedDescription",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/localizeddescription",
    "html": "See Also\nError Information\nstatic var errorDomain: String\nDefault domain of the error.\nlet UNErrorDomain: String\nThe error domain for notifications.\nenum Code\nConstants that identify notification errors."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "errorDomain",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/errordomain-7a20x",
    "html": "See Also\nError Information\nvar localizedDescription: String\nRetrieve the localized description for this error.\nlet UNErrorDomain: String\nThe error domain for notifications.\nenum Code\nConstants that identify notification errors."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationinterruptionlevel/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "isSubset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/issubset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a subset of another set B if every member of A is also a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isSubset(of: employees))\n// Prints \"true\"\n"
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "UNAlertStyle.none",
    "url": "https://developer.apple.com/documentation/usernotifications/unalertstyle/none",
    "html": "See Also\nPresentation Styles\ncase banner\nBanner alerts.\ncase alert\nModal alerts."
  },
  {
    "title": "RawRepresentable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsetting/rawrepresentable-implementations",
    "html": "Topics\nInstance Properties\nvar hashValue: Int\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable.\nInstance Methods\nfunc hash(into: inout Hasher)\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable."
  },
  {
    "title": "RawRepresentable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/rawrepresentable-implementations",
    "html": "Topics\nInstance Properties\nvar hashValue: Int\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable.\nInstance Methods\nfunc hash(into: inout Hasher)\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsetting/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "UNNotificationSetting.disabled",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsetting/disabled",
    "html": "See Also\nConstants\ncase notSupported\nThe setting is not available to your app.\ncase enabled\nThe setting is enabled."
  },
  {
    "title": "UNAuthorizationStatus.notDetermined",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationstatus/notdetermined",
    "html": "See Also\nStatus\ncase denied\nThe app isn’t authorized to schedule or receive notifications.\ncase authorized\nThe app is authorized to schedule or receive notifications.\ncase provisional\nThe application is provisionally authorized to post noninterruptive user notifications.\ncase ephemeral\nThe app is authorized to schedule or receive notifications for a limited amount of time."
  },
  {
    "title": "isStrictSubset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/isstrictsubset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict subset of another set B if every member of A is also a member of B and B contains at least one element that is not a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isStrictSubset(of: employees))\n// Prints \"true\"\n\n\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints \"false\"\n"
  },
  {
    "title": "UNAuthorizationStatus.denied",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationstatus/denied",
    "html": "See Also\nStatus\ncase notDetermined\nThe user hasn’t yet made a choice about whether the app is allowed to schedule notifications.\ncase authorized\nThe app is authorized to schedule or receive notifications.\ncase provisional\nThe application is provisionally authorized to post noninterruptive user notifications.\ncase ephemeral\nThe app is authorized to schedule or receive notifications for a limited amount of time."
  },
  {
    "title": "isStrictSuperset(of:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/isstrictsuperset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict superset of another set B if every member of B is also a member of A and A contains at least one element that is not a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints \"true\"\n\n\n// A set is never a strict superset of itself:\nprint(employees.isStrictSuperset(of: employees))\n// Prints \"false\"\n"
  },
  {
    "title": "UNAuthorizationStatus.authorized",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationstatus/authorized",
    "html": "See Also\nStatus\ncase notDetermined\nThe user hasn’t yet made a choice about whether the app is allowed to schedule notifications.\ncase denied\nThe app isn’t authorized to schedule or receive notifications.\ncase provisional\nThe application is provisionally authorized to post noninterruptive user notifications.\ncase ephemeral\nThe app is authorized to schedule or receive notifications for a limited amount of time."
  },
  {
    "title": "init(arrayLiteral:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/init(arrayliteral:)",
    "html": "Parameters\narrayLiteral\n\nA list of elements of the new set.\n\nDiscussion\n\nDo not call this initializer directly. It is used by the compiler when you use an array literal. Instead, create a new set using an array literal as its value by enclosing a comma-separated list of values in square brackets. You can use an array literal anywhere a set is expected by the type context.\n\nHere, a set of strings is created from an array literal holding only strings:\n\nlet ingredients: Set = [\"cocoa beans\", \"sugar\", \"cocoa butter\", \"salt\"]\nif ingredients.isSuperset(of: [\"sugar\", \"salt\"]) {\n    print(\"Whatever it is, it's bound to be delicious!\")\n}\n// Prints \"Whatever it is, it's bound to be delicious!\"\n"
  },
  {
    "title": "isDisjoint(with:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/isdisjoint(with:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set has no elements in common with other; otherwise, false.\n\nDiscussion\n\nIn the following example, the employees set is disjoint with the visitors set because no name appears in both sets.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet visitors: Set = [\"Marcia\", \"Nathaniel\", \"Olivia\"]\nprint(employees.isDisjoint(with: visitors))\n// Prints \"true\"\n"
  },
  {
    "title": "badge",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/badge",
    "html": "Discussion\n\nWhen the number in this property is 0, the system doesn’t display a badge. When the number is greater than 0, the system displays the badge with the specified number. When the value in this property is nil, the system leaves the current badge unchanged.\n\nSee Also\nReading app configuration\nvar launchImageName: String\nThe name of the image or storyboard to use when your app launches because of the notification.\nvar targetContentIdentifier: String?\nThe value your app uses to determine which scene to display to handle the notification."
  },
  {
    "title": "UNNotificationInterruptionLevel.critical",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationinterruptionlevel/critical",
    "html": "Discussion\n\nThis interruption level requires an approved entitlement. The system always presents this notification, even when Do Not Disturb is active. If your app doesn’t assign a sound to this notification, the system uses the default critical alert sound.\n\nSee Also\nEnumeration Cases\ncase active\nThe system presents the notification immediately, lights up the screen, and can play a sound.\ncase passive\nThe system adds the notification to the notification list without lighting up the screen or playing a sound.\ncase timeSensitive\nThe system presents the notification immediately, lights up the screen, can play a sound, and breaks through system notification controls."
  },
  {
    "title": "UNNotificationInterruptionLevel.active",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationinterruptionlevel/active",
    "html": "Discussion\n\nThis is the default interruption level. Active notifications won’t break through system notification controls.\n\nSee Also\nEnumeration Cases\ncase critical\nThe system presents the notification immediately, lights up the screen, and bypasses the mute switch to play a sound.\ncase passive\nThe system adds the notification to the notification list without lighting up the screen or playing a sound.\ncase timeSensitive\nThe system presents the notification immediately, lights up the screen, can play a sound, and breaks through system notification controls."
  },
  {
    "title": "UNError.Code.contentProvidingObjectNotAllowed",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/contentprovidingobjectnotallowed",
    "html": "See Also\nConstants\ncase notificationsNotAllowed\nNotifications aren’t allowed.\ncase attachmentInvalidURL\nThe URL for an attachment was invalid.\ncase attachmentUnrecognizedType\nThe file type of an attachment isn’t supported.\ncase attachmentInvalidFileSize\nAn attachment is too large.\ncase attachmentNotInDataStore\nThe specified attachment isn’t in the system data store.\ncase attachmentMoveIntoDataStoreFailed\nAn error occurred when trying to move an attachment to the system data store.\ncase attachmentCorrupt\nThe file for an attachment is corrupt.\ncase notificationInvalidNoDate\nThe notification doesn’t have an associated date, but should.\ncase notificationInvalidNoContent\nThe notification has no user-facing content, but should.\ncase contentProvidingInvalid"
  },
  {
    "title": "RawRepresentable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unshowpreviewssetting/rawrepresentable-implementations",
    "html": "Topics\nInstance Properties\nvar hashValue: Int\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable.\nInstance Methods\nfunc hash(into: inout Hasher)\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable."
  },
  {
    "title": "UNError.Code.attachmentCorrupt",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/attachmentcorrupt",
    "html": "See Also\nConstants\ncase notificationsNotAllowed\nNotifications aren’t allowed.\ncase attachmentInvalidURL\nThe URL for an attachment was invalid.\ncase attachmentUnrecognizedType\nThe file type of an attachment isn’t supported.\ncase attachmentInvalidFileSize\nAn attachment is too large.\ncase attachmentNotInDataStore\nThe specified attachment isn’t in the system data store.\ncase attachmentMoveIntoDataStoreFailed\nAn error occurred when trying to move an attachment to the system data store.\ncase notificationInvalidNoDate\nThe notification doesn’t have an associated date, but should.\ncase notificationInvalidNoContent\nThe notification has no user-facing content, but should.\ncase contentProvidingInvalid\ncase contentProvidingObjectNotAllowed"
  },
  {
    "title": "UNError.Code.notificationInvalidNoContent",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/notificationinvalidnocontent",
    "html": "See Also\nConstants\ncase notificationsNotAllowed\nNotifications aren’t allowed.\ncase attachmentInvalidURL\nThe URL for an attachment was invalid.\ncase attachmentUnrecognizedType\nThe file type of an attachment isn’t supported.\ncase attachmentInvalidFileSize\nAn attachment is too large.\ncase attachmentNotInDataStore\nThe specified attachment isn’t in the system data store.\ncase attachmentMoveIntoDataStoreFailed\nAn error occurred when trying to move an attachment to the system data store.\ncase attachmentCorrupt\nThe file for an attachment is corrupt.\ncase notificationInvalidNoDate\nThe notification doesn’t have an associated date, but should.\ncase contentProvidingInvalid\ncase contentProvidingObjectNotAllowed"
  },
  {
    "title": "UNError.Code.contentProvidingInvalid",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/contentprovidinginvalid",
    "html": "See Also\nConstants\ncase notificationsNotAllowed\nNotifications aren’t allowed.\ncase attachmentInvalidURL\nThe URL for an attachment was invalid.\ncase attachmentUnrecognizedType\nThe file type of an attachment isn’t supported.\ncase attachmentInvalidFileSize\nAn attachment is too large.\ncase attachmentNotInDataStore\nThe specified attachment isn’t in the system data store.\ncase attachmentMoveIntoDataStoreFailed\nAn error occurred when trying to move an attachment to the system data store.\ncase attachmentCorrupt\nThe file for an attachment is corrupt.\ncase notificationInvalidNoDate\nThe notification doesn’t have an associated date, but should.\ncase notificationInvalidNoContent\nThe notification has no user-facing content, but should.\ncase contentProvidingObjectNotAllowed"
  },
  {
    "title": "UNError.Code.attachmentNotInDataStore",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/attachmentnotindatastore",
    "html": "See Also\nConstants\ncase notificationsNotAllowed\nNotifications aren’t allowed.\ncase attachmentInvalidURL\nThe URL for an attachment was invalid.\ncase attachmentUnrecognizedType\nThe file type of an attachment isn’t supported.\ncase attachmentInvalidFileSize\nAn attachment is too large.\ncase attachmentMoveIntoDataStoreFailed\nAn error occurred when trying to move an attachment to the system data store.\ncase attachmentCorrupt\nThe file for an attachment is corrupt.\ncase notificationInvalidNoDate\nThe notification doesn’t have an associated date, but should.\ncase notificationInvalidNoContent\nThe notification has no user-facing content, but should.\ncase contentProvidingInvalid\ncase contentProvidingObjectNotAllowed"
  },
  {
    "title": "UNError.Code.attachmentMoveIntoDataStoreFailed",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/attachmentmoveintodatastorefailed",
    "html": "See Also\nConstants\ncase notificationsNotAllowed\nNotifications aren’t allowed.\ncase attachmentInvalidURL\nThe URL for an attachment was invalid.\ncase attachmentUnrecognizedType\nThe file type of an attachment isn’t supported.\ncase attachmentInvalidFileSize\nAn attachment is too large.\ncase attachmentNotInDataStore\nThe specified attachment isn’t in the system data store.\ncase attachmentCorrupt\nThe file for an attachment is corrupt.\ncase notificationInvalidNoDate\nThe notification doesn’t have an associated date, but should.\ncase notificationInvalidNoContent\nThe notification has no user-facing content, but should.\ncase contentProvidingInvalid\ncase contentProvidingObjectNotAllowed"
  },
  {
    "title": "UNError.Code.notificationsNotAllowed",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/notificationsnotallowed",
    "html": "Discussion\n\nThis error occurs when you try to submit a notification request and your app or app extension isn’t authorized to schedule notifications.\n\nSee Also\nConstants\ncase attachmentInvalidURL\nThe URL for an attachment was invalid.\ncase attachmentUnrecognizedType\nThe file type of an attachment isn’t supported.\ncase attachmentInvalidFileSize\nAn attachment is too large.\ncase attachmentNotInDataStore\nThe specified attachment isn’t in the system data store.\ncase attachmentMoveIntoDataStoreFailed\nAn error occurred when trying to move an attachment to the system data store.\ncase attachmentCorrupt\nThe file for an attachment is corrupt.\ncase notificationInvalidNoDate\nThe notification doesn’t have an associated date, but should.\ncase notificationInvalidNoContent\nThe notification has no user-facing content, but should.\ncase contentProvidingInvalid\ncase contentProvidingObjectNotAllowed"
  },
  {
    "title": "UNError.Code.attachmentUnrecognizedType",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/attachmentunrecognizedtype",
    "html": "See Also\nConstants\ncase notificationsNotAllowed\nNotifications aren’t allowed.\ncase attachmentInvalidURL\nThe URL for an attachment was invalid.\ncase attachmentInvalidFileSize\nAn attachment is too large.\ncase attachmentNotInDataStore\nThe specified attachment isn’t in the system data store.\ncase attachmentMoveIntoDataStoreFailed\nAn error occurred when trying to move an attachment to the system data store.\ncase attachmentCorrupt\nThe file for an attachment is corrupt.\ncase notificationInvalidNoDate\nThe notification doesn’t have an associated date, but should.\ncase notificationInvalidNoContent\nThe notification has no user-facing content, but should.\ncase contentProvidingInvalid\ncase contentProvidingObjectNotAllowed"
  },
  {
    "title": "UNError.Code.attachmentInvalidFileSize",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/attachmentinvalidfilesize",
    "html": "See Also\nConstants\ncase notificationsNotAllowed\nNotifications aren’t allowed.\ncase attachmentInvalidURL\nThe URL for an attachment was invalid.\ncase attachmentUnrecognizedType\nThe file type of an attachment isn’t supported.\ncase attachmentNotInDataStore\nThe specified attachment isn’t in the system data store.\ncase attachmentMoveIntoDataStoreFailed\nAn error occurred when trying to move an attachment to the system data store.\ncase attachmentCorrupt\nThe file for an attachment is corrupt.\ncase notificationInvalidNoDate\nThe notification doesn’t have an associated date, but should.\ncase notificationInvalidNoContent\nThe notification has no user-facing content, but should.\ncase contentProvidingInvalid\ncase contentProvidingObjectNotAllowed"
  },
  {
    "title": "UNError.Code.attachmentInvalidURL",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code/attachmentinvalidurl",
    "html": "See Also\nConstants\ncase notificationsNotAllowed\nNotifications aren’t allowed.\ncase attachmentUnrecognizedType\nThe file type of an attachment isn’t supported.\ncase attachmentInvalidFileSize\nAn attachment is too large.\ncase attachmentNotInDataStore\nThe specified attachment isn’t in the system data store.\ncase attachmentMoveIntoDataStoreFailed\nAn error occurred when trying to move an attachment to the system data store.\ncase attachmentCorrupt\nThe file for an attachment is corrupt.\ncase notificationInvalidNoDate\nThe notification doesn’t have an associated date, but should.\ncase notificationInvalidNoContent\nThe notification has no user-facing content, but should.\ncase contentProvidingInvalid\ncase contentProvidingObjectNotAllowed"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsoundname/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "OptionSet Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/optionset-implementations",
    "html": "Topics\nInitializers\ninit()\nCreates an empty option set.\nAvailable when RawValue conforms to FixedWidthInteger.\nInstance Methods\nfunc contains(Self) -> Bool\nReturns a Boolean value that indicates whether a given element is a member of the option set.\nAvailable when Self is Self.Element.\nfunc formIntersection(Self)\nRemoves all elements of this option set that are not also present in the given set.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc formSymmetricDifference(Self)\nReplaces this set with a new set containing all elements contained in either this set or the given set, but not in both.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc formUnion(Self)\nInserts the elements of another set into this option set.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc insert(Self.Element) -> (inserted: Bool, memberAfterInsert: Self.Element)\nAdds the given element to the option set if it is not already a member.\nAvailable when Self is Self.Element.\nfunc intersection(Self) -> Self\nReturns a new option set with only the elements contained in both this set and the given set.\nfunc remove(Self.Element) -> Self.Element?\nRemoves the given element and all elements subsumed by it.\nAvailable when Self is Self.Element.\nfunc symmetricDifference(Self) -> Self\nReturns a new option set with the elements contained in this set or in the given set, but not in both.\nfunc union(Self) -> Self\nReturns a new option set of the elements contained in this set, in the given set, or in both.\nfunc update(with: Self.Element) -> Self.Element?\nInserts the given element into the set.\nAvailable when Self is Self.Element."
  },
  {
    "title": "badge",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/badge",
    "html": "See Also\nConstants\nstatic var banner: UNNotificationPresentationOptions\nPresent the notification as a banner.\nstatic var list: UNNotificationPresentationOptions\nShow the notification in Notification Center.\nstatic var sound: UNNotificationPresentationOptions\nPlay the sound associated with the notification.\nstatic var alert: UNNotificationPresentationOptions\nDisplay the alert using the content provided by the notification.\nDeprecated"
  },
  {
    "title": "SetAlgebra Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/setalgebra-implementations",
    "html": "Topics\nInitializers\ninit<S>(S)\nCreates a new set from a finite sequence of items.\ninit(arrayLiteral: Self.Element...)\nCreates a set containing the elements of the given array literal.\nAvailable when ArrayLiteralElement is Self.Element.\nInstance Properties\nvar isEmpty: Bool\nA Boolean value that indicates whether the set has no elements.\nInstance Methods\nfunc isDisjoint(with: Self) -> Bool\nReturns a Boolean value that indicates whether the set has no members in common with the given set.\nfunc isStrictSubset(of: Self) -> Bool\nReturns a Boolean value that indicates whether this set is a strict subset of the given set.\nfunc isStrictSuperset(of: Self) -> Bool\nReturns a Boolean value that indicates whether this set is a strict superset of the given set.\nfunc isSubset(of: Self) -> Bool\nReturns a Boolean value that indicates whether the set is a subset of another set.\nfunc isSuperset(of: Self) -> Bool\nReturns a Boolean value that indicates whether the set is a superset of the given set.\nfunc subtract(Self)\nRemoves the elements of the given set from this set.\nfunc subtracting(Self) -> Self\nReturns a new set containing the elements of this set that do not occur in the given set."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "announcement",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/announcement",
    "html": "See Also\nDeprecated\nstatic var timeSensitive: UNAuthorizationOptions"
  },
  {
    "title": "timeSensitive",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/timesensitive",
    "html": "See Also\nDeprecated\nstatic var announcement: UNAuthorizationOptions\nThe ability for Siri to automatically read out messages over AirPods."
  },
  {
    "title": "providesAppNotificationSettings",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/providesappnotificationsettings",
    "html": "See Also\nOptions\nstatic var badge: UNAuthorizationOptions\nThe ability to update the app’s badge.\nstatic var sound: UNAuthorizationOptions\nThe ability to play sounds.\nstatic var alert: UNAuthorizationOptions\nThe ability to display alerts.\nstatic var carPlay: UNAuthorizationOptions\nThe ability to display notifications in a CarPlay environment.\nstatic var criticalAlert: UNAuthorizationOptions\nThe ability to play sounds for critical alerts.\nstatic var provisional: UNAuthorizationOptions\nThe ability to post noninterrupting notifications provisionally to the Notification Center."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/init(rawvalue:)",
    "html": "Parameters\nrawValue\n\nThe raw unsigned integer value for the authorization options."
  },
  {
    "title": "criticalAlert",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/criticalalert",
    "html": "Discussion\n\nCritical alerts ignore the mute switch and Do Not Disturb; the system plays a critical alert’s sound regardless of the device’s mute or Do Not Disturb settings. You can specify a custom sound and volume.\n\nCritical alerts require a special entitlement issued by Apple.\n\nSee Also\nOptions\nstatic var badge: UNAuthorizationOptions\nThe ability to update the app’s badge.\nstatic var sound: UNAuthorizationOptions\nThe ability to play sounds.\nstatic var alert: UNAuthorizationOptions\nThe ability to display alerts.\nstatic var carPlay: UNAuthorizationOptions\nThe ability to display notifications in a CarPlay environment.\nstatic var providesAppNotificationSettings: UNAuthorizationOptions\nAn option indicating the system should display a button for in-app notification settings.\nstatic var provisional: UNAuthorizationOptions\nThe ability to post noninterrupting notifications provisionally to the Notification Center."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "carPlay",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/carplay",
    "html": "See Also\nOptions\nstatic var badge: UNAuthorizationOptions\nThe ability to update the app’s badge.\nstatic var sound: UNAuthorizationOptions\nThe ability to play sounds.\nstatic var alert: UNAuthorizationOptions\nThe ability to display alerts.\nstatic var criticalAlert: UNAuthorizationOptions\nThe ability to play sounds for critical alerts.\nstatic var providesAppNotificationSettings: UNAuthorizationOptions\nAn option indicating the system should display a button for in-app notification settings.\nstatic var provisional: UNAuthorizationOptions\nThe ability to post noninterrupting notifications provisionally to the Notification Center."
  },
  {
    "title": "OptionSet Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/optionset-implementations",
    "html": "Topics\nInitializers\ninit()\nCreates an empty option set.\nAvailable when RawValue conforms to FixedWidthInteger.\nInstance Methods\nfunc contains(Self) -> Bool\nReturns a Boolean value that indicates whether a given element is a member of the option set.\nAvailable when Self is Self.Element.\nfunc formIntersection(Self)\nRemoves all elements of this option set that are not also present in the given set.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc formSymmetricDifference(Self)\nReplaces this set with a new set containing all elements contained in either this set or the given set, but not in both.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc formUnion(Self)\nInserts the elements of another set into this option set.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc insert(Self.Element) -> (inserted: Bool, memberAfterInsert: Self.Element)\nAdds the given element to the option set if it is not already a member.\nAvailable when Self is Self.Element.\nfunc intersection(Self) -> Self\nReturns a new option set with only the elements contained in both this set and the given set.\nfunc remove(Self.Element) -> Self.Element?\nRemoves the given element and all elements subsumed by it.\nAvailable when Self is Self.Element.\nfunc symmetricDifference(Self) -> Self\nReturns a new option set with the elements contained in this set or in the given set, but not in both.\nfunc union(Self) -> Self\nReturns a new option set of the elements contained in this set, in the given set, or in both.\nfunc update(with: Self.Element) -> Self.Element?\nInserts the given element into the set.\nAvailable when Self is Self.Element."
  },
  {
    "title": "SetAlgebra Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/setalgebra-implementations",
    "html": "Topics\nInitializers\ninit<S>(S)\nCreates a new set from a finite sequence of items.\ninit(arrayLiteral: Self.Element...)\nCreates a set containing the elements of the given array literal.\nAvailable when ArrayLiteralElement is Self.Element.\nInstance Properties\nvar isEmpty: Bool\nA Boolean value that indicates whether the set has no elements.\nInstance Methods\nfunc isDisjoint(with: Self) -> Bool\nReturns a Boolean value that indicates whether the set has no members in common with the given set.\nfunc isStrictSubset(of: Self) -> Bool\nReturns a Boolean value that indicates whether this set is a strict subset of the given set.\nfunc isStrictSuperset(of: Self) -> Bool\nReturns a Boolean value that indicates whether this set is a strict superset of the given set.\nfunc isSubset(of: Self) -> Bool\nReturns a Boolean value that indicates whether the set is a subset of another set.\nfunc isSuperset(of: Self) -> Bool\nReturns a Boolean value that indicates whether the set is a superset of the given set.\nfunc subtract(Self)\nRemoves the elements of the given set from this set.\nfunc subtracting(Self) -> Self\nReturns a new set containing the elements of this set that do not occur in the given set."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/init(rawvalue:)",
    "html": "Parameters\nrawValue\n\nThe raw unsigned integer value for the action options."
  },
  {
    "title": "sound",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/sound",
    "html": "See Also\nOptions\nstatic var badge: UNAuthorizationOptions\nThe ability to update the app’s badge.\nstatic var alert: UNAuthorizationOptions\nThe ability to display alerts.\nstatic var carPlay: UNAuthorizationOptions\nThe ability to display notifications in a CarPlay environment.\nstatic var criticalAlert: UNAuthorizationOptions\nThe ability to play sounds for critical alerts.\nstatic var providesAppNotificationSettings: UNAuthorizationOptions\nAn option indicating the system should display a button for in-app notification settings.\nstatic var provisional: UNAuthorizationOptions\nThe ability to post noninterrupting notifications provisionally to the Notification Center."
  },
  {
    "title": "notificationsNotAllowed",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/notificationsnotallowed",
    "html": "Discussion\n\nThis error occurs when you try to submit a notification request and your app or app extension is not authorized to schedule notifications.\n\nSee Also\nType Properties\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var contentProvidingObjectNotAllowed: UNError.Code\nstatic var badgeInputInvalid: UNError.Code"
  },
  {
    "title": "alert",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/alert",
    "html": "See Also\nOptions\nstatic var badge: UNAuthorizationOptions\nThe ability to update the app’s badge.\nstatic var sound: UNAuthorizationOptions\nThe ability to play sounds.\nstatic var carPlay: UNAuthorizationOptions\nThe ability to display notifications in a CarPlay environment.\nstatic var criticalAlert: UNAuthorizationOptions\nThe ability to play sounds for critical alerts.\nstatic var providesAppNotificationSettings: UNAuthorizationOptions\nAn option indicating the system should display a button for in-app notification settings.\nstatic var provisional: UNAuthorizationOptions\nThe ability to post noninterrupting notifications provisionally to the Notification Center."
  },
  {
    "title": "authenticationRequired",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/authenticationrequired",
    "html": "Discussion\n\nWhen the user selects an action with this option, the system prompts the user to unlock the device. After unlocking, the system notifies your app of the selected action. You might use option to perform actions that require accessing data that is encrypted while the device is locked.\n\nSee Also\nConstants\nstatic var destructive: UNNotificationActionOptions\nThe action performs a destructive task.\nstatic var foreground: UNNotificationActionOptions\nThe action causes the app to launch in the foreground."
  },
  {
    "title": "badge",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/badge",
    "html": "See Also\nOptions\nstatic var sound: UNAuthorizationOptions\nThe ability to play sounds.\nstatic var alert: UNAuthorizationOptions\nThe ability to display alerts.\nstatic var carPlay: UNAuthorizationOptions\nThe ability to display notifications in a CarPlay environment.\nstatic var criticalAlert: UNAuthorizationOptions\nThe ability to play sounds for critical alerts.\nstatic var providesAppNotificationSettings: UNAuthorizationOptions\nAn option indicating the system should display a button for in-app notification settings.\nstatic var provisional: UNAuthorizationOptions\nThe ability to post noninterrupting notifications provisionally to the Notification Center."
  },
  {
    "title": "attachmentInvalidFileSize",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/attachmentinvalidfilesize",
    "html": "See Also\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var contentProvidingObjectNotAllowed: UNError.Code\nstatic var badgeInputInvalid: UNError.Code"
  },
  {
    "title": "attachmentInvalidURL",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/attachmentinvalidurl",
    "html": "See Also\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var contentProvidingObjectNotAllowed: UNError.Code\nstatic var badgeInputInvalid: UNError.Code"
  },
  {
    "title": "attachmentNotInDataStore",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/attachmentnotindatastore",
    "html": "See Also\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var contentProvidingObjectNotAllowed: UNError.Code\nstatic var badgeInputInvalid: UNError.Code"
  },
  {
    "title": "attachmentUnrecognizedType",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/attachmentunrecognizedtype",
    "html": "See Also\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var contentProvidingObjectNotAllowed: UNError.Code\nstatic var badgeInputInvalid: UNError.Code"
  },
  {
    "title": "RawRepresentable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unalertstyle/rawrepresentable-implementations",
    "html": "Topics\nInstance Properties\nvar hashValue: Int\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable.\nInstance Methods\nfunc hash(into: inout Hasher)\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable."
  },
  {
    "title": "UNAlertStyle.alert",
    "url": "https://developer.apple.com/documentation/usernotifications/unalertstyle/alert",
    "html": "Discussion\n\nAlerts are displayed in a modal window that must be dismissed explicitly by the user.\n\nSee Also\nPresentation Styles\ncase none\nNo alert.\ncase banner\nBanner alerts."
  },
  {
    "title": "UNAlertStyle.banner",
    "url": "https://developer.apple.com/documentation/usernotifications/unalertstyle/banner",
    "html": "Discussion\n\nAlerts are displayed as a slide-down banner. Banners appear for a short time and then disappear automatically if the user does nothing.\n\nSee Also\nPresentation Styles\ncase none\nNo alert.\ncase alert\nModal alerts."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unalertstyle/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "UNAuthorizationStatus.ephemeral",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationstatus/ephemeral",
    "html": "Discussion\n\nAn App Clip may have the ability to schedule or receive notifications for a limited amount of time. For more information, see Enabling notifications in App Clips.\n\nSee Also\nStatus\ncase notDetermined\nThe user hasn’t yet made a choice about whether the app is allowed to schedule notifications.\ncase denied\nThe app isn’t authorized to schedule or receive notifications.\ncase authorized\nThe app is authorized to schedule or receive notifications.\ncase provisional\nThe application is provisionally authorized to post noninterruptive user notifications."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationstatus/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "RawRepresentable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationstatus/rawrepresentable-implementations",
    "html": "Topics\nInstance Properties\nvar hashValue: Int\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable.\nInstance Methods\nfunc hash(into: inout Hasher)\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable."
  },
  {
    "title": "categoryIdentifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/categoryidentifier",
    "html": "Discussion\n\nUse notification types to distinguish between the different types of notifications your app supports. You use this support primarily to create actionable notifications with custom action buttons, and to redirect your notifications through either your notification service app extension or your notification content app extension.\n\nFor remote notifications, the system sets this property to the value of the category key in the aps dictionary.\n\nSee Also\nRetrieving group information\nvar threadIdentifier: String\nThe identifier that groups related notifications.\nvar summaryArgument: String\nThe text the system adds to the notification summary to provide additional context.\nvar summaryArgumentCount: Int\nThe number the system adds to the notification summary when the notification represents multiple items."
  },
  {
    "title": "nextTriggerDate()",
    "url": "https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger/nexttriggerdate()",
    "html": "Return Value\n\nThe next trigger date.\n\nDiscussion\n\nUse this property to find out when the system will deliver a notification associated with this trigger.\n\nSee Also\nGetting the Trigger Information\nvar dateComponents: DateComponents\nThe date components to construct this object."
  },
  {
    "title": "repeats",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationtrigger/repeats",
    "html": "Discussion\n\nWhen this property is false, the system delivers the notification only once. When this property is true, the system reschedules the notification request automatically, resulting in the system delivering the notification each time the trigger condition is met. To unschedule the notification request, use the methods of the UNUserNotificationCenter to remove the notification request."
  },
  {
    "title": "UNNotificationInterruptionLevel.timeSensitive",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationinterruptionlevel/timesensitive",
    "html": "Discussion\n\nTime Sensitive notifications are similar to active notifications, but can break through system controls such as Notification Summary and Focus. The user can turn off the ability for time sensitive notification interruptions.\n\nSee Also\nEnumeration Cases\ncase active\nThe system presents the notification immediately, lights up the screen, and can play a sound.\ncase critical\nThe system presents the notification immediately, lights up the screen, and bypasses the mute switch to play a sound.\ncase passive\nThe system adds the notification to the notification list without lighting up the screen or playing a sound."
  },
  {
    "title": "UNNotificationInterruptionLevel.passive",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationinterruptionlevel/passive",
    "html": "See Also\nEnumeration Cases\ncase active\nThe system presents the notification immediately, lights up the screen, and can play a sound.\ncase critical\nThe system presents the notification immediately, lights up the screen, and bypasses the mute switch to play a sound.\ncase timeSensitive\nThe system presents the notification immediately, lights up the screen, can play a sound, and breaks through system notification controls."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unshowpreviewssetting/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "UNShowPreviewsSetting.never",
    "url": "https://developer.apple.com/documentation/usernotifications/unshowpreviewssetting/never",
    "html": "See Also\nPreview Styes\ncase always\nThe notification’s content is always shown, even when the device is locked.\ncase whenAuthenticated\nThe notification’s content is shown only when the device is unlocked."
  },
  {
    "title": "UNNotificationCategoryOptions",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategoryoptions",
    "html": "Topics\nCreating an option\ninit(rawValue: UInt)\nInitializes a notification category options object using the specified raw value.\nCustomizing a category\nstatic var allowInCarPlay: UNNotificationCategoryOptions\nAllow CarPlay to display notifications of this type.\nstatic var allowAnnouncement: UNNotificationCategoryOptions\nAn option that grants Siri permission to read incoming messages out loud when the user has a compatible audio output device connected.\nManaging hidden preview behavior\nstatic var hiddenPreviewsShowTitle: UNNotificationCategoryOptions\nShow the notification’s title, even if the user has disabled notification previews for the app.\nstatic var hiddenPreviewsShowSubtitle: UNNotificationCategoryOptions\nShow the notification’s subtitle, even if the user has disabled notification previews for the app.\nManaging action handling behavior\nstatic var customDismissAction: UNNotificationCategoryOptions\nSend dismiss actions to the UNUserNotificationCenter object’s delegate for handling.\nDefault Implementations\nEquatable Implementations\nOptionSet Implementations\nSetAlgebra Implementations\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nGetting the Options\nvar options: UNNotificationCategoryOptions\nOptions for how to handle notifications of this type."
  },
  {
    "title": "options",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategory/options",
    "html": "See Also\nGetting the Options\nstruct UNNotificationCategoryOptions\nConstants indicating how to handle notifications associated with this category."
  },
  {
    "title": "actions",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategory/actions",
    "html": "Discussion\n\nWhen displaying a notification assigned to this category, the system adds a button to the notification interface for each action in this property. The system displays these buttons after the notification’s content but before the Dismiss button.\n\nWhen displaying banner notifications, the system displays only the first two actions.\n\nSee Also\nGetting the Information\nvar identifier: String\nThe unique string assigned to the category.\nvar intentIdentifiers: [String]\nThe intents related to notifications of this category.\nvar hiddenPreviewsBodyPlaceholder: String\nThe placeholder text to display when the system disables notification previews for the app.\nvar categorySummaryFormat: String\nA format string for the summary description used when the system groups the category’s notifications."
  },
  {
    "title": "hiddenPreviewsBodyPlaceholder",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategory/hiddenpreviewsbodyplaceholder",
    "html": "Discussion\n\nThe string in this property may contain the special characters %u as a placeholder for the number of messages with the same thread identifier. If your app declares this string in a .stringsdict property list, the system formats the preview message using the information in that file. For more information about specifying a .stringsdict property file, see Internationalization and Localization Guide.\n\nSee Also\nGetting the Information\nvar identifier: String\nThe unique string assigned to the category.\nvar actions: [UNNotificationAction]\nThe actions to display when the system delivers notifications of this type.\nvar intentIdentifiers: [String]\nThe intents related to notifications of this category.\nvar categorySummaryFormat: String\nA format string for the summary description used when the system groups the category’s notifications."
  },
  {
    "title": "UNShowPreviewsSetting.whenAuthenticated",
    "url": "https://developer.apple.com/documentation/usernotifications/unshowpreviewssetting/whenauthenticated",
    "html": "See Also\nPreview Styes\ncase always\nThe notification’s content is always shown, even when the device is locked.\ncase never\nThe notification’s content is never shown, even when the device is unlocked"
  },
  {
    "title": "categorySummaryFormat",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategory/categorysummaryformat",
    "html": "See Also\nGetting the Information\nvar identifier: String\nThe unique string assigned to the category.\nvar actions: [UNNotificationAction]\nThe actions to display when the system delivers notifications of this type.\nvar intentIdentifiers: [String]\nThe intents related to notifications of this category.\nvar hiddenPreviewsBodyPlaceholder: String\nThe placeholder text to display when the system disables notification previews for the app."
  },
  {
    "title": "intentIdentifiers",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategory/intentidentifiers",
    "html": "Discussion\n\nWhen the system delivers a notification, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri.\n\nSee Also\nGetting the Information\nvar identifier: String\nThe unique string assigned to the category.\nvar actions: [UNNotificationAction]\nThe actions to display when the system delivers notifications of this type.\nvar hiddenPreviewsBodyPlaceholder: String\nThe placeholder text to display when the system disables notification previews for the app.\nvar categorySummaryFormat: String\nA format string for the summary description used when the system groups the category’s notifications."
  },
  {
    "title": "identifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategory/identifier",
    "html": "Discussion\n\nUse this string to differentiate the different types of notifications that your app can send. To assign a category to a local notification, assign this string to the categoryIdentifier property of the content object. To assign a category to a remote notification, use the string as the value of the category key in the notification payload aps dictionary.\n\nSee Also\nGetting the Information\nvar actions: [UNNotificationAction]\nThe actions to display when the system delivers notifications of this type.\nvar intentIdentifiers: [String]\nThe intents related to notifications of this category.\nvar hiddenPreviewsBodyPlaceholder: String\nThe placeholder text to display when the system disables notification previews for the app.\nvar categorySummaryFormat: String\nA format string for the summary description used when the system groups the category’s notifications."
  },
  {
    "title": "provisional",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions/provisional",
    "html": "See Also\nOptions\nstatic var badge: UNAuthorizationOptions\nThe ability to update the app’s badge.\nstatic var sound: UNAuthorizationOptions\nThe ability to play sounds.\nstatic var alert: UNAuthorizationOptions\nThe ability to display alerts.\nstatic var carPlay: UNAuthorizationOptions\nThe ability to display notifications in a CarPlay environment.\nstatic var criticalAlert: UNAuthorizationOptions\nThe ability to play sounds for critical alerts.\nstatic var providesAppNotificationSettings: UNAuthorizationOptions\nAn option indicating the system should display a button for in-app notification settings."
  },
  {
    "title": "UNNotificationSetting.enabled",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsetting/enabled",
    "html": "See Also\nConstants\ncase notSupported\nThe setting is not available to your app.\ncase disabled\nThe setting is disabled."
  },
  {
    "title": "UNShowPreviewsSetting.always",
    "url": "https://developer.apple.com/documentation/usernotifications/unshowpreviewssetting/always",
    "html": "See Also\nPreview Styes\ncase whenAuthenticated\nThe notification’s content is shown only when the device is unlocked.\ncase never\nThe notification’s content is never shown, even when the device is unlocked"
  },
  {
    "title": "init(identifier:actions:intentIdentifiers:hiddenPreviewsBodyPlaceholder:options:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategory/init(identifier:actions:intentidentifiers:hiddenpreviewsbodyplaceholder:options:)",
    "html": "Parameters\nidentifier\n\nThe unique identifier for the category. Each category that your app uses must have a unique identifier. Don’t specify an empty string.\n\nactions\n\nThe actions to display when the system delivers notifications of this type. When minimal space is available, the system displays only the first two actions in the array. You may specify an empty array for this parameter if you don’t want to display custom actions.\n\nintentIdentifiers\n\nThe intent identifier strings that you want to associate with notifications of this type. The Intents framework defines constants for each type of intent that you can associate with your notifications.\n\nhiddenPreviewsBodyPlaceholder\n\nA placeholder string to display when the user has disabled notification previews for the app. Include the characters %u (the only supported formatting characters) in the string to represent the number of notifications with the same thread identifier. For example, the string “%u Messages” becomes “2 Messages” when there are two messages.\n\nTo specify different strings for the singular and plural cases, use the localizedUserNotificationString(forKey:arguments:) method of NSString to specify the value for this parameter. The key passed to that method contains the identifier of an entry in a .stringsdict property list of your project. A strings dictionary lets you specify different formatted strings based on the language rules, and is as described in Internationalization and Localization Guide.\n\noptions\n\nAdditional options for handling notifications of this type. For a list of possible values, see UNNotificationCategoryOptions.\n\nReturn Value\n\nAn initialized category object.\n\nSee Also\nEssentials\nconvenience init(identifier: String, actions: [UNNotificationAction], intentIdentifiers: [String], options: UNNotificationCategoryOptions)\nCreates a category object containing the specified actions and options.\nconvenience init(identifier: String, actions: [UNNotificationAction], intentIdentifiers: [String], hiddenPreviewsBodyPlaceholder: String?, categorySummaryFormat: String?, options: UNNotificationCategoryOptions)\nCreates a category object containing the specified actions, options, placeholder text used when previews aren’t shown, and summary format string."
  },
  {
    "title": "init(identifier:actions:intentIdentifiers:hiddenPreviewsBodyPlaceholder:categorySummaryFormat:options:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategory/init(identifier:actions:intentidentifiers:hiddenpreviewsbodyplaceholder:categorysummaryformat:options:)",
    "html": "Parameters\nidentifier\n\nThe unique identifier for the category. Each category that your app uses must have a unique identifier. Don’t specify an empty string.\n\nactions\n\nThe actions to display when the system delivers notifications of this type. When minimal space is available, the system displays only the first two actions in the array. You may specify an empty array for this parameter if you don’t want to display custom actions.\n\nintentIdentifiers\n\nThe intent identifier strings that you want to associate with notifications of this type. The Intents framework defines constants for each type of intent that you can associate with your notifications.\n\nhiddenPreviewsBodyPlaceholder\n\nA placeholder string to display when the user has disabled notification previews for the app. Include the characters %u (the only supported formatting characters) in the string to represent the number of notifications with the same thread identifier. For example, the string “%u Messages” becomes “2 Messages” when there are two messages.\n\nTo specify different strings for the singular and plural cases, use the localizedUserNotificationString(forKey:arguments:) method of NSString to specify the value for this parameter. The key passed to that method contains the identifier of an entry in a .stringsdict property list of your project. A strings dictionary lets you specify different formatted strings based on the language rules, and is as described in Internationalization and Localization Guide.\n\ncategorySummaryFormat\n\nA format string for the summary description used when the system groups the category’s notifications.\n\noptions\n\nAdditional options for handling notifications of this type. For a list of possible values, see UNNotificationCategoryOptions.\n\nSee Also\nEssentials\nconvenience init(identifier: String, actions: [UNNotificationAction], intentIdentifiers: [String], options: UNNotificationCategoryOptions)\nCreates a category object containing the specified actions and options.\nconvenience init(identifier: String, actions: [UNNotificationAction], intentIdentifiers: [String], hiddenPreviewsBodyPlaceholder: String, options: UNNotificationCategoryOptions)\nCreates a category object containing the specified actions, options, and placeholder text used when previews aren’t shown."
  },
  {
    "title": "init(identifier:actions:intentIdentifiers:options:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategory/init(identifier:actions:intentidentifiers:options:)",
    "html": "Parameters\nidentifier\n\nThe unique identifier for the category. Each category that your app uses must have a unique identifier. Don’t specify an empty string.\n\nactions\n\nThe actions to display when the system delivers notifications of this type. When minimal space is available, the system displays only the first two actions in the array. You may specify an empty array for this parameter if you don’t want to display custom actions.\n\nintentIdentifiers\n\nThe intent identifier strings that you want to associate with notifications of this type. The Intents framework defines constants for each type of intent that you can associate with your notifications.\n\noptions\n\nAdditional options for handling notifications of this type. For a list of possible values, see UNNotificationCategoryOptions.\n\nReturn Value\n\nAn initialized category object.\n\nSee Also\nEssentials\nconvenience init(identifier: String, actions: [UNNotificationAction], intentIdentifiers: [String], hiddenPreviewsBodyPlaceholder: String, options: UNNotificationCategoryOptions)\nCreates a category object containing the specified actions, options, and placeholder text used when previews aren’t shown.\nconvenience init(identifier: String, actions: [UNNotificationAction], intentIdentifiers: [String], hiddenPreviewsBodyPlaceholder: String?, categorySummaryFormat: String?, options: UNNotificationCategoryOptions)\nCreates a category object containing the specified actions, options, placeholder text used when previews aren’t shown, and summary format string."
  },
  {
    "title": "textInputPlaceholder",
    "url": "https://developer.apple.com/documentation/usernotifications/untextinputnotificationaction/textinputplaceholder",
    "html": "See Also\nGetting Information\nvar textInputButtonTitle: String\nThe localized title of the text input button that the system displays to the user."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "alert",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/alert",
    "html": "Deprecated\n\nUse list and banner instead.\n\nSee Also\nConstants\nstatic var badge: UNNotificationPresentationOptions\nApply the notification’s badge value to the app’s icon.\nstatic var banner: UNNotificationPresentationOptions\nPresent the notification as a banner.\nstatic var list: UNNotificationPresentationOptions\nShow the notification in Notification Center.\nstatic var sound: UNNotificationPresentationOptions\nPlay the sound associated with the notification."
  },
  {
    "title": "SetAlgebra Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/setalgebra-implementations",
    "html": "Topics\nInitializers\ninit<S>(S)\nCreates a new set from a finite sequence of items.\ninit(arrayLiteral: Self.Element...)\nCreates a set containing the elements of the given array literal.\nAvailable when ArrayLiteralElement is Self.Element.\nInstance Properties\nvar isEmpty: Bool\nA Boolean value that indicates whether the set has no elements.\nInstance Methods\nfunc isDisjoint(with: Self) -> Bool\nReturns a Boolean value that indicates whether the set has no members in common with the given set.\nfunc isStrictSubset(of: Self) -> Bool\nReturns a Boolean value that indicates whether this set is a strict subset of the given set.\nfunc isStrictSuperset(of: Self) -> Bool\nReturns a Boolean value that indicates whether this set is a strict superset of the given set.\nfunc isSubset(of: Self) -> Bool\nReturns a Boolean value that indicates whether the set is a subset of another set.\nfunc isSuperset(of: Self) -> Bool\nReturns a Boolean value that indicates whether the set is a superset of the given set.\nfunc subtract(Self)\nRemoves the elements of the given set from this set.\nfunc subtracting(Self) -> Self\nReturns a new set containing the elements of this set that do not occur in the given set."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/init(rawvalue:)",
    "html": "Parameters\nrawValue\n\nThe raw unsigned integer value for the notification presentation options."
  },
  {
    "title": "Modifying content in newly delivered notifications",
    "url": "https://developer.apple.com/documentation/UserNotifications/modifying-content-in-newly-delivered-notifications",
    "html": "Overview\n\nYou may want to modify the content of a remote notification on a user’s iOS device if you need to:\n\nDecrypt data sent in an encrypted format.\n\nDownload images or other media attachments whose size would exceed the maximum payload size.\n\nUpdate the notification’s content, perhaps by incorporating data from the user’s device.\n\nModifying a remote notification requires a notification service app extension, which you include inside your iOS app bundle. The app extension receives the contents of your remote notifications before the system displays them to the user, giving you time to update the notification payload. You control which notifications your extension handles.\n\nImportant\n\nNotification service app extensions only operate on remote notifications configured in the system to display an alert to the user. If alerts are disabled for your app, or if the payload specifies only the playing of a sound or the badging of an icon, the extension isn’t employed.\n\nAdd a service app extension to your project\n\nA notification service app extension ships as a separate bundle inside your iOS app. To add this extension to your app:\n\nSelect File > New > Target in Xcode.\n\nSelect the Notification Service Extension target from the iOS > Application section.\n\nClick Next.\n\nSpecify a name and other configuration details for your app extension.\n\nClick Finish.\n\nImplement your extension’s handler methods\n\nThe notification service app extension template provided by Xcode includes a default implementation for you to modify.\n\nUse the didReceive(_:withContentHandler:) method to create a new UNMutableNotificationContent object with the updated content.\n\nUse the serviceExtensionTimeWillExpire() method to terminate any payload-modification tasks that are still running.\n\nYour didReceive(_:withContentHandler:) method has only about 30 seconds to modify the payload and call the provided completion handler. If your code takes longer than that, the system calls the serviceExtensionTimeWillExpire() method, at which point you must return whatever you can to the system immediately. If you fail to call the completion handler from either method, the system displays the original contents of the notification.\n\nListing 1 shows an implementation of the UNNotificationServiceExtension object that decrypts the contents of a secret message delivered using a remote notification. The didReceive(_:withContentHandler:) method decrypts the data and returns a modified version of the notification’s content if it’s successful. If it’s unsuccessful, or if time expires, the extension returns content indicating that the data is still encrypted.\n\nListing 1. Decrypting data contained in a remote notification\n\n// Storage for the completion handler and content.\nvar contentHandler: ((UNNotificationContent) -> Void)?\nvar bestAttemptContent: UNMutableNotificationContent?\n// Modify the payload contents.\noverride func didReceive(_ request: UNNotificationRequest,\n         withContentHandler contentHandler: \n         @escaping (UNNotificationContent) -> Void) {\n   self.contentHandler = contentHandler\n   self.bestAttemptContent = (request.content.mutableCopy() \n         as? UNMutableNotificationContent)\n   \n   // Try to decode the encrypted message data.\n   let encryptedData = bestAttemptContent?.userInfo[\"ENCRYPTED_DATA\"]\n   if let bestAttemptContent = bestAttemptContent {\n      if let data = encryptedData as? String {\n         let decryptedMessage = self.decrypt(data: data)\n        bestAttemptContent.body = decryptedMessage\n      }\n      else {\n         bestAttemptContent.body = \"(Encrypted)\"\n      }\n      \n      // Always call the completion handler when done.      \n      contentHandler(bestAttemptContent)\n   }\n}\n    \n// Return something before time expires.\noverride func serviceExtensionTimeWillExpire() {\n   if let contentHandler = contentHandler, \n      let bestAttemptContent = bestAttemptContent {\n         \n      // Mark the message as still encrypted.   \n      bestAttemptContent.subtitle = \"(Encrypted)\"\n      bestAttemptContent.body = \"\"\n      contentHandler(bestAttemptContent)\n   }\n}\n\nConfigure the payload for the remote notification\n\nThe system executes your notification service app extension only when a remote notification’s payload contains the following information:\n\nThe payload must include the mutable-content key with a value of 1.\n\nThe payload must include an alert dictionary with title, subtitle, or body information.\n\nListing 2 shows the JSON data for a notification payload containing encrypted data. The mutable-content flag is set so that the user’s device knows to run the corresponding service app extension, the code for which is shown in .\n\nListing 2. Specifying the remote notification payload\n\n{\n   \"aps\" : {\n      \"category\" : \"SECRET\",\n      \"mutable-content\" : 1,\n      \"alert\" : {\n         \"title\" : \"Secret Message!\",\n         \"body\"  : \"(Encrypted)\"\n     },\n   },\n   \"ENCRYPTED_DATA\" : \"Salted__·öîQÊ$UDì_¶Ù∞èΩ^¬%gq∞NÿÒQùw\"\n}\n\nSee Also\nNotification service app extension\nclass UNNotificationServiceExtension\nAn object that modifies the content of a remote notification before it’s delivered to the user."
  },
  {
    "title": "banner",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/banner",
    "html": "See Also\nConstants\nstatic var badge: UNNotificationPresentationOptions\nApply the notification’s badge value to the app’s icon.\nstatic var list: UNNotificationPresentationOptions\nShow the notification in Notification Center.\nstatic var sound: UNNotificationPresentationOptions\nPlay the sound associated with the notification.\nstatic var alert: UNNotificationPresentationOptions\nDisplay the alert using the content provided by the notification.\nDeprecated"
  },
  {
    "title": "list",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/list",
    "html": "See Also\nConstants\nstatic var badge: UNNotificationPresentationOptions\nApply the notification’s badge value to the app’s icon.\nstatic var banner: UNNotificationPresentationOptions\nPresent the notification as a banner.\nstatic var sound: UNNotificationPresentationOptions\nPlay the sound associated with the notification.\nstatic var alert: UNNotificationPresentationOptions\nDisplay the alert using the content provided by the notification.\nDeprecated"
  },
  {
    "title": "UNNotificationPresentationOptionNone",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptionnone",
    "html": "Discussion\n\nSpecify this constant when you want to silence any user interactions for a notification.\n\nSee Also\nReceiving Notifications\nfunc userNotificationCenter(UNUserNotificationCenter, willPresent: UNNotification, withCompletionHandler: (UNNotificationPresentationOptions) -> Void)\nAsks the delegate how to handle a notification that arrived while the app was running in the foreground.\nstruct UNNotificationPresentationOptions\nConstants indicating how to present a notification in a foreground app."
  },
  {
    "title": "sound",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/sound",
    "html": "Discussion\n\nUse this property to specify the sound that you want played when the notification arrives. If your app isn’t authorized to play sounds for notifications, the system ignores this property.\n\nFor information on how to specify sounds for your notifications, see UNNotificationSound.\n\nSee Also\nIntegrating with the system\nvar interruptionLevel: UNNotificationInterruptionLevel\nThe notification’s importance and required delivery timing.\nenum UNNotificationInterruptionLevel\nConstants that indicate the importance and delivery timing of a notification.\nvar relevanceScore: Double\nThe score the system uses to determine if the notification is the summary’s featured notification.\nvar filterCriteria: String?\nThe criteria the system evaluates to determine if it displays the notification in the current Focus."
  },
  {
    "title": "didReceive(_:withContentHandler:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationserviceextension/didreceive(_:withcontenthandler:)",
    "html": "Parameters\nrequest\n\nThe original notification request. Use this object to get the original content of the notification.\n\ncontentHandler\n\nThe block to execute with the modified content. This block has no return value and takes the following parameter:\n\ncontentToDeliver\n\nA UNNotificationContent object with the content the system displays to the user.\n\nDiscussion\n\nOverride this method and use it to modify the UNNotificationContent object that the system delivers with the notification. At some point during your implementation, execute the contentHandler block and pass it your modified content. If you decide not to modify the content, call the contentHandler block with the original content from the request parameter.\n\nYou can modify any of the content from the original request. You might customize the content for the current user or replace it altogether. You can use this method to download images or movies and add them as attachments to the content. You may also modify the alert text as long as you don’t remove it. If the content object doesn’t contain any alert text, the system ignores your modifications and delivers the original notification content.\n\nYour extension has a limited amount of time (no more than 30 seconds) to modify the content and execute the contentHandler block. If you don’t execute that block in a timely manner, the system calls your extension’s serviceExtensionTimeWillExpire() method to give you one last chance to execute the block. If you don’t, the system presents the notification’s original content to the user.\n\nSee Also\nProcessing Notifications\nfunc serviceExtensionTimeWillExpire()\nTells you that the system is terminating your extension."
  },
  {
    "title": "init(systemImageName:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionicon/init(systemimagename:)",
    "html": "Parameters\nsystemImageName\n\nThe name of the system symbol image. Use the SF Symbols app to look up the names of system symbol images. Download this app from the design resources page at developer.apple.com.\n\nReturn Value\n\nAn action icon that the system initializes with the system symbol image that your app specifies.\n\nSee Also\nEssentials\nconvenience init(templateImageName: String)\nCreates an action icon based on an image in your app’s bundle, preferably in an asset catalog."
  },
  {
    "title": "getPendingNotificationRequests(completionHandler:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/getpendingnotificationrequests(completionhandler:)",
    "html": "Parameters\ncompletionHandler\n\nA block for processing notification requests. This block may be executed on a background thread. The block has no return value and takes a single parameter.\n\nrequests\n\nAn array of UNNotificationRequest objects representing the scheduled notification requests. If there are no scheduled requests, this array is empty.\n\nDiscussion\n\nImportant\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc pendingNotificationRequests() async -> [UNNotificationRequest]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nHere’s an example that obtains the pending notification requests.\n\nlet center = UNUserNotificationCenter.current()\nlet requests = await center.pendingNotificationRequests()\n\nSee Also\nScheduling notifications\nfunc add(UNNotificationRequest, withCompletionHandler: (((any Error)?) -> Void)?)\nSchedules the delivery of a local notification.\nfunc removePendingNotificationRequests(withIdentifiers: [String])\nRemoves your app’s local notifications that are pending and match the specified identifiers.\nfunc removeAllPendingNotificationRequests()\nRemoves all of your app’s pending local notifications."
  },
  {
    "title": "init(identifier:title:options:icon:textInputButtonTitle:textInputPlaceholder:)",
    "url": "https://developer.apple.com/documentation/usernotifications/untextinputnotificationaction/init(identifier:title:options:icon:textinputbuttontitle:textinputplaceholder:)",
    "html": "Parameters\nidentifier\n\nThe string that you use internally to identify the action. This string must be unique among all of your app’s supported actions. When the user selects the action, the system passes this string to your app and asks you to perform the related task. This parameter must not be nil or an empty string.\n\ntitle\n\nThe localized string the system displays to the user. The system displays this string as the title of a button, which the system adds to the notification interface. This parameter must not be nil.\n\noptions\n\nAdditional options describing how the action behaves. Include options when you need the related behavior. For a list of possible values, see UNNotificationActionOptions.\n\nicon\n\nThe icon to display to the user.\n\ntextInputButtonTitle\n\nThe localized title of the text input button that’s displayed to the user.\n\ntextInputPlaceholder\n\nThe localized placeholder text to display in the text input field.\n\nReturn Value\n\nA new text input action object.\n\nSee Also\nEssentials\nconvenience init(identifier: String, title: String, options: UNNotificationActionOptions, textInputButtonTitle: String, textInputPlaceholder: String)\nCreates an action object that accepts text input from the user."
  },
  {
    "title": "announcementSetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/announcementsetting",
    "html": "See Also\nGetting Device-Specific Settings\nvar notificationCenterSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in Notification Center.\nvar lockScreenSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear on a device’s Lock screen.\nvar carPlaySetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in CarPlay.\nvar alertSetting: UNNotificationSetting\nThe authorization status for displaying alerts.\nvar badgeSetting: UNNotificationSetting\nThe setting that indicates whether badges appear on your app’s icon.\nvar soundSetting: UNNotificationSetting\nThe authorization status for playing sounds for incoming notifications.\nvar criticalAlertSetting: UNNotificationSetting\nThe authorization status for playing sounds for critical alerts.\nvar scheduledDeliverySetting: UNNotificationSetting\nThe setting that indicates the system schedules the notification.\nvar timeSensitiveSetting: UNNotificationSetting\nThe setting that indicates the system treats the notification as time-sensitive.\nenum UNNotificationSetting\nConstants that indicate the current status of a notification setting."
  },
  {
    "title": "init(identifier:title:options:textInputButtonTitle:textInputPlaceholder:)",
    "url": "https://developer.apple.com/documentation/usernotifications/untextinputnotificationaction/init(identifier:title:options:textinputbuttontitle:textinputplaceholder:)",
    "html": "Parameters\nidentifier\n\nThe string that you use internally to identify the action. This string must be unique among all of your app’s supported actions. When the user selects the action, the system passes this string to your app and asks you to perform the related task. This parameter must not be nil or an empty string.\n\ntitle\n\nThe localized string the system displays to the user. The system displays this string as the title of a button, which the system adds to the notification interface. This parameter must not be nil.\n\noptions\n\nAdditional options describing how the action behaves. Include options when you need the related behavior. For a list of possible values, see UNNotificationActionOptions.\n\ntextInputButtonTitle\n\nThe localized title of the text input button that’s displayed to the user.\n\ntextInputPlaceholder\n\nThe localized placeholder text the system displays in the text input field.\n\nReturn Value\n\nA new text input action object.\n\nSee Also\nEssentials\nconvenience init(identifier: String, title: String, options: UNNotificationActionOptions, icon: UNNotificationActionIcon?, textInputButtonTitle: String, textInputPlaceholder: String)\nCreates an action object with an icon that accepts text input from the user."
  },
  {
    "title": "textInputButtonTitle",
    "url": "https://developer.apple.com/documentation/usernotifications/untextinputnotificationaction/textinputbuttontitle",
    "html": "See Also\nGetting Information\nvar textInputPlaceholder: String\nThe placeholder text that the system localizes and displays in the text input field."
  },
  {
    "title": "timeSensitiveSetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/timesensitivesetting",
    "html": "See Also\nGetting Device-Specific Settings\nvar notificationCenterSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in Notification Center.\nvar lockScreenSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear on a device’s Lock screen.\nvar carPlaySetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in CarPlay.\nvar alertSetting: UNNotificationSetting\nThe authorization status for displaying alerts.\nvar badgeSetting: UNNotificationSetting\nThe setting that indicates whether badges appear on your app’s icon.\nvar soundSetting: UNNotificationSetting\nThe authorization status for playing sounds for incoming notifications.\nvar criticalAlertSetting: UNNotificationSetting\nThe authorization status for playing sounds for critical alerts.\nvar announcementSetting: UNNotificationSetting\nThe setting that indicates whether Siri can announce your app’s notifications.\nvar scheduledDeliverySetting: UNNotificationSetting\nThe setting that indicates the system schedules the notification.\nenum UNNotificationSetting\nConstants that indicate the current status of a notification setting."
  },
  {
    "title": "UNAuthorizationStatus",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationstatus",
    "html": "Topics\nStatus\ncase notDetermined\nThe user hasn’t yet made a choice about whether the app is allowed to schedule notifications.\ncase denied\nThe app isn’t authorized to schedule or receive notifications.\ncase authorized\nThe app is authorized to schedule or receive notifications.\ncase provisional\nThe application is provisionally authorized to post noninterruptive user notifications.\ncase ephemeral\nThe app is authorized to schedule or receive notifications for a limited amount of time.\nInitializers\ninit?(rawValue: Int)\nDefault Implementations\nEquatable Implementations\nRawRepresentable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nGetting the Authorization Status\nvar authorizationStatus: UNAuthorizationStatus\nThe app’s ability to schedule and receive local and remote notifications."
  },
  {
    "title": "UNErrorDomain",
    "url": "https://developer.apple.com/documentation/usernotifications/unerrordomain",
    "html": "See Also\nHandling errors\nstruct UNError\nAn object that represents a notification error.\nenum Code\nConstants that identify notification errors."
  },
  {
    "title": "actionIdentifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationresponse/actionidentifier",
    "html": "Discussion\n\nThis parameter may contain one the identifier of one of your UNNotificationAction objects or it may contain a system-defined identifier. The system defined identifiers are UNNotificationDefaultActionIdentifier and UNNotificationDismissActionIdentifier, which indicate that the user opened the app or dismissed the notification without any further actions.\n\nFor more information about defining custom actions, see Declaring your actionable notification types.\n\nSee Also\nGetting the Response Information\nvar notification: UNNotification\nThe notification to which the user responded.\nvar targetScene: UIScene?\nThe scene where the system reflects the user’s response to a notification.\nlet UNNotificationDefaultActionIdentifier: String\nAn action that indicates the user opened the app from the notification interface.\nlet UNNotificationDismissActionIdentifier: String\nThe action that indicates the user explicitly dismissed the notification interface."
  },
  {
    "title": "carPlaySetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/carplaysetting",
    "html": "See Also\nGetting Device-Specific Settings\nvar notificationCenterSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in Notification Center.\nvar lockScreenSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear on a device’s Lock screen.\nvar alertSetting: UNNotificationSetting\nThe authorization status for displaying alerts.\nvar badgeSetting: UNNotificationSetting\nThe setting that indicates whether badges appear on your app’s icon.\nvar soundSetting: UNNotificationSetting\nThe authorization status for playing sounds for incoming notifications.\nvar criticalAlertSetting: UNNotificationSetting\nThe authorization status for playing sounds for critical alerts.\nvar announcementSetting: UNNotificationSetting\nThe setting that indicates whether Siri can announce your app’s notifications.\nvar scheduledDeliverySetting: UNNotificationSetting\nThe setting that indicates the system schedules the notification.\nvar timeSensitiveSetting: UNNotificationSetting\nThe setting that indicates the system treats the notification as time-sensitive.\nenum UNNotificationSetting\nConstants that indicate the current status of a notification setting."
  },
  {
    "title": "criticalSoundNamed(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsound/criticalsoundnamed(_:)",
    "html": "Parameters\nname\n\nThe name of the sound file to play. This file must be located in the current executable’s main bundle or in the Library/Sounds directory of the current app container directory. If files exist at both locations, the system uses the file from the Library/Sounds directory. This parameter must not be nil.\n\nReturn Value\n\nA sound object representing a custom critical alert sound.\n\nDiscussion\n\nCritical alerts ignore the mute switch and Do Not Disturb. They require a special entitlement issued by Apple.\n\nSee Also\nGetting Critical Sounds\nclass var defaultCritical: UNNotificationSound\nThe default sound used for critical alerts.\nclass func defaultCriticalSound(withAudioVolume: Float) -> Self\nCreates a sound object that plays the default critical alert sound at the volume you specify.\nclass func criticalSoundNamed(UNNotificationSoundName, withAudioVolume: Float) -> Self\nCreates a custom sound object for critical alerts with the volume you specify."
  },
  {
    "title": "defaultCriticalSound(withAudioVolume:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsound/defaultcriticalsound(withaudiovolume:)",
    "html": "Parameters\nvolume\n\nThe volume must be a value between 0.0 and 1.0.\n\nReturn Value\n\nA sound object representing the default critical alert sound at the specified volume.\n\nDiscussion\n\nCritical alerts ignore the mute switch and Do Not Disturb. They require a special entitlement issued by Apple.\n\nSee Also\nGetting Critical Sounds\nclass var defaultCritical: UNNotificationSound\nThe default sound used for critical alerts.\nclass func criticalSoundNamed(UNNotificationSoundName) -> Self\nCreates a custom sound object for critical alerts.\nclass func criticalSoundNamed(UNNotificationSoundName, withAudioVolume: Float) -> Self\nCreates a custom sound object for critical alerts with the volume you specify."
  },
  {
    "title": "init(timeInterval:repeats:)",
    "url": "https://developer.apple.com/documentation/usernotifications/untimeintervalnotificationtrigger/init(timeinterval:repeats:)",
    "html": "Parameters\ntimeInterval\n\nThe time (in seconds) that must elapse from the current time before the trigger fires. This value must be greater than zero.\n\nrepeats\n\nSpecify false to deliver the notification one time. Specify true to reschedule the notification request each time the system delivers the notification. If this parameter is true, the value in the timeInterval parameter must be 60 seconds or greater.\n\nReturn Value\n\nA new time interval trigger based on the specified temporal information.\n\nDiscussion\n\nIf you specify true for the repeats parameter, you must explicitly remove the notification request to stop the delivery of the associated notification. Use the methods of UNUserNotificationCenter to remove notification requests that are no longer needed."
  },
  {
    "title": "sound",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions/sound",
    "html": "See Also\nConstants\nstatic var badge: UNNotificationPresentationOptions\nApply the notification’s badge value to the app’s icon.\nstatic var banner: UNNotificationPresentationOptions\nPresent the notification as a banner.\nstatic var list: UNNotificationPresentationOptions\nShow the notification in Notification Center.\nstatic var alert: UNNotificationPresentationOptions\nDisplay the alert using the content provided by the notification.\nDeprecated"
  },
  {
    "title": "defaultCritical",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsound/defaultcritical",
    "html": "Discussion\n\nCritical alerts ingore the mute switch and Do Not Disturb. They require a special entitlement issued by Apple.\n\nSee Also\nGetting Critical Sounds\nclass func defaultCriticalSound(withAudioVolume: Float) -> Self\nCreates a sound object that plays the default critical alert sound at the volume you specify.\nclass func criticalSoundNamed(UNNotificationSoundName) -> Self\nCreates a custom sound object for critical alerts.\nclass func criticalSoundNamed(UNNotificationSoundName, withAudioVolume: Float) -> Self\nCreates a custom sound object for critical alerts with the volume you specify."
  },
  {
    "title": "summaryArgument",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/summaryargument",
    "html": "See Also\nRetrieving group information\nvar threadIdentifier: String\nThe identifier that groups related notifications.\nvar categoryIdentifier: String\nThe identifier of the notification’s category.\nvar summaryArgumentCount: Int\nThe number the system adds to the notification summary when the notification represents multiple items."
  },
  {
    "title": "filterCriteria",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/filtercriteria",
    "html": "Discussion\n\nFor more information, see SetFocusFilterIntent.\n\nSee Also\nReading system configuration\nvar sound: UNNotificationSound?\nThe sound that plays when the system delivers the notification.\nvar interruptionLevel: UNNotificationInterruptionLevel\nThe notification’s importance and required delivery timing.\nenum UNNotificationInterruptionLevel\nConstants that indicate the importance and delivery timing of a notification.\nvar relevanceScore: Double\nThe score the system uses to determine if the notification is the summary’s featured notification."
  },
  {
    "title": "summaryArgumentCount",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/summaryargumentcount",
    "html": "See Also\nRetrieving group information\nvar threadIdentifier: String\nThe identifier that groups related notifications.\nvar categoryIdentifier: String\nThe identifier of the notification’s category.\nvar summaryArgument: String\nThe text the system adds to the notification summary to provide additional context."
  },
  {
    "title": "relevanceScore",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/relevancescore",
    "html": "Discussion\n\nThe system uses the relevanceScore, a value between 0 and 1, to sort the notifications from your app. The highest score gets featured in the notification summary.\n\nSee Also\nReading system configuration\nvar sound: UNNotificationSound?\nThe sound that plays when the system delivers the notification.\nvar interruptionLevel: UNNotificationInterruptionLevel\nThe notification’s importance and required delivery timing.\nenum UNNotificationInterruptionLevel\nConstants that indicate the importance and delivery timing of a notification.\nvar filterCriteria: String?\nThe criteria the system evaluates to determine if it displays the notification in the current Focus."
  },
  {
    "title": "threadIdentifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/threadidentifier",
    "html": "Discussion\n\nFor remote notifications, the system sets this property to the value of the thread-id key in the aps dictionary.\n\nSee Also\nRetrieving group information\nvar categoryIdentifier: String\nThe identifier of the notification’s category.\nvar summaryArgument: String\nThe text the system adds to the notification summary to provide additional context.\nvar summaryArgumentCount: Int\nThe number the system adds to the notification summary when the notification represents multiple items."
  },
  {
    "title": "interruptionLevel",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/interruptionlevel",
    "html": "See Also\nReading system configuration\nvar sound: UNNotificationSound?\nThe sound that plays when the system delivers the notification.\nenum UNNotificationInterruptionLevel\nConstants that indicate the importance and delivery timing of a notification.\nvar relevanceScore: Double\nThe score the system uses to determine if the notification is the summary’s featured notification.\nvar filterCriteria: String?\nThe criteria the system evaluates to determine if it displays the notification in the current Focus."
  },
  {
    "title": "init(named:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsound/init(named:)",
    "html": "Parameters\nname\n\nThe name of the sound file to play. This parameter must not be nil.\n\nReturn Value\n\nA sound object representing the custom sound.\n\nDiscussion\n\nThis method searches for sound files in the following locations, in order:\n\nThe <app_container>/Library/Sounds directory, where <app_container> is the app’s container directory.\n\nThe <group_container>/Library/Sounds directory, where <group_container> is one of the app’s shared group container directories. For information about how to configure group containers for your app, see Configure app groups.\n\nThe main bundle of the current executable.\n\nThe method chooses the first file it finds with the specified name.\n\nSee Also\nCreating Notification Sounds\nclass var `default`: UNNotificationSound\nReturns an object representing the default sound for notifications."
  },
  {
    "title": "targetContentIdentifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/targetcontentidentifier",
    "html": "Discussion\n\nUse this value to determine the content to show in your app when the user taps the notification.\n\nSee Also\nReading app configuration\nvar launchImageName: String\nThe name of the image or storyboard to use when your app launches because of the notification.\nvar badge: NSNumber?\nThe number that your app’s icon displays."
  },
  {
    "title": "default",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsound/default",
    "html": "Return Value\n\nA sound object that represents the default notification sound.\n\nSee Also\nCreating Notification Sounds\nconvenience init(named: UNNotificationSoundName)\nCreates a sound object that represents a custom sound file."
  },
  {
    "title": "launchImageName",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/launchimagename",
    "html": "Discussion\n\nIf you specify a value for this property, the system displays the specified image or storyboard when the system launches your app. The string in this property must match the name of an image file or storyboard in your app’s bundle.\n\nSee Also\nReading app configuration\nvar badge: NSNumber?\nThe number that your app’s icon displays.\nvar targetContentIdentifier: String?\nThe value your app uses to determine which scene to display to handle the notification."
  },
  {
    "title": "UNError",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror",
    "html": "Topics\nType Properties\nstatic var notificationsNotAllowed: UNError.Code\nNotifications are not allowed.\nstatic var attachmentInvalidURL: UNError.Code\nThe URL for an attachment was invalid.\nstatic var attachmentUnrecognizedType: UNError.Code\nThe file type of an attachment is not supported.\nstatic var attachmentInvalidFileSize: UNError.Code\nAn attachment is too large.\nstatic var attachmentNotInDataStore: UNError.Code\nThe specified attachment is not in the system data store.\nstatic var attachmentMoveIntoDataStoreFailed: UNError.Code\nAn error occurred when trying to move an attachment to the system data store.\nstatic var attachmentCorrupt: UNError.Code\nThe file for an attachment is corrupt.\nstatic var notificationInvalidNoDate: UNError.Code\nThe notification does not have an associated date, but should.\nstatic var notificationInvalidNoContent: UNError.Code\nThe notification has no user-facing content, but should.\nstatic var contentProvidingInvalid: UNError.Code\nstatic var contentProvidingObjectNotAllowed: UNError.Code\nstatic var badgeInputInvalid: UNError.Code\nError Information\nvar localizedDescription: String\nRetrieve the localized description for this error.\nstatic var errorDomain: String\nDefault domain of the error.\nlet UNErrorDomain: String\nThe error domain for notifications.\nenum Code\nConstants that identify notification errors.\nOperator Functions\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nType Properties\nstatic var errorDomain: String\nThe domain of the error.\nDefault Implementations\nCustomNSError Implementations\nEquatable Implementations\nError Implementations\nRelationships\nConforms To\nCustomNSError\nEquatable\nError\nHashable\nSendable\nSee Also\nHandling errors\nenum Code\nConstants that identify notification errors.\nlet UNErrorDomain: String\nThe error domain for notifications."
  },
  {
    "title": "userInfo",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/userinfo",
    "html": "Discussion\n\nFor remote notifications, this property contains the entire notification payload. For local notifications, you configure the property directly before scheduling the notification.\n\nThe keys in this dictionary must be property-list types—that’s, they must be types that can be serialized into the property-list format. For information about property-list types, see Property List Programming Guide.\n\nSee Also\nAccessing supplementary content\nvar attachments: [UNNotificationAttachment]\nThe visual and audio attachments to display alongside the notification’s main content."
  },
  {
    "title": "subtitle",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/subtitle",
    "html": "Discussion\n\nSubtitles offer additional context in cases where the title alone isn’t clear. Subtitles aren’t displayed in all cases. If your app isn’t authorized to display alert-based notifications, the system ignores this property.\n\nSee Also\nAccessing the primary content\nvar title: String\nThe localized text that provides the notification’s primary description.\nvar body: String\nThe localized text that provides the notification’s main content."
  },
  {
    "title": "body",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/body",
    "html": "Discussion\n\nThe body text contains the final text that you want to display. If your app isn’t authorized to display alert-based notifications, the system ignores this property.\n\nIf you specified two percent symbols (%%) in the message body, the system replaces it with a single percent symbol (%). The system strips all other printf style escape characters from your string prior to display.\n\nSee Also\nAccessing the primary content\nvar title: String\nThe localized text that provides the notification’s primary description.\nvar subtitle: String\nThe localized text that provides the notification’s secondary description."
  },
  {
    "title": "attachments",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/attachments",
    "html": "Discussion\n\nUse this property to retrieve the images, movies, and audio files associated with your notification’s content. A notification content app extension might use these values to add the associated content to its view controller.\n\nSee Also\nAccessing supplementary content\nvar userInfo: [AnyHashable : Any]\nThe custom data to associate with the notification."
  },
  {
    "title": "RawRepresentable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationinterruptionlevel/rawrepresentable-implementations",
    "html": "Topics\nInstance Properties\nvar hashValue: Int\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable.\nInstance Methods\nfunc hash(into: inout Hasher)\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationinterruptionlevel/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "serviceExtensionTimeWillExpire()",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationserviceextension/serviceextensiontimewillexpire()",
    "html": "Discussion\n\nIf your didReceive(_:withContentHandler:) method takes too long to execute its completion block, the system calls this method on a separate thread to give you one last chance to execute the block. Use this method to execute the block as quickly as possible. Doing so might mean providing some fallback content. For example, if your extension is still downloading an image file with the intent of attaching it to the notification’s content, update the notification’s alert text to indicate that an image download is in progress. If you fail to execute the completion block from the didReceive(_:withContentHandler:) method in time, the system displays the notification’s original content.\n\nSee Also\nProcessing Notifications\nfunc didReceive(UNNotificationRequest, withContentHandler: (UNNotificationContent) -> Void)\nAsks you to make any needed changes to the notification and notify the system when you’re done."
  },
  {
    "title": "UNNotificationDefaultActionIdentifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationdefaultactionidentifier",
    "html": "Discussion\n\nThe delivery of this action doesn’t require any special configuration of notification categories. Use the userNotificationCenter(_:didReceive:withCompletionHandler:) method of your delegate object to receive this action.\n\nSee Also\nGetting the Response Information\nvar actionIdentifier: String\nThe identifier string of the action that the user selected.\nvar notification: UNNotification\nThe notification to which the user responded.\nvar targetScene: UIScene?\nThe scene where the system reflects the user’s response to a notification.\nlet UNNotificationDismissActionIdentifier: String\nThe action that indicates the user explicitly dismissed the notification interface."
  },
  {
    "title": "notification",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationresponse/notification",
    "html": "See Also\nGetting the Response Information\nvar actionIdentifier: String\nThe identifier string of the action that the user selected.\nvar targetScene: UIScene?\nThe scene where the system reflects the user’s response to a notification.\nlet UNNotificationDefaultActionIdentifier: String\nAn action that indicates the user opened the app from the notification interface.\nlet UNNotificationDismissActionIdentifier: String\nThe action that indicates the user explicitly dismissed the notification interface."
  },
  {
    "title": "UNNotificationDismissActionIdentifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationdismissactionidentifier",
    "html": "Discussion\n\nThe system delivers this action only if your app configured the notification’s category object with the customDismissAction option. To trigger this action, the user must explicitly dismiss the notification interface. For example, the user must tap the Dismiss button or swipe down on the notification interface in watchOS to trigger this action.\n\nIgnoring a notification or flicking away a notification banner doesn’t trigger this action.\n\nSee Also\nGetting the Response Information\nvar actionIdentifier: String\nThe identifier string of the action that the user selected.\nvar notification: UNNotification\nThe notification to which the user responded.\nvar targetScene: UIScene?\nThe scene where the system reflects the user’s response to a notification.\nlet UNNotificationDefaultActionIdentifier: String\nAn action that indicates the user opened the app from the notification interface."
  },
  {
    "title": "targetScene",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationresponse/targetscene",
    "html": "See Also\nGetting the Response Information\nvar actionIdentifier: String\nThe identifier string of the action that the user selected.\nvar notification: UNNotification\nThe notification to which the user responded.\nlet UNNotificationDefaultActionIdentifier: String\nAn action that indicates the user opened the app from the notification interface.\nlet UNNotificationDismissActionIdentifier: String\nThe action that indicates the user explicitly dismissed the notification interface."
  },
  {
    "title": "userText",
    "url": "https://developer.apple.com/documentation/usernotifications/untextinputnotificationresponse/usertext",
    "html": "Discussion\n\nIf the user does not specify any text, this property contains an empty string."
  },
  {
    "title": "Setting up a remote notification server",
    "url": "https://developer.apple.com/documentation/UserNotifications/setting-up-a-remote-notification-server",
    "html": "Overview\n\nUse remote notifications (also known as push notifications) to push small amounts of data to devices that use your app, even when your app isn’t running. Apps use notifications to provide important information to users. For example, a messaging service sends remote notifications when new messages arrive.\n\nThe delivery of remote notifications involves several key components:\n\nYour company’s server, known as the provider server\n\nApple Push Notification service (APNs)\n\nThe user’s device\n\nYour app running on the user’s device\n\nRemote notifications begin with your company’s server. You decide which notifications you want to send to your users, and when to send them. When it’s time to send a notification, you generate a request that contains the notification data and a unique identifier for the user’s device. You then forward your request to APNs, which handles the delivery of the notification to the user’s device. Upon receipt of the notification, the operating system on the user’s device handles any user interactions and delivers the notification to your app.\n\nYou’re responsible for setting up a provider server (or servers) and for configuring your app to handle notifications on the user’s device. Apple manages everything in between, including the presentation of notifications to the user. You must also have an app running on the user’s device that can communicate with your server and provide necessary information. For information about how to configure your app to handle remote notifications, see Registering your app with APNs.\n\nTip\n\nIf you’re setting up a provider server to send push notifications to users in Safari and other browsers, see Sending web push notifications in web apps and browsers.\n\nBuild custom infrastructure for notifications\n\nSetting up a remote notification server consists of a few key tasks. How you implement these tasks depends on your infrastructure. Use the technologies that are appropriate for your company:\n\nWrite code to receive device tokens from instances of your app running on user devices, and to associate those tokens with your users’ accounts. See Registering your app with APNs.\n\nDetermine when to send notifications to your users, and write code to generate notification payloads. See Generating a remote notification.\n\nManage a connection to APNs using HTTP/2 and TLS. See Sending notification requests to APNs.\n\nWrite code to generate POST requests that contain your payloads, and send those requests over your HTTP/2 connection. See Sending notification requests to APNs.\n\nRegenerate your token periodically for token-based authentication. See Establishing a token-based connection to APNs.\n\nEstablish a trusted connection to APNs\n\nCommunication between your provider server and APNs must take place over a secure connection. Creating that connection requires installing the AAA Certificate Services root certificate on each of your provider servers.\n\nIf your provider server runs macOS 10.14 or later, the AAA Certificate Services root certificate is in the keychain by default. On other systems, you might need to install this certificate yourself. You can download the “AAACertificateServices 5/12/2020” certificate from the Sectigo KnowledgeBase website.\n\nTo send notifications, your provider server must establish either token-based or certificate-based trust with APNs using HTTP/2 and TLS. Both techniques have advantages and disadvantages, so decide which technique is best for your company.\n\nTo set up token-based trust with APNs, see Establishing a token-based connection to APNs.\n\nTo set up certificate-based trust with APNs, see Establishing a certificate-based connection to APNs.\n\nUnderstand what APNs provides\n\nAPNs makes every effort to deliver your notifications, and to deliver them with the best user experience:\n\nAPNs manages an accredited, encrypted, and persistent IP connection to the user’s device.\n\nAPNs can store notifications for a device that’s currently offline. APNs then forwards the stored notifications when the device comes online.\n\nIf APNs doesn’t deliver a notification immediately, either for device power considerations or because the destination is offline, it may coalesce notifications for the same bundle ID.\n\nTopics\nServer Tasks\nGenerating a remote notification\nSend notifications to the user’s device with a JSON payload.\nSending notification requests to APNs\nTransmit your remote notification payload and device token information to Apple Push Notification service (APNs).\nHandling notification responses from APNs\nRespond to the status codes that the APNs servers return.\nViewing the status of push notifications using Metrics and APNs\nMonitor and interpret the status of your push notifications with Apple Push Notification service (APNs).\nPushing background updates to your App\nDeliver notifications that wake your app and update it in the background.\nSecurity\nCreate a secure connection between your provider server and APNs.\nEstablishing a token-based connection to APNs\nSecure your communications with Apple Push Notification service (APNs) by using stateless authentication tokens.\nEstablishing a certificate-based connection to APNs\nSecure your communications with Apple Push Notification service (APNs) by installing a certificate on your provider server.\nSee Also\nRemote notifications\nRegistering your app with APNs\nCommunicate with Apple Push Notification service (APNs) and receive a unique device token that identifies your app.\nTesting notifications using the Push Notification Console\nSend test notifications and access delivery logs to test your app’s integration with Apple Push Notification service.\nSending push notifications using command-line tools\nUse basic macOS command-line tools to send push notifications to Apple Push Notification service (APNs)."
  },
  {
    "title": "UNAuthorizationStatus.provisional",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationstatus/provisional",
    "html": "See Also\nStatus\ncase notDetermined\nThe user hasn’t yet made a choice about whether the app is allowed to schedule notifications.\ncase denied\nThe app isn’t authorized to schedule or receive notifications.\ncase authorized\nThe app is authorized to schedule or receive notifications.\ncase ephemeral\nThe app is authorized to schedule or receive notifications for a limited amount of time."
  },
  {
    "title": "identifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationaction/identifier",
    "html": "Discussion\n\nWhen the user selects an action, the system reports the value of this string to your app. Because your app handles all actions by using a single delegate method, the identifier strings for all of your app’s actions must be unique.\n\nSee Also\nGetting Information\nvar title: String\nThe localized string to use as the title of the action.\nvar icon: UNNotificationActionIcon?\nThe icon associated with the action."
  },
  {
    "title": "title",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationaction/title",
    "html": "Discussion\n\nThe system displays this string as the title of the button that the user taps or selects in the notification interface.\n\nSee Also\nGetting Information\nvar identifier: String\nThe unique string that your app uses to identify the action.\nvar icon: UNNotificationActionIcon?\nThe icon associated with the action."
  },
  {
    "title": "identifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationattachment/identifier",
    "html": "See Also\nGetting the Attachment Contents\nvar url: URL\nThe URL of the file for this attachment.\nvar type: String\nThe UTI type of the attachment."
  },
  {
    "title": "type",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationattachment/type",
    "html": "Discussion\n\nThe system derives the value of this property from the attachment data.\n\nSee Also\nGetting the Attachment Contents\nvar identifier: String\nThe unique identifier for the attachment.\nvar url: URL\nThe URL of the file for this attachment."
  },
  {
    "title": "interruptionLevel",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/interruptionlevel",
    "html": "See Also\nIntegrating with the system\nvar sound: UNNotificationSound?\nThe sound that plays when the system delivers the notification.\nenum UNNotificationInterruptionLevel\nConstants that indicate the importance and delivery timing of a notification.\nvar relevanceScore: Double\nThe score the system uses to determine if the notification is the summary’s featured notification.\nvar filterCriteria: String?\nThe criteria the system evaluates to determine if it displays the notification in the current Focus."
  },
  {
    "title": "url",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationattachment/url",
    "html": "Discussion\n\nThe file at the specified URL is security scoped to your app. Before you access it, call the startAccessingSecurityScopedResource() method of NSURL.\n\nSee Also\nGetting the Attachment Contents\nvar identifier: String\nThe unique identifier for the attachment.\nvar type: String\nThe UTI type of the attachment."
  },
  {
    "title": "UNNotificationAttachmentOptionsThumbnailTimeKey",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationattachmentoptionsthumbnailtimekey",
    "html": "Discussion\n\nFor animated images, the value of this key is an NSNumber containing the frame number to use as the thumbnail. For movies, the value of this key is the time (in seconds) into the movie from which to grab the thumbnail image; you may also specify the value as a CMTime structure encoded using the CMTimeCopyAsDictionary(_:allocator:) function.\n\nSee Also\nCreating an Attachment\nconvenience init(identifier: String, url: URL, options: [AnyHashable : Any]?) throws\nCreates an attachment object from the specified file and options.\nlet UNNotificationAttachmentOptionsTypeHintKey: String\nA hint about an attachment’s file type.\nlet UNNotificationAttachmentOptionsThumbnailHiddenKey: String\nA Boolean value indicating whether the system hides the attachment’s thumbnail.\nlet UNNotificationAttachmentOptionsThumbnailClippingRectKey: String\nThe clipping rectangle for a thumbnail image."
  },
  {
    "title": "summaryArgumentCount",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/summaryargumentcount",
    "html": "See Also\nGrouping notifications\nvar threadIdentifier: String\nThe identifier that groups related notifications.\nvar categoryIdentifier: String\nThe identifier of the notification’s category.\nvar summaryArgument: String\nThe text the system adds to the notification summary to provide additional context."
  },
  {
    "title": "badge",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/badge",
    "html": "Discussion\n\nUse this property to specify the number to apply to the app’s icon when the notification arrives. If your app isn’t authorized to display badge-based notifications, the system ignores this property.\n\nSpecify the number 0 to remove the current badge, if present. Specify a number greater than 0 to display a badge with that number. Specify nil to leave the current badge unchanged.\n\nSee Also\nConfiguring app behavior\nvar launchImageName: String\nThe name of the image or storyboard to use when your app launches because of the notification.\nvar targetContentIdentifier: String?\nThe value your app uses to determine which scene to display to handle the notification."
  },
  {
    "title": "UNNotificationAttachmentOptionsThumbnailClippingRectKey",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationattachmentoptionsthumbnailclippingrectkey",
    "html": "Discussion\n\nThe value of this key is a dictionary containing a normalized CGRect — a unit rectangle whose values are in the range 0.0 to 1.0 and represent the portion of the original image that you want to display. For example, specifying an origin of (0.25, 0.25) and a size of (0.5, 0.5) defines a clipping rectangle that shows only the center portion of the image. Use the CGRectCreateDictionaryRepresentation(_:) function to create the dictionary for your rectangle.\n\nSee Also\nCreating an Attachment\nconvenience init(identifier: String, url: URL, options: [AnyHashable : Any]?) throws\nCreates an attachment object from the specified file and options.\nlet UNNotificationAttachmentOptionsTypeHintKey: String\nA hint about an attachment’s file type.\nlet UNNotificationAttachmentOptionsThumbnailHiddenKey: String\nA Boolean value indicating whether the system hides the attachment’s thumbnail.\nlet UNNotificationAttachmentOptionsThumbnailTimeKey: String\nThe frame number of an animation to use as a thumbnail image."
  },
  {
    "title": "UNNotificationAttachmentOptionsThumbnailHiddenKey",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationattachmentoptionsthumbnailhiddenkey",
    "html": "Discussion\n\nThe value of this key is an NSNumber containing a Boolean value. When set to true, the attachment’s thumbnail isn’t displayed. If you don’t include this key, the system shows the thumbnail.\n\nSee Also\nCreating an Attachment\nconvenience init(identifier: String, url: URL, options: [AnyHashable : Any]?) throws\nCreates an attachment object from the specified file and options.\nlet UNNotificationAttachmentOptionsTypeHintKey: String\nA hint about an attachment’s file type.\nlet UNNotificationAttachmentOptionsThumbnailClippingRectKey: String\nThe clipping rectangle for a thumbnail image.\nlet UNNotificationAttachmentOptionsThumbnailTimeKey: String\nThe frame number of an animation to use as a thumbnail image."
  },
  {
    "title": "launchImageName",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/launchimagename",
    "html": "Discussion\n\nIf you specify a value for this property, the system displays the specified image or storyboard when the system launches your app. The string in this property must match the name of an image file or storyboard in your app’s bundle. Specify nil to use the app’s default launch image. The default value of this property is nil.\n\nSee Also\nConfiguring app behavior\nvar badge: NSNumber?\nThe number that your app’s icon displays.\nvar targetContentIdentifier: String?\nThe value your app uses to determine which scene to display to handle the notification."
  },
  {
    "title": "UNNotificationAttachmentOptionsTypeHintKey",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationattachmentoptionstypehintkey",
    "html": "Discussion\n\nThe value of this key is an NSString containing a Uniform Type Identifier (UTI) that describes the file’s type. If you don’t include this key, the system uses the attachment’s filename extension to determine its type.\n\nSee Also\nCreating an Attachment\nconvenience init(identifier: String, url: URL, options: [AnyHashable : Any]?) throws\nCreates an attachment object from the specified file and options.\nlet UNNotificationAttachmentOptionsThumbnailHiddenKey: String\nA Boolean value indicating whether the system hides the attachment’s thumbnail.\nlet UNNotificationAttachmentOptionsThumbnailClippingRectKey: String\nThe clipping rectangle for a thumbnail image.\nlet UNNotificationAttachmentOptionsThumbnailTimeKey: String\nThe frame number of an animation to use as a thumbnail image."
  },
  {
    "title": "init(identifier:url:options:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationattachment/init(identifier:url:options:)-83grx",
    "html": "Parameters\nidentifier\n\nThe unique identifier of the attachment. Use this string to identify the attachment later. If you specify an empty string, this method creates a unique identifier string for you.\n\nURL\n\nThe URL of the file you want to attach to the notification. The URL must be a file URL and the file must be readable by the current process. This parameter must not be nil. For a list of supported file types, see Supported File Types.\n\noptions\n\nA dictionary of options related to the attached file. Use the options to specify meta information about the attachment, such as the clipping rectangle to use for the resulting thumbnail.\n\nerror\n\nAn error object indicating whether a problem occurred. If the system creates the attachment successfully, it sets this parameter to nil. If an error occurs, it’s set to an error object containing information about why the attachment wasn’t created. You may specify nil for this parameter if you don’t want the error information.\n\nReturn Value\n\nAn attachment object containing information about the specified file or nil if the attachment could not be created.\n\nDiscussion\n\nThis method verifies that the specified file is readable and that the file format is one of the supported types. When errors occur, the method provides an appropriate error object.\n\nWhen you schedule a notification request containing the attachment, the system moves the attachment’s file to a new location to facilitate access by the appropriate processes. After the move, the only way to access the file is using the methods of the UNUserNotificationCenter object.\n\nSee Also\nCreating an Attachment\nlet UNNotificationAttachmentOptionsTypeHintKey: String\nA hint about an attachment’s file type.\nlet UNNotificationAttachmentOptionsThumbnailHiddenKey: String\nA Boolean value indicating whether the system hides the attachment’s thumbnail.\nlet UNNotificationAttachmentOptionsThumbnailClippingRectKey: String\nThe clipping rectangle for a thumbnail image.\nlet UNNotificationAttachmentOptionsThumbnailTimeKey: String\nThe frame number of an animation to use as a thumbnail image."
  },
  {
    "title": "userInfo",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/userinfo",
    "html": "Discussion\n\nUse this property to associate custom information with the notification. The contents of the dictionary aren’t seen by the user, but are accessible to your app or to any notification-related app extensions.\n\nThe keys in this dictionary must be types that can be serialized into the property-list format. For information about property-list types, see Property List Programming Guide.\n\nSee Also\nProviding supplementary content\nvar attachments: [UNNotificationAttachment]\nThe visual and audio attachments to display alongside the notification’s main content."
  },
  {
    "title": "body",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/body",
    "html": "Discussion\n\nUse this property to specify the body of the notification alert. If your app isn’t authorized to display alert-based notifications, the system ignores this property.\n\nThe body text should contain the final text that you want to display, and shouldn’t contain any placeholder characters. To include a percent symbol (%) in the message body, use two percent symbols (%%). The system strips all other printf style escape characters from your string prior to display.\n\nSee Also\nProviding the primary content\nvar title: String\nThe localized text that provides the notification’s primary description.\nvar subtitle: String\nThe localized text that provides the notification’s secondary description."
  },
  {
    "title": "subtitle",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/subtitle",
    "html": "Discussion\n\nUse this property to specify additional context about the purpose of the notification. Subtitles offer additional context in cases where the title alone isn’t clear. Subtitles aren’t displayed in all cases. If your app isn’t authorized to display alert-based notifications, the system ignores this property.\n\nSee Also\nProviding the primary content\nvar title: String\nThe localized text that provides the notification’s primary description.\nvar body: String\nThe localized text that provides the notification’s main content."
  },
  {
    "title": "updating(from:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/updating(from:)",
    "html": "Parameters\nprovider\n\nThe notification content providing object.\n\nReturn Value\n\nThe notification content object for the content handler.\n\nDiscussion\n\nThe system contextualizes your UNNotificationContent object with other Apple SDK objects conforming to UNNotificationContentProviding. The system specializes the notification and decorates its look and behavior accordingly.\n\nFor example, the system treats the notification as a message with an avatar and promotes it to the top of notification center if the object passed in is a valid INSendMessageIntent that conforms to UNNotificationContentProviding. The system throws an error with a UNError.Code, if the UNNotificationContentProviding object is invalid. Pass the valid UNNotificationContent result directly to UNUserNotificationCenter without mutating.\n\nAdd this call to the UNNotificationServiceExtension in didReceive(_:withContentHandler:). Your app passes the returned UNNotificationContent to the contentHandler for incoming push notifications."
  },
  {
    "title": "attachments",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/attachments",
    "html": "Discussion\n\nUse this property to include images or movies, or to include playable audio files, with the contents of an alert. The system displays the attachments alongside the title and body of your alert. You can also customize the presentation of attachments using a notification content app extension.\n\nAll attachments must reside locally on the current device before your app adds them. For local notifications, modify this property before scheduling the notification. For remote notifications, use a notification service app extension to locate and download the specified files and modify the notification content before it’s delivered.\n\nFor more information on how to specify attachments, see UNNotificationAttachment.\n\nSee Also\nProviding supplementary content\nvar userInfo: [AnyHashable : Any]\nThe custom data to associate with the notification."
  },
  {
    "title": "title",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/title",
    "html": "Discussion\n\nUse this property to specify the title of your notification alert. If your app isn’t authorized to display alert-based notifications, the system ignores this property.\n\nTitle strings should be short, usually only a couple of words describing the reason for the notification. In watchOS, the system displays the title string as part of the short look notification interface, which has limited space.\n\nSee Also\nProviding the primary content\nvar subtitle: String\nThe localized text that provides the notification’s secondary description.\nvar body: String\nThe localized text that provides the notification’s main content."
  },
  {
    "title": "sound",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/sound",
    "html": "Discussion\n\nNotifications can play a default sound or a custom sound. For information on how to specify custom sounds for your notifications, see UNNotificationSound.\n\nSee Also\nReading system configuration\nvar interruptionLevel: UNNotificationInterruptionLevel\nThe notification’s importance and required delivery timing.\nenum UNNotificationInterruptionLevel\nConstants that indicate the importance and delivery timing of a notification.\nvar relevanceScore: Double\nThe score the system uses to determine if the notification is the summary’s featured notification.\nvar filterCriteria: String?\nThe criteria the system evaluates to determine if it displays the notification in the current Focus."
  },
  {
    "title": "init(templateImageName:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionicon/init(templateimagename:)",
    "html": "Parameters\ntemplateImageName\n\nThe name of a custom image in the app’s asset catalog. If the image isn’t in your app’s asset catalog, this method searches the app bundle for the image.\n\nYou don’t need to specify the filename extension or the @2x or @3x modifiers for this name. This method retrieves the appropriate image based on the system and the available image resources.\n\nReturn Value\n\nAn action icon initialized with the specified template image provided by your app.\n\nSee Also\nEssentials\nconvenience init(systemImageName: String)\nCreates an action icon by using a system symbol image."
  },
  {
    "title": "providesAppNotificationSettings",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/providesappnotificationsettings",
    "html": "See Also\nGetting Interface Settings\nvar alertStyle: UNAlertStyle\nThe type of alert that the app may display when the device is unlocked.\nenum UNAlertStyle\nConstants indicating the presentation styles for alerts.\nvar showPreviewsSetting: UNShowPreviewsSetting\nThe setting that indicates whether the app shows a preview of the notification’s content.\nenum UNShowPreviewsSetting\nConstants indicating the style previewing a notification’s content."
  },
  {
    "title": "showPreviewsSetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/showpreviewssetting",
    "html": "See Also\nGetting Interface Settings\nvar alertStyle: UNAlertStyle\nThe type of alert that the app may display when the device is unlocked.\nenum UNAlertStyle\nConstants indicating the presentation styles for alerts.\nenum UNShowPreviewsSetting\nConstants indicating the style previewing a notification’s content.\nvar providesAppNotificationSettings: Bool\nA Boolean value indicating the system displays a button for in-app notification settings."
  },
  {
    "title": "UNAlertStyle",
    "url": "https://developer.apple.com/documentation/usernotifications/unalertstyle",
    "html": "Topics\nPresentation Styles\ncase none\nNo alert.\ncase banner\nBanner alerts.\ncase alert\nModal alerts.\nInitializers\ninit?(rawValue: Int)\nDefault Implementations\nEquatable Implementations\nRawRepresentable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nGetting Interface Settings\nvar alertStyle: UNAlertStyle\nThe type of alert that the app may display when the device is unlocked.\nvar showPreviewsSetting: UNShowPreviewsSetting\nThe setting that indicates whether the app shows a preview of the notification’s content.\nenum UNShowPreviewsSetting\nConstants indicating the style previewing a notification’s content.\nvar providesAppNotificationSettings: Bool\nA Boolean value indicating the system displays a button for in-app notification settings."
  },
  {
    "title": "scheduledDeliverySetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/scheduleddeliverysetting",
    "html": "See Also\nGetting Device-Specific Settings\nvar notificationCenterSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in Notification Center.\nvar lockScreenSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear on a device’s Lock screen.\nvar carPlaySetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in CarPlay.\nvar alertSetting: UNNotificationSetting\nThe authorization status for displaying alerts.\nvar badgeSetting: UNNotificationSetting\nThe setting that indicates whether badges appear on your app’s icon.\nvar soundSetting: UNNotificationSetting\nThe authorization status for playing sounds for incoming notifications.\nvar criticalAlertSetting: UNNotificationSetting\nThe authorization status for playing sounds for critical alerts.\nvar announcementSetting: UNNotificationSetting\nThe setting that indicates whether Siri can announce your app’s notifications.\nvar timeSensitiveSetting: UNNotificationSetting\nThe setting that indicates the system treats the notification as time-sensitive.\nenum UNNotificationSetting\nConstants that indicate the current status of a notification setting."
  },
  {
    "title": "UNNotificationSetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsetting",
    "html": "Topics\nConstants\ncase notSupported\nThe setting is not available to your app.\ncase disabled\nThe setting is disabled.\ncase enabled\nThe setting is enabled.\nInitializers\ninit?(rawValue: Int)\nDefault Implementations\nEquatable Implementations\nRawRepresentable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nGetting Device-Specific Settings\nvar notificationCenterSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in Notification Center.\nvar lockScreenSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear on a device’s Lock screen.\nvar carPlaySetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in CarPlay.\nvar alertSetting: UNNotificationSetting\nThe authorization status for displaying alerts.\nvar badgeSetting: UNNotificationSetting\nThe setting that indicates whether badges appear on your app’s icon.\nvar soundSetting: UNNotificationSetting\nThe authorization status for playing sounds for incoming notifications.\nvar criticalAlertSetting: UNNotificationSetting\nThe authorization status for playing sounds for critical alerts.\nvar announcementSetting: UNNotificationSetting\nThe setting that indicates whether Siri can announce your app’s notifications.\nvar scheduledDeliverySetting: UNNotificationSetting\nThe setting that indicates the system schedules the notification.\nvar timeSensitiveSetting: UNNotificationSetting\nThe setting that indicates the system treats the notification as time-sensitive."
  },
  {
    "title": "alertStyle",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/alertstyle",
    "html": "Discussion\n\nWhen alerts are authorized, this property specifies the presentation style for alerts when the device is unlocked. The user may choose to display alerts as automatically disappearing banners or as modal windows that require explicit dismissal. The user may also choose not to display alerts at all.\n\nSee Also\nGetting Interface Settings\nenum UNAlertStyle\nConstants indicating the presentation styles for alerts.\nvar showPreviewsSetting: UNShowPreviewsSetting\nThe setting that indicates whether the app shows a preview of the notification’s content.\nenum UNShowPreviewsSetting\nConstants indicating the style previewing a notification’s content.\nvar providesAppNotificationSettings: Bool\nA Boolean value indicating the system displays a button for in-app notification settings."
  },
  {
    "title": "criticalAlertSetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/criticalalertsetting",
    "html": "Discussion\n\nWhen UNNotificationSetting.enabled, this property authorizes the app to play critical sounds that ignore Do Not Disturb and the device’s mute switch.\n\nFor local notifications, the system attempts to play a critical sound when the sound property of the UNNotificationContent object contains an object returned by the defaultCritical property, the criticalSoundNamed(_:) method, or a related method.\n\nFor remote notifications, the system attempts to play a critical sound when the notification’s payload contains a sound directory that contains the critical key.\n\nCritical alerts require a special entitlement issued by Apple.\n\nSee Also\nGetting Device-Specific Settings\nvar notificationCenterSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in Notification Center.\nvar lockScreenSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear on a device’s Lock screen.\nvar carPlaySetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in CarPlay.\nvar alertSetting: UNNotificationSetting\nThe authorization status for displaying alerts.\nvar badgeSetting: UNNotificationSetting\nThe setting that indicates whether badges appear on your app’s icon.\nvar soundSetting: UNNotificationSetting\nThe authorization status for playing sounds for incoming notifications.\nvar announcementSetting: UNNotificationSetting\nThe setting that indicates whether Siri can announce your app’s notifications.\nvar scheduledDeliverySetting: UNNotificationSetting\nThe setting that indicates the system schedules the notification.\nvar timeSensitiveSetting: UNNotificationSetting\nThe setting that indicates the system treats the notification as time-sensitive.\nenum UNNotificationSetting\nConstants that indicate the current status of a notification setting."
  },
  {
    "title": "badgeSetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/badgesetting",
    "html": "Discussion\n\nWhen the value of this property is UNNotificationSetting.enabled, the app is authorized to badge its icon. The system tries to badge your app’s icon when the badge property of a UNNotificationContent object contain a value, or when the aps dictionary in a remote notification contains the badge key.\n\nSee Also\nGetting Device-Specific Settings\nvar notificationCenterSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in Notification Center.\nvar lockScreenSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear on a device’s Lock screen.\nvar carPlaySetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in CarPlay.\nvar alertSetting: UNNotificationSetting\nThe authorization status for displaying alerts.\nvar soundSetting: UNNotificationSetting\nThe authorization status for playing sounds for incoming notifications.\nvar criticalAlertSetting: UNNotificationSetting\nThe authorization status for playing sounds for critical alerts.\nvar announcementSetting: UNNotificationSetting\nThe setting that indicates whether Siri can announce your app’s notifications.\nvar scheduledDeliverySetting: UNNotificationSetting\nThe setting that indicates the system schedules the notification.\nvar timeSensitiveSetting: UNNotificationSetting\nThe setting that indicates the system treats the notification as time-sensitive.\nenum UNNotificationSetting\nConstants that indicate the current status of a notification setting."
  },
  {
    "title": "soundSetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/soundsetting",
    "html": "Discussion\n\nWhen the value of this property is UNNotificationSetting.enabled, the system authorizes the app to play sounds. The system tries to play a sound when the sound property of the UNNotificationContent object contains a value, or when the aps dictionary in a remote notification contains the sound key.\n\nSee Also\nGetting Device-Specific Settings\nvar notificationCenterSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in Notification Center.\nvar lockScreenSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear on a device’s Lock screen.\nvar carPlaySetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in CarPlay.\nvar alertSetting: UNNotificationSetting\nThe authorization status for displaying alerts.\nvar badgeSetting: UNNotificationSetting\nThe setting that indicates whether badges appear on your app’s icon.\nvar criticalAlertSetting: UNNotificationSetting\nThe authorization status for playing sounds for critical alerts.\nvar announcementSetting: UNNotificationSetting\nThe setting that indicates whether Siri can announce your app’s notifications.\nvar scheduledDeliverySetting: UNNotificationSetting\nThe setting that indicates the system schedules the notification.\nvar timeSensitiveSetting: UNNotificationSetting\nThe setting that indicates the system treats the notification as time-sensitive.\nenum UNNotificationSetting\nConstants that indicate the current status of a notification setting."
  },
  {
    "title": "alertSetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/alertsetting",
    "html": "Discussion\n\nWhen the value of this property is UNNotificationSetting.enabled, the app is authorized to display alerts. Authorization does not guarantee that alerts always appear on the user’s screen. When a device is unlocked, the alertStyle property determines the presentation style for the alert, which can include not displaying the alert at all.\n\nThe system tries to display an alert when the title, subtitle, or body properties of a UNNotificationContent object contain values, or when the aps dictionary in a remote notification contains the alert key.\n\nSee Also\nGetting Device-Specific Settings\nvar notificationCenterSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in Notification Center.\nvar lockScreenSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear on a device’s Lock screen.\nvar carPlaySetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in CarPlay.\nvar badgeSetting: UNNotificationSetting\nThe setting that indicates whether badges appear on your app’s icon.\nvar soundSetting: UNNotificationSetting\nThe authorization status for playing sounds for incoming notifications.\nvar criticalAlertSetting: UNNotificationSetting\nThe authorization status for playing sounds for critical alerts.\nvar announcementSetting: UNNotificationSetting\nThe setting that indicates whether Siri can announce your app’s notifications.\nvar scheduledDeliverySetting: UNNotificationSetting\nThe setting that indicates the system schedules the notification.\nvar timeSensitiveSetting: UNNotificationSetting\nThe setting that indicates the system treats the notification as time-sensitive.\nenum UNNotificationSetting\nConstants that indicate the current status of a notification setting."
  },
  {
    "title": "notificationCenterSetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/notificationcentersetting",
    "html": "Discussion\n\nThe default value of this property is UNNotificationSetting.enabled.\n\nSee Also\nGetting Device-Specific Settings\nvar lockScreenSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear on a device’s Lock screen.\nvar carPlaySetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in CarPlay.\nvar alertSetting: UNNotificationSetting\nThe authorization status for displaying alerts.\nvar badgeSetting: UNNotificationSetting\nThe setting that indicates whether badges appear on your app’s icon.\nvar soundSetting: UNNotificationSetting\nThe authorization status for playing sounds for incoming notifications.\nvar criticalAlertSetting: UNNotificationSetting\nThe authorization status for playing sounds for critical alerts.\nvar announcementSetting: UNNotificationSetting\nThe setting that indicates whether Siri can announce your app’s notifications.\nvar scheduledDeliverySetting: UNNotificationSetting\nThe setting that indicates the system schedules the notification.\nvar timeSensitiveSetting: UNNotificationSetting\nThe setting that indicates the system treats the notification as time-sensitive.\nenum UNNotificationSetting\nConstants that indicate the current status of a notification setting."
  },
  {
    "title": "lockScreenSetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/lockscreensetting",
    "html": "Discussion\n\nEven if the user disables lock screen notifications, your notifications may still appear onscreen when the device is unlocked.\n\nSee Also\nGetting Device-Specific Settings\nvar notificationCenterSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in Notification Center.\nvar carPlaySetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in CarPlay.\nvar alertSetting: UNNotificationSetting\nThe authorization status for displaying alerts.\nvar badgeSetting: UNNotificationSetting\nThe setting that indicates whether badges appear on your app’s icon.\nvar soundSetting: UNNotificationSetting\nThe authorization status for playing sounds for incoming notifications.\nvar criticalAlertSetting: UNNotificationSetting\nThe authorization status for playing sounds for critical alerts.\nvar announcementSetting: UNNotificationSetting\nThe setting that indicates whether Siri can announce your app’s notifications.\nvar scheduledDeliverySetting: UNNotificationSetting\nThe setting that indicates the system schedules the notification.\nvar timeSensitiveSetting: UNNotificationSetting\nThe setting that indicates the system treats the notification as time-sensitive.\nenum UNNotificationSetting\nConstants that indicate the current status of a notification setting."
  },
  {
    "title": "authorizationStatus",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings/authorizationstatus",
    "html": "Discussion\n\nWhen the value of this property is UNAuthorizationStatus.authorized, your app is allowed to schedule and receive local and remote notifications. When authorized, use the alertSetting, badgeSetting, and soundSetting properties to specify which types of interactions are allowed. When the value of the property is UNAuthorizationStatus.denied, the system doesn’t deliver notifications to your app, and the system ignores any attempts to schedule local notifications.\n\nThe value of this property is UNAuthorizationStatus.notDetermined if your app has never requested authorization using the requestAuthorization(options:completionHandler:) method.\n\nSee Also\nGetting the Authorization Status\nenum UNAuthorizationStatus\nConstants indicating whether the app is allowed to schedule notifications."
  },
  {
    "title": "UNError.Code",
    "url": "https://developer.apple.com/documentation/usernotifications/unerror/code",
    "html": "Topics\nConstants\ncase notificationsNotAllowed\nNotifications aren’t allowed.\ncase attachmentInvalidURL\nThe URL for an attachment was invalid.\ncase attachmentUnrecognizedType\nThe file type of an attachment isn’t supported.\ncase attachmentInvalidFileSize\nAn attachment is too large.\ncase attachmentNotInDataStore\nThe specified attachment isn’t in the system data store.\ncase attachmentMoveIntoDataStoreFailed\nAn error occurred when trying to move an attachment to the system data store.\ncase attachmentCorrupt\nThe file for an attachment is corrupt.\ncase notificationInvalidNoDate\nThe notification doesn’t have an associated date, but should.\ncase notificationInvalidNoContent\nThe notification has no user-facing content, but should.\ncase contentProvidingInvalid\ncase contentProvidingObjectNotAllowed\nEnumeration Cases\ncase badgeInputInvalid\nInitializers\ninit?(rawValue: Int)\nDefault Implementations\nEquatable Implementations\nRawRepresentable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nHandling errors\nstruct UNError\nAn object that represents a notification error.\nlet UNErrorDomain: String\nThe error domain for notifications."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsoundname/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "nextTriggerDate()",
    "url": "https://developer.apple.com/documentation/usernotifications/untimeintervalnotificationtrigger/nexttriggerdate()",
    "html": "Return Value\n\nThe next trigger date.\n\nDiscussion\n\nUse this property to find out when a notification associated with this trigger will next be delivered.\n\nSee Also\nGetting the Trigger Information\nvar timeInterval: TimeInterval\nThe time interval to create the trigger."
  },
  {
    "title": "_SwiftNewtypeWrapper Implementations",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsoundname/_swiftnewtypewrapper-implementations",
    "html": "Topics\nInstance Properties\nvar hashValue: Int\nThe hash value.\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable.\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsoundname/init(rawvalue:)",
    "html": "Parameters\nrawValue\n\nA string containing the name of the sound.\n\nSee Also\nInitializers\ninit(String)\nCreates a notification sound name using the string parameter."
  },
  {
    "title": "init(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsoundname/init(_:)",
    "html": "Parameters\nrawValue\n\nA string containing the name of the sound.\n\nSee Also\nInitializers\ninit(rawValue: String)\nCreates a notification sound name using the string parameter."
  },
  {
    "title": "criticalSoundNamed(_:withAudioVolume:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsound/criticalsoundnamed(_:withaudiovolume:)",
    "html": "Parameters\nname\n\nThe name of the sound file to play. This file must be located in the current executable’s main bundle or in the Library/Sounds directory of the current app container directory. If files exist at both locations, the system uses the file from the Library/Sounds directory. This parameter must not be nil.\n\nvolume\n\nThe volume must be a value between 0.0 and 1.0.\n\nReturn Value\n\nA sound object representing a custom critical alert sound at the specified volume.\n\nDiscussion\n\nCritical alerts ignore the mute switch and Do Not Disturb. They require a special entitlement issued by Apple.\n\nSee Also\nGetting Critical Sounds\nclass var defaultCritical: UNNotificationSound\nThe default sound used for critical alerts.\nclass func defaultCriticalSound(withAudioVolume: Float) -> Self\nCreates a sound object that plays the default critical alert sound at the volume you specify.\nclass func criticalSoundNamed(UNNotificationSoundName) -> Self\nCreates a custom sound object for critical alerts."
  },
  {
    "title": "timeInterval",
    "url": "https://developer.apple.com/documentation/usernotifications/untimeintervalnotificationtrigger/timeinterval",
    "html": "Discussion\n\nThis property contains the original time interval that you specified when creating the trigger object. The value in this property isn’t updated as time counts down. To find out when the trigger will fire next, call the nextTriggerDate() method.\n\nSee Also\nGetting the Trigger Information\nfunc nextTriggerDate() -> Date?\nThe next date at which the trigger conditions are met."
  },
  {
    "title": "Establishing a token-based connection to APNs",
    "url": "https://developer.apple.com/documentation/usernotifications/establishing-a-token-based-connection-to-apns",
    "html": "Overview\n\nToken-based authentication offers a stateless way to communicate with APNs. Stateless communication is faster than certificate-based communication because it doesn’t require APNs to look up the certificate, or other information, related to your provider server. There are other advantages to using token-based authentication:\n\nYou can use the same token from multiple provider servers.\n\nYou can use one token to distribute notifications for all of your company’s apps.\n\nToken-based requests are slightly larger than certificate-based requests because each request contains the token. You must also update and encrypt your tokens at least once an hour using the provider token signing key that Apple provides you. To learn more about key creation, see Create a private key to access a service.\n\nImportant\n\nAPNs doesn’t support authentication tokens from multiple developer accounts over a single connection.\n\nObtain an encryption key and key ID from Apple\n\nYou need an APNs authentication token signing key to generate the tokens that your server uses. You request this key from your developer account on developer.apple.com, as shown in the following image:\n\nWhen you request a key, Apple gives you:\n\nA 10-character string with the Key ID. You must include this string in your JSON tokens. You can find instructions to get this ID in Get a key identifier.\n\nAn authentication token signing key, specified as a text file (with a .p8 file extension).\n\nSecure both pieces of information carefully. You use the authentication token signing key to encrypt your JSON tokens, so this key must remain private to prevent anyone else from generating those tokens.\n\nImportant\n\nIf you suspect that you may have a compromised authentication token signing key, revoke it and request a new one. (You revoke the key from your developer account on developer.apple.com in the same place where you created it). For maximum security, close all of your existing HTTP/2 connections to APNs and establish new connections before making new requests.\n\nFor detailed instructions on how to use an authentication token, see the authorization header field in Sending notification requests to APNs.\n\nCreate and encrypt your JSON token\n\nThe token that you include with your notification requests uses the JSON Web Token (JWT) specification. The following table describes the four key-value pairs the token itself contains:\n\nalg\n\n\t\n\nThe encryption algorithm you used to encrypt the token. APNs supports only the ES256 algorithm, so set the value of this key to ES256.\n\n\n\n\nkid\n\n\t\n\nThe 10-character Key ID you obtained from your developer account; see Get a key identifier.\n\n\n\n\niss\n\n\t\n\nThe issuer key, the value for which is the 10-character Team ID you use for developing your company’s apps. Obtain this value from your developer account.\n\n\n\n\niat\n\n\t\n\nThe “issued at” time, whose value indicates the time when the JSON token generated. Specify the value as the number of seconds since Epoch, in UTC. The value must be no more than one hour from the current time.\n\nThe keys divide between the header and claims payload of the JSON Web Token. The header of the token contains the encryption algorithm and Key ID, and the claims payload contains your Team ID and the token generation time. The code snippet below shows an example of a JSON token for a fictional developer account.\n\n{\n   \"alg\" : \"ES256\",\n   \"kid\" : \"ABC123DEFG\"\n}\n{\n   \"iss\": \"DEF123GHIJ\",\n   \"iat\": 1437179036\n}\n\n\nImportant\n\nIf the value in the iat field is more than one hour old, APNs rejects any notifications containing the token, returning an ExpiredProviderToken (403) error.\n\nEncrypt the resulting JSON data using your authentication token signing key and the specified algorithm. Your provider server must include the resulting encrypted data with all notification requests.\n\nFor detailed information about the JWT specification, see RFC 7519.\n\nAttach your token to notification requests\n\nWhen creating the POST request for a notification, include your encrypted token in the authorization header of your request. The token is in Base64URL-encoded JWT format, and is specified as bearer <token data>, as shown in the following example:\n\nauthorization = bearer eyAia2lkIjogIjhZTDNHM1JSWDciIH0.eyAiaXNzIjogIkM4Nk5WOUpYM0QiLCAiaWF0I\n\t\t jogIjE0NTkxNDM1ODA2NTAiIH0.MEYCIQDzqyahmH1rz1s-LFNkylXEa2lZ_aOCX4daxxTZkVEGzwIhALvkClnx5m5eAT6\n\t\t Lxw7LZtEQcH6JENhJTMArwLf3sXwi\n\n\n\n\nFor information on how to construct your POST requests, see Sending notification requests to APNs.\n\nRefresh your token regularly\n\nFor security, APNs requires you to refresh your token regularly. Refresh your token no more than once every 20 minutes and no less than once every 60 minutes. APNs rejects any request whose token contains a timestamp that’s more than one hour old. Similarly, APNs report an error if you use a new token more than once every 20 minutes on the same connection.\n\nOn your provider server, set up a recurring task to recreate your token with a current timestamp. Encrypt the token again and attach it to subsequent notification requests.\n\nTeam and bundle ID mapping\n\nYou can’t map a connection to APNs to multiple teams. If you manage APNs for multiple developer accounts, open separate connection pools for each of them.\n\nAs part of the authentication process, APNs relates a team ID and associated bundle IDs to a connection on the first push. After the authentication process, attempting to associate a different team or sending a push to a newly added bundle ID causes an error. To send remote notifications to a new topic, add the topic to your team in App Store Connect and create new connections to APNs.\n\nFor transferred apps, close and recreate any existing connections from your push provider server to APNs. If you don’t, APNs can’t start accepting push requests from the new team.\n\nSee Also\nSecurity\nEstablishing a certificate-based connection to APNs\nSecure your communications with Apple Push Notification service (APNs) by installing a certificate on your provider server."
  },
  {
    "title": "Pushing background updates to your App",
    "url": "https://developer.apple.com/documentation/usernotifications/pushing-background-updates-to-your-app",
    "html": "Overview\n\nIf your app’s server-based content changes infrequently or at irregular intervals, you can use background notifications to notify your app when new content becomes available. A background notification is a remote notification that doesn’t display an alert, play a sound, or badge your app’s icon. It wakes your app in the background and gives it time to initiate downloads from your server and update its content.\n\nImportant\n\nThe system treats background notifications as low priority: you can use them to refresh your app’s content, but the system doesn’t guarantee their delivery. In addition, the system may throttle the delivery of background notifications if the total number becomes excessive. The number of background notifications allowed by the system depends on current conditions, but don’t try to send more than two or three per hour.\n\nEnable the remote notifications capability\n\nTo receive background notifications, you must add the remote notifications background mode to your app. In the Signing and Capability tab, add the Background Modes capability, then select the Remote notification checkbox. The figure below shows what you must select to recieve background notifications.\n\nFor watchOS, add this capability to your WatchKit Extension.\n\nCreate a background notification\n\nTo send a background notification, create a remote notification with an aps dictionary that includes only the content-available key, as shown in the sample code below. You may include custom keys in the payload, but the aps dictionary must not contain any keys that would trigger user interactions.\n\n{\n   \"aps\" : {\n      \"content-available\" : 1\n   },\n   \"acme1\" : \"bar\",\n   \"acme2\" : 42\n}\n\n\n\n\nAdditionally, the notification’s POST request should contain the apns-push-type header field with a value of background, and the apns-priority field with a value of 5. The APNs server requires the apns-push-type field when sending push notifications to Apple Watch, and recommends it for all platforms. For more information, see Create a POST request to APNs in Sending notification requests to APNs.\n\nReceive background notifications\n\nWhen a device receives a background notification, the system may hold and delay the delivery of the notification, which can have the following side effects:\n\nWhen the system receives a new background notification, it discards the older notification and only holds the newest one.\n\nIf something force quits or kills the app, the system discards the held notification.\n\nIf the user launches the app, the system immediately delivers the held notification.\n\nTo deliver a background notification, the system wakes your app in the background. On iOS it then calls your app delegate’s application(_:didReceiveRemoteNotification:fetchCompletionHandler:) method. On watchOS, it calls your extension delegate’s didReceiveRemoteNotification(_:fetchCompletionHandler:) method. Your app has 30 seconds to perform any tasks and call the provided completion handler. For more information, see Handling notifications and notification-related actions.\n\nSee Also\nServer Tasks\nGenerating a remote notification\nSend notifications to the user’s device with a JSON payload.\nSending notification requests to APNs\nTransmit your remote notification payload and device token information to Apple Push Notification service (APNs).\nHandling notification responses from APNs\nRespond to the status codes that the APNs servers return.\nViewing the status of push notifications using Metrics and APNs\nMonitor and interpret the status of your push notifications with Apple Push Notification service (APNs)."
  },
  {
    "title": "Handling notification responses from APNs",
    "url": "https://developer.apple.com/documentation/usernotifications/handling-notification-responses-from-apns",
    "html": "Overview\n\nApple Push Notification service (APNs) provides a response to each POST request your server transmits. Each response contains a header with fields indicating the status of the response. If the request was successful, the body of the response is empty. If an error occurred, the body contains a JSON dictionary with additional information about the error.\n\nIf you find your device is having trouble receiving notifications, check the common problems listed in Troubleshoot problems with receiving notifications below.\n\nInterpret header responses\n\nTable 1 describes the meaning of the keys in the header response.\n\nTable 1. Header keys\n\nHeader name\n\n\t\n\nValue\n\n\n\n\napns-id\n\n\t\n\nThe same value found in the apns-id field of the request’s header. Use this value to identify the notification. If you don’t specify an apns-id field in your request, APNs creates a new UUID and returns it in this header.\n\n\n\n\n:status\n\n\t\n\nThe HTTP status code.\n\n\n\n\napns-unique-id\n\n\t\n\nAn identifier that is only available in the Developement enviroment. Use this to query Delivery Log information for the corresponding notification in Push Notifications Console. For more information, see Testing notifications using the Push Notification Console.\n\nTable 2 lists the possible values in the :status header of the response.\n\nTable 2. HTTP status codes\n\nStatus code\n\n\t\n\nDescription\n\n\n\n\n200\n\n\t\n\nSuccess.\n\n\n\n\n400\n\n\t\n\nBad request.\n\n\n\n\n403\n\n\t\n\nThere was an error with the certificate or with the provider’s authentication token.\n\n\n\n\n404\n\n\t\n\nThe request contained an invalid :path value.\n\n\n\n\n405\n\n\t\n\nThe request used an invalid :method value. Only POST requests are supported.\n\n\n\n\n410\n\n\t\n\nThe device token is no longer active for the topic.\n\n\n\n\n413\n\n\t\n\nThe notification payload was too large.\n\n\n\n\n429\n\n\t\n\nThe server received too many requests for the same device token.\n\n\n\n\n500\n\n\t\n\nInternal server error.\n\n\n\n\n503\n\n\t\n\nThe server is shutting down and unavailable.\n\nUnderstand error codes\n\nTable 3 lists the keys found in the JSON dictionary for unsuccessful requests. The JSON data might also be included in a GOAWAY frame when a connection is terminated.\n\nTable 3. Response keys\n\nKey\n\n\t\n\nDescription\n\n\n\n\nreason\n\n\t\n\nThe error code (specified as a string) indicating the reason for the failure. For a list of possible values, see the Response error strings table below.\n\n\n\n\ntimestamp\n\n\t\n\nThe time, represented in milliseconds since Epoch, at which APNs confirmed the token was no longer valid for the topic. This key is included only when the error in the :status field is 410.\n\nTable 4 lists the possible error codes included in the reason key of a response’s JSON payload.\n\nTable 4. Response error strings\n\nStatus code\n\n\t\n\nError string\n\n\t\n\nDescription\n\n\n\n\n400\n\n\t\n\nBadCollapseId\n\n\t\n\nThe collapse identifier exceeds the maximum allowed size.\n\n\n\n\n400\n\n\t\n\nBadDeviceToken\n\n\t\n\nThe specified device token is invalid. Verify that the request contains a valid token and that the token matches the environment.\n\n\n\n\n400\n\n\t\n\nBadExpirationDate\n\n\t\n\nThe apns-expiration value is invalid.\n\n\n\n\n400\n\n\t\n\nBadMessageId\n\n\t\n\nThe apns-id value is invalid.\n\n\n\n\n400\n\n\t\n\nBadPriority\n\n\t\n\nThe apns-priority value is invalid.\n\n\n\n\n400\n\n\t\n\nBadTopic\n\n\t\n\nThe apns-topic value is invalid.\n\n\n\n\n400\n\n\t\n\nDeviceTokenNotForTopic\n\n\t\n\nThe device token doesn’t match the specified topic.\n\n\n\n\n400\n\n\t\n\nDuplicateHeaders\n\n\t\n\nOne or more headers are repeated.\n\n\n\n\n400\n\n\t\n\nIdleTimeout\n\n\t\n\nIdle timeout.\n\n\n\n\n400\n\n\t\n\nInvalidPushType\n\n\t\n\nThe apns-push-type value is invalid.\n\n\n\n\n400\n\n\t\n\nMissingDeviceToken\n\n\t\n\nThe device token isn’t specified in the request :path. Verify that the :path header contains the device token.\n\n\n\n\n400\n\n\t\n\nMissingTopic\n\n\t\n\nThe apns-topic header of the request isn’t specified and is required. The apns-topic header is mandatory when the client is connected using a certificate that supports multiple topics.\n\n\n\n\n400\n\n\t\n\nPayloadEmpty\n\n\t\n\nThe message payload is empty.\n\n\n\n\n400\n\n\t\n\nTopicDisallowed\n\n\t\n\nPushing to this topic is not allowed.\n\n\n\n\n403\n\n\t\n\nBadCertificate\n\n\t\n\nThe certificate is invalid.\n\n\n\n\n403\n\n\t\n\nBadCertificateEnvironment\n\n\t\n\nThe client certificate is forthe wrong environment.\n\n\n\n\n403\n\n\t\n\nExpiredProviderToken\n\n\t\n\nThe provider token is stale and a new token should be generated.\n\n\n\n\n403\n\n\t\n\nForbidden\n\n\t\n\nThe specified action is not allowed.\n\n\n\n\n403\n\n\t\n\nInvalidProviderToken\n\n\t\n\nThe provider token is not valid, or the token signature can’t be verified.\n\n\n\n\n403\n\n\t\n\nMissingProviderToken\n\n\t\n\nNo provider certificate was used to connect to APNs, and the authorization header is missing or no provider token is specified.\n\n\n\n\n404\n\n\t\n\nBadPath\n\n\t\n\nThe request contained an invalid :path value.\n\n\n\n\n405\n\n\t\n\nMethodNotAllowed\n\n\t\n\nThe specified :method value isn’t POST.\n\n\n\n\n410\n\n\t\n\nExpiredToken\n\n\t\n\nThe device token has expired.\n\n\n\n\n410\n\n\t\n\nUnregistered\n\n\t\n\nThe device token is inactive for the specified topic. There is no need to send further pushes to the same device token, unless your application retrieves the same device token, see Registering your app with APNs\n\n\n\n\n413\n\n\t\n\nPayloadTooLarge\n\n\t\n\nThe message payload is too large. For information about the allowed payload size, see Create a POST request to APNs in Sending notification requests to APNs.\n\n\n\n\n429\n\n\t\n\nTooManyProviderTokenUpdates\n\n\t\n\nThe provider’s authentication token is being updated too often. Update the authentication token no more than once every 20 minutes.\n\n\n\n\n429\n\n\t\n\nTooManyRequests\n\n\t\n\nToo many requests were made consecutively to the same device token.\n\n\n\n\n500\n\n\t\n\nInternalServerError\n\n\t\n\nAn internal server error occurred.\n\n\n\n\n503\n\n\t\n\nServiceUnavailable\n\n\t\n\nThe service is unavailable.\n\n\n\n\n503\n\n\t\n\nShutdown\n\n\t\n\nThe APNs server is shutting down.\n\nListing 1 shows a sample response for a successful push request.\n\nListing 1. A successful response\n\nHEADERS\n  + END_STREAM\n  + END_HEADERS\n  apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b\n  :status = 200\n\n\nListing 2 shows a sample response when an error occurs.\n\nListing 2. An error response\n\nHEADERS\n  - END_STREAM\n  + END_HEADERS\n  :status = 400\n  content-type = application/json\n  apns-id: <a_UUID>\nDATA\n  + END_STREAM\n  { \"reason\" : \"BadDeviceToken\" }\n\nTroubleshoot problems with receiving notifications\n\nDuring testing, if you find that your test devices aren’t receiving push notifications sent by your provider server, examine the following possible causes:\n\nMake sure that your provider server has an up-to-date device token for your test device. Each time your app launches, it should request its current token and forward that token to your provider server. You should also implement the appropriate failure handler methods to determine if APNs reported an error. See Registering your app with APNs.\n\nCheck for errors returned by APNs. When failures occur, APNs reports an appropriate error back to your provider server. Use the error code to decide the proper action that makes sense for your app.\n\nMake sure you included the apns-push-type key in your request headers. This key is required starting in watchOS 6. The absence of this key may delay the delivery of notifications, or prevent their delivery altogether. See .\n\nCheck to see if you’re sending requests to the same device too quickly. APNs queues only one notification at a time for each device, and the device must acknowledge receipt of the notification before APNs dequeues it. If you send multiple notification requests in a very short period of time, each new request might overwrite the previous request.\n\nCheck to see if silent notifications are being throttled. APNs sends a limited number of silent notifications—notifications with the content-available key. In addition, if the device has already exceeded its power budget for the day, silent notifications aren’t sent again until the power budget resets, which happens once a day. These limits are disabled when testing your app from Xcode. See Pushing background updates to your App.\n\nCheck the firewall settings of your server and devices. To send notifications, your provider server must allow inbound and outbound TCP packets over port 443 for HTTP/2 connections, or port 2195 when using the binary interface. Devices connecting to APNs over Wi-Fi need to allow inbound and outbound TCP packets over port 5223, falling back to port 443 if port 5223 is unavailable.\n\nVerify that you aren’t spamming the device. If you send too many notifications to the same device within a short timespan, APNs may treat it as a denial-of-service attack and temporarily block your server from sending notifications.\n\nIf your provider server is unable to connect to APNs, examine the following possible causes:\n\nMake sure you have the needed certificates installed on your provider server. If your provider server doesn’t have the proper certificates for TLS/SSL validation, it cannot connect to APNs. For certificate-based connections, your provider server must also have the certificate you obtained from Apple. See Establishing a certificate-based connection to APNs.\n\nCheck how often your provider server connects to APNs. If your provider server opens and closes its connection to APNs repeatedly, APNs may treat it as a denial-of-service attack and temporarily block your server from connecting.\n\nYou can verify the TLS handshake between your provider server and APNs by running the OpenSSL s_client command from your server, as shown in Listing 3. This command can also show if your TLS/SSL certificates are expired or revoked.\n\nListing 3. Verifying the TLS handshake\n\n$ openssl s_client -connect api.development.push.apple.com:443 -cert YourSSLCertAndPrivateKey.pem -debug \n-showcerts -CAfile server-ca-cert.pem\n\nSee Also\nServer Tasks\nGenerating a remote notification\nSend notifications to the user’s device with a JSON payload.\nSending notification requests to APNs\nTransmit your remote notification payload and device token information to Apple Push Notification service (APNs).\nViewing the status of push notifications using Metrics and APNs\nMonitor and interpret the status of your push notifications with Apple Push Notification service (APNs).\nPushing background updates to your App\nDeliver notifications that wake your app and update it in the background."
  },
  {
    "title": "Generating a remote notification",
    "url": "https://developer.apple.com/documentation/usernotifications/generating-a-remote-notification",
    "html": "Overview\n\nRemote notifications convey important information to the user in the form of a JSON payload. The payload specifies the types of user interactions (alert, sound, or badge) that you want performed, and includes any custom data your app needs to respond to the notification.\n\nA basic remote notification payload includes Apple-defined keys and their custom values. You may also add custom keys and values specific to your notifications. Apple Push Notification service (APNs) refuses a notification if the total size of its payload exceeds the following limits:\n\nFor Voice over Internet Protocol (VoIP) notifications, the maximum payload size is 5 KB (5120 bytes).\n\nFor all other remote notifications, the maximum payload size is 4 KB (4096 bytes).\n\nCreate the JSON payload\n\nSpecify the payload for a remote notification using a JSON dictionary. Inside this dictionary, include an aps key whose value is a dictionary containing one or more additional Apple-defined keys, listed in Table 1. You can include keys instructing the system to display an alert, play a sound, or badge your app’s icon. You can also instruct the system to handle the notification silently in the background. For more information, see Pushing background updates to your App.\n\nIn addition to the Apple-defined keys, you may add custom keys to your payload to deliver small amounts of data to your app, notification service app extension, or notification content app extension. Your custom keys must have values with primitive types, such as dictionary, array, string, number, or Boolean. Custom keys are available in the userInfo dictionary of the UNNotificationContent object delivered to your app.\n\nTypically, you use custom keys to help your code process the notification. For example, you might include an identifier string that your code can use to look up app-specific data. Add app-specific keys as peers of the aps dictionary.\n\nListing 1 shows a notification payload that displays an alert message inviting the user to play a game. If the category key identifies a previously registered UNNotificationCategory object, the system adds action buttons to the alert. For example, the category here includes a play action to start the game immediately. The custom gameID key contains an identifier that the app can use to retrieve the game invitation.\n\nListing 1. A remote notification payload for showing an alert\n\n{\n   \"aps\" : {\n      \"alert\" : {\n         \"title\" : \"Game Request\",\n         \"subtitle\" : \"Five Card Draw\",\n         \"body\" : \"Bob wants to play poker\"\n      },\n      \"category\" : \"GAME_INVITATION\"\n   },\n   \"gameID\" : \"12345678\"\n}\n\n\nListing 2 shows a notification payload that badges the app’s icon and plays a sound. The specified sound file must be on the user’s device already, either in the app’s bundle or in the Library/Sounds folder of the app’s container. The messageID key contains app-specific information for identifying the message that caused the notification.\n\nListing 2. A remote notification payload for playing a sound\n\n{\n   \"aps\" : {\n      \"badge\" : 9,\n      \"sound\" : \"bingbong.aiff\"\n   },\n   \"messageID\" : \"ABCDEFGHIJ\"\n}\n\n\nFor more information about creating sounds for your notifications, see UNNotificationSound.\n\nImportant\n\nDon’t include customer information or any sensitive data, like a credit card number, in a notification’s payload. If you must include customer information or sensitive data, encrypt it before adding it to the payload. You can use a notification service app extension to decrypt the data on the user’s device. For more information, see Modifying content in newly delivered notifications.\n\nLocalize your alert messages\n\nThere are two ways to localize the content of remote notifications:\n\nInclude localized strings directly in the payload.\n\nAdd localized message strings in your app bundle, and let the system choose which strings to display.\n\nPlacing localized strings directly into the payload gives you more flexibility, but requires you to track the user’s preferred language on your provider server. Because your provider server supplies the strings, it must know which language to use. On the user’s device, you can retrieve the user’s preferred languages by examining the preferredLanguages property of NSLocale. Your app can then forward that information to your server.\n\nIf the text of your notification messages is predetermined, you can store your message strings in the Localizable.strings file of your app bundle and use the title-loc-key, subtitle-loc-key, and loc-key payload keys to specify which strings you want to display. Your localized strings may contain placeholders so that you can insert content dynamically into the final string. Listing 3 shows an example of a payload with a message derived from an app-provided string. The loc-args key contains an array of replacement variables to substitute into the string.\n\nListing 3. A remote notification payload with localized content\n\n{\n   \"aps\" : {\n      \"alert\" : {\n         \"loc-key\" : \"GAME_PLAY_REQUEST_FORMAT\",\n         \"loc-args\" : [ \"Shelly\", \"Rick\"]\n      }\n   }\n}\n\n\nFor more information about the keys you use for localized content, see Table 2.\n\nPayload key reference\n\nTable 1 lists the keys that you may include in the aps dictionary. To interact with the user, include the alert, badge, or sound keys. Don’t add your own custom keys to the aps dictionary; APNs ignores custom keys. Instead, add your custom keys as peers of the aps dictionary, as shown in Listing 1.\n\nTable 1. Keys to include in the aps dictionary\n\nKey\n\n\t\n\nValue type\n\n\t\n\nDescription\n\n\n\n\nalert\n\n\t\n\nDictionary (or String)\n\n\t\n\nThe information for displaying an alert. A dictionary is recommended. If you specify a string, the alert displays your string as the body text. For a list of dictionary keys, see Table 2.\n\n\n\n\nbadge\n\n\t\n\nNumber\n\n\t\n\nThe number to display in a badge on your app’s icon. Specify 0 to remove the current badge, if any.\n\n\n\n\nsound\n\n\t\n\nString\n\n\t\n\nThe name of a sound file in your app’s main bundle or in the Library/Sounds folder of your app’s container directory. Specify the string “default” to play the system sound. Use this key for regular notifications. For critical alerts, use the sound dictionary instead. For information about how to prepare sounds, see UNNotificationSound.\n\n\n\n\nsound\n\n\t\n\nDictionary\n\n\t\n\nA dictionary that contains sound information for critical alerts. For regular notifications, use the sound string instead.\n\n\n\n\nthread-id\n\n\t\n\nString\n\n\t\n\nAn app-specific identifier for grouping related notifications. This value corresponds to the threadIdentifier property in the UNNotificationContent object.\n\n\n\n\ncategory\n\n\t\n\nString\n\n\t\n\nThe notification’s type. This string must correspond to the identifier of one of the UNNotificationCategory objects you register at launch time. See Declaring your actionable notification types.\n\n\n\n\ncontent-available\n\n\t\n\nNumber\n\n\t\n\nThe background notification flag. To perform a silent background update, specify the value 1 and don’t include the alert, badge, or sound keys in your payload. See Pushing background updates to your App.\n\n\n\n\nmutable-content\n\n\t\n\nNumber\n\n\t\n\nThe notification service app extension flag. If the value is 1, the system passes the notification to your notification service app extension before delivery. Use your extension to modify the notification’s content. See Modifying content in newly delivered notifications.\n\n\n\n\ntarget-content-id\n\n\t\n\nString\n\n\t\n\nThe identifier of the window brought forward. The value of this key will be populated on the UNNotificationContent object created from the push payload. Access the value using the UNNotificationContent object’s targetContentIdentifier property.\n\n\n\n\ninterruption-level\n\n\t\n\nString\n\n\t\n\nThe importance and delivery timing of a notification. The string values “passive”, “active”, “time-sensitive”, or “critical” correspond to the UNNotificationInterruptionLevel enumeration cases.\n\n\n\n\nrelevance-score\n\n\t\n\nNumber\n\n\t\n\nThe relevance score, a number between 0 and 1, that the system uses to sort the notifications from your app. The highest score gets featured in the notification summary. See relevanceScore.\nIf your remote notification updates a Live Activity, you can set any Double value; for example, 25, 50, 75, or 100.\n\n\n\n\nfilter-criteria\n\n\t\n\nString\n\n\t\n\nThe criteria the system evaluates to determine if it displays the notification in the current Focus. For more information, see SetFocusFilterIntent.\n\n\n\n\nstale-date\n\n\t\n\nNumber\n\n\t\n\nThe UNIX timestamp that represents the date at which a Live Activity becomes stale, or out of date. For more information, see Displaying live data with Live Activities.\n\n\n\n\ncontent-state\n\n\t\n\nDictionary\n\n\t\n\nThe updated or final content for a Live Activity. The content of this dictionary must match the data you describe with your custom ActivityAttributes implementation. For more information, see Updating and ending your Live Activity with ActivityKit push notifications.\n\n\n\n\ntimestamp\n\n\t\n\nNumber\n\n\t\n\nThe UNIX timestamp that marks the time when you send the remote notification that updates or ends a Live Activity. For more information, see Updating and ending your Live Activity with ActivityKit push notifications.\n\n\n\n\nevent\n\n\t\n\nString\n\n\t\n\nThe string that describes whether you start, update, or end an ongoing Live Activity with the remote push notification. To start the Live Activity, use start. To update the Live Activity, use update. To end the Live Activity, use end. For more information, see Updating and ending your Live Activity with ActivityKit push notifications.\n\n\n\n\ndismissal-date\n\n\t\n\nNumber\n\n\t\n\nThe UNIX timestamp that represents the date at which the system ends a Live Activity and removes it from the Dynamic Island and the Lock Screen. For more information, see Updating and ending your Live Activity with ActivityKit push notifications.\n\n\n\n\nattributes-type\n\n\t\n\nString\n\n\t\n\nA string you use when you start a Live Activity with a remote push notification. It must match the name of the structure that describes the dynamic data that appears in a Live Activity. For more information, see Updating and ending your Live Activity with ActivityKit push notifications.\n\n\n\n\nattributes\n\n\t\n\nDictionary\n\n\t\n\nThe dictionary that contains data you pass to a Live Activity that you start with a remote push notification. For more information, see Updating and ending your Live Activity with ActivityKit push notifications.\n\nTable 2 lists the keys that you may include in the alert dictionary. Use these strings to specify the title and message to include in the alert banner.\n\nTable 2. Keys to include in the alert dictionary\n\nKey\n\n\t\n\nValue type\n\n\t\n\nDescription\n\n\n\n\ntitle\n\n\t\n\nString\n\n\t\n\nThe title of the notification. Apple Watch displays this string in the short look notification interface. Specify a string that’s quickly understood by the user.\n\n\n\n\nsubtitle\n\n\t\n\nString\n\n\t\n\nAdditional information that explains the purpose of the notification.\n\n\n\n\nbody\n\n\t\n\nString\n\n\t\n\nThe content of the alert message.\n\n\n\n\nlaunch-image\n\n\t\n\nString\n\n\t\n\nThe name of the launch image file to display. If the user chooses to launch your app, the contents of the specified image or storyboard file are displayed instead of your app’s normal launch image.\n\n\n\n\ntitle-loc-key\n\n\t\n\nString\n\n\t\n\nThe key for a localized title string. Specify this key instead of the title key to retrieve the title from your app’s Localizable.strings files. The value must contain the name of a key in your strings file.\n\n\n\n\ntitle-loc-args\n\n\t\n\nArray of strings\n\n\t\n\nAn array of strings containing replacement values for variables in your title string. Each %@ character in the string specified by the title-loc-key is replaced by a value from this array. The first item in the array replaces the first instance of the %@ character in the string, the second item replaces the second instance, and so on.\n\n\n\n\nsubtitle-loc-key\n\n\t\n\nString\n\n\t\n\nThe key for a localized subtitle string. Use this key, instead of the subtitle key, to retrieve the subtitle from your app’s Localizable.strings file. The value must contain the name of a key in your strings file.\n\n\n\n\nsubtitle-loc-args\n\n\t\n\nArray of strings\n\n\t\n\nAn array of strings containing replacement values for variables in your title string. Each %@ character in the string specified by subtitle-loc-key is replaced by a value from this array. The first item in the array replaces the first instance of the %@ character in the string, the second item replaces the second instance, and so on.\n\n\n\n\nloc-key\n\n\t\n\nString\n\n\t\n\nThe key for a localized message string. Use this key, instead of the body key, to retrieve the message text from your app’s Localizable.strings file. The value must contain the name of a key in your strings file.\n\n\n\n\nloc-args\n\n\t\n\nArray of strings\n\n\t\n\nAn array of strings containing replacement values for variables in your message text. Each %@ character in the string specified by loc-key is replaced by a value from this array. The first item in the array replaces the first instance of the %@ character in the string, the second item replaces the second instance, and so on.\n\nTable 3 lists the keys that you may include in the sound dictionary. Use these keys to configure the sound for a critical alert.\n\nTable 3. Keys to include in the sound dictionary\n\nKey\n\n\t\n\nValue type\n\n\t\n\nDescription\n\n\n\n\ncritical\n\n\t\n\nNumber\n\n\t\n\nThe critical alert flag. Set to 1 to enable the critical alert.\n\n\n\n\nname\n\n\t\n\nString\n\n\t\n\nThe name of a sound file in your app’s main bundle or in the Library/Sounds folder of your app’s container directory. Specify the string “default” to play the system sound. For information about how to prepare sounds, see UNNotificationSound.\n\n\n\n\nvolume\n\n\t\n\nNumber\n\n\t\n\nThe volume for the critical alert’s sound. Set this to a value between 0 (silent) and 1 (full volume).\n\nThe figure below shows the default placement of the title, subtitle, and body content in a banner notification. To customize the appearance of alerts, use a notification content app extension as described in Customizing the Appearance of Notifications.\n\nSee Also\nServer Tasks\nSending notification requests to APNs\nTransmit your remote notification payload and device token information to Apple Push Notification service (APNs).\nHandling notification responses from APNs\nRespond to the status codes that the APNs servers return.\nViewing the status of push notifications using Metrics and APNs\nMonitor and interpret the status of your push notifications with Apple Push Notification service (APNs).\nPushing background updates to your App\nDeliver notifications that wake your app and update it in the background."
  },
  {
    "title": "removePendingNotificationRequests(withIdentifiers:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/removependingnotificationrequests(withidentifiers:)",
    "html": "Parameters\nidentifiers\n\nAn array of NSString objects, each of which contains the identifier of an active UNNotificationRequest object. If the identifier belongs to a non repeating request, and the trigger condition for that request has already been met, this method ignores the identifier.\n\nDiscussion\n\nThis method executes asynchronously, removing the pending notification requests on a secondary thread.\n\nlet center = UNUserNotificationCenter.current()\ncenter.removePendingNotificationRequests(withIdentifiers: [\"com.example.mynotification\"])\n\nSee Also\nScheduling notifications\nfunc add(UNNotificationRequest, withCompletionHandler: (((any Error)?) -> Void)?)\nSchedules the delivery of a local notification.\nfunc getPendingNotificationRequests(completionHandler: ([UNNotificationRequest]) -> Void)\nFetches all of your app’s local notifications that are pending delivery.\nfunc removeAllPendingNotificationRequests()\nRemoves all of your app’s pending local notifications."
  },
  {
    "title": "removeAllPendingNotificationRequests()",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/removeallpendingnotificationrequests()",
    "html": "Discussion\n\nThis method executes asynchronously, removing all pending notification requests on a secondary thread.\n\nlet center = UNUserNotificationCenter.current()\ncenter.removeAllPendingNotificationRequests()\n\nSee Also\nScheduling notifications\nfunc add(UNNotificationRequest, withCompletionHandler: (((any Error)?) -> Void)?)\nSchedules the delivery of a local notification.\nfunc getPendingNotificationRequests(completionHandler: ([UNNotificationRequest]) -> Void)\nFetches all of your app’s local notifications that are pending delivery.\nfunc removePendingNotificationRequests(withIdentifiers: [String])\nRemoves your app’s local notifications that are pending and match the specified identifiers."
  },
  {
    "title": "userNotificationCenter(_:openSettingsFor:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenterdelegate/usernotificationcenter(_:opensettingsfor:)",
    "html": "Required"
  },
  {
    "title": "supportsContentExtensions",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/supportscontentextensions",
    "html": "Discussion\n\nNotification content extensions let you customize the appearance of the alerts displayed for your app’s notifications. The value of this property is true for devices that support notification content extensions and false for devices that do not support them. For information about how to implement a notification content extension, see Customizing the Appearance of Notifications.\n\nSee Also\nProcessing received notifications\nvar delegate: (any UNUserNotificationCenterDelegate)?\nThe notification center’s delegate.\nprotocol UNUserNotificationCenterDelegate\nAn interface for processing incoming notifications and responding to notification actions."
  },
  {
    "title": "UNNotificationPresentationOptions",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationpresentationoptions",
    "html": "Topics\nConstants\nstatic var badge: UNNotificationPresentationOptions\nApply the notification’s badge value to the app’s icon.\nstatic var banner: UNNotificationPresentationOptions\nPresent the notification as a banner.\nstatic var list: UNNotificationPresentationOptions\nShow the notification in Notification Center.\nstatic var sound: UNNotificationPresentationOptions\nPlay the sound associated with the notification.\nstatic var alert: UNNotificationPresentationOptions\nDisplay the alert using the content provided by the notification.\nDeprecated\nInitializers\ninit(rawValue: UInt)\nInitializes a notification presentation options object using the specified raw value.\nDefault Implementations\nEquatable Implementations\nOptionSet Implementations\nSetAlgebra Implementations\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nReceiving Notifications\nfunc userNotificationCenter(UNUserNotificationCenter, willPresent: UNNotification, withCompletionHandler: (UNNotificationPresentationOptions) -> Void)\nAsks the delegate how to handle a notification that arrived while the app was running in the foreground."
  },
  {
    "title": "userNotificationCenter(_:willPresent:withCompletionHandler:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenterdelegate/usernotificationcenter(_:willpresent:withcompletionhandler:)",
    "html": "Parameters\ncenter\n\nThe shared user notification center object that received the notification.\n\nnotification\n\nThe notification that is about to be delivered. Use the information in this object to determine an appropriate course of action. For example, you might use the information to update your app’s interface.\n\ncompletionHandler\n\nThe block to execute with the presentation option for the notification. Always execute this block at some point during your implementation of this method. Use the options parameter to specify how you want the system to alert the user, if at all. This block has no return value and takes the following parameter:\n\noptions\n\nThe option for notifying the user. Specify UNNotificationPresentationOptionNone to silence the notification completely. Specify other values to interact with the user. For a list of possible options, see UNNotificationPresentationOptions.\n\nDiscussion\n\nImportant\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\noptional func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification) async -> UNNotificationPresentationOptions\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nIf your app is in the foreground when a notification arrives, the shared user notification center calls this method to deliver the notification directly to your app. If you implement this method, you can take whatever actions are necessary to process the notification and update your app. When you finish, call the completionHandler block and specify how you want the system to alert the user, if at all.\n\nIf your delegate does not implement this method, the system behaves as if you had passed the UNNotificationPresentationOptionNone option to the completionHandler block. If you do not provide a delegate at all for the UNUserNotificationCenter object, the system uses the notification’s original options to alert the user.\n\nSee Also\nReceiving Notifications\nstruct UNNotificationPresentationOptions\nConstants indicating how to present a notification in a foreground app."
  },
  {
    "title": "destructive",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions/destructive",
    "html": "Discussion\n\nUse this option for actions that delete user data or change the app irrevocably. The action button is displayed with special highlighting to indicate that it performs a destructive task.\n\nSee Also\nConstants\nstatic var authenticationRequired: UNNotificationActionOptions\nThe action can be performed only on an unlocked device.\nstatic var foreground: UNNotificationActionOptions\nThe action causes the app to launch in the foreground."
  },
  {
    "title": "Handling Communication Notifications and Focus Status Updates",
    "url": "https://developer.apple.com/documentation/usernotifications/handling-communication-notifications-and-focus-status-updates",
    "html": "Overview\n\nCommunication notifications have a distinct user experience that features prominent avatars and group names, as well as unique breakthrough behaviors. Implement these notifications for incoming calls and messages to provide additional context to the user.\n\nNote\n\nThis sample code project is associated with WWDC21 session 10091: Send communication and Time Sensitive notifications.\n\nConfigure the Sample Code Project\n\nThis sample runs on physical devices in order to meet requirements for push notifications and the Notification Service Extension. The Notification Service Extension modifies a notification’s content before it’s displayed on the user’s device. To learn more about Notification Service Extensions, see Modifying Content in Newly Delivered Notifications.\n\nBegin by configuring the iOS target to include your development team and a bundle identifier. The bundle identifier must support the following capabilities:\n\nPush notifications\n\nCommunication notifications\n\nTime Sensitive notifications\n\nSiriKit\n\nTo support communication notifications, the app’s Info.plist file must contain a top-level entry with the key NSUserActivityTypes and type Array. This array should contain INStartCallIntent if the app supports calling functionality, and INSendMessageIntent if it supports messaging.\n\nAccessing a user’s Focus status requires their authorization. To let the user know how the app uses their Focus status, include a usage description string. Provide this usage description string as a value for the Privacy - Focus Status Usage Description key in the app’s Info.plist file.\n\nDonate Intent Interactions\n\nDonate an intent interaction for each communication that takes place in the app. The app should donate both outgoing and incoming communication interactions. Donate incoming interactions to update communication notifications and enable their unique user experience and breakthrough behavior. Donate outgoing interactions when the current user sends messages or initiates calls. This allows the system to make better suggestions and provide communication notification functionality.\n\nThe sample initializes interactions in CommunicationMapper.ineraction(communicationInformation:) and donates them in the suggest(communicationInformation:completion:) method. The provided communication information determines the interaction’s direction.\n\n    /// Outgoing messages and calls suggest people involved for Focus breakthrough.\n    static func suggest(communicationInformation: CommunicationInformation,\n                        completion: @escaping (Result<INInteraction, Error>) -> Void) {\n        do {\n            // Create an INInteraction.\n            let interaction = try CommunicationMapper.interaction(communicationInformation: communicationInformation)\n            // Donate INInteraction to the system.\n            interaction.donate { [completion] error in\n                DispatchQueue.global(qos: .userInitiated).async {\n                    if let error = error {\n                        completion(.failure(error))\n                    } else {\n                        completion(.success(interaction))\n                    }\n                }\n            }\n        } catch let error {\n            // Catch CommunicationMapper errors.\n            completion(.failure(error))\n        }\n    }\n\nUpdate Notification Content\n\nTo display a communication notification, your app should update the notification’s content. This allows the notification to break through scheduled notification summaries. It’s also possible for communication notifications to break through an enabled Focus when the Allowed People list contains the sender. Use the same intent object that initialized the incoming interaction. Wait for the interaction donation to complete before updating notification content.\n\nThe sample updates notification content in the Notification Service Extension by calling CommunicationInteractor.update(notificationContent:communicationInformation:completion:).\n\n    /// Update incoming notifications with a message or call information to allow the following:\n    /// - Display an avatar, if present.\n    /// - Check if sender is allowed to break through.\n    /// - Update notification title (sender's name) and subtitle (group information).\n    @available(iOS 15.0, watchOS 8.0, macOS 12.0, *)\n    static func update(notificationContent: UNNotificationContent,\n                       communicationInformation: CommunicationInformation,\n                       completion: @escaping (Result<UNNotificationContent, Error>) -> Void) {\n        suggest(communicationInformation: communicationInformation) { [notificationContent] result in\n            switch result {\n                case .failure(let error):\n                    completion(.failure(error))\n                case .success(let interaction):\n                    guard let notificationContentProvider = interaction.intent as? UNNotificationContentProviding else {\n                        completion(.failure(CommunicationInteractorError.unexpectedIntentType))\n                        return\n                    }\n                    do {\n                        let updatedContent = try notificationContent.updating(from: notificationContentProvider)\n                        completion(.success(updatedContent))\n                    } catch let error {\n                        completion(.failure(error))\n                    }\n            }\n        }\n    }\n\nRequest Focus Status\n\nWhen a user has enabled a Focus, it may be useful to display that status to other users of an app. This informs other users when someone silences their notifications and may not see communications right away.\n\nAccessing the user’s Focus status requires explicit user authorization. To request authorization, use INFocusStatusCenter.default.requestAuthorization(completionHandler:) and parse the result. Someone can choose to authorize the app to access their Focus status, deny the app access, or choose neither.\n\n    /// Requests FocusStatusCenter authorization.\n    /// Parameter completion: Result contains AuthorizationStatus or error.\n    @available(iOS 15.0, watchOS 8.0, macOS 12.0, *)\n    static func requestFocusStatusAuthorization(completion: @escaping (Result<AuthorizationStatus, Error>) -> Void) {\n        INFocusStatusCenter.default.requestAuthorization { status in\n            switch status {\n                case .denied:\n                    completion(.success(.denied))\n                case .authorized:\n                    completion(.success(.authorized))\n                case .notDetermined:\n                    completion(.success(.notDetermined))\n                case .restricted:\n                    completion(.success(.restricted))\n                @unknown default:\n                    completion(.success(.notSupported))\n            }\n        }\n    }\n\n\nOnce authorized, an app can request the user’s current Focus status. The perspective of the app is important; the user doesn’t appear focused to an app if an enabled Focus allows notifications from that app.\n\nThe sample accesses the current Focus status in the requestFocusStatus(completion:) method. Unauthorized apps don’t receive a Focus status value. Ensure the app handles the nil Focus status case.\n\n    /// Requests current focus status.\n    /// Requires UserNotifications and FocusStatus to be authorized and Communication Notifications capability enabled for the app's target.\n    /// Parameter completion: Result contains FocusStatus isFocused Bool, which will be true if Focus is enabled and this app\n    /// isn't in its Allowed Apps list.\n    @available(iOS 15.0, watchOS 8.0, macOS 12.0, *)\n    static func requestFocusStatus(completion: @escaping (Result<Bool, Error>) -> Void) {\n        guard let isFocused = INFocusStatusCenter.default.focusStatus.isFocused else {\n            completion(.failure(CommunicationInteractorError.focusStatusNotAvailable))\n            return\n        }\n        completion(.success(isFocused))\n    }\n\n\nObserve Focus status changes from an Intents app extension. This extension launches in the background to handle interactions between your app and SiriKit. To learn more about Intents app extensions, see Creating an Intents App Extension. Ensure your Intents app extension target includes support for INShareFocusStatusIntent. The Intents app extension target’s General tab in the project file contains the list of supported intents. Include the class names of all supported intents in the Supported Intents section.\n\nThe Intents app extension in the sample handles incoming INShareFocusStatusIntent objects. When doing so, the sample uses the intent itself to access the isFocused bool directly instead of using the default INFocusStatusCenter.\n\n/**\n     For this Intent to be handled, the following requirements must be met:\n     FocusStatusCenter authorized for parent app (target).\n     UserNotifications authorized for parent app (target).\n     Communication Notifications capability (entitlement) added to the parent app (target).\n     */\n    func handle(intent: INShareFocusStatusIntent, completion: @escaping (INShareFocusStatusIntentResponse) -> Void) {\n        let response = INShareFocusStatusIntentResponse(code: .success, userActivity: nil)\n        if let isFocused = intent.focusStatus?.isFocused {\n            // Send isFocused value to servers or AppGroup.\n            print(\"Is user focused: \\(isFocused)\")\n        }\n        completion(response)\n    }\n\nSee Also\nSample code\nImplementing Alert Push Notifications\nAdd visible alert notifications to your app by using the UserNotifications framework.\nImplementing Background Push Notifications\nAdd background notifications to your app by using the UserNotifications framework."
  },
  {
    "title": "Modifying content in newly delivered notifications",
    "url": "https://developer.apple.com/documentation/usernotifications/modifying-content-in-newly-delivered-notifications",
    "html": "Overview\n\nYou may want to modify the content of a remote notification on a user’s iOS device if you need to:\n\nDecrypt data sent in an encrypted format.\n\nDownload images or other media attachments whose size would exceed the maximum payload size.\n\nUpdate the notification’s content, perhaps by incorporating data from the user’s device.\n\nModifying a remote notification requires a notification service app extension, which you include inside your iOS app bundle. The app extension receives the contents of your remote notifications before the system displays them to the user, giving you time to update the notification payload. You control which notifications your extension handles.\n\nImportant\n\nNotification service app extensions only operate on remote notifications configured in the system to display an alert to the user. If alerts are disabled for your app, or if the payload specifies only the playing of a sound or the badging of an icon, the extension isn’t employed.\n\nAdd a service app extension to your project\n\nA notification service app extension ships as a separate bundle inside your iOS app. To add this extension to your app:\n\nSelect File > New > Target in Xcode.\n\nSelect the Notification Service Extension target from the iOS > Application section.\n\nClick Next.\n\nSpecify a name and other configuration details for your app extension.\n\nClick Finish.\n\nImplement your extension’s handler methods\n\nThe notification service app extension template provided by Xcode includes a default implementation for you to modify.\n\nUse the didReceive(_:withContentHandler:) method to create a new UNMutableNotificationContent object with the updated content.\n\nUse the serviceExtensionTimeWillExpire() method to terminate any payload-modification tasks that are still running.\n\nYour didReceive(_:withContentHandler:) method has only about 30 seconds to modify the payload and call the provided completion handler. If your code takes longer than that, the system calls the serviceExtensionTimeWillExpire() method, at which point you must return whatever you can to the system immediately. If you fail to call the completion handler from either method, the system displays the original contents of the notification.\n\nListing 1 shows an implementation of the UNNotificationServiceExtension object that decrypts the contents of a secret message delivered using a remote notification. The didReceive(_:withContentHandler:) method decrypts the data and returns a modified version of the notification’s content if it’s successful. If it’s unsuccessful, or if time expires, the extension returns content indicating that the data is still encrypted.\n\nListing 1. Decrypting data contained in a remote notification\n\n// Storage for the completion handler and content.\nvar contentHandler: ((UNNotificationContent) -> Void)?\nvar bestAttemptContent: UNMutableNotificationContent?\n// Modify the payload contents.\noverride func didReceive(_ request: UNNotificationRequest,\n         withContentHandler contentHandler: \n         @escaping (UNNotificationContent) -> Void) {\n   self.contentHandler = contentHandler\n   self.bestAttemptContent = (request.content.mutableCopy() \n         as? UNMutableNotificationContent)\n   \n   // Try to decode the encrypted message data.\n   let encryptedData = bestAttemptContent?.userInfo[\"ENCRYPTED_DATA\"]\n   if let bestAttemptContent = bestAttemptContent {\n      if let data = encryptedData as? String {\n         let decryptedMessage = self.decrypt(data: data)\n        bestAttemptContent.body = decryptedMessage\n      }\n      else {\n         bestAttemptContent.body = \"(Encrypted)\"\n      }\n      \n      // Always call the completion handler when done.      \n      contentHandler(bestAttemptContent)\n   }\n}\n    \n// Return something before time expires.\noverride func serviceExtensionTimeWillExpire() {\n   if let contentHandler = contentHandler, \n      let bestAttemptContent = bestAttemptContent {\n         \n      // Mark the message as still encrypted.   \n      bestAttemptContent.subtitle = \"(Encrypted)\"\n      bestAttemptContent.body = \"\"\n      contentHandler(bestAttemptContent)\n   }\n}\n\nConfigure the payload for the remote notification\n\nThe system executes your notification service app extension only when a remote notification’s payload contains the following information:\n\nThe payload must include the mutable-content key with a value of 1.\n\nThe payload must include an alert dictionary with title, subtitle, or body information.\n\nListing 2 shows the JSON data for a notification payload containing encrypted data. The mutable-content flag is set so that the user’s device knows to run the corresponding service app extension, the code for which is shown in .\n\nListing 2. Specifying the remote notification payload\n\n{\n   \"aps\" : {\n      \"category\" : \"SECRET\",\n      \"mutable-content\" : 1,\n      \"alert\" : {\n         \"title\" : \"Secret Message!\",\n         \"body\"  : \"(Encrypted)\"\n     },\n   },\n   \"ENCRYPTED_DATA\" : \"Salted__·öîQÊ$UDì_¶Ù∞èΩ^¬%gq∞NÿÒQùw\"\n}\n\nSee Also\nNotification service app extension\nclass UNNotificationServiceExtension\nAn object that modifies the content of a remote notification before it’s delivered to the user."
  },
  {
    "title": "UNAuthorizationOptions",
    "url": "https://developer.apple.com/documentation/usernotifications/unauthorizationoptions",
    "html": "Topics\nOptions\nstatic var badge: UNAuthorizationOptions\nThe ability to update the app’s badge.\nstatic var sound: UNAuthorizationOptions\nThe ability to play sounds.\nstatic var alert: UNAuthorizationOptions\nThe ability to display alerts.\nstatic var carPlay: UNAuthorizationOptions\nThe ability to display notifications in a CarPlay environment.\nstatic var criticalAlert: UNAuthorizationOptions\nThe ability to play sounds for critical alerts.\nstatic var providesAppNotificationSettings: UNAuthorizationOptions\nAn option indicating the system should display a button for in-app notification settings.\nstatic var provisional: UNAuthorizationOptions\nThe ability to post noninterrupting notifications provisionally to the Notification Center.\nInitializers\ninit(rawValue: UInt)\nInitializes an authorization options constant using the specified raw value.\nDeprecated\nstatic var announcement: UNAuthorizationOptions\nThe ability for Siri to automatically read out messages over AirPods.\nstatic var timeSensitive: UNAuthorizationOptions\nDefault Implementations\nEquatable Implementations\nOptionSet Implementations\nSetAlgebra Implementations\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nRequesting authorization\nfunc requestAuthorization(options: UNAuthorizationOptions, completionHandler: (Bool, (any Error)?) -> Void)\nRequests a person’s authorization to allow local and remote notifications for your app."
  },
  {
    "title": "delegate",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/delegate",
    "html": "Discussion\n\nUse the delegate object to respond to user-selected actions and to process incoming notifications when your app is in the foreground. For example, you might use your delegate to silence notifications when your app is in the foreground.\n\nTo guarantee that your app responds to all actionable notifications, you must set the value of this property before your app finishes launching. For an iOS app, this means updating this property in the application(_:willFinishLaunchingWithOptions:) or application(_:didFinishLaunchingWithOptions:) method of the app delegate. Notifications that cause your app to be launched or delivered shortly after these methods finish executing.\n\nFor more information about implementing the delegate methods, see UNUserNotificationCenterDelegate.\n\nSee Also\nProcessing received notifications\nprotocol UNUserNotificationCenterDelegate\nAn interface for processing incoming notifications and responding to notification actions.\nvar supportsContentExtensions: Bool\nA Boolean value that indicates whether the device supports notification content extensions."
  },
  {
    "title": "setBadgeCount(_:withCompletionHandler:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/setbadgecount(_:withcompletionhandler:)",
    "html": "Parameters\nnewBadgeCount\n\nThe new value to display.\n\ncompletionHandler\n\nThe handler to execute after the update finishes. If the update fails, the system provides an error that contains additional information about the failure.\n\nDiscussion\n\nImportant\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc setBadgeCount(_ newBadgeCount: Int) async throws\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nHere’s an example that sets the badge count to a specific number.\n\nlet center = UNUserNotificationCenter.current()\ndo {\n     // Set the badge count to 3.\n     try await center.setBadgeCount(3)\n} catch {\n     // Handle any errors.\n}\n\nSee Also\nManaging the notification center\nclass func current() -> UNUserNotificationCenter\nReturns your app’s notification center.\nfunc getNotificationSettings(completionHandler: (UNNotificationSettings) -> Void)\nRetrieves the authorization and feature-related settings for your app."
  },
  {
    "title": "requestAuthorization(options:completionHandler:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/requestauthorization(options:completionhandler:)",
    "html": "Parameters\noptions\n\nThe authorization options your app is requesting. You may combine the available constants to request authorization for multiple items. Request only the authorization options that you plan to use. For a list of possible values, see UNAuthorizationOptions.\n\ncompletionHandler\n\nThe block to execute asynchronously with the results. This block may execute on a background thread. The block has no return value and has the following parameters:\n\ngranted\n\nA Boolean value indicating whether the person grants authorization. The value of this parameter is true when the person grants authorization for one or more options. The value is false when the person denies authorization or authorization is undetermined. Use getNotificationSettings(completionHandler:) to check the authorization status.\n\nerror\n\nAn object containing error information or nil if no error occurs.\n\nDiscussion\n\nImportant\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc requestAuthorization(options: UNAuthorizationOptions = []) async throws -> Bool\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nIf your app’s local or remote notifications involve user interactions, you must request authorization for the system to perform those interactions on your app’s behalf. Interactions include displaying an alert, playing a sound, or badging the app’s icon.\n\nNote\n\nAlways call this method before scheduling any local notifications and before registering with the Apple Push Notification service. Do this in a context that helps people understand why your app needs authorization, as described in Asking permission to use notifications.\n\nThe first time your app calls the method, the system prompts the person to authorize the requested interactions. The person may grant or deny authorization, and the system stores the person’s response. Subsequent calls to this method don’t prompt the person again. After determining the authorization status, the user notification center object executes the block in the completionHandler parameter. Use that block to make any adjustments to your app’s behavior. For example, if the person denied authorization, you might notify a remote notification server not to send notifications to the user’s device.\n\nThe person may change the interactions they allow at any time in system settings. Use the getNotificationSettings(completionHandler:) method to determine what interactions are allowed for your app.\n\nlet center = UNUserNotificationCenter.current()\ndo {\n     if try await center.requestAuthorization() == true {\n          // You have authorization.\n     } else {\n          // You don't have authorization.\n     }\n} catch {\n     // Handle any errors.\n}\n\nSee Also\nRequesting authorization\nstruct UNAuthorizationOptions\nOptions that determine the authorized features of local and remote notifications."
  },
  {
    "title": "getNotificationSettings(completionHandler:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/getnotificationsettings(completionhandler:)",
    "html": "Parameters\ncompletionHandler\n\nThe block to execute asynchronously with the results. Your app may execute this block on a background thread. The block has no return value and takes the following parameter:\n\nsettings\n\nThe UNNotificationSettings object containing the current authorization settings for your app.\n\nDiscussion\n\nImportant\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc notificationSettings() async -> UNNotificationSettings\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nUse this method to determine the user interactions and notification-related features that the system authorizes your app to use. You might then use this information to enable or disable specific notification-related features of your app.\n\nlet center = UNUserNotificationCenter.current()\nlet settings = await center.notificationSettings()\n// Add code here to inspect or act on the settings.\n\n\nWhen the user initially grants authorization to your app, the system gives your app a set of default notification-related settings. The user may change those settings at any time to enable or disable specific capabilities. For example, the user might disable the playing of sounds when a notification arrives.\n\nSee Also\nManaging the notification center\nclass func current() -> UNUserNotificationCenter\nReturns your app’s notification center.\nfunc setBadgeCount(Int, withCompletionHandler: (((any Error)?) -> Void)?)\nUpdates the badge count for your app’s icon."
  },
  {
    "title": "userNotificationCenter(_:didReceive:withCompletionHandler:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenterdelegate/usernotificationcenter(_:didreceive:withcompletionhandler:)",
    "html": "Required\n\nParameters\ncenter\n\nThe shared user notification center object that received the notification.\n\nresponse\n\nThe user’s response to the notification. This object contains the original notification and the identifier string for the selected action. If the action allowed the user to provide a textual response, this parameter contains a UNTextInputNotificationResponse object.\n\ncompletionHandler\n\nThe block to execute when you have finished processing the user’s response. You must execute this block at some point after processing the user’s response to let the system know that you are done. The block has no return value or parameters.\n\nDiscussion\n\nImportant\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\noptional func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse) async\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nUse this method to process the user’s response to a notification. If the user selected one of your app’s custom actions, the response parameter contains the identifier for that action. (The response can also indicate that the user dismissed the notification interface, or launched your app, without selecting a custom action.) At the end of your implementation, call the completionHandler block to let the system know that you are done processing the user’s response. If you do not implement this method, your app never responds to custom actions.\n\nYou specify your app’s notification types at app launch using UNNotificationCategory objects, and you specify the custom actions for each type using UNNotificationAction objects. For information, see Declaring your actionable notification types."
  },
  {
    "title": "current()",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/current()",
    "html": "Return Value\n\nThe notification center object to use.\n\nDiscussion\n\nAlways use this method to retrieve the shared notification center object for your app. Do not try to create instances of the UNUserNotificationCenter class directly.\n\nSee Also\nManaging the notification center\nfunc getNotificationSettings(completionHandler: (UNNotificationSettings) -> Void)\nRetrieves the authorization and feature-related settings for your app.\nfunc setBadgeCount(Int, withCompletionHandler: (((any Error)?) -> Void)?)\nUpdates the badge count for your app’s icon."
  },
  {
    "title": "init(identifier:title:options:icon:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationaction/init(identifier:title:options:icon:)",
    "html": "Parameters\nidentifier\n\nThe string that you use internally to identify the action. This string must be unique among your app’s supported actions. When the user selects the action, the system passes this string to your app and asks the user to perform the related task. This parameter must not be nil or an empty string.\n\ntitle\n\nThe localized string the system displays to the user. The system displays this string as the title of a button, which the system adds to the notification interface. This parameter must not be nil.\n\noptions\n\nAdditional options that describe how the action behaves. Include options when you need the related behavior. For a list of possible values, see UNNotificationActionOptions.\n\nicon\n\nThe icon that the system displays to the user.\n\nReturn Value\n\nAn action object that the system initializes.\n\nSee Also\nEssentials\nconvenience init(identifier: String, title: String, options: UNNotificationActionOptions)\nCreates an action object by using the specified title and options."
  },
  {
    "title": "UNNotificationActionOptions",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionoptions",
    "html": "Topics\nInitializers\ninit(rawValue: UInt)\nInitializes an action options object using the specified raw value.\nConstants\nstatic var authenticationRequired: UNNotificationActionOptions\nThe action can be performed only on an unlocked device.\nstatic var destructive: UNNotificationActionOptions\nThe action performs a destructive task.\nstatic var foreground: UNNotificationActionOptions\nThe action causes the app to launch in the foreground.\nDefault Implementations\nEquatable Implementations\nOptionSet Implementations\nSetAlgebra Implementations\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSendable\nSetAlgebra\nSee Also\nGetting Options\nvar options: UNNotificationActionOptions\nThe behaviors associated with the action."
  },
  {
    "title": "icon",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationaction/icon",
    "html": "Discussion\n\nThe system displays this icon in the notification interface to help the user identify the app associated with the action.\n\nSee Also\nGetting Information\nvar identifier: String\nThe unique string that your app uses to identify the action.\nvar title: String\nThe localized string to use as the title of the action."
  },
  {
    "title": "UNCalendarNotificationTrigger",
    "url": "https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger",
    "html": "Overview\n\nCreate a UNCalendarNotificationTrigger object when you want to schedule the delivery of a local notification at the date and time you specify. You use an NSDateComponents object to specify only the time values that you want the system to use to determine the matching date and time.\n\nListing 1 creates a trigger that delivers its notification every morning at 8:30. The repeating behavior is achieved by specifying true for the repeats parameter when creating the trigger.\n\nListing 1. Creating a trigger that repeats at a specific time\n\nSwift\nObjective-C\nvar date = DateComponents()\ndate.hour = 8\ndate.minute = 30 \nlet trigger = UNCalendarNotificationTrigger(dateMatching: date, repeats: true)\n\nTopics\nCreating a Calendar Trigger\nconvenience init(dateMatching: DateComponents, repeats: Bool)\nCreates a calendar trigger using the date components parameter.\nGetting the Trigger Information\nfunc nextTriggerDate() -> Date?\nThe next date at which the trigger conditions are met.\nvar dateComponents: DateComponents\nThe date components to construct this object.\nInitializers\nconvenience init(dateMatchingComponents: DateComponents, repeats: Bool)\nRelationships\nInherits From\nUNNotificationTrigger\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nTriggers\nclass UNTimeIntervalNotificationTrigger\nA trigger condition that causes the system to deliver a notification after the amount of time you specify elapses.\nclass UNLocationNotificationTrigger\nA trigger condition that causes the system to deliver a notification when the user’s device enters or exits a geographic region you specify.\nclass UNPushNotificationTrigger\nA trigger condition that indicates Apple Push Notification Service (APNs) has sent the notification.\nclass UNNotificationTrigger\nThe common behavior for subclasses that trigger the delivery of a local or remote notification."
  },
  {
    "title": "options",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationaction/options",
    "html": "Discussion\n\nYou app should define options for an action when your app requires the corresponding behavior.\n\nSee Also\nGetting Options\nstruct UNNotificationActionOptions\nThe behaviors you can apply to an action."
  },
  {
    "title": "title",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent/title",
    "html": "Discussion\n\nWhen a title is present, the system attempts to display a notification alert. If your app isn’t authorized to display alert-based notifications, the system ignores this property.\n\nTitle strings should be short, usually only a couple of words describing the reason for the notification. In watchOS, the system displays the title string as part of the short look notification interface, which has limited space.\n\nSee Also\nAccessing the primary content\nvar subtitle: String\nThe localized text that provides the notification’s secondary description.\nvar body: String\nThe localized text that provides the notification’s main content."
  },
  {
    "title": "UNNotificationTrigger",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationtrigger",
    "html": "Overview\n\nThe UNNotificationTrigger class is an abstract class for representing an event that triggers the delivery of a notification. You don’t create instances of this class directly. Instead, you instantiate the concrete subclass that defines the trigger condition you want for your notification. You then assign the resulting object to the UNNotificationRequest object that you use to schedule your notification.\n\nConcrete trigger classes include the following:\n\nUNTimeIntervalNotificationTrigger\n\nUNCalendarNotificationTrigger\n\nUNLocationNotificationTrigger\n\nUNPushNotificationTrigger\n\nTopics\nConfiguring the Trigger’s Behavior\nvar repeats: Bool\nA Boolean value indicating whether the system reschedules the notification after it’s delivered.\nInitializers\ninit?(coder: NSCoder)\nRelationships\nInherits From\nNSObject\nInherited By\nUNCalendarNotificationTrigger\nUNLocationNotificationTrigger\nUNPushNotificationTrigger\nUNTimeIntervalNotificationTrigger\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nTriggers\nclass UNCalendarNotificationTrigger\nA trigger condition that causes a notification the system delivers at a specific date and time.\nclass UNTimeIntervalNotificationTrigger\nA trigger condition that causes the system to deliver a notification after the amount of time you specify elapses.\nclass UNLocationNotificationTrigger\nA trigger condition that causes the system to deliver a notification when the user’s device enters or exits a geographic region you specify.\nclass UNPushNotificationTrigger\nA trigger condition that indicates Apple Push Notification Service (APNs) has sent the notification."
  },
  {
    "title": "Declaring your actionable notification types",
    "url": "https://developer.apple.com/documentation/usernotifications/declaring-your-actionable-notification-types",
    "html": "Overview\n\nActionable notifications let the user respond to a delivered notification without launching the corresponding app. Other notifications display information in a notification interface, but the user’s only course of action is to launch the app. For an actionable notification, the system displays one or more buttons in addition to the notification interface. Tapping a button sends the selected action to the app, which then processes the action in the background.\n\nNote\n\nWhen someone performs a Double Tap gesture while viewing a notification on Apple Watch Series 9 or Apple Watch Ultra 2, the system invokes the first nondestructive action. A nondestructive action doesn’t include the destructive option, and won’t delete user data or change the app irrevocably.\n\nTo support actionable notifications, you must:\n\nDeclare one or more notification categories at launch time from your iOS app.\n\nAssign appropriate actions to your notification categories.\n\nHandle all actions that you register.\n\nAssign category identifiers to notification payloads when generating notifications.\n\nNote\n\nThe system also uses categories to determine whether it should launch your notification service app extension or notification content app extension. For information about how to create a notification service app extension, see Modifying content in newly delivered notifications. For information about how to create a notification content app extension, see Customizing the Appearance of Notifications.\n\nDeclare your custom actions and notification types\n\nBecause your app must handle all actions, you must declare the actions that your app supports at launch time. You declare actions using a combination of category and action objects. UNNotificationCategory objects define the types of notifications that your app supports, and UNNotificationAction objects define the buttons to display for each type. For example, a notification for a meeting invitation might include buttons to accept or reject the invitation.\n\nEach UNNotificationCategory object has a unique identifier and options for how you want to handle notifications of that type. The string in the identifier property is the most important part of the category object. When generating notifications, you must include the same string in your notification’s payload. The system uses that string to locate the corresponding category object and any actions.\n\nTo associate actions with a notification category, assign one or more UNNotificationAction objects to it. Each action object contains the localized string to display to the user and options indicating how you want that action handled. For example, when you tag an action as destructive, the system displays it with a different highlight to indicate its behavior.\n\nListing 1 shows how to register a custom category with two actions. In addition to a title and options, each action has a unique identifier. When the user selects the action, the system passes that identifier to your app.\n\nListing 1. Registering actions and notification types\n\n// Define the custom actions.\nlet acceptAction = UNNotificationAction(identifier: \"ACCEPT_ACTION\",\n      title: \"Accept\", \n      options: [])\nlet declineAction = UNNotificationAction(identifier: \"DECLINE_ACTION\",\n      title: \"Decline\", \n      options: [])\n// Define the notification type\nlet meetingInviteCategory = \n      UNNotificationCategory(identifier: \"MEETING_INVITATION\",\n      actions: [acceptAction, declineAction], \n      intentIdentifiers: [], \n      hiddenPreviewsBodyPlaceholder: \"\",\n      options: .customDismissAction)\n// Register the notification type.\nlet notificationCenter = UNUserNotificationCenter.current()\nnotificationCenter.setNotificationCategories([meetingInviteCategory])\n\n\nImportant\n\nAll of your action objects must have unique identifiers. When handling actions, the identifier is the only way to distinguish one action from another, even when those actions belong to different categories.\n\nMost actions result in a user selection, but text input actions also let the user type custom text-based responses. Your app can then incorporate the user’s typed response into your handling of the action. For example, a messaging app could send the typed text as the response to an incoming message. To create a text input action, create a UNTextInputNotificationAction object instead of a UNNotificationAction object. When the user taps the button for a text input action, the system displays an editable text field. When reporting the action to your app, the system includes the text that the user typed as part of the response.\n\nInclude a notification category in the payload\n\nThe system displays actions only for notifications whose payload contains a valid category identifier string. The system uses the category identifier to look up your app’s registered categories and their associated actions. It then uses that information to add the action buttons to the notification interface.\n\nTo assign a category to a local notification, assign the appropriate string to the categoryIdentifier property of your UNMutableNotificationContent object. Listing 2 shows the creation of the content for a local notification. In addition to the basic information, this code also adds custom data to the notification’s userInfo dictionary, which it uses later to process the invitation.\n\nListing 2. Assigning a category to a local notification\n\nlet content = UNMutableNotificationContent()\ncontent.title = \"Weekly Staff Meeting\"\ncontent.body = \"Every Tuesday at 2pm\"\ncontent.userInfo = [\"MEETING_ID\" : meetingID, \n                    \"USER_ID\" : userID ]\ncontent.categoryIdentifier = \"MEETING_INVITATION\"\n\n\nTo add a category identifier to a remote notification, include the category key in the aps dictionary of your JSON payload, as shown in Listing 3. Set the value of this key to the appropriate category string. In the example, the category is set to the same meeting invitation category that was previously defined. As in the local notification example, the payload includes custom keys with the meeting ID and user ID, which are put into the payload’s userInfo dictionary. The app can use that information to accept or decline the invitation.\n\nListing 3. Assigning a category to a remote notification\n\n{\n   \"aps\" : {\n      \"category\" : \"MEETING_INVITATION\"\n      \"alert\" : {\n         \"title\" : \"Weekly Staff Meeting\"\n         \"body\" : \"Every Tuesday at 2pm\"\n      },\n   },\n   \"MEETING_ID\" : \"123456789\",\n   \"USER_ID\" : \"ABCD1234\"\n\n\n} \n\nHandle the selected action\n\nYour app must handle all of the actions that it defines. When the user selects an action, the system launches your app in the background and notifies the shared UNUserNotificationCenter object, which notifies its delegate. Use your delegate object’s userNotificationCenter(_:didReceive:withCompletionHandler:) method to identify the selected action and provide an appropriate response.\n\nListing 4 shows an implementation of the delegate method for an app that manages meeting invitations. The method uses the actionIdentifier property of the response to determine whether to accept or decline a given invitation. It also relies on custom data from the notification payload to process the notification successfully. Always call the completion handler after you finish handling the action.\n\nListing 4. Performing a selected action\n\nfunc userNotificationCenter(_ center: UNUserNotificationCenter,\n       didReceive response: UNNotificationResponse,\n       withCompletionHandler completionHandler: \n         @escaping () -> Void) {\n       \n   // Get the meeting ID from the original notification.\n   let userInfo = response.notification.request.content.userInfo\n   let meetingID = userInfo[\"MEETING_ID\"] as! String\n   let userID = userInfo[\"USER_ID\"] as! String\n        \n   // Perform the task associated with the action.\n   switch response.actionIdentifier {\n   case \"ACCEPT_ACTION\":\n      sharedMeetingManager.acceptMeeting(user: userID, \n                                    meetingID: meetingID)\n      break\n        \n   case \"DECLINE_ACTION\":\n      sharedMeetingManager.declineMeeting(user: userID, \n                                     meetingID: meetingID)\n      break\n        \n   // Handle other actions...\n   default:\n      break\n   }\n    \n   // Always call the completion handler when done.    \n   completionHandler()\n}\n\n\nImportant\n\nIf your response to an action involves accessing files on disk, consider a different approach. Users can respond to actions while the device is locked, which would make files encrypted with the complete option unavailable to your app. If that happens, you may need to save changes temporarily and integrate them into your app’s data structures later.\n\nSee Also\nNotification categories and user actions\nclass UNNotificationCategory\nA type of notification your app supports and the custom actions that the system displays.\nclass UNNotificationAction\nA task your app performs in response to a notification that the system delivers.\nclass UNTextInputNotificationAction\nAn action that accepts user-typed text."
  },
  {
    "title": "UNPushNotificationTrigger",
    "url": "https://developer.apple.com/documentation/usernotifications/unpushnotificationtrigger",
    "html": "Overview\n\nYou don’t create instances of this class yourself. The system creates UNPushNotificationTrigger objects and associates them with requests that originated from Apple Push Notification service. You encounter instances of this class when managing your app’s delivered notification requests, which store an object of this type in their trigger property.\n\nRelationships\nInherits From\nUNNotificationTrigger\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nTriggers\nclass UNCalendarNotificationTrigger\nA trigger condition that causes a notification the system delivers at a specific date and time.\nclass UNTimeIntervalNotificationTrigger\nA trigger condition that causes the system to deliver a notification after the amount of time you specify elapses.\nclass UNLocationNotificationTrigger\nA trigger condition that causes the system to deliver a notification when the user’s device enters or exits a geographic region you specify.\nclass UNNotificationTrigger\nThe common behavior for subclasses that trigger the delivery of a local or remote notification."
  },
  {
    "title": "targetContentIdentifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/targetcontentidentifier",
    "html": "Discussion\n\nUse this value to determine the content to show in your app when the user taps the notification.\n\nSee Also\nConfiguring app behavior\nvar launchImageName: String\nThe name of the image or storyboard to use when your app launches because of the notification.\nvar badge: NSNumber?\nThe number that your app’s icon displays."
  },
  {
    "title": "summaryArgument",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/summaryargument",
    "html": "See Also\nGrouping notifications\nvar threadIdentifier: String\nThe identifier that groups related notifications.\nvar categoryIdentifier: String\nThe identifier of the notification’s category.\nvar summaryArgumentCount: Int\nThe number the system adds to the notification summary when the notification represents multiple items."
  },
  {
    "title": "threadIdentifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/threadidentifier",
    "html": "Discussion\n\nYou may specify any value for the string, but assign the same thread identifier string to all notifications that you want to group together visually.\n\nSee Also\nGrouping notifications\nvar categoryIdentifier: String\nThe identifier of the notification’s category.\nvar summaryArgument: String\nThe text the system adds to the notification summary to provide additional context.\nvar summaryArgumentCount: Int\nThe number the system adds to the notification summary when the notification represents multiple items."
  },
  {
    "title": "categoryIdentifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/categoryidentifier",
    "html": "Discussion\n\nUse notification types to distinguish between the different types of notifications your app supports. You use this support primarily to create actionable notifications with custom action buttons to redirect your notifications through either your notification service app extension or your notification content app extension.\n\nAssign a value to this property that matches the identifier property of one of the UNNotificationCategory objects you previously registered with your app. If you assign a string that doesn’t match one of your registered categories, the system displays your notification without custom actions and without routing it through your app extensions.\n\nSee Also\nGrouping notifications\nvar threadIdentifier: String\nThe identifier that groups related notifications.\nvar summaryArgument: String\nThe text the system adds to the notification summary to provide additional context.\nvar summaryArgumentCount: Int\nThe number the system adds to the notification summary when the notification represents multiple items."
  },
  {
    "title": "UNNotificationInterruptionLevel",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationinterruptionlevel",
    "html": "Topics\nEnumeration Cases\ncase active\nThe system presents the notification immediately, lights up the screen, and can play a sound.\ncase critical\nThe system presents the notification immediately, lights up the screen, and bypasses the mute switch to play a sound.\ncase passive\nThe system adds the notification to the notification list without lighting up the screen or playing a sound.\ncase timeSensitive\nThe system presents the notification immediately, lights up the screen, can play a sound, and breaks through system notification controls.\nInitializers\ninit?(rawValue: UInt)\nDefault Implementations\nEquatable Implementations\nRawRepresentable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nIntegrating with the system\nvar sound: UNNotificationSound?\nThe sound that plays when the system delivers the notification.\nvar interruptionLevel: UNNotificationInterruptionLevel\nThe notification’s importance and required delivery timing.\nvar relevanceScore: Double\nThe score the system uses to determine if the notification is the summary’s featured notification.\nvar filterCriteria: String?\nThe criteria the system evaluates to determine if it displays the notification in the current Focus."
  },
  {
    "title": "filterCriteria",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/filtercriteria",
    "html": "Discussion\n\nFor more information, see SetFocusFilterIntent.\n\nSee Also\nIntegrating with the system\nvar sound: UNNotificationSound?\nThe sound that plays when the system delivers the notification.\nvar interruptionLevel: UNNotificationInterruptionLevel\nThe notification’s importance and required delivery timing.\nenum UNNotificationInterruptionLevel\nConstants that indicate the importance and delivery timing of a notification.\nvar relevanceScore: Double\nThe score the system uses to determine if the notification is the summary’s featured notification."
  },
  {
    "title": "relevanceScore",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent/relevancescore",
    "html": "Discussion\n\nThe system uses the relevanceScore, a value between 0 and 1, to sort the notifications from your app. The highest score gets featured in the notification summary.\n\nSee Also\nIntegrating with the system\nvar sound: UNNotificationSound?\nThe sound that plays when the system delivers the notification.\nvar interruptionLevel: UNNotificationInterruptionLevel\nThe notification’s importance and required delivery timing.\nenum UNNotificationInterruptionLevel\nConstants that indicate the importance and delivery timing of a notification.\nvar filterCriteria: String?\nThe criteria the system evaluates to determine if it displays the notification in the current Focus."
  },
  {
    "title": "add(_:withCompletionHandler:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/add(_:withcompletionhandler:)",
    "html": "Parameters\nrequest\n\nThe request object containing the notification payload and trigger information. This parameter must not be nil.\n\ncompletionHandler\n\nThe block to execute with the results. This block may be executed on a background thread. The block has no return value and takes the following parameter:\n\nerror\n\nAn error object indicating whether a problem occurred. If the notification was scheduled successfully, this parameter is nil; otherwise, it is set to an error object indicating the reason for the failure.\n\nDiscussion\n\nImportant\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc add(_ request: UNNotificationRequest) async throws\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis method schedules local notifications only; you cannot use it to schedule the delivery of remote notifications. Upon calling this method, the system begins tracking the trigger conditions associated with your request. When the trigger condition is met, the system delivers your notification. If the request does not contain a UNNotificationTrigger object, the notification is delivered right away.\n\nYou may call this method from any thread of your app.\n\nlet center = UNUserNotificationCenter.current()\nlet content = UNMutableNotificationContent()\ncontent.title = \"My notification title\"\ncontent.body = \"My notification body\"\nlet notification = UNNotificationRequest(identifier: \"com.example.mynotification\", content: content, trigger: nil)\ndo {\n    try await center.add(notification)\n} catch {\n    // Handle any errors.\n}\n\nSee Also\nScheduling notifications\nfunc getPendingNotificationRequests(completionHandler: ([UNNotificationRequest]) -> Void)\nFetches all of your app’s local notifications that are pending delivery.\nfunc removePendingNotificationRequests(withIdentifiers: [String])\nRemoves your app’s local notifications that are pending and match the specified identifiers.\nfunc removeAllPendingNotificationRequests()\nRemoves all of your app’s pending local notifications."
  },
  {
    "title": "trigger",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationrequest/trigger",
    "html": "Discussion\n\nFor notifications that the system has delivered, use this property to determine what caused the delivery to occur. For remote notifications, this property contains a UNPushNotificationTrigger object. For other notifications, the system sets this type using the trigger condition specified in the original request.\n\nSee Also\nGetting the Request Details\nvar identifier: String\nThe unique identifier for this notification request.\nvar content: UNNotificationContent\nThe content associated with the notification."
  },
  {
    "title": "init(identifier:content:trigger:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationrequest/init(identifier:content:trigger:)",
    "html": "Parameters\nidentifier\n\nAn identifier for the request; this parameter must not be nil. You can use this identifier to cancel the request if it’s still pending (see the removePendingNotificationRequests(withIdentifiers:) method).\n\ncontent\n\nThe content of the notification. This parameter must not be nil.\n\ntrigger\n\nThe condition that causes the system to deliver the notification. Specify nil to deliver the notification right away.\n\nReturn Value\n\nA new notification request object.\n\nDiscussion\n\nUse this method when you want to schedule the delivery of a local notification. This method creates the request object that you subsequently pass to the add(_:withCompletionHandler:) method.\n\nThe system uses the identifier parameter to determine how to handle the request:\n\nIf you provide a unique identifier, the system creates a new notification.\n\nIf the identifier matches a previously delivered notification, the system alerts the user again, replaces the old notification with the new one, and places the new notification at the top of the list.\n\nIf the identifier matches a pending request, the new request replaces the pending request."
  },
  {
    "title": "content",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationrequest/content",
    "html": "Discussion\n\nUse this property to access the contents of the notification.\n\nSee Also\nGetting the Request Details\nvar identifier: String\nThe unique identifier for this notification request.\nvar trigger: UNNotificationTrigger?\nThe conditions that trigger the delivery of the notification."
  },
  {
    "title": "identifier",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationrequest/identifier",
    "html": "Discussion\n\nUse this string to identify notifications in your app. For example, you can pass this string to the removePendingNotificationRequests(withIdentifiers:) method to cancel a previously scheduled notification.\n\nIf you use the same identifier when scheduling a new notification, the system removes the previously scheduled notification with that identifier and replaces it with the new one.\n\nFor local notifications, the system sets this property to the value passed to the request’s initializer (see the init(identifier:content:trigger:) method). For remote notifications, the system sets this property to the value of the apns-collapse-id key that you specified in the APNs request header when generating the remote notification. If your app doesn’t set a value, the system automatically assigns an identifier.\n\nSee Also\nGetting the Request Details\nvar content: UNNotificationContent\nThe content associated with the notification.\nvar trigger: UNNotificationTrigger?\nThe conditions that trigger the delivery of the notification."
  },
  {
    "title": "getDeliveredNotifications(completionHandler:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/getdeliverednotifications(completionhandler:)",
    "html": "Parameters\ncompletionHandler\n\nThe block to execute with the results. This block may be executed on a background thread. The block has no return value and takes the following parameter:\n\nnotifications\n\nAn array of UNNotification objects representing the local and remote notifications of your app that have been delivered and are still visible in Notification Center. If none of your app’s notifications are visible in Notification Center, the array is empty.\n\nDiscussion\n\nImportant\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc deliveredNotifications() async -> [UNNotification]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis method executes asynchronously, returning immediately and executing the provided block on a background thread when the results become available.\n\nSee Also\nRemoving delivered notifications\nfunc removeDeliveredNotifications(withIdentifiers: [String])\nRemoves your app’s notifications from Notification Center that match the specified identifiers.\nfunc removeAllDeliveredNotifications()\nRemoves all of your app’s delivered notifications from Notification Center."
  },
  {
    "title": "date",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotification/date",
    "html": "Discussion\n\nThe system displays this date to the user in Notification Center.\n\nSee Also\nGetting the Notification Details\nvar request: UNNotificationRequest\nThe notification request containing the payload and trigger condition for the notification."
  },
  {
    "title": "Sending notification requests to APNs",
    "url": "https://developer.apple.com/documentation/usernotifications/sending-notification-requests-to-apns",
    "html": "Overview\n\nAs a best-effort service, APNs may reorder notifications you send to the same device token. If APNs can’t deliver a notification immediately, it may store the notification for 30 days or less, depending on the date you specify in the apns-expiration header. APNs attempts to deliver the notification the next time the device activates and is available online.\n\nAPNs stores only one notification per bundle ID. When you send multiple notifications to the same device for a bundle ID, APNs selects only one notification to store in a non-deterministic way. Notifications with apns-priority 5 and 1 might get grouped and delivered in bursts to the user’s device. Your notifications may also get throttled, saved in storage, and in some cases, not delivered. The way the user interacts with your application and the power state of the device determines the exact behavior. For more information about the factors that impact the delivery of a push notification, see Viewing the status of push notifications using Metrics and APNs.\n\nWhen you have a notification to send to a user, your provider must construct a POST request and send it to Apple Push Notification service (APNs). Upon receiving your server’s POST request, APNs validates the request using either the provided authentication token or your server’s certificate. If validation succeeds, APNs uses the provided device token to identify the user’s device. It then tries to send your JSON payload to that device. For information on sending test notifications without setting up the environment, see Testing notifications using the Push Notification Console.\n\nEstablish a connection to APNs\n\nUse HTTP/2 and TLS 1.2 or later to establish a connection between your provider server and one of the following servers:\n\nDevelopment server: api.sandbox.push.apple.com:443\n\nProduction server: api.push.apple.com:443\n\nUse the production server for your shipping apps and the development server for testing. When sending many remote notifications, you can establish multiple connections to these servers to improve performance.\n\nTip\n\nYou can also use port 2197 (instead of port 443) on either server when communicating with APNs. You might use this port to allow APNs traffic through your firewall but to block other HTTPS traffic.\n\nAPNs allows multiple concurrent streams for each connection, but don’t assume a specific number of streams. The exact number varies based on server load and whether you use a provider certificate or an authentication token. For example, when using an authentication token, APNs allows only one stream until you post a request with a valid authentication token. APNs ignores HTTP/2 PRIORITY frames, so don’t send them on your streams.\n\nIf you experience a revoked provider certificate, or if you revoke your authentication token, close all connections to APNs, fix the problem, and then open new connections. APNs may also terminate a connection by sending a GOAWAY frame. The payload of the GOAWAY frame includes JSON data with a reason key, indicating the reason for the connection termination. For a list of values for the reason key, see the response error strings in Handling notification responses from APNs.\n\nCreate a POST request to APNs\n\nTo send a notification to a user’s device, construct and send a POST notification to APNs. Send this request over the connection you created using HTTP/2 and TLS. To create your POST notification, you must already have the following pieces of information:\n\nThe device token that identifies the user device to receive the notification; see Registering your app with APNs.\n\nYour current authentication token (only if you’re using token-based authentication); see Establishing a token-based connection to APNs.\n\nThe notification’s payload, specified as JSON data; see Generating a remote notification.\n\nNote\n\nIf you’re using certificate-based authentication, you send your provider certificate to APNs when setting up your TLS connection. For more information, see Establishing a certificate-based connection to APNs.\n\nSend a POST request to APNs\n\nTo deliver the notifications, you’re required to have some header fields. In addition to the preceding data, add the following header fields in to your request. Other headers are optional or may depend on whether you’re using token-based or certificate-based authentication.\n\nHeader field\n\n\t\n\nRequired\n\n\t\n\nDescription\n\n\n\n\n:method\n\n\t\n\nRequired\n\n\t\n\nThe value POST.\n\n\n\n\n:path\n\n\t\n\nRequired\n\n\t\n\nThe path to the device token. The value of this header is /3/device/<device_token>, where <device_token> is the hexadecimal bytes that identify the user’s device. Your app receives the bytes for this device token when registering for remote notifications. For more information, see Registering your app with APNs.\n\n\n\n\nauthorization\n\n\t\n\nRequired for token-based authentication\n\n\t\n\nThe value of this header is bearer <provider_token>, where <provider_token> is the encrypted token that authorizes you to send notifications for the specified topic. APNs ignores this header if you use certificate-based authentication. For more information, see Establishing a token-based connection to APNs.\n\n\n\n\napns-push-type\n\n\t\n\nRequired for watchOS 6 and later; recommended for macOS, iOS, tvOS, and iPadOS\n\n\t\n\nThe value of this header must accurately reflect the contents of your notification’s payload. If there’s a mismatch, or if the header is missing on required systems, APNs may return an error, delay the delivery of the notification, or drop it altogether.\n\n\n\n\napns-id\n\n\t\n\nOptional\n\n\t\n\nA canonical UUID that’s the unique ID for the notification. If an error occurs when sending the notification, APNs includes this value when reporting the error to your server. Canonical UUIDs are 32 lowercase hexadecimal digits, displayed in five groups separated by hyphens in the form 8-4-4-4-12. For example: 123e4567-e89b-12d3-a456-4266554400a0. If you omit this header, APNs creates a UUID for you and returns it in its response.\n\n\n\n\napns-expiration\n\n\t\n\nOptional\n\n\t\n\nThe date at which the notification is no longer valid. This value is a UNIX epoch expressed in seconds (UTC). If the value is nonzero, APNs stores the notification and tries to deliver it at least once, repeating the attempt as needed until the specified date. If the value is 0, APNs attempts to deliver the notification only once and doesn’t store it.\nA single APNs attempt may involve retries over multiple network interfaces and connections of the destination device. Often these retries span over some time period, depending on the network characteristics. In addition, a push notification may take some time on the network after APNs sends it to the device. APNs uses best efforts to honor the expiry date without any guarantee. If the value is nonzero, the notification may deliver after the specified timestamp. If the value is 0, the notification may deliver with some delay.\nIf you omit this header, APNs stores the push according to APNs storage policy. For more information, see Sending notification requests to APNs.\n\n\n\n\napns-priority\n\n\t\n\nOptional\n\n\t\n\nThe priority of the notification. If you omit this header, APNs sets the notification priority to 10.\nSpecify 10 to send the notification immediately.\nSpecify 5 to send the notification based on power considerations on the user’s device.\nSpecify 1 to prioritize the device’s power considerations over all other factors for delivery, and prevent awakening the device.\n\n\n\n\napns-topic\n\n\t\n\nOptional\n\n\t\n\nThe topic for the notification. In general, the topic is your app’s bundle ID/app ID. It can have a suffix based on the type of push notification. If you’re using a certificate that supports PushKit VoIP or watchOS complication notifications, you must include this header with the bundle ID of your app and if applicable, the proper suffix. If you’re using token-based authentication with APNs, you must include this header with the correct bundle ID and suffix combination. To learn more about app ID, see Register an App ID.\n\n\n\n\napns-collapse-id\n\n\t\n\nOptional\n\n\t\n\nAn identifier you use to merge multiple notifications into a single notification for the user. Typically, each notification request displays a new notification on the user’s device. When sending the same notification more than once, use the same value in this header to merge the requests. The value of this key must not exceed 64 bytes.\n\nAPNs requires the use of HPACK (header compression for HTTP/2), which prevents repeatedly storing header keys and values. APNs maintains a small dynamic table for HPACK. To avoid filling up that table, encode your headers in the following way—especially when using many streams:\n\nEncode the :path and authorization values as literal header fields without indexing.\n\nEncode the apns-id, apns-expiration, and apns-collapse-id values differently based on whether this is an initial or subsequent request.\n\nThe first time you send these headers, encode them with incremental indexing to add the header fields to the dynamic table.\n\nFor subsequent requests, encode these headers as literal header fields without indexing.\n\nEncode all other fields as literal header fields with incremental indexing.\n\nPut the JSON payload with the notification’s content into the body of your request. You must not use a compressed JSON payload, and it’s limited to a maximum size of 4 KB (4096 bytes). The maxiumum size for a Voice over Internet Protocol (VoIP) notification is 5 KB (5120 bytes).\n\nThe code snippet below shows a sample request constructed with an authentication token.\n\nHEADERS\n  - END_STREAM\n  + END_HEADERS\n  :method = POST\n  :scheme = https\n  :path = /3/device/00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0\n  host = api.sandbox.push.apple.com\n  authorization = bearer eyAia2lkIjogIjhZTDNHM1JSWDciIH0.eyAiaXNzIjogIkM4Nk5WOUpYM0QiLCAiaWF0I\n\t\t jogIjE0NTkxNDM1ODA2NTAiIH0.MEYCIQDzqyahmH1rz1s-LFNkylXEa2lZ_aOCX4daxxTZkVEGzwIhALvkClnx5m5eAT6\n\t\t Lxw7LZtEQcH6JENhJTMArwLf3sXwi\n  apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b\n  apns-push-type = alert\n  apns-expiration = 0\n  apns-priority = 10\n  apns-topic = com.example.MyApp\nDATA\n  + END_STREAM\n  { \"aps\" : { \"alert\" : \"Hello\" } }\n\n\n\n\nThe code snippet below shows a sample request constructed for use with a certificate. APNs uses the app’s bundle ID as the default topic.\n\nHEADERS\n  - END_STREAM\n  + END_HEADERS\n  :method = POST\n  :scheme = https\n  :path = /3/device/00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0\n  host = api.sandbox.push.apple.com\n  apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b\n  apns-push-type = alert\n  apns-expiration = 0\n  apns-priority = 10\nDATA\n  + END_STREAM\n  { \"aps\" : { \"alert\" : \"Hello\" } }\n\n\n\nKnow when to use push types\n\nThe apns-push-type header field has the following valid values. The descriptions below describe when and how to use these values. Send an apns-push-type header with each push. Recent and upcoming features may not work if this header is missing. See the table above to determine if this header is required or optional.\n\nalert\n\nThe push type for notifications that trigger a user interaction—for example, an alert, badge, or sound. If you set this push type, the apns-topic header field must use your app’s bundle ID as the topic. For more information, see Generating a remote notification.\n\nIf the notification requires immediate action from the user, set notification priority to 10; otherwise use 5.\n\nYou’re required to use the alert push type on watchOS 6 and later. It’s recommended on macOS, iOS, tvOS, and iPadOS.\n\nbackground\n\nThe push type for notifications that deliver content in the background, and don’t trigger any user interactions. If you set this push type, the apns-topic header field must use your app’s bundle ID as the topic. Always use priority 5. Using priority 10 is an error. For more information, see Pushing background updates to your App.\n\nYou’re required to use the background push type on watchOS 6 and later. It’s recommended on macOS, iOS, tvOS, and iPadOS.\n\nlocation\n\nThe push type for notifications that request a user’s location. If you set this push type, the apns-topic header field must use your app’s bundle ID with.location-query appended to the end. For more information, see Creating a location push service extension.\n\nThe location push type isn’t available on macOS, tvOS, and watchOS. It’s recommended for iOS and iPadOS.\n\nIf the location query requires an immediate response from the Location Push Service Extension, set notification apns-priority to 10; otherwise, use 5.\n\nThe location push type supports only token-based authentication.\n\nvoip\n\nThe push type for notifications that provide information about an incoming Voice-over-IP (VoIP) call. For more information, see Responding to VoIP Notifications from PushKit.\n\nIf you set this push type, the apns-topic header field must use your app’s bundle ID with.voip appended to the end. If you’re using certificate-based authentication, you must also register the certificate for VoIP services. The topic is then part of the 1.2.840.113635.100.6.3.4 or 1.2.840.113635.100.6.3.6 extension.\n\nThe voip push type isn’t available on watchOS. It’s recommended on macOS, iOS, tvOS, and iPadOS.\n\ncomplication\n\nThe push type for notifications that contain update information for a watchOS app’s complications. For more information, see Keeping your complications up to date.\n\nIf you set this push type, the apns-topic header field must use your app’s bundle ID with.complication appended to the end. If you’re using certificate-based authentication, you must also register the certificate for WatchKit services. The topic is then part of the 1.2.840.113635.100.6.3.6 extension.\n\nThe complication push type isn’t available on macOS, tvOS, and iPadOS. It’s recommended for watchOS and iOS.\n\nfileprovider\n\nThe push type to signal changes to a File Provider extension. If you set this push type, the apns-topic header field must use your app’s bundle ID with.pushkit.fileprovider appended to the end. For more information, see Using push notifications to signal changes.\n\nThe fileprovider push type isn’t available on watchOS. It’s recommended on macOS, iOS, tvOS, and iPadOS.\n\nmdm\n\nThe push type for notifications that tell managed devices to contact the MDM server. If you set this push type, you must use the topic from the UID attribute in the subject of your MDM push certificate. For more information, see Device Management.\n\nThe mdm push type isn’t available on watchOS. It’s recommended on macOS, iOS, tvOS, and iPadOS.\n\nliveactivity\n\nThe push type to signal changes to a live activity session. If you set this push type, the apns-topic header field must use your app’s bundle ID with.push-type.liveactivity appended to the end. For more information, see Updating and ending your Live Activity with ActivityKit push notifications.\n\nThe liveactivity push type isn’t available on watchOS, macOS, and tvOS. It’s recommended on iOS and iPadOS.\n\npushtotalk\n\nThe push type for notifications that provide information about updates to your application’s push to talk services. For more information, see Push to Talk. If you set this push type, the apns-topic header field must use your app’s bundle ID with.voip-ptt appended to the end.\n\nThe pushtotalk push type isn’t available on watchOS, macOS, and tvOS. It’s recommended on iOS and iPadOS.\n\nCertificate-based connection supports only a subset of push types and token-based connection supports all push-types. For more information, see Establishing a certificate-based connection to APNs. Check Extension 1.2.840.113635.100.6.3.6 and 1.2.840.113635.100.6.3.4 of your push certificate. These extensions list all the push topics allowed for your certificate. If a push topic for a specific push type isn’t listed, you can’t use the certificate to send a notification of that push type.\n\nFollow best practices while sending push notifications with APNs\n\nBelow are some APNs best practices to consider:\n\nMake an uncached DNS query to resolve the APNs server name, before each connection. This helps distribute push traffic from all providers across all APNs servers.\n\nAvoid push bursts over selective connections. Diversifying push traffic over many connections distributes push traffic for your application across all APNs servers.\n\nReuse a connection as long as possible. In most cases, you can reuse a connection for many hours to days. If your connection is mostly idle, you may send a HTTP2 PING frame after an hour of inactivity. Reusing a connection often results in less bandwidth and CPU consumption.\n\nCreate a unique value for the apns-id header to track your push notification. If you don’t provide one, APNs creates one and returns it as part of the response. Record this UUID to assist with debugging.\n\nPay attention to status returned by APNs for each push and take appropriate action for your application. For more information, see Handling notification responses from APNs.\n\nIf you’re using a certificate to connect to APNs, remember to get a new certificate and deploy it with your service before the expiry of the current certificate.\n\nDon’t make assumptions about device token size.\n\nNote\n\nAPNs doesn’t support legacy binary protocol as of March 31, 2021. Update to the HTTP/2-based API as soon as possible.\n\nSee Also\nServer Tasks\nGenerating a remote notification\nSend notifications to the user’s device with a JSON payload.\nHandling notification responses from APNs\nRespond to the status codes that the APNs servers return.\nViewing the status of push notifications using Metrics and APNs\nMonitor and interpret the status of your push notifications with Apple Push Notification service (APNs).\nPushing background updates to your App\nDeliver notifications that wake your app and update it in the background."
  },
  {
    "title": "UNShowPreviewsSetting",
    "url": "https://developer.apple.com/documentation/usernotifications/unshowpreviewssetting",
    "html": "Topics\nPreview Styes\ncase always\nThe notification’s content is always shown, even when the device is locked.\ncase whenAuthenticated\nThe notification’s content is shown only when the device is unlocked.\ncase never\nThe notification’s content is never shown, even when the device is unlocked\nInitializers\ninit?(rawValue: Int)\nDefault Implementations\nEquatable Implementations\nRawRepresentable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nGetting Interface Settings\nvar alertStyle: UNAlertStyle\nThe type of alert that the app may display when the device is unlocked.\nenum UNAlertStyle\nConstants indicating the presentation styles for alerts.\nvar showPreviewsSetting: UNShowPreviewsSetting\nThe setting that indicates whether the app shows a preview of the notification’s content.\nvar providesAppNotificationSettings: Bool\nA Boolean value indicating the system displays a button for in-app notification settings."
  },
  {
    "title": "request",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotification/request",
    "html": "Discussion\n\nFor local notifications, the request object is a copy of the one you originally configured. For remote notifications, the system synthesizes the request object from information received from Apple Push Notification service.\n\nSee Also\nGetting the Notification Details\nvar date: Date\nThe delivery date of the notification."
  },
  {
    "title": "Viewing the status of push notifications using Metrics and APNs",
    "url": "https://developer.apple.com/documentation/usernotifications/viewing-the-status-of-push-notifications-using-metrics-and-apns",
    "html": "Overview\n\nPush notifications can help optimize the user experience for your app by delivering important and time-sensitive information. Knowing the status of your notifications and whether your audience actually recieved them provides clarity and a better experience for people who use your app. You can monitor the status of your push notifications, after APNs accepts your request, using Metrics. Metrics shows you if APNs delivers or discards your push notifications, or saves them in persistent storage to attempt delivery later.\n\nView your metrics\n\nThe Push Notification Console Metrics tab provides aggregated, rounded reports on notification states as your notifications pass through APNs. Under the Metrics tab, it shows multiple notification statuses, such as delivered, stored, and discarded. Successful delivery depends on multiple factors, including:\n\nNotification attributes, such as push priority and push type\n\nThe destination device, such as the device’s power state\n\nExternal factors, such as the device’s connection quality (both cellular and Wi-Fi)\n\nA person’s actions, such as disabling push notifications or background refresh\n\nIf APNs stores or discards a notification, Metrics seperates the notifications into categories that explain why that status occured. For example, Stored - Device Offline means APNs stored the notification because the device was offline. Metrics collects the notification status data when a notification reaches a specific state. For example, a notification for an offline device may get delivered later when the device is back online. For that notification, saving in APNs storage and delivery are seperate data points for a single notification.\n\nUse the notification metrics to observe adoption of your new notification features or to tune your existing solution. For example, an uptick of Discarded - Disabled means that people who use your app find notifications for your app irrelevant or noisy. Consider emphasizing on events that are interesting for people who use your app. Check the number of notifications preserved in APNs storage for offline devices and compare it with the number of push notifications delivered from APNs storage. If the former is significantly higher, it’s a strong indication that a large volume of notifications are sent to devices that aren’t active with APNs. To preserve privacy, APNs doesn’t track states of offline devices, other than preserving notifications. In this scenario, consider building a system to remove push tokens of inactive users and save on resources for your service.\n\nInterpret data about discarded notifications\n\nThe figure below shows the logical flow that APNs takes to deliver a push notification to the destination device.\n\nAfter viewing or exporting your notification metrics, you may see that APNs discarded some notifications. APNs discards a push notification for a number of reasons:\n\nYour push token is no longer active on the destination device because a person removed your application or the push token for your application changes. For more information, see Registering your app with APNs.\n\nA person disabled push notifications for your app in Settings on the destination device. For more information, see Asking permission to use notifications.\n\nThe push notification expires. You can adjust the expiration attribute accordingly for future notifications. For more information, see Sending notification requests to APNs.\n\nYou can use the Push Notification Console to send test notifications. For information on how to test notifications, see Testing notifications using the Push Notification Console.\n\nInterpret data about stored notifications\n\nAfter viewing or exporting your notification metrics, you may see that APNs stored some notifications in storage. APNs stores a push notification for a number of reasons. If the destination device isn’t connected to APNs, then APNs saves the push notification in persistent storage to deliver later (unless it expires). APNs attempts to deliver an unexpired, stored push notification when the destination device connects to the APNs server the next time. When APNs delivers the push notification to the destination device, the delivery may take multiple attempts and some attempts may reach across multiple network interfaces.\n\nIf the destination device is connected to APNs but it has power restrictions, APNs may defer delivery of a notification to conserve battery. In that case, APNs stores the notification in persistent storage. When the device revises its power assertions and removes the restriction on delivery, APNs reattempts to deliver the stored notification.\n\nWhen APNs tries to deliver a notification from the APNs persistent storage, it might get delivered successfully or get discarded, depending on a number of factors. See the figure below to understand the logical flow of a push notification getting discarded in APNs persistant storage.\n\nWhile in APNs persistent storage, other notifications can overwrite notifications you send for the same device token and bundle ID. APNs persistent storage only stores one notification per application per device. If you send multiple notifications for the same bundle ID while APNs can’t deliver the notifications, APNs preserves only one of the accepted push notifications. Most of the time, it’s the last notification sent, but because APNs doesn’t have any ordering guarantees, this isn’t always the case.\n\nNote\n\nWhen storing a push notification, APNs uses either the specified expiry or defaults to time-to-live (TTL) of 30 days, whichever comes first.\n\nIf your push notification expires before the destination device connects to APNs and removes power state restrictions, APNs discards the notification. Your app may need to synchronize with your application server about the information missed due to discarded, expired, or overwritten notification.\n\nSee Also\nServer Tasks\nGenerating a remote notification\nSend notifications to the user’s device with a JSON payload.\nSending notification requests to APNs\nTransmit your remote notification payload and device token information to Apple Push Notification service (APNs).\nHandling notification responses from APNs\nRespond to the status codes that the APNs servers return.\nPushing background updates to your App\nDeliver notifications that wake your app and update it in the background."
  },
  {
    "title": "Testing notifications using the Push Notification Console",
    "url": "https://developer.apple.com/documentation/usernotifications/testing-notifications-using-the-push-notification-console",
    "html": "Overview\n\nPush notifications inform people about the most recent updates, news, or events from your app. A successfully sent notification ensures that people can still get relevant information from your app even when it’s not in use. Testing notifications before you send them can ensure functionality, reliability, and enhance a person’s experience with your app.\n\nThe Push Notification Console is a web interface you use to send test notifications and monitor their delivery status in the development environment. The console contains the delivery log, where you can gain insight into your notification history. The Push Notification Console also provides status information about your notification such as when APNs recieves your notification, and if it goes to persistent storage.\n\nThe console also provides additional tooling to help debug and authenticate tokens used in Apple Push Notification service (APNs). You can determine the validity of your tokens to troubleshoot sending a notification and generate a JSON Web token (JWT).\n\nRelated sessions from WWDC23\n\nSession 10025: Meet Push Notifications Console\n\nCreate and send a test push notification\n\nThe Push Notification Console provides guidance on configuring various push notification parameters like push type, priority, and expiration as well as constructing the payload for the notification. Push Notification Console keeps a history of all the notifications sent from this page for 30 days. You can access the history in the sidebar on the left. All team members can access the console and view the history of the push notifications sent.\n\nUse the payload editor to input raw JSON directly or construct the payload using the editor’s interface. The payload format changes depending on the push type you select for the notification, and as a result, the layout of the editor may change accordingly. For more information about construction of the notification payload, see Generating a remote notification.\n\nThe screenshot below is an example of a test notification form used to send a test notification in the Push Notification Console.\n\nAfter entering the required information for a push notification request, you can generate the corresponding cURL command by clicking the Get cURL Command button. The generated cURL command includes the necessary headers, authentication information, and payload data for the request. Use this to send the same notification by connecting directly to APNs from the command line. For more information, see Sending push notifications using command-line tools.\n\nIn the APNs production environment, only team members with the admin role can send push notifications. Both non-admins and admins can send pushes to the APNs development environment. For more information about the request parameters, see Sending notification requests to APNs.\n\nVerify delivery in the development environment\n\nAfter APNs receives a push notification, it can undergo several state transitions before it reaches the device. The delivery of a push notification depends on a device’s battery, network connectivity, and other factors. APNs might deliver the notification immediately, defer delivery, make multiple attempts to deliver, or discard it based on those conditions. For more information, see Viewing the status of push notifications using Metrics and APNs.\n\nYou can use the Delivery Log to monitor a notification’s delivery and give you insight into what happens to the notifications you send. To access this information, provide an “apns-unique-id”, an identifier that APNs returns in response to each notification request.\n\nTo view the delivery log for a particular push notification sent to APNs, you need to select the bundle ID that you used to send the notification from the dashboard. You can only query delivery logs of notifications sent for the selected bundle ID. Delivery logs are only available in the development environment. You can access the logs for up to seven days after you send the notification. Download and save the logs to retain them for future analysis or reference.\n\nDebug APNs tokens\n\nThe authentication token that you include with your notification requests uses the JSON Web Token (JWT) specification. You need a private key to sign the JWT. You can manage those keys through the developer portal. A team can have multiple signing keys. Each key is uniquely identified by a key ID. For more information about key management, see the “Manage keys” section in Developer Account Help.\n\nYou can determine the validity of an authentication token by using the JWT Validator. Whether the token is valid depends on many factors, including but not limited to:\n\nSignature validity (public/private key match)\n\nTeam ID\n\nExpiration\n\nIf the provided key is invalid, the tool gives the reason why it’s invalid. For debugging purposes, the validator parses and displays the key-value pairs that constitute the token’s header and payload. This helps identify any authentication problems you may face when using these credentials to initiate push notification requests. For more information on the token-based authentication that APNs uses, refer to Establishing a token-based connection to APNs.\n\nYou can use the Device Token Validator to determine the validity of the device token. To verify a device token associated with a bundle ID, you need to select the respective bundle ID in the dashboard. For more information on getting a device token, see Registering your app with APNs.\n\nGenerate an authentication token\n\nYou can generate an authentication token using the JWT generator by providing your private signing key and key ID. You need to get a private key before you can generate a JWT. For more information, see Create a private key to access a service. The screenshot below shows the JSON Web Token Generator with the correct information in the Private Key and Key ID fields. The generator tells you whether your key is valid.\n\nNote\n\nThe signing key isn’t uploaded anywhere, it’s only used in your browser.\n\nSee Also\nRemote notifications\nSetting up a remote notification server\nGenerate notifications and push them to user devices.\nRegistering your app with APNs\nCommunicate with Apple Push Notification service (APNs) and receive a unique device token that identifies your app.\nSending push notifications using command-line tools\nUse basic macOS command-line tools to send push notifications to Apple Push Notification service (APNs)."
  },
  {
    "title": "Establishing a certificate-based connection to APNs",
    "url": "https://developer.apple.com/documentation/usernotifications/establishing-a-certificate-based-connection-to-apns",
    "html": "Overview\n\nWith certificate-based authentication, you use a provider certificate to establish a secure connection between your provider server and APNs. You obtain this certificate from Apple through your developer account.\n\nBecause you establish trust at the server level, individual notification requests contain only your payload and a device token. They don’t include an authentication token, which reduces the size of each notification request slightly.\n\nYou can use a provider certificate to send notifications to a single app, the Apple Watch complication, or to background VoIP services associated with a single app. To send remote notifications to multiple apps, you must create separate certificates for each app. You must also manage separate APNs connections for each app’s notifications. As a result, it’s often simpler to use token-based authentication to support multiple apps.\n\nObtain a provider certificate from Apple\n\nYou obtain a provider certificate from your developer account when you sign in to developer.apple.com. In the Program resources section:\n\nSelect Certificates under Certificates, IDs & Profiles.\n\nAdd a new certificate.\n\nUnder Services, select Apple Push Notification service SSL (Sandbox & Production) for the type and click Continue.\n\nSelect the App ID (also known as Bundle ID) of your app and click Continue.\n\nGenerate a Certificate Signing Request (CSR) on your server.\n\nClick Continue.\n\nUpload your CSR file and click Continue.\n\nDownload the resulting certificate.\n\nImportant\n\nCertificates must be tied to a specific app.\n\nTie a different provider certificate to each app, whose App ID you specify when creating the certificate. You must also tie your certificate to a CSR, which is the private key used to encrypt the certificate. The certificate itself becomes the public key that you exchange with APNs. For more information on certificate creation, see Certificates overview.\n\nInstall the certificate and private key\n\nInstall both the certificate and the private key on your provider server. In macOS, double-clicking the certificate installs it in Keychain Access automatically. If you created your CSR file from your provider server, Keychain Access installs the key in your keychain automatically.\n\nYou can use a certificate generated by selecting VoIP Services Certificate to send Pushkit VOIP notifications. A WatchKit Services Certificate allows both PushKit VoIP and notifications for the watchOS complication. Use the command-line tool openssl with command option x509 to inspect a certificate.\n\nYou can also use the Keychain Access app to inspect a certificate. In Keychain Access, you can find the Topic/Bundle ID under Details > Subject Name > Common Name. Also check for Extension 1.2.840.113635.100.6.3.4 and 1.2.840.113635.100.6.3.6 under Details > Public Key Info for additional Topics/Bundle IDs for Pushkit VoIP, watchOS complication, and Push to Talk. If a certificate doesn’t have the push topic for a specific push type, you can’t use the certificate to send a notification of that type.\n\nImportant\n\nCheck expiry of a certificate with Keychain Access. To avoid a disruption in service for your users, update your provider certificates before they expire. Provider certificates are valid for a year and you must update them to continue communicating with APNs.\n\nEstablish trust with APNs\n\nWith your certificates installed, the following figure shows the sequence of steps that occur when you open a connection to the APNs server. After requesting a secure connection using transport layer security (TLS), APNs responds by sending over a certificate for your provider server to validate. After validating that certificate, your provider certificate validates it and completes the secure connection. After that, you can begin sending remote notification requests to APNs.\n\nYou can revoke your certificate from your developer account if you think you have a compromised certificate or private key. APNs maintains a list of revoked certificates, and it refuses TLS connections from servers whose certificates are on that list. If your server is using a revoked certificate, close all existing connections to APNs and configure a new provider certificate for your server before opening any new connections.\n\nSee Also\nSecurity\nEstablishing a token-based connection to APNs\nSecure your communications with Apple Push Notification service (APNs) by using stateless authentication tokens."
  },
  {
    "title": "Asking permission to use notifications",
    "url": "https://developer.apple.com/documentation/usernotifications/asking-permission-to-use-notifications",
    "html": "Overview\n\nLocal and remote notifications get a person’s attention by displaying an alert, playing sounds, or badging your app’s icon. These interactions occur when your app isn’t running or is in the background. They let people know that your app has relevant information for them to view. Because a person might consider notification-based interactions disruptive, you must obtain permission to use them.\n\nExplicitly request authorization in context\n\nTo ask for authorization, get the shared UNUserNotificationCenter instance and call its requestAuthorization(options:completionHandler:) method. Specify all of the interaction types that your app employs. For example, you can request authorization to display alerts, add a badge to the app icon, or play sounds:\n\nlet center = UNUserNotificationCenter.current()\n\n\ndo {\n    try await center.requestAuthorization(options: [.alert, .sound, .badge])\n} catch {\n    // Handle the error here.\n}\n    \n// Enable or disable features based on the authorization.\n\n\nThe first time your app makes this authorization request, the system prompts the person to grant or deny the request and records that response. Subsequent authorization requests don’t prompt the person.\n\nMake the request in a context that helps people understand why your app needs authorization. In a task-tracking app that sends reminder notifications, you might make the request after the person schedules a first task. Sending the request in context provides a better experience than automatically requesting authorization on first launch, because people can see the purpose your apps notifications serve.\n\nUse provisional authorization to send trial notifications\n\nWhen you explicitly ask for permission to send notifications, people must decide whether to allow or deny permission before they’ve seen a notification from your app. Even if you carefully set the context before requesting authorization, people may not have enough information to make a decision, and might reject the authorization.\n\nUse provisional authorization to send notifications on a trial basis. People can then evaluate the notifications and decide whether to authorize them.\n\nThe system delivers provisional notifications quietly — they don’t interrupt the person with a sound or banner, or appear on the lock screen. Instead, they only appear in the notification center’s history. These notifications also include buttons that prompt the person to keep or turn off the notification.\n\nIf a person presses the Keep button, the system prompts them to choose between two options: Deliver Immediately or Deliver in Scheduled Summary. Deliver Immediately delivers future notifications quietly. The system authorizes your app to send notifications, but it doesn’t give your app permission to show alerts, play sounds, or badge the app icon. Your notification only appears in the notification center history unless they change their notification settings. Deliver in Scheduled Summary only appears if the person has Scheduled Summary toggled On in Settings.\n\nIf the person presses the Turn Off button, the system confirms the selection before denying your app authorization to send additional notifications.\n\nTo request provisional authorization, add the provisional option when requesting permission to send notifications.\n\nlet center = UNUserNotificationCenter.current()do {\n    try await center.requestAuthorization(options: [.alert, .sound, .badge, .provisional])\n} catch {\n    // Handle errors that may occur during requestAuthorization.\n}\n\n\nUnlike explicitly requesting authorization, this code doesn’t prompt the person for permission to receive notifications. Instead, the first time you call this method, it automatically grants authorization. However, until the person either explicitly keeps or turns off the notification, the authorization status is UNAuthorizationStatus.provisional. Because people can change the authorization status at any point, check the status before scheduling local notifications.\n\nAdditionally, if you request provisional authorization, you can request authorization when your app first launches. The person is only asked to keep or turn off notifications when they actually receive the notification.\n\nCustomize notifications based on the current authorizations\n\nAlways check your app’s authorization status before scheduling local notifications. People can change your app’s authorization settings at any time. They can also change the type of interactions allowed by your app — which may cause you to alter the number or type of notifications your app sends.\n\nTo provide the best experience for people, call the notification center’s getNotificationSettings(completionHandler:) method to get the current notification settings. Then customize the notification based on these settings.\n\nlet center = UNUserNotificationCenter.current()\n\n\n// Obtain the notification settings.\nlet settings = await center.notificationSettings()\n\n\n// Verify the authorization status.\nguard (settings.authorizationStatus == .authorized) ||\n      (settings.authorizationStatus == .provisional) else { return }\n\n\nif settings.alertSetting == .enabled {\n    // Schedule an alert-only notification.\n} else {\n    // Schedule a notification with a badge and sound.\n}\n\n\nThe above example uses a guard condition to prevent the scheduling of notifications if the app isn’t authorized. The code then configures the notification based on the types of interactions allowed, preferring the use of an alert-based notification whenever possible.\n\nYou might want to configure your notification with alert, sound, and badge information even if your app isn’t authorized for some of the interactions. The system still displays alerts in Notification Center if your UNNotificationSettings instance’s notificationCenterSetting property is set to UNNotificationSetting.enabled. Your notification center delegate’s userNotificationCenter(_:willPresent:withCompletionHandler:) method also receives notifications when your app is in the foreground, and can still access the alert, sound, or badge information."
  },
  {
    "title": "setNotificationCategories(_:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/setnotificationcategories(_:)",
    "html": "Parameters\ncategories\n\nA set of UNNotificationCategory objects, each of which contains the actions that are displayed with the notification interface. This parameter must contain all of your app’s supported categories.\n\nDiscussion\n\nCall this method at launch time to register your app’s actionable notification types. This method registers all of your categories at once, replacing any previously registered categories with the new ones in the categories parameter. Typically, you call this method only once.\n\nEach object in the categories parameter contains a string for identifying the notification’s type. It also contains one or more custom actions that the user may perform in response to notifications of that type. When the system displays an alert for a notification, it looks in the notification payload for one of the identifier strings from your category objects. If it finds one, it adds user-selectable buttons for each action associated with that category object. Tapping a button notifies your app of the selected action, without bringing your app to the foreground.\n\nlet center = UNUserNotificationCenter.current()\nlet category1 = UNNotificationCategory(identifier: \"com.example.mynotification\", actions: [], intentIdentifiers: [])\ncenter.setNotificationCategories([category1])\ncenter.removeAllPendingNotificationRequests()\n\nSee Also\nManaging notification categories\nfunc getNotificationCategories(completionHandler: (Set<UNNotificationCategory>) -> Void)\nFetches your app’s registered notification categories."
  },
  {
    "title": "removeDeliveredNotifications(withIdentifiers:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/removedeliverednotifications(withidentifiers:)",
    "html": "Parameters\nidentifiers\n\nAn array of NSString objects, each of which corresponds to a value in the identifier property of a UNNotificationRequest object. This method ignores the identifiers of requests whose notifications are not currently displayed in Notification Center.\n\nDiscussion\n\nUse this method to selectively remove notifications that you no longer want displayed in Notification Center. The method executes asynchronously, returning immediately and removing the specified notifications on a background thread.\n\nSee Also\nRemoving delivered notifications\nfunc getDeliveredNotifications(completionHandler: ([UNNotification]) -> Void)\nFetches all of your app’s delivered notifications that are still present in Notification Center.\nfunc removeAllDeliveredNotifications()\nRemoves all of your app’s delivered notifications from Notification Center."
  },
  {
    "title": "removeAllDeliveredNotifications()",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/removealldeliverednotifications()",
    "html": "Discussion\n\nUse this method to remove all of your app’s delivered notifications from Notification Center. The method executes asynchronously, returning immediately and removing the identifiers on a background thread. This method does not affect any notification requests that are scheduled, but have not yet been delivered.\n\nSee Also\nRemoving delivered notifications\nfunc getDeliveredNotifications(completionHandler: ([UNNotification]) -> Void)\nFetches all of your app’s delivered notifications that are still present in Notification Center.\nfunc removeDeliveredNotifications(withIdentifiers: [String])\nRemoves your app’s notifications from Notification Center that match the specified identifiers."
  },
  {
    "title": "getNotificationCategories(completionHandler:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/getnotificationcategories(completionhandler:)",
    "html": "Parameters\ncompletionHandler\n\nThe block to execute asynchronously with the results. This block may be executed on a background thread. The block has no return value and takes the following parameter:\n\ncategories\n\nThe set of UNNotificationCategory objects containing your registered notification types. If your app has not yet registered any categories, this parameter is an empty set.\n\nDiscussion\n\nImportant\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc notificationCategories() async -> Set<UNNotificationCategory>\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nUse this method to retrieve your app’s currently registered notification types. You might use this method when you want to augment the current set of categories with new categories later on. Simply merge the returned set with any new category objects and register the updated set.\n\nlet center = UNUserNotificationCenter.current()\nlet categories = await center.notificationCategories()\n\nSee Also\nManaging notification categories\nfunc setNotificationCategories(Set<UNNotificationCategory>)\nRegisters the notification categories that your app supports."
  },
  {
    "title": "UNUserNotificationCenter",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenter",
    "html": "Overview\n\nUse the shared UNUserNotificationCenter object to manage all notification-related behaviors in your app or app extension. Specifically, use this object to do the following:\n\nRequest authorization to interact with the user through alerts, sounds, and icon badges. See Asking permission to use notifications.\n\nDeclare the notification types that your app supports and the custom actions the user may perform when the system delivers those notifications. See Declaring your actionable notification types.\n\nSchedule the delivery of notifications from your app. See Scheduling a notification locally from your app.\n\nProcess the payloads from remote notifications the system delivers by Apple Push Notification service (APNs). See Handling notifications and notification-related actions.\n\nManage the already delivered notifications the system displays in Notification Center. See Managing Delivered Notifications.\n\nHandle user-selected actions associated with your custom notification types. See Handling notifications and notification-related actions.\n\nGet the notification-related settings for your app. See Managing Settings and Authorization.\n\nTo handle incoming notifications and notification-related actions, create an object that adopts the UNUserNotificationCenterDelegate protocol and assign it to the delegate property. Always assign an object to the delegate property before performing any tasks that might interact with that delegate.\n\nYou may use the shared user notification center object simultaneously from any of your app’s threads. The object processes requests serially in the order that the system initiates them.\n\nTopics\nManaging the notification center\nclass func current() -> UNUserNotificationCenter\nReturns your app’s notification center.\nfunc getNotificationSettings(completionHandler: (UNNotificationSettings) -> Void)\nRetrieves the authorization and feature-related settings for your app.\nfunc setBadgeCount(Int, withCompletionHandler: (((any Error)?) -> Void)?)\nUpdates the badge count for your app’s icon.\nRequesting authorization\nfunc requestAuthorization(options: UNAuthorizationOptions, completionHandler: (Bool, (any Error)?) -> Void)\nRequests a person’s authorization to allow local and remote notifications for your app.\nstruct UNAuthorizationOptions\nOptions that determine the authorized features of local and remote notifications.\nProcessing received notifications\nvar delegate: (any UNUserNotificationCenterDelegate)?\nThe notification center’s delegate.\nprotocol UNUserNotificationCenterDelegate\nAn interface for processing incoming notifications and responding to notification actions.\nvar supportsContentExtensions: Bool\nA Boolean value that indicates whether the device supports notification content extensions.\nScheduling notifications\nfunc add(UNNotificationRequest, withCompletionHandler: (((any Error)?) -> Void)?)\nSchedules the delivery of a local notification.\nfunc getPendingNotificationRequests(completionHandler: ([UNNotificationRequest]) -> Void)\nFetches all of your app’s local notifications that are pending delivery.\nfunc removePendingNotificationRequests(withIdentifiers: [String])\nRemoves your app’s local notifications that are pending and match the specified identifiers.\nfunc removeAllPendingNotificationRequests()\nRemoves all of your app’s pending local notifications.\nRemoving delivered notifications\nfunc getDeliveredNotifications(completionHandler: ([UNNotification]) -> Void)\nFetches all of your app’s delivered notifications that are still present in Notification Center.\nfunc removeDeliveredNotifications(withIdentifiers: [String])\nRemoves your app’s notifications from Notification Center that match the specified identifiers.\nfunc removeAllDeliveredNotifications()\nRemoves all of your app’s delivered notifications from Notification Center.\nManaging notification categories\nfunc setNotificationCategories(Set<UNNotificationCategory>)\nRegisters the notification categories that your app supports.\nfunc getNotificationCategories(completionHandler: (Set<UNNotificationCategory>) -> Void)\nFetches your app’s registered notification categories.\nHandling errors\nstruct UNError\nAn object that represents a notification error.\nenum Code\nConstants that identify notification errors.\nlet UNErrorDomain: String\nThe error domain for notifications.\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSObjectProtocol\nSee Also\nNotification management\nprotocol UNUserNotificationCenterDelegate\nAn interface for processing incoming notifications and responding to notification actions.\nclass UNNotificationSettings\nThe object for managing notification-related settings and the authorization status of your app."
  },
  {
    "title": "Implementing Background Push Notifications",
    "url": "https://developer.apple.com/documentation/usernotifications/implementing-background-push-notifications",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC20 session 10095: Push Notifications Primer.\n\nConfigure the Sample Code Project\n\nBefore you run the sample code project in Xcode, set up a remote notification server to send pushes. See Setting Up a Remote Notification Server.\n\nSee Also\nSample code\nHandling Communication Notifications and Focus Status Updates\nCreate a richer calling and messaging experience in your app by implementing communication notifications and Focus status updates.\nImplementing Alert Push Notifications\nAdd visible alert notifications to your app by using the UserNotifications framework."
  },
  {
    "title": "UNNotificationServiceExtension",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationserviceextension",
    "html": "Overview\n\nA UNNotificationServiceExtension object provides the entry point for a notification service app extension. This object lets you customize the content of a remote notification before the system delivers it to the user. A notification service app extension doesn’t present any UI of its own. Instead, it’s launched on demand when the system delivers a notification of the appropriate type to the user’s device. You use this extension to modify the notification’s content or download content related to the extension. For example, you could use the extension to decrypt an encrypted data block or to download images associated with the notification.\n\nYou don’t create UNNotificationServiceExtension objects yourself. Instead, the Xcode template for a notification service extension target contains a subclass for you to modify. Use the methods of that subclass to implement your app extension’s behavior. When your app recieves a remote notification for your app, the system loads your extension and calls its didReceive(_:withContentHandler:) method given the following conditions:\n\nYour app has configured the remote notification to display an alert.\n\nThe remote notification’s aps dictionary includes the mutable-content key with the value set to 1.\n\nNote\n\nYou can’t modify silent notifications or those that only play a sound or badge the app’s icon.\n\nThe didReceive(_:withContentHandler:) method performs the main work of your extension. You use that method to make any changes to the notification’s content. That method has a limited amount of time to perform its task and execute the provided completion block. If your method doesn’t finish in time, the system calls the serviceExtensionTimeWillExpire() method to give you one last chance to submit your changes. If you don’t update the notification content before time expires, the system displays the original content.\n\nAs for any app extension, you deliver a notification service app extension class as a bundle inside your app. The template that Xcode provides configures the Info.plist file automatically for this app extension type. Specifically, it sets the value of the NSExtensionPointIdentifier key to com.apple.usernotifications.service and sets the value of the NSExtensionPrincipalClass key to the name of your UNNotificationServiceExtension subclass.\n\nFor information about how to set up and send remote notifications, see Setting up a remote notification server.\n\nSubclassing Notes\n\nThe Xcode templates provide a subclass of UNNotificationServiceExtension for you to modify. You must implement the didReceive(_:withContentHandler:) method and use it to process incoming notifications. It’s also strongly recommended that you override the serviceExtensionTimeWillExpire() method.\n\nTopics\nProcessing Notifications\nfunc didReceive(UNNotificationRequest, withContentHandler: (UNNotificationContent) -> Void)\nAsks you to make any needed changes to the notification and notify the system when you’re done.\nfunc serviceExtensionTimeWillExpire()\nTells you that the system is terminating your extension.\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSObjectProtocol\nSee Also\nNotification service app extension\nModifying content in newly delivered notifications\nModify the payload of a remote notification before it’s displayed on the user’s iOS device."
  },
  {
    "title": "UserNotifications Constants",
    "url": "https://developer.apple.com/documentation/usernotifications/usernotifications-constants",
    "html": "Topics\nConstants\nUNNotificationCategoryOptionNone\nNo options."
  },
  {
    "title": "Implementing Alert Push Notifications",
    "url": "https://developer.apple.com/documentation/usernotifications/implementing-alert-push-notifications",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC20 session 10095: Push Notifications Primer.\n\nConfigure the Sample Code Project\n\nBefore you run the sample code project in Xcode, set up a remote notification server to send pushes. See Setting Up a Remote Notification Server.\n\nSee Also\nSample code\nHandling Communication Notifications and Focus Status Updates\nCreate a richer calling and messaging experience in your app by implementing communication notifications and Focus status updates.\nImplementing Background Push Notifications\nAdd background notifications to your app by using the UserNotifications framework."
  },
  {
    "title": "UNNotificationResponse",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationresponse",
    "html": "Overview\n\nWhen the user interacts with a delivered notification, the system delivers a UNNotificationResponse object to your app so that you can process the response. Users can interact with delivered notifications in many ways. If the notification’s category had associated action buttons, they can select one of those buttons. Users can also dismiss the notification without selecting one of your actions and they can open your app. A response object tells you which option the user selected.\n\nYou don’t create UNNotificationResponse objects yourself. Instead, the shared user notification center object creates them and delivers them to the userNotificationCenter(_:didReceive:withCompletionHandler:) method of its delegate object. Use that method to extract any needed information from the response object and take appropriate action.\n\nFor more information about responding to actions, see Handling notifications and notification-related actions.\n\nTopics\nGetting the Response Information\nvar actionIdentifier: String\nThe identifier string of the action that the user selected.\nvar notification: UNNotification\nThe notification to which the user responded.\nvar targetScene: UIScene?\nThe scene where the system reflects the user’s response to a notification.\nlet UNNotificationDefaultActionIdentifier: String\nAn action that indicates the user opened the app from the notification interface.\nlet UNNotificationDismissActionIdentifier: String\nThe action that indicates the user explicitly dismissed the notification interface.\nInitializers\ninit?(coder: NSCoder)\nRelationships\nInherits From\nNSObject\nInherited By\nUNTextInputNotificationResponse\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification responses\nHandling notifications and notification-related actions\nRespond to user interactions with the system’s notification interfaces, including handling your app’s custom actions.\nclass UNTextInputNotificationResponse\nThe user’s response to an actionable notification, including any custom text that the user typed or dictated."
  },
  {
    "title": "UNTextInputNotificationResponse",
    "url": "https://developer.apple.com/documentation/usernotifications/untextinputnotificationresponse",
    "html": "Overview\n\nThe system delivers a UNTextInputNotificationResponse object to your app so that you can process user-provided text content. When defining your categories, you can specify an UNTextInputNotificationAction object instead of an UNNotificationAction object for your action. If you do, the system creates an UNTextInputNotificationResponse object when the user selects the accompanying action, and it fills the userText property with any user-entered text.\n\nYou don’t create UNTextInputNotificationResponse objects yourself. Instead, the shared user notification center object creates them and delivers them to the userNotificationCenter(_:didReceive:withCompletionHandler:) method of its delegate object. Use that method to extract any needed information from the response object and take appropriate action.\n\nFor more information about responding to actions, see Handling notifications and notification-related actions.\n\nTopics\nGetting the Text Response\nvar userText: String\nThe text response provided by the user.\nRelationships\nInherits From\nUNNotificationResponse\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification responses\nHandling notifications and notification-related actions\nRespond to user interactions with the system’s notification interfaces, including handling your app’s custom actions.\nclass UNNotificationResponse\nThe user’s response to an actionable notification."
  },
  {
    "title": "UNNotificationCategory",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcategory",
    "html": "Overview\n\nA UNNotificationCategory object defines a type of notification that your executable can receive. You create category objects to define your app’s actionable notifications — notifications that have action buttons the user can select in response to the notification. Each category object you create stores the actions and other behaviors associated with a specific type of notification. Register your category objects using the setNotificationCategories(_:) method of UNUserNotificationCenter. You can register as many category objects as you need.\n\nNote\n\nWhen someone performs a Double Tap gesture while viewing a notification on Apple Watch Series 9 or Apple Watch Ultra 2, the system invokes the first nondestructive action. A nondestructive action doesn’t include the destructive option, and won’t delete user data or change the app irrevocably.\n\nTo apply category objects to your notifications, include the category’s identifier string in the payload of any notifications you create. For local notifications, put this string in the categoryIdentifier property of the UNMutableNotificationContent object that you use to specify the notification’s content. For remote notifications, use this string as the value of the category key in the aps dictionary of your payload.\n\nCategories can have associated actions, which define custom buttons the system displays for notifications of that category. When the system has unlimited space, the system displays up to 10 actions. When the system has limited space, the system displays at most two actions.\n\nTopics\nEssentials\nconvenience init(identifier: String, actions: [UNNotificationAction], intentIdentifiers: [String], options: UNNotificationCategoryOptions)\nCreates a category object containing the specified actions and options.\nconvenience init(identifier: String, actions: [UNNotificationAction], intentIdentifiers: [String], hiddenPreviewsBodyPlaceholder: String, options: UNNotificationCategoryOptions)\nCreates a category object containing the specified actions, options, and placeholder text used when previews aren’t shown.\nconvenience init(identifier: String, actions: [UNNotificationAction], intentIdentifiers: [String], hiddenPreviewsBodyPlaceholder: String?, categorySummaryFormat: String?, options: UNNotificationCategoryOptions)\nCreates a category object containing the specified actions, options, placeholder text used when previews aren’t shown, and summary format string.\nGetting the Information\nvar identifier: String\nThe unique string assigned to the category.\nvar actions: [UNNotificationAction]\nThe actions to display when the system delivers notifications of this type.\nvar intentIdentifiers: [String]\nThe intents related to notifications of this category.\nvar hiddenPreviewsBodyPlaceholder: String\nThe placeholder text to display when the system disables notification previews for the app.\nvar categorySummaryFormat: String\nA format string for the summary description used when the system groups the category’s notifications.\nGetting the Options\nvar options: UNNotificationCategoryOptions\nOptions for how to handle notifications of this type.\nstruct UNNotificationCategoryOptions\nConstants indicating how to handle notifications associated with this category.\nInitializers\ninit?(coder: NSCoder)\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification categories and user actions\nDeclaring your actionable notification types\nDifferentiate your notifications and add action buttons to the notification interface.\nclass UNNotificationAction\nA task your app performs in response to a notification that the system delivers.\nclass UNTextInputNotificationAction\nAn action that accepts user-typed text."
  },
  {
    "title": "UNTextInputNotificationAction",
    "url": "https://developer.apple.com/documentation/usernotifications/untextinputnotificationaction",
    "html": "Overview\n\nUse UNTextInputNotificationAction objects to define an action that allows the user to provide a custom text-based response. When the user selects an action of this type, the system displays controls for the user to enter or dictate the text content. That text is then included in the response object that’s delivered to your app.\n\nFor information on how to define actions and categories, see Declaring your actionable notification types.\n\nTopics\nEssentials\nconvenience init(identifier: String, title: String, options: UNNotificationActionOptions, textInputButtonTitle: String, textInputPlaceholder: String)\nCreates an action object that accepts text input from the user.\nconvenience init(identifier: String, title: String, options: UNNotificationActionOptions, icon: UNNotificationActionIcon?, textInputButtonTitle: String, textInputPlaceholder: String)\nCreates an action object with an icon that accepts text input from the user.\nGetting Information\nvar textInputButtonTitle: String\nThe localized title of the text input button that the system displays to the user.\nvar textInputPlaceholder: String\nThe placeholder text that the system localizes and displays in the text input field.\nRelationships\nInherits From\nUNNotificationAction\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification categories and user actions\nDeclaring your actionable notification types\nDifferentiate your notifications and add action buttons to the notification interface.\nclass UNNotificationCategory\nA type of notification your app supports and the custom actions that the system displays.\nclass UNNotificationAction\nA task your app performs in response to a notification that the system delivers."
  },
  {
    "title": "init(identifier:title:options:)",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationaction/init(identifier:title:options:)",
    "html": "Parameters\nidentifier\n\nThe string that you use internally to identify the action. This string must be unique among your app’s supported actions. When the user selects the action, the system passes this string to your app and asks the user to perform the related task. This parameter must not be nil or an empty string.\n\ntitle\n\nThe localized string the system displays to the user. The system displays this string as the title of a button, which the system adds to the notification interface. This parameter must not be nil.\n\noptions\n\nAdditional options that describe how the action behaves. Include options when you need the related behavior. For a list of possible values, see UNNotificationActionOptions.\n\nReturn Value\n\nAn action object that the system initializes.\n\nSee Also\nEssentials\nconvenience init(identifier: String, title: String, options: UNNotificationActionOptions, icon: UNNotificationActionIcon?)\nCreates an action object by using the specified title, options, and icon."
  },
  {
    "title": "Handling notifications and notification-related actions",
    "url": "https://developer.apple.com/documentation/usernotifications/handling-notifications-and-notification-related-actions",
    "html": "Overview\n\nNotifications are primarily a way of putting information in front of the user, but your app can also respond to them. For example, you might want to respond to:\n\nActions selected by the user from the notification interface.\n\nA notification that arrives when your app is running in the foreground.\n\nA silent notification (see Pushing background updates to your App).\n\nA notification associated with the PushKit framework, such as VoIP or complication-related notifications.\n\nHandle user-selected actions\n\nActionable notifications let the user respond to a notification directly from the notification interface. In addition to the notification’s content, an actionable notification displays one or more buttons representing the actions that the user can take. Tapping one of the buttons forwards the selected action to your app, without bringing the app to the foreground. If your app supports actionable notification types, you must handle the associated actions.\n\nNote\n\nYou declare actionable notification types at launch time at the same time you declare your app’s supported categories. For more information, see Declaring your actionable notification types.\n\nYou handle selected actions from the delegate object of the shared UNUserNotificationCenter object. When the user selects an action, the system launches your app in the background and calls the delegate’s userNotificationCenter(_:didReceive:withCompletionHandler:) method. Match the value in the actionIdentifier property of the response object to one of your app’s actions or a system-defined action. The system reports special actions when the user dismisses the notification or launches your app.\n\nListing 1 shows an example that processes actions associated with a meeting invitation. The ACCEPT_ACTION and DECLINE_ACTION strings identify the app-specific actions, which generate an appropriate response to the meeting invitation. If the user doesn’t choose one of the app-defined actions, the method saves the invitation until the user launches the app.\n\nListing 1. Handling the actions in your actionable notifications\n\nfunc userNotificationCenter(_ center: UNUserNotificationCenter,\n            didReceive response: UNNotificationResponse,\n            withCompletionHandler completionHandler: \n               @escaping () -> Void) {\n   // Get the meeting ID from the original notification.\n   let userInfo = response.notification.request.content.userInfo\n        \n   if response.notification.request.content.categoryIdentifier ==\n              \"MEETING_INVITATION\" {\n      // Retrieve the meeting details.\n      let meetingID = userInfo[\"MEETING_ID\"] as! String\n      let userID = userInfo[\"USER_ID\"] as! String\n            \n      switch response.actionIdentifier {\n      case \"ACCEPT_ACTION\":\n         sharedMeetingManager.acceptMeeting(user: userID, \n               meetingID: meetingID)\n         break\n                \n      case \"DECLINE_ACTION\":\n         sharedMeetingManager.declineMeeting(user: userID, \n               meetingID: meetingID)\n         break\n                \n      case UNNotificationDefaultActionIdentifier,\n           UNNotificationDismissActionIdentifier:\n         // Queue meeting-related notifications for later\n         //  if the user does not act.\n         sharedMeetingManager.queueMeetingForDelivery(user: userID,\n               meetingID: meetingID)\n         break\n                \n      default:\n         break\n      }\n   }\n   else {\n      // Handle other notification types...\n   }\n        \n   // Always call the completion handler when done.\n   completionHandler()\n}\n\nHandle notifications while your app runs in the foreground\n\nIf a notification arrives when your app is running in the foreground, the system delivers that notification directly to your app. Upon receiving a notification, you can use the notification’s payload to do whatever you want. For example, you can update your app’s interface to reflect new information contained in the notification. You can then suppress any scheduled alerts or modify those alerts.\n\nWhen a notification arrives, the system calls the userNotificationCenter(_:willPresent:withCompletionHandler:) method of the UNUserNotificationCenter object’s delegate. Use that method to process the notification and let the system know how you want it to proceed. Listing 2 shows a version of this method for a calendar app. When a meeting invitation arrives, the app calls its custom queueMeetingForDelivery method to show the new invitation in the app’s interface. The app also asks the system to play the notification’s sound by passing the sound value to the completion handler. For other notification types, the method silences the notification.\n\nListing 2. Processing notifications in the foreground\n\nfunc userNotificationCenter(_ center: UNUserNotificationCenter,\n         willPresent notification: UNNotification,\n         withCompletionHandler completionHandler: \n            @escaping (UNNotificationPresentationOptions) -> Void) {\n   if notification.request.content.categoryIdentifier == \n            \"MEETING_INVITATION\" {\n      // Retrieve the meeting details.\n      let meetingID = notification.request.content.\n                       userInfo[\"MEETING_ID\"] as! String\n      let userID = notification.request.content.\n                       userInfo[\"USER_ID\"] as! String\n            \n      // Add the meeting to the queue.\n      sharedMeetingManager.queueMeetingForDelivery(user: userID,\n            meetingID: meetingID)\n\n\n      // Play a sound to let the user know about the invitation.\n      completionHandler(.sound)\n      return\n   }\n   else {\n      // Handle other notification types...\n   }\n\n\n   // Don't alert the user for other types.\n   completionHandler(UNNotificationPresentationOptions(rawValue: 0))\n}\n\n\nIf you registered your app with PushKit, notifications targeting PushKit-types are always delivered directly to your app and are never displayed to the user. If your app is in the foreground or background, the system gives your app time to process the notification. If your app isn’t running, the system launches your app in the background so that it can process the notification. To send a PushKit notification, your provider server must set the notification’s topic to the appropriate target, such as your app’s complication. For more information about registering for PushKit notifications, see PushKit.\n\nSee Also\nNotification responses\nclass UNNotificationResponse\nThe user’s response to an actionable notification.\nclass UNTextInputNotificationResponse\nThe user’s response to an actionable notification, including any custom text that the user typed or dictated."
  },
  {
    "title": "UNLocationNotificationTrigger",
    "url": "https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger",
    "html": "Overview\n\nCreate a UNLocationNotificationTrigger object when you want to schedule the delivery of a local notification when the device enters or leaves a specific geographic region. The system limits the number of location-based triggers that it schedules at the same time.\n\nImportant\n\nBefore scheduling any notifications using this trigger, your app must have authorization to use Core Location and must have when-in-use permissions. (Because the system actually monitors the regions, you don’t need to request always permissions for your app). For information about how to request authorization, see Requesting authorization to use location services.\n\nWhen configuring the region, use the notifyOnEntry and notifyOnExit properties to specify whether you want the system to deliver notifications on entry, on exit, or both. Listing 1 shows the creation of a trigger that fires only once when the user’s device enters a circular region with a 2-kilometer radius.\n\nListing 1. Creating a location-based trigger\n\nSwift\nObjective-C\nlet center = CLLocationCoordinate2D(latitude: 37.335400, longitude: -122.009201)\nlet region = CLCircularRegion(center: center, radius: 2000.0, identifier: \"Headquarters\")\nregion.notifyOnEntry = true\nregion.notifyOnExit = false\nlet trigger = UNLocationNotificationTrigger(region: region, repeats: false)\n\n\nThe system doesn’t immediately trigger region-based notifications when the edge of the boundary is crossed. The system applies heuristics to ensure that the boundary crossing represents a deliberate event and isn’t the result of spurious location data. For more information about the heuristics, see Monitoring the user's proximity to geographic regions.\n\nRelationships\nInherits From\nUNNotificationTrigger\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nTriggers\nclass UNCalendarNotificationTrigger\nA trigger condition that causes a notification the system delivers at a specific date and time.\nclass UNTimeIntervalNotificationTrigger\nA trigger condition that causes the system to deliver a notification after the amount of time you specify elapses.\nclass UNPushNotificationTrigger\nA trigger condition that indicates Apple Push Notification Service (APNs) has sent the notification.\nclass UNNotificationTrigger\nThe common behavior for subclasses that trigger the delivery of a local or remote notification."
  },
  {
    "title": "UNTimeIntervalNotificationTrigger",
    "url": "https://developer.apple.com/documentation/usernotifications/untimeintervalnotificationtrigger",
    "html": "Overview\n\nCreate a UNTimeIntervalNotificationTrigger object when you want to schedule the delivery of a local notification after the number of seconds you specify elapses. You use this type of trigger to implement timers.\n\nListing 1 creates a trigger that delivers its notification one time after 30 minutes have elapsed.\n\nListing 1. Creating a trigger that fires in 30 minutes\n\nSwift\nObjective-C\n// Fire in 30 minutes (60 seconds times 30)\nlet trigger = UNTimeIntervalNotificationTrigger(timeInterval: (30*60), repeats: false)\n\nTopics\nCreating a Time Interval Trigger\nconvenience init(timeInterval: TimeInterval, repeats: Bool)\nCreates a time interval trigger using the time value parameter.\nGetting the Trigger Information\nfunc nextTriggerDate() -> Date?\nThe next date at which the trigger conditions are met.\nvar timeInterval: TimeInterval\nThe time interval to create the trigger.\nRelationships\nInherits From\nUNNotificationTrigger\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nTriggers\nclass UNCalendarNotificationTrigger\nA trigger condition that causes a notification the system delivers at a specific date and time.\nclass UNLocationNotificationTrigger\nA trigger condition that causes the system to deliver a notification when the user’s device enters or exits a geographic region you specify.\nclass UNPushNotificationTrigger\nA trigger condition that indicates Apple Push Notification Service (APNs) has sent the notification.\nclass UNNotificationTrigger\nThe common behavior for subclasses that trigger the delivery of a local or remote notification."
  },
  {
    "title": "UNNotificationSoundName",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsoundname",
    "html": "Topics\nInitializers\ninit(String)\nCreates a notification sound name using the string parameter.\ninit(rawValue: String)\nCreates a notification sound name using the string parameter.\nDefault Implementations\nEquatable Implementations\n_SwiftNewtypeWrapper Implementations\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nNotification content\nImplementing communication notifications\nConfigure and display your app’s communication notifications by using intents.\nprotocol UNNotificationContentProviding\nA protocol the system uses to provide context relevant to user notifications.\nclass UNNotificationActionIcon\nAn icon associated with an action.\nclass UNMutableNotificationContent\nThe editable content for a notification.\nclass UNNotificationContent\nThe uneditable content of a notification.\nclass UNNotificationAttachment\nA media file associated with a notification.\nclass UNNotificationSound\nThe sound played upon delivery of a notification."
  },
  {
    "title": "UNNotificationSound",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsound",
    "html": "Overview\n\nCreate a UNNotificationSound object when you want the system to play a specific sound when it delivers with your notification. To play the default system sound, create your sound object using the default method. If you want to play a custom sound, create a new sound object and specify the name of the audio file that you want to play.\n\nFor local notifications, assign the sound object to the sound property of your UNMutableNotificationContent object. For a remote notification, assign the name of your sound file to the sound key in the aps dictionary. You can also use a notification service app extension to add a sound file to a notification shortly before delivery. In your extension, create a UNNotificationSound object and add it to your notification content in the same way that you’d for a local notification.\n\nAudio files must already be on the user’s device before the system can play them. If you use a predefined set of sounds for your notifications, include the audio files in your app’s bundle. For all other sounds, the UNNotificationSound object looks only in the following locations:\n\nThe /Library/Sounds directory of the app’s container directory.\n\nThe /Library/Sounds directory of one of the app’s shared group container directories.\n\nThe main bundle of the current executable.\n\nPrepare Sound Resources\n\nThe system sound facility plays custom alert sounds, so they must be in one of the following audio data formats:\n\nLinear PCM\n\nMA4 (IMA/ADPCM)\n\nµLaw\n\naLaw\n\nYou can package the audio data in an aiff, wav, or caf file. Sound files must be less than 30 seconds in length. If the sound file is longer than 30 seconds, the system plays the default sound instead.\n\nYou can use the afconvert command-line tool to convert sounds. For example, to convert the system sound Submarine.aiff to IMA4 audio in a CAF file, use the following command in Terminal:\n\nafconvert /System/Library/Sounds/Submarine.aiff ~/Desktop/sub.caf -d ima4 -f caff -v\n\nTopics\nCreating Notification Sounds\nclass var `default`: UNNotificationSound\nReturns an object representing the default sound for notifications.\nconvenience init(named: UNNotificationSoundName)\nCreates a sound object that represents a custom sound file.\nGetting Critical Sounds\nclass var defaultCritical: UNNotificationSound\nThe default sound used for critical alerts.\nclass func defaultCriticalSound(withAudioVolume: Float) -> Self\nCreates a sound object that plays the default critical alert sound at the volume you specify.\nclass func criticalSoundNamed(UNNotificationSoundName) -> Self\nCreates a custom sound object for critical alerts.\nclass func criticalSoundNamed(UNNotificationSoundName, withAudioVolume: Float) -> Self\nCreates a custom sound object for critical alerts with the volume you specify.\nType Properties\nclass var defaultRingtone: UNNotificationSound\nType Methods\nclass func ringtoneSoundNamed(UNNotificationSoundName) -> Self\nInitializers\ninit?(coder: NSCoder)\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification content\nImplementing communication notifications\nConfigure and display your app’s communication notifications by using intents.\nprotocol UNNotificationContentProviding\nA protocol the system uses to provide context relevant to user notifications.\nclass UNNotificationActionIcon\nAn icon associated with an action.\nclass UNMutableNotificationContent\nThe editable content for a notification.\nclass UNNotificationContent\nThe uneditable content of a notification.\nclass UNNotificationAttachment\nA media file associated with a notification.\nstruct UNNotificationSoundName\nA string providing the name of a sound file."
  },
  {
    "title": "UNNotificationContent",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontent",
    "html": "Overview\n\nA UNNotificationContent object contains the data associated with a notification. When your app receives a notification, the associated UNNotificationRequest object contains an object of this type with the content that your app received. Use the content object to get the details of the notification, including the type of notification that the system delivered, any custom data you stored in the userInfo dictionary before scheduling the notification, and any attachments.\n\nDon’t create instances of this class directly. For remote notifications, the system derives the contents of this object from the JSON payload that your server sends to the APNS server. For local notifications, create a UNMutableNotificationContent object, and configure the contents of that object instead.\n\nTopics\nAccessing the primary content\nvar title: String\nThe localized text that provides the notification’s primary description.\nvar subtitle: String\nThe localized text that provides the notification’s secondary description.\nvar body: String\nThe localized text that provides the notification’s main content.\nAccessing supplementary content\nvar attachments: [UNNotificationAttachment]\nThe visual and audio attachments to display alongside the notification’s main content.\nvar userInfo: [AnyHashable : Any]\nThe custom data to associate with the notification.\nReading app configuration\nvar launchImageName: String\nThe name of the image or storyboard to use when your app launches because of the notification.\nvar badge: NSNumber?\nThe number that your app’s icon displays.\nvar targetContentIdentifier: String?\nThe value your app uses to determine which scene to display to handle the notification.\nReading system configuration\nvar sound: UNNotificationSound?\nThe sound that plays when the system delivers the notification.\nvar interruptionLevel: UNNotificationInterruptionLevel\nThe notification’s importance and required delivery timing.\nenum UNNotificationInterruptionLevel\nConstants that indicate the importance and delivery timing of a notification.\nvar relevanceScore: Double\nThe score the system uses to determine if the notification is the summary’s featured notification.\nvar filterCriteria: String?\nThe criteria the system evaluates to determine if it displays the notification in the current Focus.\nRetrieving group information\nvar threadIdentifier: String\nThe identifier that groups related notifications.\nvar categoryIdentifier: String\nThe identifier of the notification’s category.\nvar summaryArgument: String\nThe text the system adds to the notification summary to provide additional context.\nvar summaryArgumentCount: Int\nThe number the system adds to the notification summary when the notification represents multiple items.\nUpdating the notification’s content\nfunc updating(from: any UNNotificationContentProviding) throws -> UNNotificationContent\nReturns a copy of the notification that includes content from the specified provider.\nInitializers\ninit?(coder: NSCoder)\nRelationships\nInherits From\nNSObject\nInherited By\nUNMutableNotificationContent\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSMutableCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification content\nImplementing communication notifications\nConfigure and display your app’s communication notifications by using intents.\nprotocol UNNotificationContentProviding\nA protocol the system uses to provide context relevant to user notifications.\nclass UNNotificationActionIcon\nAn icon associated with an action.\nclass UNMutableNotificationContent\nThe editable content for a notification.\nclass UNNotificationAttachment\nA media file associated with a notification.\nclass UNNotificationSound\nThe sound played upon delivery of a notification.\nstruct UNNotificationSoundName\nA string providing the name of a sound file."
  },
  {
    "title": "UNNotificationAttachment",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationattachment",
    "html": "Overview\n\nCreate a UNNotificationAttachment object when you want to include audio, image, or video content together in an alert-based notification. When creating the UNNotificationAttachment object, the file you specify must be on disk, and the file format must be one of the supported types.\n\nYou’re responsible for supplying attachments before the system displays your notification’s alert. For local notifications, add attachments when creating the notification’s content. For remote notifications, use a notification service app extension to download the attached files and then add them to the notification’s content before delivery.\n\nThe system validates attachments before displaying the associated notification. If you attach a file to a local notification request that’s corrupted, invalid, or of an unsupported file type, the system doesn’t schedule your request. For remote notifications, the system validates attachments after your notification service app extension finishes. Once validated, the system moves the attached files into the attachment data store so that the appropriate processes can access the files. The system copies attachments located inside an app’s bundle.\n\nSupported File Types\n\nTable 1 lists the types of files you can include as an attachment and the supported file formats. The table also lists the maximum size allowed for attachments of each type. An image file may contain a static image or an animated image sequence.\n\nTable 1. Supported attachment file types\n\nAttachment\n\n\t\n\nSupported file types\n\n\t\n\nMaximum size\n\n\n\n\nAudio\n\n\t\n\nkUTTypeAudioInterchangeFileFormat\nkUTTypeWaveformAudio\nkUTTypeMP3\nkUTTypeMPEG4Audio\n\n\t\n\n5 MB\n\n\n\n\nImage\n\n\t\n\nkUTTypeJPEG\nkUTTypeGIF\nkUTTypePNG\n\n\t\n\n10 MB\n\n\n\n\nMovie\n\n\t\n\nkUTTypeMPEG\nkUTTypeMPEG2Video\nkUTTypeMPEG4\nkUTTypeAVIMovie\n\n\t\n\n50 MB\n\nWhen creating an attachment, you can specify optional details about how to present the thumbnail image for the image or movie. Use the UNNotificationAttachmentOptionsThumbnailClippingRectKey option to use only the specified portion of an image as a thumbnail. For animated images and movies, use the UNNotificationAttachmentOptionsThumbnailTimeKey option to select which frame to use for the thumbnail image.\n\nThe system limits the amount of storage space allocated for attachments for each app. To delete attachments, use the methods of the UNUserNotificationCenter class to remove the notification requests that contain those attachments.\n\nTopics\nCreating an Attachment\nconvenience init(identifier: String, url: URL, options: [AnyHashable : Any]?) throws\nCreates an attachment object from the specified file and options.\nlet UNNotificationAttachmentOptionsTypeHintKey: String\nA hint about an attachment’s file type.\nlet UNNotificationAttachmentOptionsThumbnailHiddenKey: String\nA Boolean value indicating whether the system hides the attachment’s thumbnail.\nlet UNNotificationAttachmentOptionsThumbnailClippingRectKey: String\nThe clipping rectangle for a thumbnail image.\nlet UNNotificationAttachmentOptionsThumbnailTimeKey: String\nThe frame number of an animation to use as a thumbnail image.\nGetting the Attachment Contents\nvar identifier: String\nThe unique identifier for the attachment.\nvar url: URL\nThe URL of the file for this attachment.\nvar type: String\nThe UTI type of the attachment.\nInitializers\ninit?(coder: NSCoder)\nconvenience init(identifier: String, URL: URL, options: [AnyHashable : Any]?) throws\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification content\nImplementing communication notifications\nConfigure and display your app’s communication notifications by using intents.\nprotocol UNNotificationContentProviding\nA protocol the system uses to provide context relevant to user notifications.\nclass UNNotificationActionIcon\nAn icon associated with an action.\nclass UNMutableNotificationContent\nThe editable content for a notification.\nclass UNNotificationContent\nThe uneditable content of a notification.\nclass UNNotificationSound\nThe sound played upon delivery of a notification.\nstruct UNNotificationSoundName\nA string providing the name of a sound file."
  },
  {
    "title": "UNMutableNotificationContent",
    "url": "https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent",
    "html": "Overview\n\nCreate a UNMutableNotificationContent object when you want to specify the payload for a local notification. Specifically, use this object to specify the title and message for an alert, the sound to play, or the value to assign to your app’s badge. You might also provide details about how the system handles the notification. For example, you can specify a custom launch image and a thread identifier for visually grouping related notifications.\n\nAfter creating your content object, assign it to a UNNotificationRequest object, add a trigger condition, and schedule your notification. The trigger condition defines when the system delivers the notification to the user. Listing 1 shows the scheduling of a local notification that displays an alert and plays a sound after a delay of five seconds. Store the strings for the alert’s title and body in the app’s Localizable.strings file.\n\nListing 1. Creating the content for a local notification\n\nSwift\nObjective-C\n// Configure the notification's payload.\nlet content = UNMutableNotificationContent()\ncontent.title = NSString.localizedUserNotificationStringForKey(\"Hello!\", arguments: nil)\ncontent.body = NSString.localizedUserNotificationStringForKey(\"Hello_message_body\", arguments: nil)\ncontent.sound = UNNotificationSound.default()\n \n// Deliver the notification in five seconds.\nlet trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)\nlet request = UNNotificationRequest(identifier: \"FiveSecond\", content: content, trigger: trigger) // Schedule the notification.\nlet center = UNUserNotificationCenter.current()\ncenter.add(request) { (error : Error?) in\n     if let theError = error {\n         // Handle any errors\n     }\n}\n\n\nNote\n\nLocal notifications always result in user interactions, and the system ignores any interactions for which your app isn’t authorized. For information about how to request authorization for user interactions, see Asking permission to use notifications.\n\nLocalizing the Alert Strings\n\nLocalize the strings you display in a notification alert for the current user. Although you can use the NSLocalizedString macros to load strings from your app’s resource files, a better option is to specify your string using the localizedUserNotificationString(forKey:arguments:) method of NSString. The localizedUserNotificationString(forKey:arguments:) method delays the loading of the localized string until the system delivers the notification. If the user changes the language setting before the system delivers a notification, the system updates the alert text to the user’s current language instead of the language in use when the system scheduled the notification.\n\nTopics\nProviding the primary content\nvar title: String\nThe localized text that provides the notification’s primary description.\nvar subtitle: String\nThe localized text that provides the notification’s secondary description.\nvar body: String\nThe localized text that provides the notification’s main content.\nProviding supplementary content\nvar attachments: [UNNotificationAttachment]\nThe visual and audio attachments to display alongside the notification’s main content.\nvar userInfo: [AnyHashable : Any]\nThe custom data to associate with the notification.\nConfiguring app behavior\nvar launchImageName: String\nThe name of the image or storyboard to use when your app launches because of the notification.\nvar badge: NSNumber?\nThe number that your app’s icon displays.\nvar targetContentIdentifier: String?\nThe value your app uses to determine which scene to display to handle the notification.\nIntegrating with the system\nvar sound: UNNotificationSound?\nThe sound that plays when the system delivers the notification.\nvar interruptionLevel: UNNotificationInterruptionLevel\nThe notification’s importance and required delivery timing.\nenum UNNotificationInterruptionLevel\nConstants that indicate the importance and delivery timing of a notification.\nvar relevanceScore: Double\nThe score the system uses to determine if the notification is the summary’s featured notification.\nvar filterCriteria: String?\nThe criteria the system evaluates to determine if it displays the notification in the current Focus.\nGrouping notifications\nvar threadIdentifier: String\nThe identifier that groups related notifications.\nvar categoryIdentifier: String\nThe identifier of the notification’s category.\nvar summaryArgument: String\nThe text the system adds to the notification summary to provide additional context.\nvar summaryArgumentCount: Int\nThe number the system adds to the notification summary when the notification represents multiple items.\nRelationships\nInherits From\nUNNotificationContent\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSMutableCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification content\nImplementing communication notifications\nConfigure and display your app’s communication notifications by using intents.\nprotocol UNNotificationContentProviding\nA protocol the system uses to provide context relevant to user notifications.\nclass UNNotificationActionIcon\nAn icon associated with an action.\nclass UNNotificationContent\nThe uneditable content of a notification.\nclass UNNotificationAttachment\nA media file associated with a notification.\nclass UNNotificationSound\nThe sound played upon delivery of a notification.\nstruct UNNotificationSoundName\nA string providing the name of a sound file."
  },
  {
    "title": "UNNotificationActionIcon",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationactionicon",
    "html": "Topics\nEssentials\nconvenience init(systemImageName: String)\nCreates an action icon by using a system symbol image.\nconvenience init(templateImageName: String)\nCreates an action icon based on an image in your app’s bundle, preferably in an asset catalog.\nInitializers\ninit?(coder: NSCoder)\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification content\nImplementing communication notifications\nConfigure and display your app’s communication notifications by using intents.\nprotocol UNNotificationContentProviding\nA protocol the system uses to provide context relevant to user notifications.\nclass UNMutableNotificationContent\nThe editable content for a notification.\nclass UNNotificationContent\nThe uneditable content of a notification.\nclass UNNotificationAttachment\nA media file associated with a notification.\nclass UNNotificationSound\nThe sound played upon delivery of a notification.\nstruct UNNotificationSoundName\nA string providing the name of a sound file."
  },
  {
    "title": "UNNotificationContentProviding",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationcontentproviding",
    "html": "Overview\n\nThe system allows only objects in the Apple SDK that conform to UNNotificationContentProviding. The system ignores objects outside of the Apple SDK that your app conforms to UNNotificationContentProviding.\n\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nNotification content\nImplementing communication notifications\nConfigure and display your app’s communication notifications by using intents.\nclass UNNotificationActionIcon\nAn icon associated with an action.\nclass UNMutableNotificationContent\nThe editable content for a notification.\nclass UNNotificationContent\nThe uneditable content of a notification.\nclass UNNotificationAttachment\nA media file associated with a notification.\nclass UNNotificationSound\nThe sound played upon delivery of a notification.\nstruct UNNotificationSoundName\nA string providing the name of a sound file."
  },
  {
    "title": "Implementing communication notifications",
    "url": "https://developer.apple.com/documentation/usernotifications/implementing-communication-notifications",
    "html": "Overview\n\nCommunication notifications provide a rich experience for direct communications. These notifications have a distinct user experience that features prominent avatars and group names. Communication notifications are unique in their ability to break through the scheduled notification summary by default, and can also break through a Focus.\n\nEnable the Communication Notifications capability in your app and include the activity types that your app supports in its NSUserActivityTypes array. Your app initializes relevant participants of the communication, configures an intent object that describes the communication taking place, and then donates the interaction. Siri uses these donations to refine suggestions given to the user. After your app donates the interaction, your app updates the incoming notification’s content and displays a communication notification. To learn more about SiriKit interaction donations, see Donating Shortcuts.\n\nEnable communication notifications\n\nEnable the Communication Notifications capability in your app target before you implement communication notifications. To learn more about enabling capabilities, see Adding capabilities to your app. Add the class name of each intent that your app supports to the NSUserActivityTypes array in your Info.plist. To support INSendMessageIntent donations, for example, ensure the NSUserActivityTypes array includes the string INSendMessageIntent.\n\nOnce you enable the Communications Notifications capability, begin updating the content of notifications that your app receives so it can display communication notifications. Implement this functionality wherever your app can receive notifications, including your app’s Notification Service Extension (NSE), which you use to modify the content of incoming notifications when your app is in the background. For more information about handling notifications in the background, refer to Modifying content in newly delivered notifications.\n\nIdentify the participants\n\nYou must include relevant participants in communication notifications to ensure correct display and breakthrough behavior. Create an INPerson object for each relevant participant of a communication when your app receives a communication notification. The current user is always a recipient of an incoming communication notification. Don’t include the current user as a participant of the communication for your app’s intent donations.\n\nIf a person in your app matches a contact in address book, provide the contact identifier when initializing the INPerson object. If your app has access to a person’s email address or phone number, provide a person handle type of INPersonHandleType.emailAddress or INPersonHandleType.phoneNumber respectively, and also specify the person’s suggestion type as INPersonSuggestionType.none. Providing both of these types ensures an exact match for the corresponding email address or phone number in the user’s contacts.\n\nIf the information necessary to ensure an exact match isn’t available, create an INPersonHandle specific to your app. Set the person’s INPersonSuggestionType to whichever type it most closely resembles, which provides a contact suggestion to the user if a matching contact isn’t found.\n\nConfigure a message intent\n\nWhen the user receives a message, you create an INSendMessageIntent. An INSendMessageIntent has a single sender and one or more recipients. For incoming communication notification donations, the system includes the current user as a recipient in addition to those your app provides in the recipients array. Provide a unique conversationIdentifier that represents the conversation. Use the same identifier for each message that the user receives in the same conversation. This is especially important for group conversations where the group name and membership can change for each message.\n\nThe example below represents a direct message. There are no recipients other than the current user in this case. The image of the sender becomes the avatar for the notification.\n\n// Initialize only the sender for a one-to-one message intent.\nlet handle = INPersonHandle(value: \"unique-user-id-1\", type: .unknown)\nlet avatar = INImage(named: \"profilepicture.png\")\nlet sender = INPerson(personHandle: handle,\n                      nameComponents: nil,\n                      displayName: \"Example\",\n                      image: avatar,\n                      contactIdentifier: nil,\n                      customIdentifier: nil)\n\n\n// Because this communication is incoming, you can infer that the current user is\n// a recipient. Don't include the current user when initializing the intent.\nlet intent = INSendMessageIntent(recipients: nil,\n                                 outgoingMessageType: .outgoingMessageText,\n                                 content: \"Message content\",\n                                 speakableGroupName: nil,\n                                 conversationIdentifier: \"unique-conversation-id-1\",\n                                 serviceName: nil,\n                                 sender: sender,\n                                 attachments: nil)\n\n\nFor group message intents, provide an array that contains the other participants of the message for the recipients parameter. For example, in a group of three participants that includes the current user, the sender of the message and the current user are already represented. The recipients array contains one object — the other recipient. Group conversations can also provide a speakableGroupName if the conversation has a name. The notification shows a summary of the recipients if your app doesn’t provide one. Call setImage:forParameterNamed: on the intent using the speakableGroupName parameter to provide an avatar for a group message. Set the avatar image prior to donating the interaction.\n\nConfigure a call intent\n\nWhen the user receives an incoming call, you create an INStartCallIntent. An INStartCallIntent has an array of one or more contacts that are participants of the call. For incoming communication notification donations, the system includes the current user as a recipient in addition to those added to the contacts array. Provide the most accurate additional information available about the call, including a callback record to use in the event of a missed call. The example below represents a call between caller and the current user. The caller’s image becomes the avatar for the notification.\n\n// Initialize only the caller for a one-to-one call intent.\nlet handle = INPersonHandle(value: \"unique-user-id-1\", type: .unknown)\nlet avatar = INImage(named: \"profilepicture.png\")\nlet caller = INPerson(personHandle: handle,\n                      nameComponents: nil,\n                      displayName: \"Example\",\n                      image: avatar,\n                      contactIdentifier: nil,\n                      customIdentifier: nil)\n\n\n// Include the other participants of the call in the contacts array.\n// Because this communication is incoming, you can infer that the current user is\n// a participant of the call. Don't include the user in the contacts array.\nlet intent = INStartCallIntent(callRecordFilter: nil,\n                               callRecordToCallBack: callRecordToCallBack,\n                               audioRoute: .bluetoothAudioRoute,\n                               destinationType: .normal,\n                               contacts: [caller],\n                               callCapability: .audioCall)\n\n\nFor group call intents, add the other participants to the contacts parameter array. In a group of three participants that includes the current user, for example, only include the caller and the third participant in the contacts array. Call setImage:forParameterNamed: on the intent using the callRecordToCallBack parameter to provide an avatar for a group call. Set the avatar image prior to donating the interaction.\n\nDonate an interaction and update the notification\n\nAfter you configure a communication intent, donate an interaction for the intent. Initialize an INInteraction object from the previously configured message or call intent. Set the interaction’s direction to INInteractionDirection.incoming. This indicates the user is the recipient of an interaction — the incoming communication. Call donate(completion:) on the interaction and handle errors that may occur in its completion handler.\n\nIf the donation completes successfully, update the content of a received notification to display a communication notification. Call updating(from:) on the received notification content. Use the updated notification content to display a communication notification. In the example below, the handling of this process happens in an NSE. Call the contentHandler with the updated notification content to display a communication notification before returning from the didReceive(_:withContentHandler:) method.\n\nfunc didReceive(_ request: UNNotificationRequest,\n                withContentHandler contentHandler:\n                @escaping (UNNotificationContent) -> Void) async {\n\n\n    // Create an intent as shown in previous code listings.\n    // For an incoming message, refer to the first code listing.\n    // For an incoming call, refer to the second code listing.\n    let intent: INSendMessageIntent = sendMessageIntent()\n\n\n    // Use the intent to initialize the interaction.\n    let interaction = INInteraction(intent: intent, response: nil)\n\n\n    // Interaction direction is incoming because the user is\n    // receiving this message.\n    interaction.direction = .incoming\n\n\n    // Donate the interaction before updating notification content.\n    do {\n        try await interaction.donate()\n    } catch {\n        // Handle errors that may occur during donation.\n        return\n    }\n        \n    // After donation, update the notification content.\n    let content = request.content\n    \n    do {\n        // Update notification content before displaying the\n        // communication notification.\n        let updatedContent = try content.updating(from: intent)\n        \n        // Call the content handler with the updated content\n        // to display the communication notification.\n        contentHandler(updatedContent)\n        \n    } catch {\n        // Handle errors that may occur while updating content.\n    }\n}\n\nDonate outgoing interactions\n\nOutgoing interactions are important to enable proper breakthrough behavior. An outgoing interaction represents a decision or action that the user initiates. Siri uses outgoing intent donations to refine suggestions to the user in a variety of ways, including Share Sheet recommendations and contact suggestions.\n\nInitializing an outgoing interaction is similar to initializing an incoming interaction. Set the direction of an outgoing interaction to INInteractionDirection.outgoing prior to donating. The process to donate an outgoing INStartCallIntent interaction is identical to the process to donate incoming interactions. When donating an outgoing INSendMessageIntent interaction, however, the current user becomes the sender. Therefore, leave the sender parameter of an outgoing INSendMessageIntent nil, and provide the recipients of the message, and any other metadata available.\n\nAdditional donation metadata\n\nYou can provide optional donation metadata for message intent donations in the form of INSendMessageIntentDonationMetadata objects. This additional metadata changes the behavior of the interaction donation.\n\nYou can manually specify the recipient count and initialize a partial list of relevant recipients when the full list of INSendMessageIntent recipients is prohibitively large. Supply an INSendMessageIntentDonationMetadata object to the intent and specify the full recipientCount. This recipient count overrides the count of the recipients array on the intent. You must either provide the full recipient list to the intent, or instead provide an accurate recipient count on the intent’s donation metadata.\n\nYou can also use a donation metadata object when the user receives messages that explicity mention that user, or reply messages to previous conversations. Use a donation metadata object to specify this behavior. Set mentionsCurrentUser and isReplyToCurrentUser to enable these behaviors, respectively, on the communication notification.\n\nSomeone can choose to notify a user even when the other user has Focus enabled. Your app requires authorization to access the user’s Focus status for this functionality to work.\n\nRequest authorization by calling requestAuthorization(completionHandler:) on the default INFocusStatusCenter instance.\n\nEnsure the user has authorized your app before continuing.\n\nSet notifyRecipientAnyway on the donation metadata object when the notification should break through Focus and interrupt them.\n\nReserve this functionality for instances where the sender has explicitly chosen to notify the user anyway. Users only expect an interruption like this after they’ve received a communication notification for a message that Focus silenced on their behalf.\n\nSee Also\nNotification content\nprotocol UNNotificationContentProviding\nA protocol the system uses to provide context relevant to user notifications.\nclass UNNotificationActionIcon\nAn icon associated with an action.\nclass UNMutableNotificationContent\nThe editable content for a notification.\nclass UNNotificationContent\nThe uneditable content of a notification.\nclass UNNotificationAttachment\nA media file associated with a notification.\nclass UNNotificationSound\nThe sound played upon delivery of a notification.\nstruct UNNotificationSoundName\nA string providing the name of a sound file."
  },
  {
    "title": "Scheduling a notification locally from your app",
    "url": "https://developer.apple.com/documentation/usernotifications/scheduling-a-notification-locally-from-your-app",
    "html": "Overview\n\nUse local notifications to get the user’s attention. You can display an alert, play a sound, or badge your app’s icon. For example, a background app could ask the system to display an alert when your app finishes a particular task. Always use local notifications to convey important information that the user wants.\n\nThe system handles delivery of notifications based on a time or location that you specify. If the delivery of the notification occurs when your app isn’t running or in the background, the system interacts with the user for you. If your app is in the foreground, the system delivers the notification to your app for handling.\n\nCreate the notification’s content\n\nFill in the properties of a UNMutableNotificationContent object with the details of your notification. The fields you fill in define how the system delivers your notification. For example, to play a sound, assign a value to the sound property of the object. Listing 1 shows a content object that displays an alert containing a title string and body text. You can specify multiple types of interaction in the same request.\n\nListing 1. Configuring the notification content\n\nlet content = UNMutableNotificationContent()\ncontent.title = \"Weekly Staff Meeting\"\ncontent.body = \"Every Tuesday at 2pm\"\n\nSpecify the conditions for delivery\n\nSpecify the conditions for delivering your notification using a UNCalendarNotificationTrigger, UNTimeIntervalNotificationTrigger, or UNLocationNotificationTrigger object. Each trigger object requires different parameters. For example, a calendar-based trigger requires you to specify the date and time of delivery.\n\nListing 2 shows you how to configure a notification for the system to deliver every Tuesday at 2pm. The DateComponents structure specifies the timing for the event. Configuring the trigger with the repeats parameter set to true causes the system to reschedule the event after its delivery.\n\nListing 2. Configuring a recurring date-based trigger\n\n// Configure the recurring date.\nvar dateComponents = DateComponents()\ndateComponents.calendar = Calendar.current\n\n\ndateComponents.weekday = 3  // Tuesday\ndateComponents.hour = 14    // 14:00 hours\n   \n// Create the trigger as a repeating event.    \nlet trigger = UNCalendarNotificationTrigger(\n         dateMatching: dateComponents, repeats: true)\n\nCreate and register a notification request\n\nCreate a UNNotificationRequest object that includes your content and trigger conditions, and call the (add(_:withCompletionHandler:) method to schedule your request with the system. Listing 1 shows an example that uses the content from Listing 1 and Listing 2 to fill in the request object.\n\nListing 1. Registering the notification request\n\nlet uuidString = UUID().uuidString\nlet request = UNNotificationRequest(identifier: uuidString, content: content, trigger: trigger)\n\n\n// Schedule the request with the system.\nlet notificationCenter = UNUserNotificationCenter.current()\ndo {\n    try await notificationCenter.add(request)\n} catch {\n    // Handle errors that may occur during add.\n}\n\nCancel a scheduled notification request\n\nOnce scheduled, a notification request remains active until its trigger condition is met, or you explicitly cancel it. Typically, you cancel a request when conditions change and you no longer need to notify the user. For example, if the user completes a reminder, you’d cancel any active requests associated with that reminder. To cancel an active notification request, call the removePendingNotificationRequests(withIdentifiers:) method of UNUserNotificationCenter.\n\nTopics\nRelated Topics\nHandling notifications and notification-related actions\nRespond to user interactions with the system’s notification interfaces, including handling your app’s custom actions.\nSee Also\nNotification requests\nclass UNNotificationRequest\nA request to schedule a local notification, which includes the content of the notification and the trigger conditions for delivery.\nclass UNNotification\nThe data for a local or remote notification the system delivers to your app."
  },
  {
    "title": "Sending push notifications using command-line tools",
    "url": "https://developer.apple.com/documentation/usernotifications/sending-push-notifications-using-command-line-tools",
    "html": "Overview\n\nTesting your APNs connection and configuration by writing a test app can be effort intensive and time consuming. The command-line tools described below provide a quick way to test your setup with APNs in a nonproduction-quality test suite or app.\n\nBefore you begin, verify that:\n\nYour target device is unlocked and connected to the internet.\n\nYour app is open and in the foreground.\n\nSend a Push Notification Using a Certificate\n\nWhat you’ll need:\n\nA DER-encoded certificate from WWDR to connect to the APNs sandbox. For details on how to set up certificate-based trust with APNs, see Establishing a certificate-based connection to APNs.\n\nThe PEM-encoded private key, without a password, used to generate the above certificate. The Keychain app generates the private key when you create a certificate signing request (CSR). To learn more, see Create a certificate signing request.\n\nYour App ID. To learn more about App IDs, see Register an App ID.\n\nThe device token from your app, as a hexadecimal-encoded ASCII string. To learn more about device tokens, see Registering your app with APNs.\n\nStart by launching the Terminal app in the most recent macOS version. Then set these shell variables:\n\nCERTIFICATE_FILE_NAME=path to the certificate file\nCERTIFICATE_KEY_FILE_NAME=path to the private key file\nTOPIC=App ID\nDEVICE_TOKEN=device token for your app\nAPNS_HOST_NAME=api.sandbox.push.apple.com\n\n\nTest that you can use your certificate to connect to APNs using this command:\n\n% openssl s_client -connect \"${APNS_HOST_NAME}\":443 -cert \"${CERTIFICATE_FILE_NAME}\" -certform DER -key \"${CERTIFICATE_KEY_FILE_NAME}\" -keyform PEM\n\n\nThen send a push notification using this command:\n\n% curl -v --header \"apns-topic: ${TOPIC}\" --header \"apns-push-type: alert\" --cert \"${CERTIFICATE_FILE_NAME}\" --cert-type DER --key \"${CERTIFICATE_KEY_FILE_NAME}\" --key-type PEM --data '{\"aps\":{\"alert\":\"test\"}}' --http2  https://${APNS_HOST_NAME}/3/device/${DEVICE_TOKEN}\n\n\nThe result is an HTTP status of 200 (request succeeded). A notification with the text “test” appears on your destination device.``\n\nSend a Push Notification Using a Token\n\nWhat you’ll need:\n\nYour Team ID. For more information, see Locate your Team ID.\n\nYour key identifier for APNs. For more information, see Get a key identifier.\n\nThe PEM-encoded private key, without a password, associated with the above key identifier. To learn more about downloading keys, see Revoke, edit, and download keys.\n\nYour App ID. To learn more about App IDs, see Register an App ID.\n\nThe device token from your app, as a hexadecimal-encoded ASCII string. To learn more about device tokens, see Registering your app with APNs.\n\nStart by launching the Terminal app in the most recent macOS version. Then set these shell variables:\n\nTEAM_ID=Team ID\nTOKEN_KEY_FILE_NAME=path to the private key file\nAUTH_KEY_ID=your key identifier\nTOPIC=App ID\nDEVICE_TOKEN=device token for your app\nAPNS_HOST_NAME=api.sandbox.push.apple.com\n\n\nTest that you can connect to APNs using this command:\n\n% openssl s_client -connect \"${APNS_HOST_NAME}\":443\n\n\nSet these additional shell variables just before sending a push notification:\n\nJWT_ISSUE_TIME=$(date +%s)\nJWT_HEADER=$(printf '{ \"alg\": \"ES256\", \"kid\": \"%s\" }' \"${AUTH_KEY_ID}\" | openssl base64 -e -A | tr -- '+/' '-_' | tr -d =)\nJWT_CLAIMS=$(printf '{ \"iss\": \"%s\", \"iat\": %d }' \"${TEAM_ID}\" \"${JWT_ISSUE_TIME}\" | openssl base64 -e -A | tr -- '+/' '-_' | tr -d =)\nJWT_HEADER_CLAIMS=\"${JWT_HEADER}.${JWT_CLAIMS}\"\nJWT_SIGNED_HEADER_CLAIMS=$(printf \"${JWT_HEADER_CLAIMS}\" | openssl dgst -binary -sha256 -sign \"${TOKEN_KEY_FILE_NAME}\" | openssl base64 -e -A | tr -- '+/' '-_' | tr -d =)\nAUTHENTICATION_TOKEN=\"${JWT_HEADER}.${JWT_CLAIMS}.${JWT_SIGNED_HEADER_CLAIMS}\"\n\n\nSend the push notification using this command:\n\n% curl -v --header \"apns-topic: $TOPIC\" --header \"apns-push-type: alert\" --header \"authorization: bearer $AUTHENTICATION_TOKEN\" --data '{\"aps\":{\"alert\":\"test\"}}' --http2 https://${APNS_HOST_NAME}/3/device/${DEVICE_TOKEN}\n\n\nThe result is an HTTP status of 200 (request succeeded). A notification with the text “test” appears on your destination device.\n\nSee Also\nRemote notifications\nSetting up a remote notification server\nGenerate notifications and push them to user devices.\nRegistering your app with APNs\nCommunicate with Apple Push Notification service (APNs) and receive a unique device token that identifies your app.\nTesting notifications using the Push Notification Console\nSend test notifications and access delivery logs to test your app’s integration with Apple Push Notification service."
  },
  {
    "title": "UNNotificationSettings",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationsettings",
    "html": "Overview\n\nA UNNotificationSettings object contains the current authorization status and notification-related settings for your app. Apps must receive authorization to schedule notifications and to interact with the user. Apps that run in CarPlay must similarly receive authorization to do so. Use this object to determine what notification-related actions your app can perform. You might then use that information to enable, disable, or adjust your app’s notification-related behaviors. Regardless of whether you take action, the system enforces your app’s settings by preventing denied interactions from occurring.\n\nYou don’t create instances of this class directly. Instead, call the getNotificationSettings(completionHandler:) method of your app’s UNUserNotificationCenter object to get the current settings.\n\nFor more information about requesting authorization for user interactions, see UNUserNotificationCenter.\n\nTopics\nGetting the Authorization Status\nvar authorizationStatus: UNAuthorizationStatus\nThe app’s ability to schedule and receive local and remote notifications.\nenum UNAuthorizationStatus\nConstants indicating whether the app is allowed to schedule notifications.\nGetting Device-Specific Settings\nvar notificationCenterSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in Notification Center.\nvar lockScreenSetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear on a device’s Lock screen.\nvar carPlaySetting: UNNotificationSetting\nThe setting that indicates whether your app’s notifications appear in CarPlay.\nvar alertSetting: UNNotificationSetting\nThe authorization status for displaying alerts.\nvar badgeSetting: UNNotificationSetting\nThe setting that indicates whether badges appear on your app’s icon.\nvar soundSetting: UNNotificationSetting\nThe authorization status for playing sounds for incoming notifications.\nvar criticalAlertSetting: UNNotificationSetting\nThe authorization status for playing sounds for critical alerts.\nvar announcementSetting: UNNotificationSetting\nThe setting that indicates whether Siri can announce your app’s notifications.\nvar scheduledDeliverySetting: UNNotificationSetting\nThe setting that indicates the system schedules the notification.\nvar timeSensitiveSetting: UNNotificationSetting\nThe setting that indicates the system treats the notification as time-sensitive.\nenum UNNotificationSetting\nConstants that indicate the current status of a notification setting.\nGetting Interface Settings\nvar alertStyle: UNAlertStyle\nThe type of alert that the app may display when the device is unlocked.\nenum UNAlertStyle\nConstants indicating the presentation styles for alerts.\nvar showPreviewsSetting: UNShowPreviewsSetting\nThe setting that indicates whether the app shows a preview of the notification’s content.\nenum UNShowPreviewsSetting\nConstants indicating the style previewing a notification’s content.\nvar providesAppNotificationSettings: Bool\nA Boolean value indicating the system displays a button for in-app notification settings.\nInstance Properties\nvar directMessagesSetting: UNNotificationSetting\nInitializers\ninit?(coder: NSCoder)\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification management\nclass UNUserNotificationCenter\nThe central object for managing notification-related activities for your app or app extension.\nprotocol UNUserNotificationCenterDelegate\nAn interface for processing incoming notifications and responding to notification actions."
  },
  {
    "title": "Setting up a remote notification server",
    "url": "https://developer.apple.com/documentation/usernotifications/setting-up-a-remote-notification-server",
    "html": "Overview\n\nUse remote notifications (also known as push notifications) to push small amounts of data to devices that use your app, even when your app isn’t running. Apps use notifications to provide important information to users. For example, a messaging service sends remote notifications when new messages arrive.\n\nThe delivery of remote notifications involves several key components:\n\nYour company’s server, known as the provider server\n\nApple Push Notification service (APNs)\n\nThe user’s device\n\nYour app running on the user’s device\n\nRemote notifications begin with your company’s server. You decide which notifications you want to send to your users, and when to send them. When it’s time to send a notification, you generate a request that contains the notification data and a unique identifier for the user’s device. You then forward your request to APNs, which handles the delivery of the notification to the user’s device. Upon receipt of the notification, the operating system on the user’s device handles any user interactions and delivers the notification to your app.\n\nYou’re responsible for setting up a provider server (or servers) and for configuring your app to handle notifications on the user’s device. Apple manages everything in between, including the presentation of notifications to the user. You must also have an app running on the user’s device that can communicate with your server and provide necessary information. For information about how to configure your app to handle remote notifications, see Registering your app with APNs.\n\nTip\n\nIf you’re setting up a provider server to send push notifications to users in Safari and other browsers, see Sending web push notifications in web apps and browsers.\n\nBuild custom infrastructure for notifications\n\nSetting up a remote notification server consists of a few key tasks. How you implement these tasks depends on your infrastructure. Use the technologies that are appropriate for your company:\n\nWrite code to receive device tokens from instances of your app running on user devices, and to associate those tokens with your users’ accounts. See Registering your app with APNs.\n\nDetermine when to send notifications to your users, and write code to generate notification payloads. See Generating a remote notification.\n\nManage a connection to APNs using HTTP/2 and TLS. See Sending notification requests to APNs.\n\nWrite code to generate POST requests that contain your payloads, and send those requests over your HTTP/2 connection. See Sending notification requests to APNs.\n\nRegenerate your token periodically for token-based authentication. See Establishing a token-based connection to APNs.\n\nEstablish a trusted connection to APNs\n\nCommunication between your provider server and APNs must take place over a secure connection. Creating that connection requires installing the AAA Certificate Services root certificate on each of your provider servers.\n\nIf your provider server runs macOS 10.14 or later, the AAA Certificate Services root certificate is in the keychain by default. On other systems, you might need to install this certificate yourself. You can download the “AAACertificateServices 5/12/2020” certificate from the Sectigo KnowledgeBase website.\n\nTo send notifications, your provider server must establish either token-based or certificate-based trust with APNs using HTTP/2 and TLS. Both techniques have advantages and disadvantages, so decide which technique is best for your company.\n\nTo set up token-based trust with APNs, see Establishing a token-based connection to APNs.\n\nTo set up certificate-based trust with APNs, see Establishing a certificate-based connection to APNs.\n\nUnderstand what APNs provides\n\nAPNs makes every effort to deliver your notifications, and to deliver them with the best user experience:\n\nAPNs manages an accredited, encrypted, and persistent IP connection to the user’s device.\n\nAPNs can store notifications for a device that’s currently offline. APNs then forwards the stored notifications when the device comes online.\n\nIf APNs doesn’t deliver a notification immediately, either for device power considerations or because the destination is offline, it may coalesce notifications for the same bundle ID.\n\nTopics\nServer Tasks\nGenerating a remote notification\nSend notifications to the user’s device with a JSON payload.\nSending notification requests to APNs\nTransmit your remote notification payload and device token information to Apple Push Notification service (APNs).\nHandling notification responses from APNs\nRespond to the status codes that the APNs servers return.\nViewing the status of push notifications using Metrics and APNs\nMonitor and interpret the status of your push notifications with Apple Push Notification service (APNs).\nPushing background updates to your App\nDeliver notifications that wake your app and update it in the background.\nSecurity\nCreate a secure connection between your provider server and APNs.\nEstablishing a token-based connection to APNs\nSecure your communications with Apple Push Notification service (APNs) by using stateless authentication tokens.\nEstablishing a certificate-based connection to APNs\nSecure your communications with Apple Push Notification service (APNs) by installing a certificate on your provider server.\nSee Also\nRemote notifications\nRegistering your app with APNs\nCommunicate with Apple Push Notification service (APNs) and receive a unique device token that identifies your app.\nTesting notifications using the Push Notification Console\nSend test notifications and access delivery logs to test your app’s integration with Apple Push Notification service.\nSending push notifications using command-line tools\nUse basic macOS command-line tools to send push notifications to Apple Push Notification service (APNs)."
  },
  {
    "title": "Registering your app with APNs",
    "url": "https://developer.apple.com/documentation/usernotifications/registering-your-app-with-apns",
    "html": "Overview\n\nApple Push Notification service (APNs) must know the address of a user’s device before it can send notifications to that device. This address takes the form of a device token unique to both the device and your app. At launch time, your app communicates with APNs and receives its device token, which you then forward to your provider server. Your server includes that token with any notifications it sends.\n\nNote\n\nYou can’t use the same device token for more than one app, even when the apps are on the same device. Every app must request their own unique device token and forward it to your provider server.\n\nEnable the push notifications capability\n\nTo add the required entitlements to your app, enable the Push Notifications capability in your Xcode project, as shown in . Enabling this option in iOS adds the APS Environment Entitlement to the app. In macOS, it adds the APS Environment (macOS) Entitlement. See Enable push notifications in Xcode help for more information.\n\nImportant\n\nIn your developer account, enable the push notification service for the App ID assigned to your project. For more information about configuring your developer account, go to your Developer Account page.\n\nRegister your app and retrieve your app’s device token\n\nRegister your app with APNs and receive a globally unique device token, which is effectively the address of your app on the current device. Your provider server must have this token before it can deliver notifications to the device.\n\nYou register your app and receive your device token each time your app launches using Apple-provided APIs. The registration process is similar across platforms:\n\nIn iOS and tvOS, call the registerForRemoteNotifications() method of UIApplication to request the device token. Upon successful registration, you receive the token in your app delegate’s application(_:didRegisterForRemoteNotificationsWithDeviceToken:) method.\n\nIn macOS, call the registerForRemoteNotifications() method of NSApplication to request the device token. Upon successful registration, you receive the token in your app delegate’s application(_:didRegisterForRemoteNotificationsWithDeviceToken:) method.\n\nIn watchOS, call the registerForRemoteNotifications() method of WKExtension to request the device token. Upon successful registration, you receive the token in your extension delegate’s didRegisterForRemoteNotifications(withDeviceToken:) method.\n\nIn addition to handling successful registrations with APNs, prepare your app to handle unsuccessful registrations by implementing the application(_:didFailToRegisterForRemoteNotificationsWithError:) method. Registration might fail if the user’s device isn’t connected to the network, if the APNs server is unreachable for any reason, or if the app doesn’t have the proper code-signing entitlement. When a failure occurs, set a flag and try to register again at a later time.\n\nListing 1 shows a sample implementation of the iOS app delegate methods needed to register for remote notifications and receive the corresponding token. The sendDeviceTokenToServer method is a custom method that the app uses to send the data to its provider server.\n\nListing 1. Communicating with APNs at launch time\n\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions:[UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n    // Override point for customization after application launch.\n    UIApplication.shared.registerForRemoteNotifications()\n    return true\n}\n\n\nfunc application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n    self.sendDeviceTokenToServer(data: deviceToken)\n}\n\n\nfunc application(_ application: UIApplication,\n                 didFailToRegisterForRemoteNotificationsWithError\n                 error: Error) {\n    // Try again later.\n}\n\n\nImportant\n\nNever cache device tokens in local storage. APNs issues a new token when the user restores a device from a backup, when the user installs your app on a new device, and when the user reinstalls the operating system. You get an up-to-date token each time you ask the system to provide the token.\n\nForward tokens to your provider server\n\nUpon receiving a device token, open a network connection from your app to your provider server. Securely forward the device token and any other information you need to identify the specific user to your server. For example, you might include the user’s login name or something that connects them to your service. Encrypt any information you send over the network.\n\nOn your provider server, store tokens in a secure place where you can access them to send notifications. When generating notifications, your server must be able to send notifications to specific devices. So, if you have notifications linked to a user’s account, store device tokens with the user’s account information. Because a user can have multiple devices, prepare your app to handle multiple device tokens.\n\nFor information about how to send payloads and device tokens to APNs, see Sending notification requests to APNs.\n\nSee Also\nRemote notifications\nSetting up a remote notification server\nGenerate notifications and push them to user devices.\nTesting notifications using the Push Notification Console\nSend test notifications and access delivery logs to test your app’s integration with Apple Push Notification service.\nSending push notifications using command-line tools\nUse basic macOS command-line tools to send push notifications to Apple Push Notification service (APNs)."
  },
  {
    "title": "UNUserNotificationCenterDelegate",
    "url": "https://developer.apple.com/documentation/usernotifications/unusernotificationcenterdelegate",
    "html": "Overview\n\nUse the methods of the UNUserNotificationCenterDelegate protocol to handle user-selected actions from notifications, and to process notifications that arrive when your app is running in the foreground. After implementing these methods in an object, assign that object to the delegate property of the shared UNUserNotificationCenter object. The user notification center object calls the methods of your delegate at appropriate times.\n\nImportant\n\nYou must assign your delegate object to the UNUserNotificationCenter object before your app finishes launching. For example, in an iOS app, you must assign it in the application(_:willFinishLaunchingWithOptions:) or application(_:didFinishLaunchingWithOptions:) method of your app delegate. Assigning a delegate after the system calls these methods might cause you to miss incoming notifications.\n\nFor information about the shared user notification center object, see UNUserNotificationCenter.\n\nTopics\nFirst Steps\nHandling notifications and notification-related actions\nRespond to user interactions with the system’s notification interfaces, including handling your app’s custom actions.\nHandling the Selection of Custom Actions\nfunc userNotificationCenter(UNUserNotificationCenter, didReceive: UNNotificationResponse, withCompletionHandler: () -> Void)\nAsks the delegate to process the user’s response to a delivered notification.\n\nRequired\n\nReceiving Notifications\nfunc userNotificationCenter(UNUserNotificationCenter, willPresent: UNNotification, withCompletionHandler: (UNNotificationPresentationOptions) -> Void)\nAsks the delegate how to handle a notification that arrived while the app was running in the foreground.\nstruct UNNotificationPresentationOptions\nConstants indicating how to present a notification in a foreground app.\nDisplaying Notification Settings\nfunc userNotificationCenter(UNUserNotificationCenter, openSettingsFor: UNNotification?)\nAsks the delegate to display the in-app notification settings.\n\nRequired\n\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nNotification management\nclass UNUserNotificationCenter\nThe central object for managing notification-related activities for your app or app extension.\nclass UNNotificationSettings\nThe object for managing notification-related settings and the authorization status of your app."
  },
  {
    "title": "UNNotificationAction",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationaction",
    "html": "Overview\n\nUse UNNotificationAction objects to define the actions that your app can perform in response to a delivered notification. You define the actions that your app supports. For example, a meeting app might define actions for accepting or rejecting a meeting invitation. The action object itself contains the title to display in an action button and the button’s appearance. After creating action objects, add them to a UNNotificationCategory object and register your categories with the system.\n\nNote\n\nWhen someone performs a Double Tap gesture while viewing a notification on Apple Watch Series 9 or Apple Watch Ultra 2, the system invokes the first nondestructive action. A nondestructive action doesn’t include the destructive option, and won’t delete user data or change the app irrevocably.\n\nFor information on how to define actions and categories, see Declaring your actionable notification types.\n\nResponding to the Selection of Actions\n\nWhen the user selects one of your actions in response to a notification, the system notifies the delegate of the shared UNUserNotificationCenter object. Specifically, the system calls the userNotificationCenter(_:didReceive:withCompletionHandler:) method of your delegate object. The response object passed to your delegate includes the identifier string of the action the user selects, which you can use to perform the corresponding task.\n\nFor information on how to handle actions, see Handling notifications and notification-related actions.\n\nTopics\nEssentials\nconvenience init(identifier: String, title: String, options: UNNotificationActionOptions)\nCreates an action object by using the specified title and options.\nconvenience init(identifier: String, title: String, options: UNNotificationActionOptions, icon: UNNotificationActionIcon?)\nCreates an action object by using the specified title, options, and icon.\nGetting Information\nvar identifier: String\nThe unique string that your app uses to identify the action.\nvar title: String\nThe localized string to use as the title of the action.\nvar icon: UNNotificationActionIcon?\nThe icon associated with the action.\nGetting Options\nvar options: UNNotificationActionOptions\nThe behaviors associated with the action.\nstruct UNNotificationActionOptions\nThe behaviors you can apply to an action.\nInitializers\ninit?(coder: NSCoder)\nRelationships\nInherits From\nNSObject\nInherited By\nUNTextInputNotificationAction\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification categories and user actions\nDeclaring your actionable notification types\nDifferentiate your notifications and add action buttons to the notification interface.\nclass UNNotificationCategory\nA type of notification your app supports and the custom actions that the system displays.\nclass UNTextInputNotificationAction\nAn action that accepts user-typed text."
  },
  {
    "title": "UNNotificationRequest",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotificationrequest",
    "html": "Overview\n\nCreate a UNNotificationRequest object when you want to schedule the delivery of a local notification. A notification request object contains a UNNotificationContent object with the payload and the UNNotificationTrigger object with the conditions that trigger the delivery of the notification. To schedule the delivery of your notification, pass your request object to the add(_:withCompletionHandler:) method of the shared user notification center object.\n\nAfter scheduling a request, you interact with UNNotificationRequest objects in the following ways:\n\nView your app’s pending notifications by calling the getPendingNotificationRequests(completionHandler:) method of your shared user notification center object.\n\nWhen the system delivers a notification to your app, the provided UNNotification object contains a UNNotificationRequest object that you can inspect to get the notification details.\n\nUse the request’s identifier to remove delivered notifications from Notification Center.\n\nWhen receiving a local or remote notification, use the provided UNNotificationRequest object to fetch details about the notification.\n\n// Create a content object with the message to convey.\nlet content = UNMutableNotificationContent()\ncontent.title = \"Lunch time\"\ncontent.body = \"Food is cooked... let's eat!\"\n// Create a notification trigger for 60 seconds in the future.\nlet trigger = UNTimeIntervalNotificationTrigger(timeInterval: 60.0, repeats: false)\n// Create the request with the content and the trigger.\nlet request = UNNotificationRequest(identifier: \"com.example.mynotification\", content: content, trigger: trigger)\n\nTopics\nCreating a Notification Request\nconvenience init(identifier: String, content: UNNotificationContent, trigger: UNNotificationTrigger?)\nCreates a notification request object that you use to schedule a notification.\nGetting the Request Details\nvar identifier: String\nThe unique identifier for this notification request.\nvar content: UNNotificationContent\nThe content associated with the notification.\nvar trigger: UNNotificationTrigger?\nThe conditions that trigger the delivery of the notification.\nInitializers\ninit?(coder: NSCoder)\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification requests\nScheduling a notification locally from your app\nCreate and schedule notifications from your app when you want to get the user’s attention.\nclass UNNotification\nThe data for a local or remote notification the system delivers to your app."
  },
  {
    "title": "UNNotification",
    "url": "https://developer.apple.com/documentation/usernotifications/unnotification",
    "html": "Overview\n\nA UNNotification object contains the initial notification request, which contains the notification’s payload, and the date that the system delivered the notification.\n\nDon’t create notification objects directly. When handling notifications, the system delivers notification objects to your UNUserNotificationCenterDelegate object. The UNUserNotificationCenter object also maintains the list of notifications that the system delivers, and you use the getDeliveredNotifications(completionHandler:) method to retrieve those objects.\n\nTopics\nGetting the Notification Details\nvar request: UNNotificationRequest\nThe notification request containing the payload and trigger condition for the notification.\nvar date: Date\nThe delivery date of the notification.\nInitializers\ninit?(coder: NSCoder)\nRelationships\nInherits From\nNSObject\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSCopying\nNSObjectProtocol\nNSSecureCoding\nSee Also\nNotification requests\nScheduling a notification locally from your app\nCreate and schedule notifications from your app when you want to get the user’s attention.\nclass UNNotificationRequest\nA request to schedule a local notification, which includes the content of the notification and the trigger conditions for delivery."
  },
  {
    "title": "Sending web push notifications in web apps and browsers",
    "url": "https://developer.apple.com/documentation/usernotifications/sending-web-push-notifications-in-web-apps-and-browsers",
    "html": "Overview\n\nWhen important, time-sensitive events occur, inform your website users with push notifications you send from your server. To do this, add support for web push — push notifications that use the cross-browser Push API, Notifications API, Badging API, and Service Worker standards. For more information on these standards, see the W3C document on Push API standards. Add web push to Home Screen web apps in iOS 16.4 or later and Webpages in Safari 16 for macOS 13 or later.\n\nTo send web push notifications, update your webpage to subscribe users and handle notifications, and update your server to send push notifications. If you’re already sending push notifications with web push for other browsers, confirm that your server fulfills Safari’s requirements so that your existing implementation works for webpages in macOS Safari and web apps. You don’t need to join the Apple Developer Program to send web push notifications.\n\nIf you’re already sending push notifications to users in Safari 15 or earlier using Safari Push Notifications, continue sending push notifications to those users. Update your webpage with feature detection to use Push API code if it’s available, or Safari Push Notifications code if it isn’t. For more information about best practices while sending a push notification with APNs, see Sending notification requests to APNs.\n\nEnable push notifications for your webpage or web app\n\nTo enable push notifications, follow this general approach in your webpage or web app:\n\nAsk the user for permission to send them push notifications. Provide a method for the user to grant permission with a gesture, such as clicking or tapping a button. When the user completes the gesture, call the push subscription method immediately from the gesture’s event handler code.\n\nIf the user grants permission, register the provided push notification endpoint and encryption keys from the subscription on your push server with the user’s account.\n\nAdd a service worker that handles receiving push notifications.\n\nAdd Notifications API code to display push notifications when the service worker receives them.\n\nSafari doesn’t support invisible push notifications. Present push notifications to the user immediately after your service worker receives them. If you don’t, Safari revokes the push notification permission for your site.\n\nFor more information on enabling web push in your webpage, see Push API in Mozilla documentation.\n\nPrepare your server to send push notifications\n\nBefore you add code to send push notifications, make these preparations on your server:\n\nPrepare a Voluntary Application Server Identification (VAPID) key pair for your server. You use this to identify your server to the push notification services when you send a push notification.\n\nSet up your server to build and encrypt the payload for each push notification.\n\nSet up your server to package and send a push notification to a push service according to the RFC8030 specification.\n\nIf your network infrastructure limits which URLs your server can access, allow access for https://*.push.apple.com.\n\nYour service should maintain TLS encrypted connections to APNs. For more information, see Setting up a remote notification server. To send web pushes, your service must use the Server Name Indication (SNI) extension of TLS. For more information, see RFC3546. APNs supports both HTTP/1.1 and HTTP/2.0. The default protocol is HTTP/1.1. An application server should use the Application-Layer Protocol Negotiation (APLN) extension of TLS to choose between the supported protocols. For more information, see RFC7301.\n\nThen add code to your server to:\n\nReceive user push notification registrations.\n\nStore the push notification subscription endpoint and encryption keys together with the user’s account information.\n\nDetermine which users should receive a push notification when important events occur.\n\nPrepare and send push notifications to the users you identify.\n\nFor more information on preparing your server to send push notifications, see Push API in Mozilla documentation.\n\nSend your notification request to the recipient’s endpoint\n\nPrepare your push notification request according to the specification. Then send the notification request over HTTP/1.1 or HTTP/2 to the endpoint you stored from the recipient’s push registration.\n\nThe push notification service supports HTTP pipelining for HTTP/1.1. Don’t send more than 100 unacknowledged push requests over the connection. There’s a limit of concurrent streams for HTTP/2. Don’t make assumptions about the number of concurrent streams allowed; instead, don’t exceed the SETTINGS_MAX_CONCURRENT_STREAMS value in the HTTP/2 SETTINGS frame.\n\nInclude the standard headers with your push notification request:\n\nTTL\n\nThe number of seconds before your message expires. If the push service can’t deliver a notification immediately, it may store the notification for 30 days or fewer, depending on the value you specify. The push service attempts to deliver the notification the next time the device activates and is available online. If the push service can’t deliver the notification, the push service removes the notification from storage permanently. The number of notifications the push services stores while the device is offline is limited.\n\nAuthorization\n\nThe VAPID JSON web token (JWT) and public key.The public key you include must match the public key you provided to PushManager.subscribe. Don’t refresh your JWT more frequently than once per hour.\n\nContent-Encoding\n\nThe name of the encryption method you used to encrypt the payload. If the payload is empty, you may omit this header\n\nTopic\n\nOptional identifier that the push service uses to coalesce notifications. Use a maximum of 32 characters from the URL or filename-safe Base64 characters sets.\n\nUrgency\n\nIndication of whether to send the notification immediately or prioritize the recipient’s device power considerations for delivery. Provide one of the following values: very-low, low, normal, or high. To attempt to deliver the notification immediately, specify high.\n\nDisplay badge counts for your web app\n\nTo display badge counts on your web app’s icon, use navigator.setAppBadge in your JavaScript to set a badge count. Clear the badge count with navigator.clearAppBadge.\n\nUsers can configure badging permissions for your Home Screen web app in Notifications settings in iOS 16.4 or later.\n\nReview responses for push notification errors\n\nThe push notification service provides a response for each push notification request. Inspect each response to see how the push service handled your push request. The response headers include the HTTP status code and the apns-id, which uniquely identifies your push request. The HTTP status code indicates if the request succeeds; if the request fails, the status code identifies the type of error:\n\nHTTP status code\n\n\t\n\nDescription\n\n\n\n\n201\n\n\t\n\nSuccess.\n\n\n\n\n400\n\n\t\n\nBad request.\n\n\n\n\n403\n\n\t\n\nThere’s an error with your authentication.\n\n\n\n\n404\n\n\t\n\nThe request contains an invalid :path value.\n\n\n\n\n405\n\n\t\n\nThe request contains an invalid :method value. Only use POST requests.\n\n\n\n\n410\n\n\t\n\nThe device token has expired.\n\n\n\n\n413\n\n\t\n\nThe notification payload is too large.\n\n\n\n\n429\n\n\t\n\nThe server is receiving too many requests for the same destination.\n\n\n\n\n500\n\n\t\n\nInternal server error.\n\n\n\n\n503\n\n\t\n\nThe server is shutting down and is unavailable.\n\nIf the push service encounters an error processing your push request, it returns a JSON dictionary response, which includes an error code identified by the reason key. Inspect the reason code for more details about the cause of the error.\n\nBadTtl\n\nThe TTL header is either missing or isn’t a positive number.\n\nBadUrgency\n\nThe Urgency header is present but isn’t one of the allowed values: very-low, low, normal, high.\n\nBadWebPushRequest\n\nThe request doesn’t conform to the encryption rules.\n\nBadWebPushTopic\n\nThe Topic header is present but doesn’t conform to the specification.\n\nVapidPkHashMismatch\n\nThe VAPID public key from the push subscription doesn’t match the VAPID public key in the request.\n\nIdleTimeout\n\nThe connection timed out.\n\nBadAuthorizationHeader\n\nThe Authorization header doesn’t conform to the specification.\n\nBadJwtToken\n\nThe JSON web token (JWT) has one of following issues: The JWT is missing. The JWT is signed with the wrong private key. The JWT subject claim isn’t a URL or mailto:. The JWT audience claim isn’t the origin of the push service where you sent the request. The JWT expiration parameter is more than one day into the future.\n\nBadVapidPublicKey\n\nThe VAPID public key has one of the following issues: The VAPID public key isn’t present. The VAPID public key is present but not base64url encoded. The VAPID public key isn’t the correct type of key.\n\nBadPath\n\nThe request contained an invalid :path value.\n\nMethodNotAllowed\n\nThe specified :method value isn’t POST.\n\nPayloadTooLarge\n\nThe payload size is over the limit of 4 KB.\n\nTooManyRequests\n\nThe push service received too many consecutive requests to the same device token.\n\nInternalServerError\n\nAn internal server error occurred.\n\nServiceUnavailable\n\nThe service is unavailable.\n\nShutdown\n\nThe push server is shutting down.\n\nTo resolve an error, address the issue and resend your push notification request. For more information about the factors that impact the delivery of a push notification, see Viewing the status of push notifications using Metrics and APNs.\n\nFor more information about APNs service and storage details, see Sending notification requests to APNs."
  },
  {
    "title": "User Notifications",
    "url": "https://developer.apple.com/documentation/usernotifications",
    "html": "Overview\n\nUser-facing notifications communicate important information to users of your app, regardless of whether your app is running on the user’s device. For example, a sports app can let the user know when their favorite team scores. Notifications can also tell your app to download information and update its interface. Notifications can display an alert, play a sound, or badge the app’s icon.\n\nYou can generate notifications locally from your app or remotely from a server that you manage. For local notifications, the app creates the notification content and specifies a condition, like a time or location, that triggers the delivery of the notification. For remote notifications, your company’s server generates push notifications, and Apple Push Notification service (APNs) handles the delivery of those notifications to the user’s devices.\n\nUse this framework to do the following:\n\nDefine the types of notifications that your app supports.\n\nDefine any custom actions associated with your notification types.\n\nSchedule local notifications for delivery.\n\nProcess already delivered notifications.\n\nRespond to user-selected actions.\n\nThe system makes every attempt to deliver local and remote notifications in a timely manner, but delivery isn’t guaranteed. The PushKit framework offers a more timely delivery mechanism for specific types of notifications, such as those VoIP and watchOS complications use. For more information, see PushKit.\n\nFor webpages in Safari version 16.0 and higher, generate remote notifications from a server that you manage using Push API code that works in Safari and other browsers.\n\nNote\n\nSiri can provide suggestions to users in search, News, Safari, and other apps using on-device information that your app contributes through the Notifications API. Users can change this functionality to allow at any time through Siri and Search settings for your app.\n\nFor design guidance, see Human Interface Guidelines > Notifications.\n\nTopics\nEssentials\nAsking permission to use notifications\nRequest permission to display alerts, play sounds, or badge the app’s icon in response to a notification.\nNotification management\nclass UNUserNotificationCenter\nThe central object for managing notification-related activities for your app or app extension.\nprotocol UNUserNotificationCenterDelegate\nAn interface for processing incoming notifications and responding to notification actions.\nclass UNNotificationSettings\nThe object for managing notification-related settings and the authorization status of your app.\nRemote notifications\nGenerate notifications from your company’s servers, and deliver those notifications using APNs.\nSetting up a remote notification server\nGenerate notifications and push them to user devices.\nRegistering your app with APNs\nCommunicate with Apple Push Notification service (APNs) and receive a unique device token that identifies your app.\nTesting notifications using the Push Notification Console\nSend test notifications and access delivery logs to test your app’s integration with Apple Push Notification service.\nSending push notifications using command-line tools\nUse basic macOS command-line tools to send push notifications to Apple Push Notification service (APNs).\nNotification requests\nCreate delivery requests for local notifications, and access the content of delivered local and remote notifications.\nScheduling a notification locally from your app\nCreate and schedule notifications from your app when you want to get the user’s attention.\nclass UNNotificationRequest\nA request to schedule a local notification, which includes the content of the notification and the trigger conditions for delivery.\nclass UNNotification\nThe data for a local or remote notification the system delivers to your app.\nPush notifications in safari\nSending web push notifications in web apps and browsers\nUpdate your web server and website to send push notifications that work in Safari, other browsers, and web apps, following cross-browser standards.\nNotification content\nModify and examine the payload of a notification.\nImplementing communication notifications\nConfigure and display your app’s communication notifications by using intents.\nprotocol UNNotificationContentProviding\nA protocol the system uses to provide context relevant to user notifications.\nclass UNNotificationActionIcon\nAn icon associated with an action.\nclass UNMutableNotificationContent\nThe editable content for a notification.\nclass UNNotificationContent\nThe uneditable content of a notification.\nclass UNNotificationAttachment\nA media file associated with a notification.\nclass UNNotificationSound\nThe sound played upon delivery of a notification.\nstruct UNNotificationSoundName\nA string providing the name of a sound file.\nTriggers\nDefine the trigger conditions for delivering notifications. Detect when a remote notification was delivered from APNs.\nclass UNCalendarNotificationTrigger\nA trigger condition that causes a notification the system delivers at a specific date and time.\nclass UNTimeIntervalNotificationTrigger\nA trigger condition that causes the system to deliver a notification after the amount of time you specify elapses.\nclass UNLocationNotificationTrigger\nA trigger condition that causes the system to deliver a notification when the user’s device enters or exits a geographic region you specify.\nclass UNPushNotificationTrigger\nA trigger condition that indicates Apple Push Notification Service (APNs) has sent the notification.\nclass UNNotificationTrigger\nThe common behavior for subclasses that trigger the delivery of a local or remote notification.\nNotification categories and user actions\nDefine the types of notifications that your app supports, and define how users can respond.\nDeclaring your actionable notification types\nDifferentiate your notifications and add action buttons to the notification interface.\nclass UNNotificationCategory\nA type of notification your app supports and the custom actions that the system displays.\nclass UNNotificationAction\nA task your app performs in response to a notification that the system delivers.\nclass UNTextInputNotificationAction\nAn action that accepts user-typed text.\nNotification responses\nHandling notifications and notification-related actions\nRespond to user interactions with the system’s notification interfaces, including handling your app’s custom actions.\nclass UNNotificationResponse\nThe user’s response to an actionable notification.\nclass UNTextInputNotificationResponse\nThe user’s response to an actionable notification, including any custom text that the user typed or dictated.\nNotification service app extension\nUse a notification service app extension to modify the content of a notification before it’s delivered to your app.\nModifying content in newly delivered notifications\nModify the payload of a remote notification before it’s displayed on the user’s iOS device.\nclass UNNotificationServiceExtension\nAn object that modifies the content of a remote notification before it’s delivered to the user.\nEntitlements\nAPS Environment Entitlement\nThe environment for push notifications.\nAPS Environment (macOS) Entitlement\nThe environment for push notifications in macOS apps.\nSample code\nHandling Communication Notifications and Focus Status Updates\nCreate a richer calling and messaging experience in your app by implementing communication notifications and Focus status updates.\nImplementing Alert Push Notifications\nAdd visible alert notifications to your app by using the UserNotifications framework.\nImplementing Background Push Notifications\nAdd background notifications to your app by using the UserNotifications framework.\nReference\nUserNotifications Constants"
  }
]