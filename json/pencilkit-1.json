[
  {
    "title": "maximumWidthForEraserType: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/4123103-maximumwidthforerasertype",
    "html": "See Also\nGetting the width information\nwidth\nThe width of the eraser.\n+ defaultWidthForEraserType:\nThe default width for the specified eraser type.\n+ minimumWidthForEraserType:\nThe minimum width for the specified eraser type."
  },
  {
    "title": "PKEraserTypeVector | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertype/pkerasertypevector",
    "html": "Discussion\n\nWhen a vector eraser touches any portion of a drawn line, it removes the entire line.\n\nSee Also\nEraser types\nPKEraserTypeBitmap\nAn eraser that removes only those portions of the drawing it touches.\nPKEraserTypeFixedWidthBitmap"
  },
  {
    "title": "eraserType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/3229038-erasertype",
    "html": "See Also\nGetting the eraser type\nPKEraserType\nConstants that indicate the behavior of the eraser."
  },
  {
    "title": "minimumWidthForEraserType: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/4123104-minimumwidthforerasertype",
    "html": "See Also\nGetting the width information\nwidth\nThe width of the eraser.\n+ defaultWidthForEraserType:\nThe default width for the specified eraser type.\n+ maximumWidthForEraserType:\nThe maximum width for the specified eraser type."
  },
  {
    "title": "defaultWidthForEraserType: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/4123101-defaultwidthforerasertype",
    "html": "See Also\nGetting the width information\nwidth\nThe width of the eraser.\n+ minimumWidthForEraserType:\nThe minimum width for the specified eraser type.\n+ maximumWidthForEraserType:\nThe maximum width for the specified eraser type."
  },
  {
    "title": "PKEraserTypeFixedWidthBitmap | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertype/pkerasertypefixedwidthbitmap",
    "html": "See Also\nEraser types\nPKEraserTypeVector\nAn eraser that removes an entire drawn line.\nPKEraserTypeBitmap\nAn eraser that removes only those portions of the drawing it touches."
  },
  {
    "title": "PKEraserTypeBitmap | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertype/pkerasertypebitmap",
    "html": "See Also\nEraser types\nPKEraserTypeVector\nAn eraser that removes an entire drawn line.\nPKEraserTypeFixedWidthBitmap"
  },
  {
    "title": "initWithEraserType:width: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/4123102-initwitherasertype",
    "html": "See Also\nCreating an eraser tool\n- initWithEraserType:\nCreates an eraser tool object that removes objects wholly or partially from a canvas view."
  },
  {
    "title": "initWithEraserType: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/3229039-initwitherasertype",
    "html": "Parameters\neraserType\n\nA constant that determines how the eraser affects drawn content. For a list of possible values, see PKEraserType.\n\nReturn Value\n\nA new eraser tool object.\n\nSee Also\nCreating an eraser tool\n- initWithEraserType:width:"
  },
  {
    "title": "width | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/4123105-width",
    "html": "See Also\nGetting the width information\n+ defaultWidthForEraserType:\nThe default width for the specified eraser type.\n+ minimumWidthForEraserType:\nThe minimum width for the specified eraser type.\n+ maximumWidthForEraserType:\nThe maximum width for the specified eraser type."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3566682-subscript",
    "html": "Parameters\ni\n\nA control point index.\n\nReturn Value\n\nThe PKStrokePointReference at control point subscript location i.\n\nSee Also\nAccessing and interpolating points\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByDistance: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a distance step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByParametricStep: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a parametric step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByTime: TimeInterval, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a time step.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetByDistance: CGFloat) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified distance from the given parametric value.\nfunc parametricValue(CGFloat, offsetByTime: TimeInterval) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified time from the given parametric value.\nfunc point(at: Int) -> PKStrokePoint\nReturns the B-spline control point at an index point that you provide."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595142-prefix",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity: O(1)\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> DropWhileSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence by skipping the initial, consecutive elements that satisfy the given predicate.\nfunc dropFirst(Int) -> DropFirstSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> [PKStrokePoint]\nReturns a sequence containing all but the given number of final elements.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns a sequence containing the initial, consecutive elements that satisfy the given predicate.\nfunc suffix(Int) -> [PKStrokePoint]\nReturns a subsequence, up to the given maximum length, containing the final elements of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595151-reversed",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595135-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nMapping elements\nfunc flatMap<SegmentOfResult>((PKStrokePoint) -> SegmentOfResult) -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nDeprecated"
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595277-starts",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of possiblePrefix.\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nSee Also\nApplying matching criteria to elements\nfunc allSatisfy((PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (PKStrokePoint, PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595197-first",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nSelecting specific elements\nfunc last(where: (PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc randomElement() -> PKStrokePoint?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> PKStrokePoint?\nReturns a random element of the collection, using the given generator as a source for randomness."
  },
  {
    "title": "lowerBound | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkfloatrange/3566642-lowerbound",
    "html": "See Also\nGetting the boundaries of the range\nupperBound\nA floating point value that represents the upper bound of the range."
  },
  {
    "title": "upperBound | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkfloatrange/3566643-upperbound",
    "html": "See Also\nGetting the boundaries of the range\nlowerBound\nA floating point value that represents the lower bound of the range."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595168-withcontiguousstorageifavailable",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively.\n\nNote\n\nThis documentation comment was inherited from Sequence."
  },
  {
    "title": "init(inkType:color:width:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtoolreference/3229051-init",
    "html": "Parameters\ntype\n\nThe shape of the tool. You may specify PKInkTypeMarker, PKInkTypePen, or PKInkTypePencil.\n\ncolor\n\nThe color to apply to drawn lines.\n\nwidth\n\nThe base width to apply to any drawn lines. The value in the inkType parameter and input from Apple Pencil affects the final actual width.\n\nReturn Value\n\nA new inking tool with the specified type, color, and width.\n\nSee Also\nCreating an inking tool\ninit(inkType: __PKInkType, color: UIColor)\nCreates an ink tool object with the default line width and the specified color.\ninit(ink: PKInk, width: CGFloat)\nCreate an inking tool with the specified ink and width."
  },
  {
    "title": "initWithLowerBound:upperBound: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkfloatrange/3566641-initwithlowerbound",
    "html": "Parameters\nlowerBound\n\nA floating point value that represents the lower bound of the range.\n\nupperBound\n\nA floating point value that represents the upper bound of the range.\n\nReturn Value\n\nA new range instance with the supplied upper and lower bounds."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595118-elementsequal",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of other.\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nSee Also\nComparing elements\nfunc compare<Comparator>(Comparator.Compared, Comparator.Compared) -> ComparisonResult"
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595141-next",
    "html": "Relationships\nFrom Protocol\nIteratorProtocol\nSee Also\nSelecting specific elements\nfunc first(where: (PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the first element of the sequence that satisfies the given predicate."
  },
  {
    "title": "PKEraserType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertype",
    "html": "Topics\nEraser types\nPKEraserTypeVector\nAn eraser that removes an entire drawn line.\nPKEraserTypeBitmap\nAn eraser that removes only those portions of the drawing it touches.\nPKEraserTypeFixedWidthBitmap\nSee Also\nGetting the eraser type\neraserType\nThe behavior adopted by the eraser when deleting content."
  },
  {
    "title": "compare(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3802995-compare",
    "html": "See Also\nComparing elements\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (PKStrokePoint, OtherSequence.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595144-prefix",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity: O(k), where k is the length of the result.\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> DropWhileSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence by skipping the initial, consecutive elements that satisfy the given predicate.\nfunc dropFirst(Int) -> DropFirstSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> [PKStrokePoint]\nReturns a sequence containing all but the given number of final elements.\nfunc prefix(Int) -> PrefixSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence, up to the specified maximum length, containing the initial elements of the sequence.\nfunc suffix(Int) -> [PKStrokePoint]\nReturns a subsequence, up to the given maximum length, containing the final elements of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595125-first",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nSelecting specific elements\nfunc next() -> PKStrokePoint?"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595165-suffix",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> DropWhileSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence by skipping the initial, consecutive elements that satisfy the given predicate.\nfunc dropFirst(Int) -> DropFirstSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> [PKStrokePoint]\nReturns a sequence containing all but the given number of final elements.\nfunc prefix(Int) -> PrefixSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence, up to the specified maximum length, containing the initial elements of the sequence.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns a sequence containing the initial, consecutive elements that satisfy the given predicate."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595112-drop",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity: O(k), where k is the number of elements to drop from the beginning of the sequence.\n\nSee Also\nApplying sequence operations to elements\nfunc dropFirst(Int) -> DropFirstSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> [PKStrokePoint]\nReturns a sequence containing all but the given number of final elements.\nfunc prefix(Int) -> PrefixSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence, up to the specified maximum length, containing the initial elements of the sequence.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns a sequence containing the initial, consecutive elements that satisfy the given predicate.\nfunc suffix(Int) -> [PKStrokePoint]\nReturns a subsequence, up to the given maximum length, containing the final elements of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595116-droplast",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> DropWhileSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence by skipping the initial, consecutive elements that satisfy the given predicate.\nfunc dropFirst(Int) -> DropFirstSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence containing all but the given number of initial elements.\nfunc prefix(Int) -> PrefixSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence, up to the specified maximum length, containing the initial elements of the sequence.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns a sequence containing the initial, consecutive elements that satisfy the given predicate.\nfunc suffix(Int) -> [PKStrokePoint]\nReturns a subsequence, up to the given maximum length, containing the final elements of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595133-lexicographicallyprecedes",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of other.\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nSee Also\nApplying matching criteria to elements\nfunc allSatisfy((PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (PKStrokePoint, PossiblePrefix.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595164-starts",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of possiblePrefix.\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nSee Also\nApplying matching criteria to elements\nfunc allSatisfy((PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (PKStrokePoint, PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595109-contains",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nApplying matching criteria to elements\nfunc allSatisfy((PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (PKStrokePoint, PossiblePrefix.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (PKStrokePoint, PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595154-shuffled",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift.\n\nSee Also\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc reversed() -> [PKStrokePoint]\nReturns an array containing the elements of this sequence in reverse order.\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595105-allsatisfy",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nApplying matching criteria to elements\nfunc contains(where: (PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (PKStrokePoint, PossiblePrefix.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (PKStrokePoint, PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595137-max",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nApplying mathematical operations on elements\nfunc min(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595152-shuffled",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc reversed() -> [PKStrokePoint]\nReturns an array containing the elements of this sequence in reverse order.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "sorted(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3802997-sorted",
    "html": "See Also\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc reversed() -> [PKStrokePoint]\nReturns an array containing the elements of this sequence in reverse order.\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "sorted(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3802996-sorted",
    "html": "See Also\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc reversed() -> [PKStrokePoint]\nReturns an array containing the elements of this sequence in reverse order.\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595156-sorted",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity: O(n log n), where n is the length of the sequence.\n\nSee Also\nSorting elements\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc reversed() -> [PKStrokePoint]\nReturns an array containing the elements of this sequence in reverse order.\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "makeIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595134-makeiterator",
    "html": "See Also\nIterating elements\nfunc enumerated() -> EnumeratedSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc forEach((PKStrokePoint) -> Void)\nCalls the given closure on each element in the sequence in the same order as a for-in loop."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595149-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nReducing elements\nfunc reduce<Result>(Result, (Result, PKStrokePoint) -> Result) -> Result\nReturns the result of combining the elements of the sequence using the given closure."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595147-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nReducing elements\nfunc reduce<Result>(into: Result, (inout Result, PKStrokePoint) -> ()) -> Result\nReturns the result of combining the elements of the sequence using the given closure."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595107-compactmap",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity: O(n), where n is the length of this sequence.\n\nSee Also\nFiltering elements\nfunc filter((PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc filter(Predicate<PKStrokePoint>) -> [PKStrokePoint]\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (PKStrokePoint) -> Bool) -> [ArraySlice<PKStrokePoint>]\nReturns the longest possible subsequences of the sequence, in order, that don’t contain elements satisfying the given predicate. Elements that are used to split the sequence are not returned as part of any subsequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595127-flatmap",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity: O(m + n), where n is the length of this sequence and m is the length of the result.\n\nSee Also\nMapping elements\nfunc map<T>((PKStrokePoint) -> T) -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc flatMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nDeprecated"
  },
  {
    "title": "minimumWidthForInkType: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3229054-minimumwidthforinktype",
    "html": "Parameters\ninkType\n\nThe type of tool whose minimum line width you want.\n\nReturn Value\n\nThe minimum line width (in points) for the specified tool type.\n\nSee Also\nGetting the standard ink widths\n+ defaultWidthForInkType:\nReturns the default line width for the specified tool type.\n+ maximumWidthForInkType:\nReturns the maximum allowed line width for the specified tool type."
  },
  {
    "title": "maximumWidthForInkType: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3229053-maximumwidthforinktype",
    "html": "Parameters\ninkType\n\nThe type of tool whose maximum line width you want.\n\nReturn Value\n\nThe maximum line width (in points) for the specified tool type.\n\nSee Also\nGetting the standard ink widths\n+ defaultWidthForInkType:\nReturns the default line width for the specified tool type.\n+ minimumWidthForInkType:\nReturns the minimum allowed line width for the specified tool type."
  },
  {
    "title": "PKInkTypeWatercolor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinktypewatercolor",
    "html": "See Also\nGetting the tool type\ninkType\nThe tool type that determines the shape of the rendered content.\nPKInkType\nThe type that defines the shape of stroked lines.\nPKInkTypeMarker\nAn inking tool that creates the appearance of a felt-tip marker.\nPKInkTypePen\nAn inking tool that creates the appearance of drawing with a pen.\nPKInkTypePencil\nAn inking tool that creates the appearance of drawing with a pencil.\nPKInkTypeMonoline\nAn inking tool that creates the appearance of a monoline pen.\nPKInkTypeFountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\nPKInkTypeCrayon\nAn inking tool that creates the appearance of a crayon."
  },
  {
    "title": "convertColor:fromUserInterfaceStyle:to: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3335018-convertcolor",
    "html": "Parameters\ncolor\n\nThe color to convert.\n\nfromUserInterfaceStyle\n\nThe user interface style to convert the color from.\n\ntoUserInterfaceStyle\n\nThe user interface style to convert the color to."
  },
  {
    "title": "PKInkTypeCrayon | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinktypecrayon",
    "html": "See Also\nGetting the tool type\ninkType\nThe tool type that determines the shape of the rendered content.\nPKInkType\nThe type that defines the shape of stroked lines.\nPKInkTypeMarker\nAn inking tool that creates the appearance of a felt-tip marker.\nPKInkTypePen\nAn inking tool that creates the appearance of drawing with a pen.\nPKInkTypePencil\nAn inking tool that creates the appearance of drawing with a pencil.\nPKInkTypeMonoline\nAn inking tool that creates the appearance of a monoline pen.\nPKInkTypeFountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\nPKInkTypeWatercolor\nAn inking tool that creates the appearance of a watercolor brush."
  },
  {
    "title": "PKInkingTool.InkType.fountainPen | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/fountainpen",
    "html": "See Also\nChoosing ink types\ncase marker\nAn inking tool that creates the appearance of a felt-tip marker.\ncase pen\nAn inking tool that creates the appearance of a pen-based drawing.\ncase pencil\nAn inking tool that creates the appearance of a narrow line from a pencil.\ncase monoline\nAn inking tool that creates the appearance of a monoline pen.\ncase watercolor\nAn inking tool that creates the appearance of a watercolor brush.\ncase crayon\nAn inking tool that creates the appearance of a crayon.\nvar rawValue: String\nThe raw string value of a given enumeration case."
  },
  {
    "title": "PKInkingTool.InkType.monoline | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/monoline",
    "html": "See Also\nChoosing ink types\ncase marker\nAn inking tool that creates the appearance of a felt-tip marker.\ncase pen\nAn inking tool that creates the appearance of a pen-based drawing.\ncase pencil\nAn inking tool that creates the appearance of a narrow line from a pencil.\ncase fountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\ncase watercolor\nAn inking tool that creates the appearance of a watercolor brush.\ncase crayon\nAn inking tool that creates the appearance of a crayon.\nvar rawValue: String\nThe raw string value of a given enumeration case."
  },
  {
    "title": "PKInkingTool.InkType.crayon | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/crayon",
    "html": "See Also\nChoosing ink types\ncase marker\nAn inking tool that creates the appearance of a felt-tip marker.\ncase pen\nAn inking tool that creates the appearance of a pen-based drawing.\ncase pencil\nAn inking tool that creates the appearance of a narrow line from a pencil.\ncase monoline\nAn inking tool that creates the appearance of a monoline pen.\ncase fountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\ncase watercolor\nAn inking tool that creates the appearance of a watercolor brush.\nvar rawValue: String\nThe raw string value of a given enumeration case."
  },
  {
    "title": "canvasViewDidEndUsingTool(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasviewdelegate/3229956-canvasviewdidendusingtool",
    "html": "Parameters\ncanvasView\n\nThe canvas view whose contents changed.\n\nSee Also\nResponding to new event sequences\nfunc canvasViewDidBeginUsingTool(PKCanvasView)\nTells the delegate that the user started a new drawing sequence with the currently selected tool."
  },
  {
    "title": "PKContentVersion.version1 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcontentversion/version1",
    "html": "See Also\nSpecific versions\ncase version2\nThe PencilKit version that supports inks from iPadOS 17 and earlier, including marker, pen, pencil, monoline, fountain pen, watercolor, and crayon."
  },
  {
    "title": "PKEraserTool.EraserType.fixedWidthBitmap | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/erasertype/fixedwidthbitmap",
    "html": "See Also\nEraser types\ncase vector\nAn eraser that removes an entire drawn line.\ncase bitmap\nAn eraser that removes only those portions of the drawing it touches."
  },
  {
    "title": "PKInkTypeMarker | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinktypemarker",
    "html": "See Also\nGetting the tool type\ninkType\nThe tool type that determines the shape of the rendered content.\nPKInkType\nThe type that defines the shape of stroked lines.\nPKInkTypePen\nAn inking tool that creates the appearance of drawing with a pen.\nPKInkTypePencil\nAn inking tool that creates the appearance of drawing with a pencil.\nPKInkTypeMonoline\nAn inking tool that creates the appearance of a monoline pen.\nPKInkTypeFountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\nPKInkTypeWatercolor\nAn inking tool that creates the appearance of a watercolor brush.\nPKInkTypeCrayon\nAn inking tool that creates the appearance of a crayon."
  },
  {
    "title": "PKEraserTool.EraserType.vector | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/erasertype/vector",
    "html": "Discussion\n\nWhen a vector eraser touches any portion of a drawn line, it removes the entire line.\n\nSee Also\nEraser types\ncase bitmap\nAn eraser that removes only those portions of the drawing it touches.\ncase fixedWidthBitmap"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595201-flatmap",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity: O(m + n), where n is the length of this sequence and m is the length of the result.\n\nSee Also\nMapping elements\nfunc map<T>((PKStrokePoint) -> T) -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc flatMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nDeprecated"
  },
  {
    "title": "width | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3229055-width",
    "html": "Discussion\n\nThe actual line width at any given point varies based on input from Apple Pencil. For finger-based drawing, the line width is equal to the value in this property.\n\nSee Also\nGetting the inking tool attributes\ncolor\nThe color of the ink.\nink\nThe ink that this tool creates strokes with."
  },
  {
    "title": "PKInkTypeMonoline | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinktypemonoline",
    "html": "See Also\nGetting the tool type\ninkType\nThe tool type that determines the shape of the rendered content.\nPKInkType\nThe type that defines the shape of stroked lines.\nPKInkTypeMarker\nAn inking tool that creates the appearance of a felt-tip marker.\nPKInkTypePen\nAn inking tool that creates the appearance of drawing with a pen.\nPKInkTypePencil\nAn inking tool that creates the appearance of drawing with a pencil.\nPKInkTypeFountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\nPKInkTypeWatercolor\nAn inking tool that creates the appearance of a watercolor brush.\nPKInkTypeCrayon\nAn inking tool that creates the appearance of a crayon."
  },
  {
    "title": "ink | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3566665-ink",
    "html": "See Also\nGetting the inking tool attributes\ncolor\nThe color of the ink.\nwidth\nThe base line width for new content."
  },
  {
    "title": "PKStrokePath.InterpolatedSlice.Stride.time(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/stride/time",
    "html": "See Also\nStride types\ncase distance(CGFloat)\nA stride based on a distance between elements you provide.\ncase parametricStep(CGFloat)\nA stride based on a parametric step value you provide."
  },
  {
    "title": "initWithInkType:color: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3229050-initwithinktype",
    "html": "Parameters\ntype\n\nThe shape of the tool. You may specify PKInkTypeMarker, PKInkTypePen, or PKInkTypePencil.\n\ncolor\n\nThe color to apply to drawn lines.\n\nReturn Value\n\nA new inking tool with the specified type and color.\n\nDiscussion\n\nThis method sets the line width to the value returned by defaultWidthForInkType:.\n\nSee Also\nCreating an inking tool\n- initWithInkType:color:width:\nCreates an ink tool object with the specified color and line width values.\n- initWithInk:width:\nCreate an inking tool with the specified ink and width."
  },
  {
    "title": "PKStrokePath.InterpolatedSlice.Stride.parametricStep(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/stride/parametricstep",
    "html": "See Also\nStride types\ncase distance(CGFloat)\nA stride based on a distance between elements you provide.\ncase time(TimeInterval)\nA stride based on a time interval in seconds you provide."
  },
  {
    "title": "init(eraserType:width:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertoolreference/4123102-init",
    "html": "See Also\nCreating an eraser tool\ninit(eraserType: __PKEraserType)\nCreates an eraser tool object that removes objects wholly or partially from a canvas view."
  },
  {
    "title": "initWithInkType:color:width: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3229051-initwithinktype",
    "html": "Parameters\ntype\n\nThe shape of the tool. You may specify PKInkTypeMarker, PKInkTypePen, or PKInkTypePencil.\n\ncolor\n\nThe color to apply to drawn lines.\n\nwidth\n\nThe base width to apply to any drawn lines. The value in the inkType parameter and input from Apple Pencil affects the final actual width.\n\nReturn Value\n\nA new inking tool with the specified type, color, and width.\n\nSee Also\nCreating an inking tool\n- initWithInkType:color:\nCreates an ink tool object with the default line width and the specified color.\n- initWithInk:width:\nCreate an inking tool with the specified ink and width."
  },
  {
    "title": "width | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertoolreference/4123105-width",
    "html": "See Also\nGetting the width information\nclass func defaultWidth(for: __PKEraserType) -> CGFloat\nThe default width for the specified eraser type.\nclass func minimumWidth(for: __PKEraserType) -> CGFloat\nThe minimum width for the specified eraser type.\nclass func maximumWidth(for: __PKEraserType) -> CGFloat\nThe maximum width for the specified eraser type."
  },
  {
    "title": "maximumWidth(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertoolreference/4123103-maximumwidth",
    "html": "See Also\nGetting the width information\nvar width: CGFloat\nThe width of the eraser.\nclass func defaultWidth(for: __PKEraserType) -> CGFloat\nThe default width for the specified eraser type.\nclass func minimumWidth(for: __PKEraserType) -> CGFloat\nThe minimum width for the specified eraser type."
  },
  {
    "title": "minimumWidth(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertoolreference/4123104-minimumwidth",
    "html": "See Also\nGetting the width information\nvar width: CGFloat\nThe width of the eraser.\nclass func defaultWidth(for: __PKEraserType) -> CGFloat\nThe default width for the specified eraser type.\nclass func maximumWidth(for: __PKEraserType) -> CGFloat\nThe maximum width for the specified eraser type."
  },
  {
    "title": "init(ink:width:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtoolreference/3566664-init",
    "html": "Parameters\nink\n\nThe shape of the tool. You may specify PKInkTypeMarker, PKInkTypePen, or PKInkTypePencil.\n\nwidth\n\nThe width of a line drawn with the tool.\n\nSee Also\nCreating an inking tool\ninit(inkType: __PKInkType, color: UIColor, width: CGFloat)\nCreates an ink tool object with the specified color and line width values.\ninit(inkType: __PKInkType, color: UIColor)\nCreates an ink tool object with the default line width and the specified color."
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtoolreference/3229048-color",
    "html": "Discussion\n\nThe alpha of the final color may vary due to input from Apple Pencil. For example, light pressure from Apple Pencil introduces more transparency into the final color, while additional force increases opacity to create a more solid line.\n\nSee Also\nGetting the inking tool attributes\nvar width: CGFloat\nThe base line width for new content.\nvar ink: PKInk\nThe ink that this tool creates strokes with."
  },
  {
    "title": "ink | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtoolreference/3566665-ink",
    "html": "See Also\nGetting the inking tool attributes\nvar color: UIColor\nThe color of the ink.\nvar width: CGFloat\nThe base line width for new content."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595139-min",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nApplying mathematical operations on elements\nfunc max(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "convert(_:from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtoolreference/3335018-convert",
    "html": "Parameters\ncolor\n\nThe color to convert.\n\nfromUserInterfaceStyle\n\nThe user interface style to convert the color from.\n\ntoUserInterfaceStyle\n\nThe user interface style to convert the color to."
  },
  {
    "title": "enumerateInterpolatedPoints(in:strideByParametricStep:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3566677-enumerateinterpolatedpoints",
    "html": "Parameters\nrange\n\nThe parametric range in which to enumerate points.\n\nparametricStep\n\nThe parametric step between points.\n\nblock\n\nThe block to execute for each point. This block takes two parameters:\n\npoint —The interpolated point on the spline.\n\nstop —A reference to a Boolean value. Setting the value to YES within the block stops further enumeration, but the block continues to run until it’s finished.\n\nSee Also\nAccessing and interpolating points\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByDistance: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a distance step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByTime: TimeInterval, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a time step.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetByDistance: CGFloat) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified distance from the given parametric value.\nfunc parametricValue(CGFloat, offsetByTime: TimeInterval) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified time from the given parametric value.\nfunc point(at: Int) -> PKStrokePoint\nReturns the B-spline control point at an index point that you provide.\nsubscript(Int) -> PKStrokePoint\nReturns the B-spline control point the location index that you provide."
  },
  {
    "title": "creationDate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3571378-creationdate",
    "html": "Discussion\n\nThe time offset of the contained stroke points is relative to this date.\n\nSee Also\nGetting the stroke path properties\nvar count: Int\nThe number of control points in this stroke path."
  },
  {
    "title": "defaultWidth(forInkType:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtoolreference/3229049-defaultwidth",
    "html": "Parameters\ninkType\n\nThe type of tool whose default line width you want.\n\nReturn Value\n\nThe default line width (in points) for the specified tool type.\n\nSee Also\nGetting the standard ink widths\nclass func minimumWidth(forInkType: __PKInkType) -> CGFloat\nReturns the minimum allowed line width for the specified tool type.\nclass func maximumWidth(forInkType: __PKInkType) -> CGFloat\nReturns the maximum allowed line width for the specified tool type."
  },
  {
    "title": "interpolatedPoint(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3566681-interpolatedpoint",
    "html": "Parameters\nparametricValue\n\nThe on-curve location [0, count-1] where interpolation occurs.\n\nReturn Value\n\nA PKStrokePointReference interpolated from supplied parametricValue.\n\nSee Also\nAccessing and interpolating points\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByDistance: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a distance step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByParametricStep: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a parametric step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByTime: TimeInterval, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a time step.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc parametricValue(CGFloat, offsetByDistance: CGFloat) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified distance from the given parametric value.\nfunc parametricValue(CGFloat, offsetByTime: TimeInterval) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified time from the given parametric value.\nfunc point(at: Int) -> PKStrokePoint\nReturns the B-spline control point at an index point that you provide.\nsubscript(Int) -> PKStrokePoint\nReturns the B-spline control point the location index that you provide."
  },
  {
    "title": "enumerateInterpolatedPoints(in:strideByTime:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3566678-enumerateinterpolatedpoints",
    "html": "Parameters\nrange\n\nThe parametric range to enumerate points in.\n\ntimeStep\n\nThe time interval to step between points.\n\nblock\n\nThe block to execute for each point. This block takes two parameters:\n\npoint —The interpolated point on the spline.\n\nstop — A reference to a Boolean value. Setting the value to YES within the block stops further enumeration of the array. If a block stops further enumeration, that block continues to run until it’s finished.\n\nSee Also\nAccessing and interpolating points\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByDistance: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a distance step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByParametricStep: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a parametric step.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetByDistance: CGFloat) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified distance from the given parametric value.\nfunc parametricValue(CGFloat, offsetByTime: TimeInterval) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified time from the given parametric value.\nfunc point(at: Int) -> PKStrokePoint\nReturns the B-spline control point at an index point that you provide.\nsubscript(Int) -> PKStrokePoint\nReturns the B-spline control point the location index that you provide."
  },
  {
    "title": "parametricValue(_:offsetByTime:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3591055-parametricvalue",
    "html": "Parameters\nparametricValue\n\nThe floating point [0, count-1] parametric value.\n\ntimeStep\n\nThe time to offset parametricValue; timeStep can be positive or negative.\n\nReturn Value\n\nA parametric value offset by timeStep from parametricValue.\n\nSee Also\nAccessing and interpolating points\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByDistance: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a distance step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByParametricStep: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a parametric step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByTime: TimeInterval, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a time step.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetByDistance: CGFloat) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified distance from the given parametric value.\nfunc point(at: Int) -> PKStrokePoint\nReturns the B-spline control point at an index point that you provide.\nsubscript(Int) -> PKStrokePoint\nReturns the B-spline control point the location index that you provide."
  },
  {
    "title": "parametricValue(_:offsetByDistance:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3591054-parametricvalue",
    "html": "Parameters\nparametricValue\n\nThe floating point [0, count-1] parametric value.\n\ndistanceStep\n\nThe distance to offset parametricValue; distanceStep can be positive or negative.\n\nReturn Value\n\nA parametric value offset by distanceStep from parametricValue.\n\nSee Also\nAccessing and interpolating points\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByDistance: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a distance step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByParametricStep: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a parametric step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByTime: TimeInterval, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a time step.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetByTime: TimeInterval) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified time from the given parametric value.\nfunc point(at: Int) -> PKStrokePoint\nReturns the B-spline control point at an index point that you provide.\nsubscript(Int) -> PKStrokePoint\nReturns the B-spline control point the location index that you provide."
  },
  {
    "title": "point(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3566683-point",
    "html": "Parameters\ni\n\nA control point index.\n\nReturn Value\n\nThe PKStrokePointReference at control point index i.\n\nSee Also\nAccessing and interpolating points\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByDistance: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a distance step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByParametricStep: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a parametric step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByTime: TimeInterval, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a time step.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetByDistance: CGFloat) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified distance from the given parametric value.\nfunc parametricValue(CGFloat, offsetByTime: TimeInterval) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified time from the given parametric value.\nsubscript(Int) -> PKStrokePoint\nReturns the B-spline control point the location index that you provide."
  },
  {
    "title": "opacity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepointreference/3566690-opacity",
    "html": "Discussion\n\nThe opacity of a PKStrokePointReference has a range of 0-2, which is a multiplier of the ink opacity.\n\nSee Also\nGetting the point’s drawing data\nvar size: CGSize\nThe size of the point.\nvar secondaryScale: CGFloat"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595114-dropfirst",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity: O(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence.\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> DropWhileSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence by skipping the initial, consecutive elements that satisfy the given predicate.\nfunc dropLast(Int) -> [PKStrokePoint]\nReturns a sequence containing all but the given number of final elements.\nfunc prefix(Int) -> PrefixSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence, up to the specified maximum length, containing the initial elements of the sequence.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns a sequence containing the initial, consecutive elements that satisfy the given predicate.\nfunc suffix(Int) -> [PKStrokePoint]\nReturns a subsequence, up to the given maximum length, containing the final elements of the sequence."
  },
  {
    "title": "toolPickerVisibilityDidChange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpickerobserver/3229972-toolpickervisibilitydidchange",
    "html": "Parameters\ntoolPicker\n\nThe tool picker whose configuration changed.\n\nSee Also\nMonitoring Visibility Changes\nfunc toolPickerFramesObscuredDidChange(PKToolPicker)\nTells the observer that area obscured by the tool picker changed."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595130-foreach",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls.\n\nSee Also\nIterating elements\nfunc enumerated() -> EnumeratedSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc makeIterator() -> PKStrokePath.InterpolatedSlice\nReturns an iterator over the elements of this sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/4166105-filter",
    "html": "See Also\nFiltering elements\nfunc compactMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc filter((PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (PKStrokePoint) -> Bool) -> [ArraySlice<PKStrokePoint>]\nReturns the longest possible subsequences of the sequence, in order, that don’t contain elements satisfying the given predicate. Elements that are used to split the sequence are not returned as part of any subsequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595123-filter",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nFiltering elements\nfunc compactMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc filter(Predicate<PKStrokePoint>) -> [PKStrokePoint]\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (PKStrokePoint) -> Bool) -> [ArraySlice<PKStrokePoint>]\nReturns the longest possible subsequences of the sequence, in order, that don’t contain elements satisfying the given predicate. Elements that are used to split the sequence are not returned as part of any subsequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595119-enumerated",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity: O(1)\n\nSee Also\nIterating elements\nfunc forEach((PKStrokePoint) -> Void)\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc makeIterator() -> PKStrokePath.InterpolatedSlice\nReturns an iterator over the elements of this sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595160-split",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nFiltering elements\nfunc compactMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc filter((PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc filter(Predicate<PKStrokePoint>) -> [PKStrokePoint]"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595129-flatmap",
    "html": "See Also\nMapping elements\nfunc map<T>((PKStrokePoint) -> T) -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc flatMap<SegmentOfResult>((PKStrokePoint) -> SegmentOfResult) -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence."
  },
  {
    "title": "defaultWidthForInkType: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3229049-defaultwidthforinktype",
    "html": "Parameters\ninkType\n\nThe type of tool whose default line width you want.\n\nReturn Value\n\nThe default line width (in points) for the specified tool type.\n\nSee Also\nGetting the standard ink widths\n+ minimumWidthForInkType:\nReturns the minimum allowed line width for the specified tool type.\n+ maximumWidthForInkType:\nReturns the maximum allowed line width for the specified tool type."
  },
  {
    "title": "publisher | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595146-publisher",
    "html": "See Also\nGetting the slice data\nvar lazy: LazySequence<PKStrokePath.InterpolatedSlice>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the sequence, calculated nondestructively."
  },
  {
    "title": "PKInkingTool.InkType.marker | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/marker",
    "html": "See Also\nChoosing ink types\ncase pen\nAn inking tool that creates the appearance of a pen-based drawing.\ncase pencil\nAn inking tool that creates the appearance of a narrow line from a pencil.\ncase monoline\nAn inking tool that creates the appearance of a monoline pen.\ncase fountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\ncase watercolor\nAn inking tool that creates the appearance of a watercolor brush.\ncase crayon\nAn inking tool that creates the appearance of a crayon.\nvar rawValue: String\nThe raw string value of a given enumeration case."
  },
  {
    "title": "PKInkTypePen | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinktypepen",
    "html": "See Also\nGetting the tool type\ninkType\nThe tool type that determines the shape of the rendered content.\nPKInkType\nThe type that defines the shape of stroked lines.\nPKInkTypeMarker\nAn inking tool that creates the appearance of a felt-tip marker.\nPKInkTypePencil\nAn inking tool that creates the appearance of drawing with a pencil.\nPKInkTypeMonoline\nAn inking tool that creates the appearance of a monoline pen.\nPKInkTypeFountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\nPKInkTypeWatercolor\nAn inking tool that creates the appearance of a watercolor brush.\nPKInkTypeCrayon\nAn inking tool that creates the appearance of a crayon."
  },
  {
    "title": "validWidthRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/erasertype/4123237-validwidthrange",
    "html": "See Also\nGetting the width information\nvar defaultWidth: CGFloat\nThe default width for an eraser type."
  },
  {
    "title": "defaultWidth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/erasertype/4123235-defaultwidth",
    "html": "See Also\nGetting the width information\nvar validWidthRange: ClosedRange<CGFloat>\nThe valid width range for an eraser type."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/erasertype/3358570",
    "html": "Parameters\na\n\nThe first eraser type.\n\nb\n\nThe second eraser type.\n\nReturn Value\n\ntrue if the objects are equal; false if they aren’t.\n\nSee Also\nComparing eraser types\nstatic func != (PKEraserTool.EraserType, PKEraserTool.EraserType) -> Bool\nReturns a Boolean value that indicates whether the two eraser types aren’t the same.\nfunc hash(into: inout Hasher)\nGenerates hash values into a hasher structure reference that you provide.\nvar hashValue: Int\nThe hash value representing this eraser tool."
  },
  {
    "title": "PKFloatRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkfloatrange",
    "html": "Topics\nCreating a new range\n- initWithLowerBound:upperBound:\nA utility class used to contain ranges returned by the PKStroke API.\nGetting the boundaries of the range\nlowerBound\nA floating point value that represents the lower bound of the range.\nupperBound\nA floating point value that represents the upper bound of the range.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nSee Also\nCanvas\nPKCanvasView\nA view that captures Apple Pencil input and displays the rendered results in an iOS app.\nPKDrawing\nA data structure that contains the drawing information captured by a canvas view.\nPKStroke\nA class that represents the paths, boundaries and other properties of a stroke drawn on a canvas.\nPKStrokePath\nA class that captures the components of a stroke and provides methods to find and interpolate points along the stroke’s path.\nPKStrokePoint\nA class that represents the properties of a specific point along a stroke’s path.\nPKInk\nProvides a description of the creation and rendering of marks on a canvas."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595187-elementsequal",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of other.\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nSee Also\nComparing elements\nfunc compare<Comparator>(Comparator.Compared, Comparator.Compared) -> ComparisonResult\nfunc difference<C>(from: C, by: (C.Element, PKStrokePoint) -> Bool) -> CollectionDifference<PKStrokePoint>\nReturns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595180-difference",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity: Worst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements.\n\nSee Also\nComparing elements\nfunc compare<Comparator>(Comparator.Compared, Comparator.Compared) -> ComparisonResult\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (PKStrokePoint, OtherSequence.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595240-prefix",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection.\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the specified number of final elements.\nfunc prefix(through: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595182-drop",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity: O(n), where n is the length of the collection.\n\nSee Also\nApplying sequence operations to elements\nfunc dropFirst(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the specified number of final elements.\nfunc prefix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595234-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\nSee Also\nMapping elements\nfunc flatMap<SegmentOfResult>((PKStrokePoint) -> SegmentOfResult) -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nDeprecated"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595232-lexicographicallyprecedes",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of other.\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nSee Also\nApplying matching criteria to elements\nfunc allSatisfy((PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (PKStrokePoint, PossiblePrefix.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595272-split",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity: O(n), where n is the length of the collection.\n\nSee Also\nFiltering elements\nfunc compactMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc filter((PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc filter(Predicate<PKStrokePoint>) -> [PKStrokePoint]\nfunc trimmingPrefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595255-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nReducing elements\nfunc reduce<Result>(into: Result, (inout Result, PKStrokePoint) -> ()) -> Result\nReturns the result of combining the elements of the sequence using the given closure."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595193-filter",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nFiltering elements\nfunc compactMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc filter(Predicate<PKStrokePoint>) -> [PKStrokePoint]\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (PKStrokePoint) -> Bool) -> [Slice<PKStrokePath>]\nReturns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.\nfunc trimmingPrefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>"
  },
  {
    "title": "trimmingPrefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/4049359-trimmingprefix",
    "html": "See Also\nFiltering elements\nfunc compactMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc filter((PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc filter(Predicate<PKStrokePoint>) -> [PKStrokePoint]\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (PKStrokePoint) -> Bool) -> [Slice<PKStrokePath>]\nReturns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595173-compactmap",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity: O(n), where n is the length of this sequence.\n\nSee Also\nFiltering elements\nfunc filter((PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc filter(Predicate<PKStrokePoint>) -> [PKStrokePoint]\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (PKStrokePoint) -> Bool) -> [Slice<PKStrokePath>]\nReturns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.\nfunc trimmingPrefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595257-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nReducing elements\nfunc reduce<Result>(Result, (Result, PKStrokePoint) -> Result) -> Result\nReturns the result of combining the elements of the sequence using the given closure."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595189-enumerated",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity: O(1)\n\nSee Also\nIterating elements\nfunc forEach((PKStrokePoint) -> Void)\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc makeIterator() -> IndexingIterator<PKStrokePath>\nReturns an iterator over the elements of the collection."
  },
  {
    "title": "sorted(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3803000-sorted",
    "html": "See Also\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc reversed() -> ReversedCollection<PKStrokePath>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595268-sorted",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity: O(n log n), where n is the length of the sequence.\n\nSee Also\nSorting elements\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc reversed() -> ReversedCollection<PKStrokePath>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "makeIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595233-makeiterator",
    "html": "See Also\nIterating elements\nfunc enumerated() -> EnumeratedSequence<PKStrokePath>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc forEach((PKStrokePoint) -> Void)\nCalls the given closure on each element in the sequence in the same order as a for-in loop."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595261-reversed",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity: O(1)\n\nSee Also\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "PKInkTypeFountainPen | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinktypefountainpen",
    "html": "See Also\nGetting the tool type\ninkType\nThe tool type that determines the shape of the rendered content.\nPKInkType\nThe type that defines the shape of stroked lines.\nPKInkTypeMarker\nAn inking tool that creates the appearance of a felt-tip marker.\nPKInkTypePen\nAn inking tool that creates the appearance of drawing with a pen.\nPKInkTypePencil\nAn inking tool that creates the appearance of drawing with a pencil.\nPKInkTypeMonoline\nAn inking tool that creates the appearance of a monoline pen.\nPKInkTypeWatercolor\nAn inking tool that creates the appearance of a watercolor brush.\nPKInkTypeCrayon\nAn inking tool that creates the appearance of a crayon."
  },
  {
    "title": "PKStrokePath.InterpolatedSlice.Stride.distance(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/stride/distance",
    "html": "See Also\nStride types\ncase parametricStep(CGFloat)\nA stride based on a parametric step value you provide.\ncase time(TimeInterval)\nA stride based on a time interval in seconds you provide."
  },
  {
    "title": "initWithInk:width: | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3566664-initwithink",
    "html": "Parameters\nink\n\nThe shape of the tool. You may specify PKInkTypeMarker, PKInkTypePen, or PKInkTypePencil.\n\nwidth\n\nThe width of a line drawn with the tool.\n\nSee Also\nCreating an inking tool\n- initWithInkType:color:width:\nCreates an ink tool object with the specified color and line width values.\n- initWithInkType:color:\nCreates an ink tool object with the default line width and the specified color."
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3229048-color",
    "html": "Discussion\n\nThe alpha of the final color may vary due to input from Apple Pencil. For example, light pressure from Apple Pencil introduces more transparency into the final color, while additional force increases opacity to create a more solid line.\n\nSee Also\nGetting the inking tool attributes\nwidth\nThe base line width for new content.\nink\nThe ink that this tool creates strokes with."
  },
  {
    "title": "inkType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3229052-inktype",
    "html": "See Also\nGetting the tool type\nPKInkType\nThe type that defines the shape of stroked lines.\nPKInkTypeMarker\nAn inking tool that creates the appearance of a felt-tip marker.\nPKInkTypePen\nAn inking tool that creates the appearance of drawing with a pen.\nPKInkTypePencil\nAn inking tool that creates the appearance of drawing with a pencil.\nPKInkTypeMonoline\nAn inking tool that creates the appearance of a monoline pen.\nPKInkTypeFountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\nPKInkTypeWatercolor\nAn inking tool that creates the appearance of a watercolor brush.\nPKInkTypeCrayon\nAn inking tool that creates the appearance of a crayon."
  },
  {
    "title": "init(eraserType:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertoolreference/3229039-init",
    "html": "Parameters\neraserType\n\nA constant that determines how the eraser affects drawn content. For a list of possible values, see PKEraserType.\n\nReturn Value\n\nA new eraser tool object.\n\nSee Also\nCreating an eraser tool\ninit(eraserType: __PKEraserType, width: CGFloat)"
  },
  {
    "title": "defaultWidth(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertoolreference/4123101-defaultwidth",
    "html": "See Also\nGetting the width information\nvar width: CGFloat\nThe width of the eraser.\nclass func minimumWidth(for: __PKEraserType) -> CGFloat\nThe minimum width for the specified eraser type.\nclass func maximumWidth(for: __PKEraserType) -> CGFloat\nThe maximum width for the specified eraser type."
  },
  {
    "title": "init(inkType:color:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtoolreference/3229050-init",
    "html": "Parameters\ntype\n\nThe shape of the tool. You may specify PKInkTypeMarker, PKInkTypePen, or PKInkTypePencil.\n\ncolor\n\nThe color to apply to drawn lines.\n\nReturn Value\n\nA new inking tool with the specified type and color.\n\nDiscussion\n\nThis method sets the line width to the value returned by defaultWidth(forInkType:).\n\nSee Also\nCreating an inking tool\ninit(inkType: __PKInkType, color: UIColor, width: CGFloat)\nCreates an ink tool object with the specified color and line width values.\ninit(ink: PKInk, width: CGFloat)\nCreate an inking tool with the specified ink and width."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3566675-count",
    "html": "See Also\nGetting the stroke path properties\nvar creationDate: Date\nThe time at which this stroke path starts."
  },
  {
    "title": "enumerateInterpolatedPoints(in:strideByDistance:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3566676-enumerateinterpolatedpoints",
    "html": "Parameters\nrange\n\nThe parametric range to enumerate points in.\n\ndistanceStep\n\nThe distance to step between points.\n\nblock\n\nThe block to execute for each point. This block takes two parameters:\n\npoint —The interpolated point on the spline.\n\nstop —A reference to a Boolean value. Setting the value to YES within the block stops further enumeration, but the that block continues to run until it’s finished.\n\nSee Also\nAccessing and interpolating points\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByParametricStep: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a parametric step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByTime: TimeInterval, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a time step.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetByDistance: CGFloat) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified distance from the given parametric value.\nfunc parametricValue(CGFloat, offsetByTime: TimeInterval) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified time from the given parametric value.\nfunc point(at: Int) -> PKStrokePoint\nReturns the B-spline control point at an index point that you provide.\nsubscript(Int) -> PKStrokePoint\nReturns the B-spline control point the location index that you provide."
  },
  {
    "title": "init(controlPoints:creationDate:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3571379-init",
    "html": "Parameters\ncontrolPoints\n\nAn array of control points for a cubic B-spline.\n\ncreationDate\n\nThe creation time of this path. The timeOffset of points in this stroke path is relative to this date."
  },
  {
    "title": "minimumWidth(forInkType:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtoolreference/3229054-minimumwidth",
    "html": "Parameters\ninkType\n\nThe type of tool whose minimum line width you want.\n\nReturn Value\n\nThe minimum line width (in points) for the specified tool type.\n\nSee Also\nGetting the standard ink widths\nclass func defaultWidth(forInkType: __PKInkType) -> CGFloat\nReturns the default line width for the specified tool type.\nclass func maximumWidth(forInkType: __PKInkType) -> CGFloat\nReturns the maximum allowed line width for the specified tool type."
  },
  {
    "title": "maximumWidth(forInkType:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtoolreference/3229053-maximumwidth",
    "html": "Parameters\ninkType\n\nThe type of tool whose maximum line width you want.\n\nReturn Value\n\nThe maximum line width (in points) for the specified tool type.\n\nSee Also\nGetting the standard ink widths\nclass func defaultWidth(forInkType: __PKInkType) -> CGFloat\nReturns the default line width for the specified tool type.\nclass func minimumWidth(forInkType: __PKInkType) -> CGFloat\nReturns the minimum allowed line width for the specified tool type."
  },
  {
    "title": "interpolatedLocation(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference/3566680-interpolatedlocation",
    "html": "Parameters\nparametricValue\n\nThe on-curve location [0, count-1] where interpolation occurs.\n\nReturn Value\n\nA CGPoint interpolated from supplied parametricValue.\n\nSee Also\nAccessing and interpolating points\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByDistance: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a distance step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByParametricStep: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a parametric step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByTime: TimeInterval, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a time step.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetByDistance: CGFloat) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified distance from the given parametric value.\nfunc parametricValue(CGFloat, offsetByTime: TimeInterval) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified time from the given parametric value.\nfunc point(at: Int) -> PKStrokePoint\nReturns the B-spline control point at an index point that you provide.\nsubscript(Int) -> PKStrokePoint\nReturns the B-spline control point the location index that you provide."
  },
  {
    "title": "PKInkTypePencil | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinktypepencil",
    "html": "See Also\nGetting the tool type\ninkType\nThe tool type that determines the shape of the rendered content.\nPKInkType\nThe type that defines the shape of stroked lines.\nPKInkTypeMarker\nAn inking tool that creates the appearance of a felt-tip marker.\nPKInkTypePen\nAn inking tool that creates the appearance of drawing with a pen.\nPKInkTypeMonoline\nAn inking tool that creates the appearance of a monoline pen.\nPKInkTypeFountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\nPKInkTypeWatercolor\nAn inking tool that creates the appearance of a watercolor brush.\nPKInkTypeCrayon\nAn inking tool that creates the appearance of a crayon."
  },
  {
    "title": "toolPickerFramesObscuredDidChange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpickerobserver/3229969-toolpickerframesobscureddidchang",
    "html": "Parameters\ntoolPicker\n\nThe tool picker whose configuration changed.\n\nSee Also\nMonitoring Visibility Changes\nfunc toolPickerVisibilityDidChange(PKToolPicker)\nTells the observer that the user showed or hid the tool picker."
  },
  {
    "title": "toolPickerIsRulerActiveDidChange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpickerobserver/3229970-toolpickerisruleractivedidchange",
    "html": "Parameters\ntoolPicker\n\nThe tool picker whose configuration changed.\n\nSee Also\nDetecting Tool Configuration Changes\nfunc toolPickerSelectedToolDidChange(PKToolPicker)\nTells the observer that the user selected a new tool."
  },
  {
    "title": "toolPickerSelectedToolDidChange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpickerobserver/3229971-toolpickerselectedtooldidchange",
    "html": "Parameters\ntoolPicker\n\nThe tool picker whose configuration changed.\n\nSee Also\nDetecting Tool Configuration Changes\nfunc toolPickerIsRulerActiveDidChange(PKToolPicker)\nTells the observer that the user showed or hid the ruler."
  },
  {
    "title": "mask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokereference/3566669-mask",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe line properties used to render this stroke.\nvar maskedPathRanges: [__PKFloatRange]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32\nAn unsigned 32-bit integer to use as a random seed for drawing strokes that use randomized effects."
  },
  {
    "title": "init(_:color:width:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3281914-init",
    "html": "Parameters\ninkType\n\nThe shape of the tool, which can be PKInkingTool.InkType.marker, PKInkingTool.InkType.pen, or PKInkingTool.InkType.pencil.\n\ncolor\n\nThe color to apply to drawn lines.\n\nwidth\n\nThe base width to apply to any drawn lines. The value in the inkType parameter and input from Apple Pencil affects the final width.\n\nReturn Value\n\nA new inking tool with the specified type, color, and width.\n\nSee Also\nCreating an inking tool\ninit(PKInkingTool.InkType, color: NSColor, width: CGFloat?)\nCreates an ink tool object with the specified color and line width values.\ninit(ink: PKInk, width: CGFloat)\nCreate an inking tool with the specified ink and width."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595238-min",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nApplying mathematical operations on elements\nfunc max(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "init(ink:path:transform:mask:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/3595087-init",
    "html": "Parameters\nink\n\nThe PKInk the framework uses to render this stroke.\n\npath\n\nThe B-spline path that describes this stroke.\n\ntransform\n\nThe CGAffineTransform to apply to this stroke.\n\nmask\n\nThe pretransform mask the framework uses to clip the rendering of the stroke.\n\nSee Also\nCreating a stroke object\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: NSBezierPath?)\nCreates a stroke with the line properties, path, transform, and mask that you specify.\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?, randomSeed: UInt32)\nCreates a stroke with the line properties, path, transform, mask, and random seed that you specify.\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: NSBezierPath?, randomSeed: UInt32)\nCreates a macOS stroke with the line properties, path, transform, mask, and random seed that you specify."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595175-contains",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nApplying matching criteria to elements\nfunc allSatisfy((PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (PKStrokePoint, PossiblePrefix.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (PKStrokePoint, PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements."
  },
  {
    "title": "PKStrokePath.InterpolatedSlice.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/element",
    "html": "See Also\nSupporting types\ntypealias PKStrokePath.InterpolatedSlice.Iterator\nA type that provides the collection’s iteration interface and encapsulates its iteration state."
  },
  {
    "title": "Protocol implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/protocol_implementations",
    "html": "Topics\nMapping elements\nfunc map<T>((PKStrokePoint) -> T) -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc flatMap<SegmentOfResult>((PKStrokePoint) -> SegmentOfResult) -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nDeprecated\nFiltering elements\nfunc compactMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc filter((PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc filter(Predicate<PKStrokePoint>) -> [PKStrokePoint]\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (PKStrokePoint) -> Bool) -> [ArraySlice<PKStrokePoint>]\nReturns the longest possible subsequences of the sequence, in order, that don’t contain elements satisfying the given predicate. Elements that are used to split the sequence are not returned as part of any subsequence.\nReducing elements\nfunc reduce<Result>(Result, (Result, PKStrokePoint) -> Result) -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, PKStrokePoint) -> ()) -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nIterating elements\nfunc enumerated() -> EnumeratedSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc forEach((PKStrokePoint) -> Void)\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc makeIterator() -> PKStrokePath.InterpolatedSlice\nReturns an iterator over the elements of this sequence.\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc reversed() -> [PKStrokePoint]\nReturns an array containing the elements of this sequence in reverse order.\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness.\nApplying mathematical operations on elements\nfunc max(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements.\nApplying matching criteria to elements\nfunc allSatisfy((PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (PKStrokePoint, PossiblePrefix.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (PKStrokePoint, PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> DropWhileSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence by skipping the initial, consecutive elements that satisfy the given predicate.\nfunc dropFirst(Int) -> DropFirstSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> [PKStrokePoint]\nReturns a sequence containing all but the given number of final elements.\nfunc prefix(Int) -> PrefixSequence<PKStrokePath.InterpolatedSlice>\nReturns a sequence, up to the specified maximum length, containing the initial elements of the sequence.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns a sequence containing the initial, consecutive elements that satisfy the given predicate.\nfunc suffix(Int) -> [PKStrokePoint]\nReturns a subsequence, up to the given maximum length, containing the final elements of the sequence.\nSelecting specific elements\nfunc first(where: (PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc next() -> PKStrokePoint?\nComparing elements\nfunc compare<Comparator>(Comparator.Compared, Comparator.Compared) -> ComparisonResult\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (PKStrokePoint, OtherSequence.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nFormatting elements\nfunc formatted<S>(S) -> S.FormatOutput\nWorking with underlying data\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<PKStrokePoint>) -> R) -> R?\nExecutes a closure on the sequence’s contiguous storage."
  },
  {
    "title": "PKStrokePath.InterpolatedSlice.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/iterator",
    "html": "See Also\nSupporting types\ntypealias PKStrokePath.InterpolatedSlice.Element\nA type that represents the sequence’s elements."
  },
  {
    "title": "PKCanvasViewDrawingPolicy.anyInput | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasviewdrawingpolicy/anyinput",
    "html": "See Also\nDrawing policies\ncase `default`\nThe default input type to use for drawing on a canvas.\ncase pencilOnly\nPencil touches are the only input that draw on the canvas."
  },
  {
    "title": "PKCanvasViewDrawingPolicy.pencilOnly | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasviewdrawingpolicy/pencilonly",
    "html": "See Also\nDrawing policies\ncase `default`\nThe default input type to use for drawing on a canvas.\ncase anyInput\nAllows drawing on the canvas from any input source."
  },
  {
    "title": "PKInkingTool.InkType.pencil | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/pencil",
    "html": "See Also\nChoosing ink types\ncase marker\nAn inking tool that creates the appearance of a felt-tip marker.\ncase pen\nAn inking tool that creates the appearance of a pen-based drawing.\ncase monoline\nAn inking tool that creates the appearance of a monoline pen.\ncase fountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\ncase watercolor\nAn inking tool that creates the appearance of a watercolor brush.\ncase crayon\nAn inking tool that creates the appearance of a crayon.\nvar rawValue: String\nThe raw string value of a given enumeration case."
  },
  {
    "title": "canvasViewDidBeginUsingTool(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasviewdelegate/3229955-canvasviewdidbeginusingtool",
    "html": "Parameters\ncanvasView\n\nThe canvas view whose contents changed.\n\nSee Also\nResponding to new event sequences\nfunc canvasViewDidEndUsingTool(PKCanvasView)\nTells the delegate that the user ended a drawing sequence with the tool they were using."
  },
  {
    "title": "PKInkingTool.InkType.watercolor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/watercolor",
    "html": "See Also\nChoosing ink types\ncase marker\nAn inking tool that creates the appearance of a felt-tip marker.\ncase pen\nAn inking tool that creates the appearance of a pen-based drawing.\ncase pencil\nAn inking tool that creates the appearance of a narrow line from a pencil.\ncase monoline\nAn inking tool that creates the appearance of a monoline pen.\ncase fountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\ncase crayon\nAn inking tool that creates the appearance of a crayon.\nvar rawValue: String\nThe raw string value of a given enumeration case."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/3281907-hash",
    "html": "Parameters\nhasher\n\nA reference to a Hasher structure.\n\nSee Also\nComparing ink types\nstatic func != (PKInkingTool.InkType, PKInkingTool.InkType) -> Bool\nReturns a Boolean value that indicates whether the two ink types aren’t the same.\nvar hashValue: Int\nThe hash value representing this ink type."
  },
  {
    "title": "setVisible(_:forFirstResponder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3229966-setvisible",
    "html": "Parameters\nvisible\n\nA Boolean value that indicates whether to make the palette visible when responder becomes active. Specify true to show the palette when the object becomes the first responder.\n\nresponder\n\nA responder object associated with the tool picker’s window. Typically, you specify a view capable of becoming the first responder.\n\nDiscussion\n\nEach time you call this method with the visible parameter set to true, the tool picker adds responder to a list of objects to monitor. When any object in the list becomes the first responder, the tool picker displays the palette. Calling this method with the visible parameter set to false removes responder from the list of monitored objects.\n\nSee Also\nCoordinating the visibility of the picker\nvar isVisible: Bool\nA Boolean value that indicates whether the tool picker is currently visible.\nfunc frameObscured(in: UIView) -> CGRect\nReturns the portion of the specified view that the tool picker obscures."
  },
  {
    "title": "selectedTool | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3335021-selectedtool",
    "html": "Discussion\n\nThis is one of the available tools associated with a PKCanvasView that adopt the PKTool protocol.\n\nSee Also\nGetting the tool configuration\nvar colorUserInterfaceStyle: UIUserInterfaceStyle\nThe user interface style for this tool picker.\nvar isRulerActive: Bool\nA Boolean value that indicates whether the ruler is visible on the canvas.\nvar overrideUserInterfaceStyle: UIUserInterfaceStyle\nThe specific user interface style to apply to this tool picker.\nvar showsDrawingPolicyControls: Bool\nA Boolean value that indicates whether the default drawing policy UI is visible.\nvar stateAutosaveName: String?\nThe name used to automatically save the tool picker’s state in the defaults system."
  },
  {
    "title": "frameObscured(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3229961-frameobscured",
    "html": "Parameters\nview\n\nThe view that’s potentially obscured by the tool picker’s palette.\n\nReturn Value\n\nThe portion of view (in its own coordinate space) obscured by the palette.\n\nDiscussion\n\nBecause the palette is transparent in places, part of your view’s content may continue to show through in the specified rectangle.\n\nSee Also\nCoordinating the visibility of the picker\nfunc setVisible(Bool, forFirstResponder: UIResponder)\nSets the visibility for the tool picker, based on when the specified responder object becomes active.\nvar isVisible: Bool\nA Boolean value that indicates whether the tool picker is currently visible."
  },
  {
    "title": "showsDrawingPolicyControls | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3552394-showsdrawingpolicycontrols",
    "html": "See Also\nGetting the tool configuration\nvar selectedTool: PKTool\nThe currently selected tool in this tool picker.\nvar colorUserInterfaceStyle: UIUserInterfaceStyle\nThe user interface style for this tool picker.\nvar isRulerActive: Bool\nA Boolean value that indicates whether the ruler is visible on the canvas.\nvar overrideUserInterfaceStyle: UIUserInterfaceStyle\nThe specific user interface style to apply to this tool picker.\nvar stateAutosaveName: String?\nThe name used to automatically save the tool picker’s state in the defaults system."
  },
  {
    "title": "isRulerActive | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3229964-isruleractive",
    "html": "See Also\nGetting the tool configuration\nvar selectedTool: PKTool\nThe currently selected tool in this tool picker.\nvar colorUserInterfaceStyle: UIUserInterfaceStyle\nThe user interface style for this tool picker.\nvar overrideUserInterfaceStyle: UIUserInterfaceStyle\nThe specific user interface style to apply to this tool picker.\nvar showsDrawingPolicyControls: Bool\nA Boolean value that indicates whether the default drawing policy UI is visible.\nvar stateAutosaveName: String?\nThe name used to automatically save the tool picker’s state in the defaults system."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/erasertype/3281897",
    "html": "Parameters\nlhs\n\nThe first eraser type.\n\nrhs\n\nThe second eraser type.\n\nReturn Value\n\ntrue if the objects aren’t equal or false if they are.\n\nSee Also\nComparing eraser types\nstatic func == (PKEraserTool.EraserType, PKEraserTool.EraserType) -> Bool\nReturns a Boolean value that indicates whether the two eraser types are the same.\nfunc hash(into: inout Hasher)\nGenerates hash values into a hasher structure reference that you provide.\nvar hashValue: Int\nThe hash value representing this eraser tool."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595297-withcontiguousstorageifavailable",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively.\n\nNote\n\nThis documentation comment was inherited from Sequence."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595206-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance.\n\nSee Also\nWorking with element indices\nfunc firstIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc lastIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc index(Int, offsetBy: Int, limitedBy: Int) -> Int?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Int, offsetBy: Int, limitedBy: Int) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Int)\nReplaces the given index with its successor.\nfunc formIndex(before: inout Int)\nReplaces the given index with its predecessor."
  },
  {
    "title": "compare(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3802998-compare",
    "html": "See Also\nComparing elements\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (PKStrokePoint, OtherSequence.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc difference<C>(from: C, by: (C.Element, PKStrokePoint) -> Bool) -> CollectionDifference<PKStrokePoint>\nReturns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595207-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance.\n\nSee Also\nWorking with element indices\nfunc firstIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc lastIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc index(Int, offsetBy: Int, limitedBy: Int) -> Int?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Int, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(after: inout Int)\nReplaces the given index with its successor.\nfunc formIndex(before: inout Int)\nReplaces the given index with its predecessor."
  },
  {
    "title": "rulerActive | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasview/3229952-ruleractive",
    "html": "See Also\nConfiguring the drawing environment\ntool\nThe currently selected tool used for drawing.\nallowsFingerDrawing\nA Boolean value that indicates whether the canvas accepts input from the user’s finger in addition to Apple Pencil.\nDeprecated\ndrawingPolicy\nThe policy that controls the types of touches allowed when drawing on the canvas.\nPKCanvasViewDrawingPolicy\nConstants that you use to specify the type of drawing gestures your app permits while the user draws on the canvas."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595209-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nDiscussion\n\nNote\n\nThis documentation comment was inherited from BidirectionalCollection.\n\nSee Also\nWorking with element indices\nfunc firstIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc lastIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc index(Int, offsetBy: Int, limitedBy: Int) -> Int?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Int, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Int, offsetBy: Int, limitedBy: Int) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Int)\nReplaces the given index with its successor."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595212-index",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity: O(1)\n\nSee Also\nWorking with element indices\nfunc firstIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc lastIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc formIndex(inout Int, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Int, offsetBy: Int, limitedBy: Int) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Int)\nReplaces the given index with its successor.\nfunc formIndex(before: inout Int)\nReplaces the given index with its predecessor."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595208-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nSee Also\nWorking with element indices\nfunc firstIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc lastIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc index(Int, offsetBy: Int, limitedBy: Int) -> Int?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Int, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Int, offsetBy: Int, limitedBy: Int) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(before: inout Int)\nReplaces the given index with its predecessor."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595229-lastindex",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity: O(n), where n is the length of the collection.\n\nSee Also\nWorking with element indices\nfunc firstIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc index(Int, offsetBy: Int, limitedBy: Int) -> Int?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Int, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Int, offsetBy: Int, limitedBy: Int) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Int)\nReplaces the given index with its successor.\nfunc formIndex(before: inout Int)\nReplaces the given index with its predecessor."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595199-firstindex",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity: O(n), where n is the length of the collection.\n\nSee Also\nWorking with element indices\nfunc lastIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc index(Int, offsetBy: Int, limitedBy: Int) -> Int?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Int, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Int, offsetBy: Int, limitedBy: Int) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Int)\nReplaces the given index with its successor.\nfunc formIndex(before: inout Int)\nReplaces the given index with its predecessor."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595253-randomelement",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift.\n\nSee Also\nSelecting specific elements\nfunc first(where: (PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc last(where: (PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc randomElement() -> PKStrokePoint?\nReturns a random element of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595251-randomelement",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nSee Also\nSelecting specific elements\nfunc first(where: (PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc last(where: (PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc randomElement<T>(using: inout T) -> PKStrokePoint?\nReturns a random element of the collection, using the given generator as a source for randomness."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595183-dropfirst",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection.\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropLast(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the specified number of final elements.\nfunc prefix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595227-last",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity: O(n), where n is the length of the collection.\n\nSee Also\nSelecting specific elements\nfunc first(where: (PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc randomElement() -> PKStrokePoint?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> PKStrokePoint?\nReturns a random element of the collection, using the given generator as a source for randomness."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595185-droplast",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop.\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the given number of initial elements.\nfunc prefix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595249-prefix",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity: O(n), where n is the length of the collection.\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the specified number of final elements.\nfunc prefix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc suffix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595292-suffix",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity: O(1)\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the specified number of final elements.\nfunc prefix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595290-suffix",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength.\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the specified number of final elements.\nfunc prefix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(from: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595242-prefix",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity: O(1)\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the specified number of final elements.\nfunc prefix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(upTo: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595245-prefix",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity: O(1)\n\nSee Also\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the specified number of final elements.\nfunc prefix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595203-flatmap",
    "html": "See Also\nMapping elements\nfunc map<T>((PKStrokePoint) -> T) -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc flatMap<SegmentOfResult>((PKStrokePoint) -> SegmentOfResult) -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/4166106-filter",
    "html": "See Also\nFiltering elements\nfunc compactMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc filter((PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (PKStrokePoint) -> Bool) -> [Slice<PKStrokePath>]\nReturns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.\nfunc trimmingPrefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>"
  },
  {
    "title": "sorted(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3802999-sorted",
    "html": "See Also\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc reversed() -> ReversedCollection<PKStrokePath>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595204-foreach",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls.\n\nSee Also\nIterating elements\nfunc enumerated() -> EnumeratedSequence<PKStrokePath>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc makeIterator() -> IndexingIterator<PKStrokePath>\nReturns an iterator over the elements of the collection."
  },
  {
    "title": "shared(for:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3229967-shared",
    "html": "Parameters\nwindow\n\nA window of your app.\n\nReturn Value\n\nThe tool picker associated with the window, or nil if an error occurred.\n\nDiscussion\n\nCall this method when you want to retrieve the tool picker assigned to one of your app’s windows. If the specified window doesn’t yet have a tool picker, this method creates and associates it with that window."
  },
  {
    "title": "inkType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkreference/3566648-inktype",
    "html": "See Also\nGetting the ink attributes\nvar color: UIColor\nThe base color for this ink."
  },
  {
    "title": "PKInkType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinktype",
    "html": "See Also\nGetting the tool type\ninkType\nThe tool type that determines the shape of the rendered content.\nPKInkTypeMarker\nAn inking tool that creates the appearance of a felt-tip marker.\nPKInkTypePen\nAn inking tool that creates the appearance of drawing with a pen.\nPKInkTypePencil\nAn inking tool that creates the appearance of drawing with a pencil.\nPKInkTypeMonoline\nAn inking tool that creates the appearance of a monoline pen.\nPKInkTypeFountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\nPKInkTypeWatercolor\nAn inking tool that creates the appearance of a watercolor brush.\nPKInkTypeCrayon\nAn inking tool that creates the appearance of a crayon."
  },
  {
    "title": "randomSeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokereference/4076576-randomseed",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe line properties used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [__PKFloatRange]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3552393-init",
    "html": "Discussion\n\nCall this method to create a new tool picker. To retrieve the tool picker assigned to one of your app’s windows call shared(for:)."
  },
  {
    "title": "path | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokereference/3566671-path",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe line properties used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [__PKFloatRange]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32\nAn unsigned 32-bit integer to use as a random seed for drawing strokes that use randomized effects."
  },
  {
    "title": "transform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokereference/3566673-transform",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe line properties used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [__PKFloatRange]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar randomSeed: UInt32\nAn unsigned 32-bit integer to use as a random seed for drawing strokes that use randomized effects."
  },
  {
    "title": "renderBounds | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokereference/3566672-renderbounds",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe line properties used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [__PKFloatRange]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32\nAn unsigned 32-bit integer to use as a random seed for drawing strokes that use randomized effects."
  },
  {
    "title": "maskedPathRanges | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokereference/3566670-maskedpathranges",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe line properties used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32\nAn unsigned 32-bit integer to use as a random seed for drawing strokes that use randomized effects."
  },
  {
    "title": "init(ink:strokePath:transform:mask:randomSeed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokereference/4076575-init",
    "html": "Parameters\nink\n\nThe PKInkReference used to render this stroke.\n\nstrokePath\n\nThe B-spline path that describes this stroke.\n\ntransform\n\nThe CGAffineTransform to apply to this stroke. Defaults to CGAffineTransformIdentity.\n\nmask\n\nThe pretransform mask used to clip the rendering of the stroke.\n\nrandomSeed\n\nThe random seed for the stroke.\n\nSee Also\nCreating a stroke object\ninit(ink: PKInk, strokePath: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?)\nCreates a stroke with the line properties, path, transform, and mask that you specify."
  },
  {
    "title": "init(ink:strokePath:transform:mask:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokereference/3566667-init",
    "html": "Parameters\nink\n\nThe PKInkReference the class uses to render this stroke.\n\nstrokePath\n\nThe B-spline path that describes this stroke.\n\ntransform\n\nThe CGAffineTransform to apply to this stroke. Defaults to CGAffineTransformIdentity.\n\nmask\n\nThe pretransform mask the class uses to clip the rendering of the stroke.\n\nSee Also\nCreating a stroke object\ninit(ink: PKInk, strokePath: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?, randomSeed: UInt32)\nCreates a stroke with the line properties, path, transform, mask, and random seed that you specify."
  },
  {
    "title": "ink | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokereference/3566668-ink",
    "html": "See Also\nGetting the stroke properties\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [__PKFloatRange]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32\nAn unsigned 32-bit integer to use as a random seed for drawing strokes that use randomized effects."
  },
  {
    "title": "size | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepointreference/3566691-size",
    "html": "See Also\nGetting the point’s drawing data\nvar opacity: CGFloat\nOpacity of the point.\nvar secondaryScale: CGFloat"
  },
  {
    "title": "secondaryScale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepointreference/4195368-secondaryscale",
    "html": "See Also\nGetting the point’s drawing data\nvar size: CGSize\nThe size of the point.\nvar opacity: CGFloat\nOpacity of the point."
  },
  {
    "title": "timeOffset | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepointreference/3566692-timeoffset",
    "html": "See Also\nGetting the point’s location\nvar location: CGPoint\nThe location of this point."
  },
  {
    "title": "location | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepointreference/3566689-location",
    "html": "See Also\nGetting the point’s location\nvar timeOffset: TimeInterval\nThe time offset since the start of the stroke path in seconds."
  },
  {
    "title": "init(location:timeOffset:size:opacity:force:azimuth:altitude:secondaryScale:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepointreference/4195367-init",
    "html": "See Also\nCreating a stroke point object\ninit(location: CGPoint, timeOffset: TimeInterval, size: CGSize, opacity: CGFloat, force: CGFloat, azimuth: CGFloat, altitude: CGFloat)\nCreates a new point with the provided properties."
  },
  {
    "title": "PKStrokePath.InterpolatedSlice.Stride | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/stride",
    "html": "Topics\nStride types\ncase distance(CGFloat)\nA stride based on a distance between elements you provide.\ncase parametricStep(CGFloat)\nA stride based on a parametric step value you provide.\ncase time(TimeInterval)\nA stride based on a time interval in seconds you provide."
  },
  {
    "title": "maximumSupportedContentVersion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/4195369-maximumsupportedcontentversion",
    "html": "Discussion\n\nThe default value is latest.\n\nIf you set this property to a value less than latest, the tool picker limits the tools that are available so they’re compatible with the version of PencilKit you specify.\n\nIf you set this property, also set maximumSupportedContentVersion on the PKCanvasView you use."
  },
  {
    "title": "PKEraserToolReference | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertoolreference",
    "html": "Overview\n\nA PKEraserTool object supports the deletion of content from a PKCanvasView object. The eraser tool’s type determines whether the canvas removes entire items or just the portion of an item that it touches.\n\nCreate an eraser tool programmatically or display a PKToolPicker object and let the user select the eraser. Assign the resulting object to the tool property of your PKCanvasView object. The canvas uses any subsequent touch sequences to erase content on the canvas.\n\nTopics\nCreating an eraser tool\ninit(eraserType: __PKEraserType)\nCreates an eraser tool object that removes objects wholly or partially from a canvas view.\ninit(eraserType: __PKEraserType, width: CGFloat)\nGetting the eraser type\nvar eraserType: __PKEraserType\nThe behavior adopted by the eraser when deleting content.\nGetting the width information\nvar width: CGFloat\nThe width of the eraser.\nclass func defaultWidth(for: __PKEraserType) -> CGFloat\nThe default width for the specified eraser type.\nclass func minimumWidth(for: __PKEraserType) -> CGFloat\nThe minimum width for the specified eraser type.\nclass func maximumWidth(for: __PKEraserType) -> CGFloat\nThe maximum width for the specified eraser type."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/erasertype/3358572-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing eraser types\nstatic func == (PKEraserTool.EraserType, PKEraserTool.EraserType) -> Bool\nReturns a Boolean value that indicates whether the two eraser types are the same.\nstatic func != (PKEraserTool.EraserType, PKEraserTool.EraserType) -> Bool\nReturns a Boolean value that indicates whether the two eraser types aren’t the same.\nfunc hash(into: inout Hasher)\nGenerates hash values into a hasher structure reference that you provide."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/3281895",
    "html": "Parameters\nlhs\n\nThe first eraser tool.\n\nrhs\n\nThe second eraser tool.\n\nReturn Value\n\ntrue if the objects aren’t equal; false if they are.\n\nSee Also\nComparing eraser tools\nstatic func == (PKEraserTool, PKEraserTool) -> Bool\nReturns a Boolean value that indicates whether the two eraser tools are the same.\nfunc hash(into: inout Hasher)\nGenerates hash values into a hasher structure reference that you provide.\nvar hashValue: Int\nThe hash value representing this eraser tool."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/3358569",
    "html": "Parameters\na\n\nThe first eraser tool.\n\nb\n\nThe second eraser tool.\n\nReturn Value\n\ntrue if the objects are equal; false if they aren’t.\n\nSee Also\nComparing eraser tools\nstatic func != (PKEraserTool, PKEraserTool) -> Bool\nReturns a Boolean value that indicates whether the two eraser tools aren’t the same.\nfunc hash(into: inout Hasher)\nGenerates hash values into a hasher structure reference that you provide.\nvar hashValue: Int\nThe hash value representing this eraser tool."
  },
  {
    "title": "PKEraserTool.EraserType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/erasertype",
    "html": "Topics\nEraser types\ncase vector\nAn eraser that removes an entire drawn line.\ncase bitmap\nAn eraser that removes only those portions of the drawing it touches.\ncase fixedWidthBitmap\nGetting the width information\nvar defaultWidth: CGFloat\nThe default width for an eraser type.\nvar validWidthRange: ClosedRange<CGFloat>\nThe valid width range for an eraser type.\nComparing eraser types\nstatic func == (PKEraserTool.EraserType, PKEraserTool.EraserType) -> Bool\nReturns a Boolean value that indicates whether the two eraser types are the same.\nstatic func != (PKEraserTool.EraserType, PKEraserTool.EraserType) -> Bool\nReturns a Boolean value that indicates whether the two eraser types aren’t the same.\nfunc hash(into: inout Hasher)\nGenerates hash values into a hasher structure reference that you provide.\nvar hashValue: Int\nThe hash value representing this eraser tool.\nSee Also\nGetting the eraser type\nvar eraserType: PKEraserTool.EraserType\nThe behavior adopted by the eraser when deleting content."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595236-max",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nApplying mathematical operations on elements\nfunc min(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595171-allsatisfy",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nApplying matching criteria to elements\nfunc contains(where: (PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (PKStrokePoint, PossiblePrefix.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (PKStrokePoint, PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595266-shuffled",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift.\n\nSee Also\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc reversed() -> ReversedCollection<PKStrokePath>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595264-shuffled",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity: O(n), where n is the length of the sequence.\n\nSee Also\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc reversed() -> ReversedCollection<PKStrokePath>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "width | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtoolreference/3229055-width",
    "html": "Discussion\n\nThe actual line width at any given point varies based on input from Apple Pencil. For finger-based drawing, the line width is equal to the value in this property.\n\nSee Also\nGetting the inking tool attributes\nvar color: UIColor\nThe color of the ink.\nvar ink: PKInk\nThe ink that this tool creates strokes with."
  },
  {
    "title": "PKInkingToolReference | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtoolreference",
    "html": "Overview\n\nA PKInkingTool object supports the creation of new content on a PKCanvasView. With an inking tool, the canvas turns touch input from the user into a continuously rendered stroke. The value in the width property determines the base width of that stroke; however, that base value also depends on input from Apple Pencil, including force, azimuth, and angle data.\n\nCreate an inking tool programmatically, or display a PKToolPicker object and from which a user can select a tool. Assign the resulting object to the tool property of your PKCanvasView object. The canvas uses any subsequent touch sequences to draw new content on the canvas. Assigning a new inking tool doesn’t change the characteristics for any previously drawn strokes.\n\nTopics\nCreating an inking tool\ninit(inkType: __PKInkType, color: UIColor, width: CGFloat)\nCreates an ink tool object with the specified color and line width values.\ninit(inkType: __PKInkType, color: UIColor)\nCreates an ink tool object with the default line width and the specified color.\ninit(ink: PKInk, width: CGFloat)\nCreate an inking tool with the specified ink and width.\nGetting the inking tool attributes\nvar color: UIColor\nThe color of the ink.\nvar width: CGFloat\nThe base line width for new content.\nvar ink: PKInk\nThe ink that this tool creates strokes with.\nGetting the tool type\nvar inkType: __PKInkType\nThe tool type that determines the shape of the rendered content.\nWorking with colors\nclass func convert(UIColor, from: UIUserInterfaceStyle, to: UIUserInterfaceStyle) -> UIColor\nConverts a color from one user interface style to another.\nGetting the standard ink widths\nclass func defaultWidth(forInkType: __PKInkType) -> CGFloat\nReturns the default line width for the specified tool type.\nclass func minimumWidth(forInkType: __PKInkType) -> CGFloat\nReturns the minimum allowed line width for the specified tool type.\nclass func maximumWidth(forInkType: __PKInkType) -> CGFloat\nReturns the maximum allowed line width for the specified tool type.\nSupporting backward compatibility\nvar requiredContentVersion: PKContentVersion\nThe version of PencilKit necessary to use the inking tool."
  },
  {
    "title": "lazy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595132-lazy",
    "html": "See Also\nGetting the slice data\nvar publisher: Publishers.Sequence<PKStrokePath.InterpolatedSlice, Never>\nA publisher of interpolated slices of stroke path elements.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the sequence, calculated nondestructively."
  },
  {
    "title": "convertColor(_:from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3368183-convertcolor",
    "html": "Parameters\ncolor\n\nThe color to convert.\n\nfrom\n\nThe user interface style to convert the color from.\n\nto\n\nThe user interface style to convert the color to.\n\nReturn Value\n\nA UIColor from the user interface style specified in the to parameter."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pklassotool/3358577",
    "html": "Parameters\na\n\nThe first lasso tool.\n\nb\n\nThe second lasso tool.\n\nReturn Value\n\ntrue if the objects are equal; false if they aren’t.\n\nSee Also\nComparing lasso tools\nstatic func != (PKLassoTool, PKLassoTool) -> Bool\nReturns a Boolean value that indicates whether the two lasso tools are equivalent."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice/3595167-underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity: O(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount.\n\nSee Also\nGetting the slice data\nvar lazy: LazySequence<PKStrokePath.InterpolatedSlice>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.\nvar publisher: Publishers.Sequence<PKStrokePath.InterpolatedSlice, Never>\nA publisher of interpolated slices of stroke path elements."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pklassotool/3281919-init",
    "html": "Return Value\n\nA new lasso tool."
  },
  {
    "title": "dataRepresentation() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawingreference/3229030-datarepresentation",
    "html": "Return Value\n\nA new NSData object that contains the entire contents of the drawing.\n\nSee Also\nGetting the drawing data\nvar strokes: [PKStroke]\nAn array of strokes used to represent the drawing.\nlet PKAppleDrawingTypeIdentifier: CFString\nThe uniform type identifier for data associated with a drawing object."
  },
  {
    "title": "applying(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawingreference/3229032-applying",
    "html": "Parameters\ntransform\n\nThe transform to apply to the drawing.\n\nReturn Value\n\nA new drawing created by applying the specified transform to the current object.\n\nSee Also\nModifying the drawing\nfunc appendingStrokes([PKStroke]) -> PKDrawing\nReturns a copy of the current drawing with the strokes you provide appended.\nfunc appending(PKDrawing) -> PKDrawing\nReturns a new drawing created by appending the current drawing with another drawing you provide."
  },
  {
    "title": "appendingStrokes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawingreference/3566637-appendingstrokes",
    "html": "Parameters\nstrokes\n\nAn array of strokes to append to this drawing.\n\nReturn Value\n\nA new drawing created by appending the provided strokes to the current drawing.\n\nSee Also\nModifying the drawing\nfunc applying(CGAffineTransform) -> PKDrawing\nReturns a new drawing object by applying the specified transform to a copy of the current object’s contents.\nfunc appending(PKDrawing) -> PKDrawing\nReturns a new drawing created by appending the current drawing with another drawing you provide."
  },
  {
    "title": "appending(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawingreference/3229031-appending",
    "html": "Parameters\ndrawing\n\nA drawing object that contains additional content.\n\nReturn Value\n\nA new drawing created by merging the content from the current object with the content in the drawing parameter.\n\nSee Also\nModifying the drawing\nfunc applying(CGAffineTransform) -> PKDrawing\nReturns a new drawing object by applying the specified transform to a copy of the current object’s contents.\nfunc appendingStrokes([PKStroke]) -> PKDrawing\nReturns a copy of the current drawing with the strokes you provide appended."
  },
  {
    "title": "image(from:scale:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawingreference/3237277-image",
    "html": "Parameters\nrect\n\nThe portion of the drawing that you want to capture. Specify a rectangle in the canvas' coordinate system.\n\nscale\n\nThe scale factor at which to create the image. Specifying scale factors greater than 1.0 creates an image with more detail. For example, you might specify a scale factor of 2.0 or 3.0 when displaying the image on a Retina display.\n\nReturn Value\n\nA new image object that contains the rendered content.\n\nDiscussion\n\nThis method creates a new image and renders content from the canvas into that image at the specified scale factor."
  },
  {
    "title": "strokes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawingreference/3566639-strokes",
    "html": "See Also\nGetting the drawing data\nfunc dataRepresentation() -> Data\nReturns a representation of the rendered content as data.\nlet PKAppleDrawingTypeIdentifier: CFString\nThe uniform type identifier for data associated with a drawing object."
  },
  {
    "title": "init(strokes:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawingreference/3566638-init",
    "html": "Parameters\nstrokes\n\nAn array of PKStrokeReference elements.\n\nSee Also\nCreating a drawing object\ninit(data: Data)\nCreates a drawing object and populates it with previously drawn content.\ninit()\nCreates an empty drawing object."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawingreference/3229034-init",
    "html": "Return Value\n\nA new canvas object that doesn’t contain any data.\n\nSee Also\nCreating a drawing object\ninit(data: Data)\nCreates a drawing object and populates it with previously drawn content.\ninit(strokes: [PKStroke])\nCreates a drawing object with the strokes you supply."
  },
  {
    "title": "init(data:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawingreference/3229035-init",
    "html": "Parameters\ndata\n\nThe initial data to add to the canvas. Only specify data you previously obtained from a canvas view.\n\nerror\n\nOn input, a variable to use for storing an error. If an error occurs, the initializer replaces this parameter with an NSError object that contains information about the error that occurred. Specify nil to ignore errors.\n\nReturn Value\n\nA new canvas object initialized with the specified data.\n\nSee Also\nCreating a drawing object\ninit(strokes: [PKStroke])\nCreates a drawing object with the strokes you supply.\ninit()\nCreates an empty drawing object."
  },
  {
    "title": "PKCanvasViewDrawingPolicy.default | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasviewdrawingpolicy/default",
    "html": "Discussion\n\nBy default, if the tool picker is visible, respect the pencil interaction setting of the prefersPencilOnlyDrawing property; otherwise only accept input from Apple Pencil.\n\nSee Also\nDrawing policies\ncase anyInput\nAllows drawing on the canvas from any input source.\ncase pencilOnly\nPencil touches are the only input that draw on the canvas."
  },
  {
    "title": "canvasViewDidFinishRendering(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasviewdelegate/3229957-canvasviewdidfinishrendering",
    "html": "Parameters\ncanvasView\n\nThe canvas view whose contents changed.\n\nDiscussion\n\nThe PKCanvasView object calls this method when you assign a new drawing to its drawing property, when the user zooms in on the canvas, or when the canvas scrolls.\n\nSee Also\nResponding to drawing-related changes\nfunc canvasViewDrawingDidChange(PKCanvasView)\nTells the delegate that the contents of the current drawing changed."
  },
  {
    "title": "PKInkingTool.InkType.pen | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/pen",
    "html": "See Also\nChoosing ink types\ncase marker\nAn inking tool that creates the appearance of a felt-tip marker.\ncase pencil\nAn inking tool that creates the appearance of a narrow line from a pencil.\ncase monoline\nAn inking tool that creates the appearance of a monoline pen.\ncase fountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\ncase watercolor\nAn inking tool that creates the appearance of a watercolor brush.\ncase crayon\nAn inking tool that creates the appearance of a crayon.\nvar rawValue: String\nThe raw string value of a given enumeration case."
  },
  {
    "title": "canvasViewDrawingDidChange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasviewdelegate/3229958-canvasviewdrawingdidchange",
    "html": "Parameters\ncanvasView\n\nThe canvas view whose contents changed.\n\nSee Also\nResponding to drawing-related changes\nfunc canvasViewDidFinishRendering(PKCanvasView)\nTells the delegate that the previously drawn content is ready to display."
  },
  {
    "title": "init(rawValue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/3358575-init",
    "html": "Parameters\nrawValue\n\nThe string equivalent of one of the cases from the PKInkingTool.InkType enumeration.\n\nRelationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating ink types\ntypealias PKInkingTool.InkType.RawValue\nThe raw type to represent values of the ink type."
  },
  {
    "title": "PKInkingTool.InkType.RawValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/rawvalue",
    "html": "See Also\nCreating ink types\ninit?(rawValue: String)\nCreate a new ink type using a string."
  },
  {
    "title": "PKContentVersion.version2 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcontentversion/version2",
    "html": "See Also\nSpecific versions\ncase version1\nThe PencilKit version that supports inks from iPadOS 14 and earlier, including marker, pen, and pencil."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/3281908-hashvalue",
    "html": "See Also\nComparing ink types\nstatic func != (PKInkingTool.InkType, PKInkingTool.InkType) -> Bool\nReturns a Boolean value that indicates whether the two ink types aren’t the same.\nfunc hash(into: inout Hasher)\nGenerates hash values into a hasher structure reference that you provide."
  },
  {
    "title": "stateAutosaveName | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3552395-stateautosavename",
    "html": "See Also\nGetting the tool configuration\nvar selectedTool: PKTool\nThe currently selected tool in this tool picker.\nvar colorUserInterfaceStyle: UIUserInterfaceStyle\nThe user interface style for this tool picker.\nvar isRulerActive: Bool\nA Boolean value that indicates whether the ruler is visible on the canvas.\nvar overrideUserInterfaceStyle: UIUserInterfaceStyle\nThe specific user interface style to apply to this tool picker.\nvar showsDrawingPolicyControls: Bool\nA Boolean value that indicates whether the default drawing policy UI is visible."
  },
  {
    "title": "overrideUserInterfaceStyle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3335020-overrideuserinterfacestyle",
    "html": "Discussion\n\nIf you set this property, consider if you need to set colorUserInterfaceStyle to a select a different user interface style. The default user interface style is UIUserInterfaceStyle.unspecified.\n\nSee Also\nGetting the tool configuration\nvar selectedTool: PKTool\nThe currently selected tool in this tool picker.\nvar colorUserInterfaceStyle: UIUserInterfaceStyle\nThe user interface style for this tool picker.\nvar isRulerActive: Bool\nA Boolean value that indicates whether the ruler is visible on the canvas.\nvar showsDrawingPolicyControls: Bool\nA Boolean value that indicates whether the default drawing policy UI is visible.\nvar stateAutosaveName: String?\nThe name used to automatically save the tool picker’s state in the defaults system."
  },
  {
    "title": "colorUserInterfaceStyle | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3335019-coloruserinterfacestyle",
    "html": "See Also\nGetting the tool configuration\nvar selectedTool: PKTool\nThe currently selected tool in this tool picker.\nvar isRulerActive: Bool\nA Boolean value that indicates whether the ruler is visible on the canvas.\nvar overrideUserInterfaceStyle: UIUserInterfaceStyle\nThe specific user interface style to apply to this tool picker.\nvar showsDrawingPolicyControls: Bool\nA Boolean value that indicates whether the default drawing policy UI is visible.\nvar stateAutosaveName: String?\nThe name used to automatically save the tool picker’s state in the defaults system."
  },
  {
    "title": "removeObserver(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3229963-removeobserver",
    "html": "Parameters\nobserver\n\nThe object to stop sending notifications to.\n\nSee Also\nDetecting changes to the picker\nfunc addObserver(PKToolPickerObserver)\nAdds the specified object to the list of objects to notify when the picker configuration changes.\nprotocol PKToolPickerObserver\nAn interface you use to detect when the user changes the selected tools and drawing characteristics of a tool picker object."
  },
  {
    "title": "isVisible | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3229962-isvisible",
    "html": "See Also\nCoordinating the visibility of the picker\nfunc setVisible(Bool, forFirstResponder: UIResponder)\nSets the visibility for the tool picker, based on when the specified responder object becomes active.\nfunc frameObscured(in: UIView) -> CGRect\nReturns the portion of the specified view that the tool picker obscures."
  },
  {
    "title": "init(location:timeOffset:size:opacity:force:azimuth:altitude:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepoint/3595302-init",
    "html": "Parameters\nlocation\n\nThe location of this point.\n\ntimeOffset\n\nThe time offset since the start of this stoke path in seconds.\n\nsize\n\nThe size of this point.\n\nopacity\n\nThe opacity of this point, ranging from 0 to 2.\n\nforce\n\nThe amount of force used to create this point.\n\nazimuth\n\nThe azimuth of this point in radians.\n\naltitude\n\nThe altitude of this point in radians.\n\nSee Also\nCreating a stroke point object\ninit(location: CGPoint, timeOffset: TimeInterval, size: CGSize, opacity: CGFloat, force: CGFloat, azimuth: CGFloat, altitude: CGFloat, secondaryScale: CGFloat)"
  },
  {
    "title": "PKStrokePathReference | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepathreference",
    "html": "Topics\nCreating a new stroke path\ninit(controlPoints: [PKStrokePoint], creationDate: Date)\nCreates a stroke path with the cubic B-spline control points and a date that you specify.\nGetting the stroke path properties\nvar count: Int\nThe number of control points in this stroke path.\nvar creationDate: Date\nThe time at which this stroke path starts.\nAccessing and interpolating points\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByDistance: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a distance step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByParametricStep: CGFloat, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a parametric step.\nfunc enumerateInterpolatedPoints(in: __PKFloatRange, strideByTime: TimeInterval, using: (PKStrokePoint, UnsafeMutablePointer<ObjCBool>) -> Void)\nExecutes a given block using each point in a range with a time step.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetByDistance: CGFloat) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified distance from the given parametric value.\nfunc parametricValue(CGFloat, offsetByTime: TimeInterval) -> CGFloat\nReturns a parametric value on the B-spline that’s a specified time from the given parametric value.\nfunc point(at: Int) -> PKStrokePoint\nReturns the B-spline control point at an index point that you provide.\nsubscript(Int) -> PKStrokePoint\nReturns the B-spline control point the location index that you provide.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying"
  },
  {
    "title": "PKStrokePath.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/subsequence",
    "html": "See Also\nSupporting types\nstruct PKStrokePath.InterpolatedSlice\nA struct representing an interpolated slice of stroke points with a specific stride across a range of this stroke data.\ntypealias PKStrokePath.Element\nA type that represents the sequence’s elements.\ntypealias PKStrokePath.Index\nA type that represents a position in the collection.\ntypealias PKStrokePath.Indices\nA type that represents the indices that are valid for subscripting the collection, in ascending order.\ntypealias PKStrokePath.Iterator\nA type that provides the collection’s iteration interface and encapsulates its iteration state."
  },
  {
    "title": "PKStrokePath.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/index",
    "html": "See Also\nSupporting types\nstruct PKStrokePath.InterpolatedSlice\nA struct representing an interpolated slice of stroke points with a specific stride across a range of this stroke data.\ntypealias PKStrokePath.Element\nA type that represents the sequence’s elements.\ntypealias PKStrokePath.Indices\nA type that represents the indices that are valid for subscripting the collection, in ascending order.\ntypealias PKStrokePath.Iterator\nA type that provides the collection’s iteration interface and encapsulates its iteration state.\ntypealias PKStrokePath.SubSequence\nA type that represents a contiguous subrange of this collection’s elements."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595282-subscript",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity: O(1)\n\nSee Also\nAccessing and interpolating points\nfunc interpolatedPoints(in: ClosedRange<CGFloat>?, by: PKStrokePath.InterpolatedSlice.Stride) -> PKStrokePath.InterpolatedSlice\nReturns the slice on-curve points using the floating point range and stride that you specify.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetBy: PKStrokePath.InterpolatedSlice.Stride) -> CGFloat\nsubscript(PKStrokePath.Index) -> PKStrokePoint\nAccess the stroke point at the provided index.\nsubscript((UnboundedRange_) -> ()) -> Slice<PKStrokePath>\nsubscript(Range<Int>) -> Slice<PKStrokePath>\nAccesses a contiguous subrange of the collection’s elements."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3281879-encode",
    "html": "Parameters\nencoder\n\nAn encoder that conforms to the Encoder protocol.\n\nRelationships\nFrom Protocol\nEncodable"
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595225-last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity: O(1)\n\nSee Also\nGetting the stroke path properties\nvar count: Int\nThe number of elements in the collection.\nvar creationDate: Date\nThe creation date and time of this stroke path.\nvar endIndex: Int\nThe index of the last item in the collection.\nvar first: PKStrokePoint?\nThe first element of the collection.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar startIndex: Int\nThe index of the first item in the collection.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection."
  },
  {
    "title": "creationDate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595179-creationdate",
    "html": "See Also\nGetting the stroke path properties\nvar count: Int\nThe number of elements in the collection.\nvar endIndex: Int\nThe index of the last item in the collection.\nvar first: PKStrokePoint?\nThe first element of the collection.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar last: PKStrokePoint?\nThe last element of the collection.\nvar startIndex: Int\nThe index of the first item in the collection.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection."
  },
  {
    "title": "image(from:scale:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3281880-image",
    "html": "Parameters\nrect\n\nThe portion of the drawing that you want to capture. Specify a rectangle in the canvas' coordinate system.\n\nscale\n\nThe scale factor at which to create the image. Specifying scale factors greater than 1.0 creates an image with more detail. For example, you might specify a scale factor of 2.0 or 3.0 when displaying the image on a Retina display.\n\nReturn Value\n\nA new image object that contains the rendered content.\n\nDiscussion\n\nThis method creates a new image and renders content from the canvas into that image at the specified scale factor.\n\nSee Also\nGenerating an image\nfunc image(from: CGRect, scale: CGFloat) -> UIImage\nReturns an image object that contains the specified portion of the drawing."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3358573",
    "html": "Parameters\na\n\nThe first inking tool.\n\nb\n\nThe second inking tool.\n\nReturn Value\n\ntrue if the objects are equal; false if they aren’t.\n\nSee Also\nComparing inking tool types\nstatic func != (PKInkingTool, PKInkingTool) -> Bool\nReturns a Boolean value that indicates whether the two inking tools aren’t equivalent.\nstatic func != (PKInkingTool.InkType, PKInkingTool.InkType) -> Bool\nReturns a Boolean value that indicates whether the two ink types aren’t the same."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3281903",
    "html": "Parameters\nlhs\n\nThe first inking tool.\n\nrhs\n\nThe second inking tool.\n\nReturn Value\n\ntrue if the objects aren’t equal; false if they are equal.\n\nSee Also\nComparing inking tool types\nstatic func == (PKInkingTool, PKInkingTool) -> Bool\nReturns a Boolean value that indicates whether the two inking tools are the same.\nstatic func != (PKInkingTool.InkType, PKInkingTool.InkType) -> Bool\nReturns a Boolean value that indicates whether the two ink types aren’t the same."
  },
  {
    "title": "PKToolPickerObserver | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpickerobserver",
    "html": "Overview\n\nImplement the methods of PKToolPickerObserver to detect when the user changes the configuration of a PKToolPicker view. Each time the user changes the selected tool or other drawing characteristics, the tool picker notifies any registered observers. You use these notifications to update the configuration of the underlying canvas.\n\nTo register an observer with a tool picker, call the addObserver(_:) method of the PKToolPicker object.\n\nTopics\nDetecting Tool Configuration Changes\nfunc toolPickerSelectedToolDidChange(PKToolPicker)\nTells the observer that the user selected a new tool.\nfunc toolPickerIsRulerActiveDidChange(PKToolPicker)\nTells the observer that the user showed or hid the ruler.\nMonitoring Visibility Changes\nfunc toolPickerVisibilityDidChange(PKToolPicker)\nTells the observer that the user showed or hid the tool picker.\nfunc toolPickerFramesObscuredDidChange(PKToolPicker)\nTells the observer that area obscured by the tool picker changed.\nRelationships\nInherits From\nNSObjectProtocol\nConforming Types\nPKCanvasView\nSee Also\nDetecting changes to the picker\nfunc addObserver(PKToolPickerObserver)\nAdds the specified object to the list of objects to notify when the picker configuration changes.\nfunc removeObserver(PKToolPickerObserver)\nRemoves the specified object from the list of objects to notify when the picker configuration changes."
  },
  {
    "title": "init(strokes:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3595077-init",
    "html": "Parameters\nstrokes\n\nA sequence of PKStroke elements.\n\nSee Also\nCreating a drawing object\ninit(data: Data)\nCreates a drawing object and populates it with previously drawn content.\ninit()\nCreates an empty drawing object.\ninit(from: Decoder)\nCreates a drawing object and populates it with previously drawn content stored on disk."
  },
  {
    "title": "init(inkType:color:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkreference/3566647-init",
    "html": "Parameters\ntype\n\nThe type of ink to create, from one of the available PKInkType enumerations.\n\ncolor\n\nThe base color for this ink."
  },
  {
    "title": "ink | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3595085-ink",
    "html": "See Also\nGetting the inking tool attributes\nvar color: UIColor\nThe color of the ink.\nvar color: NSColor\nThe color of the ink.\nvar width: CGFloat\nThe width of the ink.\nvar rawValue: String\nThe raw string value of a given enumeration case."
  },
  {
    "title": "image(from:scale:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3281893-image",
    "html": "Parameters\nrect\n\nThe portion of the drawing that you want to capture. Specify a rectangle in the canvas' coordinate system.\n\nscale\n\nThe scale factor at which to create the image. Specifying scale factors greater than 1.0 creates an image with more detail. For example, you might specify a scale factor of 2.0 or 3.0 when displaying the image on a Retina display.\n\nReturn Value\n\nA new image object that contains the rendered content.\n\nDiscussion\n\nThis method creates a new image and renders content from the canvas into that image at the specified scale factor.\n\nSee Also\nGenerating an image\nfunc image(from: CGRect, scale: CGFloat) -> NSImage\nReturns an image object that contains the specified portion of the drawing."
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkreference/3566645-color",
    "html": "See Also\nGetting the ink attributes\nvar inkType: __PKInkType\nThe type of ink, such as pen or pencil, as defined in the PKInkType enumeration."
  },
  {
    "title": "init(data:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3281882-init",
    "html": "Parameters\ndata\n\nThe initial data to add to the canvas. Only specify data you previously obtained from a canvas view.\n\nReturn Value\n\nA new canvas object initialized with the specified data.\n\nSee Also\nCreating a drawing object\ninit<S>(strokes: S)\nCreates a drawing object and populates it with a sequence of strokes the user provides.\ninit()\nCreates an empty drawing object.\ninit(from: Decoder)\nCreates a drawing object and populates it with previously drawn content stored on disk."
  },
  {
    "title": "addObserver(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker/3229960-addobserver",
    "html": "Parameters\nobserver\n\nThe object to notify when changes occur.\n\nSee Also\nDetecting changes to the picker\nfunc removeObserver(PKToolPickerObserver)\nRemoves the specified object from the list of objects to notify when the picker configuration changes.\nprotocol PKToolPickerObserver\nAn interface you use to detect when the user changes the selected tools and drawing characteristics of a tool picker object."
  },
  {
    "title": "rawValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/3358576-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nChoosing ink types\ncase marker\nAn inking tool that creates the appearance of a felt-tip marker.\ncase pen\nAn inking tool that creates the appearance of a pen-based drawing.\ncase pencil\nAn inking tool that creates the appearance of a narrow line from a pencil.\ncase monoline\nAn inking tool that creates the appearance of a monoline pen.\ncase fountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\ncase watercolor\nAn inking tool that creates the appearance of a watercolor brush.\ncase crayon\nAn inking tool that creates the appearance of a crayon."
  },
  {
    "title": "defaultWidth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/3281906-defaultwidth",
    "html": "See Also\nGetting the width information\nvar validWidthRange: ClosedRange<CGFloat>\nThe range of widths allowed for an ink of this type."
  },
  {
    "title": "width | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3281916-width",
    "html": "Discussion\n\nThe actual line width at any given point varies based on input from Apple Pencil. For finger-based drawing, the line width is equal to the value in this property.\n\nSee Also\nGetting the inking tool attributes\nvar color: UIColor\nThe color of the ink.\nvar color: NSColor\nThe color of the ink.\nvar rawValue: String\nThe raw string value of a given enumeration case.\nvar ink: PKInk\nThe ink used by this inking tool."
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3603650-color",
    "html": "See Also\nGetting the inking tool attributes\nvar color: UIColor\nThe color of the ink.\nvar width: CGFloat\nThe width of the ink.\nvar rawValue: String\nThe raw string value of a given enumeration case.\nvar ink: PKInk\nThe ink used by this inking tool."
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3281913-color",
    "html": "Discussion\n\nThe alpha of the final color may vary due to input from Apple Pencil. For example, light pressure from Apple Pencil introduces more transparency into the final color, while additional force increases opacity to create a more solid line.\n\nSee Also\nGetting the inking tool attributes\nvar color: NSColor\nThe color of the ink.\nvar width: CGFloat\nThe width of the ink.\nvar rawValue: String\nThe raw string value of a given enumeration case.\nvar ink: PKInk\nThe ink used by this inking tool."
  },
  {
    "title": "init(ink:width:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3595084-init",
    "html": "Parameters\nink\n\nThe shape of the tool, which can be PKInkTypeMarker, PKInkTypePen, or PKInkTypePencil.\n\nwidth\n\nThe width of a line drawn with the tool.\n\nSee Also\nCreating an inking tool\ninit(PKInkingTool.InkType, color: UIColor, width: CGFloat?)\nCreates an ink tool object with the specified color and line width values.\ninit(PKInkingTool.InkType, color: NSColor, width: CGFloat?)\nCreates an ink tool object with the specified color and line width values."
  },
  {
    "title": "init(_:color:width:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3603651-init",
    "html": "Parameters\ninkType\n\nThe shape of the tool, which can be PKInkingTool.InkType.marker, PKInkingTool.InkType.pen, or PKInkingTool.InkType.pencil.\n\ncolor\n\nThe color to apply to drawn lines.\n\nwidth\n\nThe base width to apply to any drawn lines. The value in the inkType parameter and input from Apple Pencil affects the final width.\n\nSee Also\nCreating an inking tool\ninit(PKInkingTool.InkType, color: UIColor, width: CGFloat?)\nCreates an ink tool object with the specified color and line width values.\ninit(ink: PKInk, width: CGFloat)\nCreate an inking tool with the specified ink and width."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/3281905",
    "html": "Parameters\nlhs\n\nThe first ink type.\n\nrhs\n\nThe second ink type.\n\nReturn Value\n\ntrue if the objects aren’t equal; false if they are.\n\nSee Also\nComparing ink types\nfunc hash(into: inout Hasher)\nGenerates hash values into a hasher structure reference that you provide.\nvar hashValue: Int\nThe hash value representing this ink type."
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkink/3603648-color",
    "html": "See Also\nGetting the ink attributes\nvar color: UIColor\nThe color of this ink.\nvar inkType: PKInk.InkType\nThe line presentation to use for this Ink."
  },
  {
    "title": "color | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkink/3595081-color",
    "html": "See Also\nGetting the ink attributes\nvar color: NSColor\nThe color of this ink.\nvar inkType: PKInk.InkType\nThe line presentation to use for this Ink."
  },
  {
    "title": "altitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepointreference/3566685-altitude",
    "html": "See Also\nGetting the point’s touch data\nvar azimuth: CGFloat\nThe azimuth of this point in radians.\nvar force: CGFloat\nThe amount of force applied by the touch."
  },
  {
    "title": "azimuth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepointreference/3566686-azimuth",
    "html": "See Also\nGetting the point’s touch data\nvar altitude: CGFloat\nThe altitude of this point in radians.\nvar force: CGFloat\nThe amount of force applied by the touch."
  },
  {
    "title": "force | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepointreference/3566687-force",
    "html": "Discussion\n\nThis is a value predetermined by the system and isn’t user specific. A value of 1.0 represents the force of an average touch.\n\nSee Also\nGetting the point’s touch data\nvar altitude: CGFloat\nThe altitude of this point in radians.\nvar azimuth: CGFloat\nThe azimuth of this point in radians."
  },
  {
    "title": "PKInk.InkType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkink/inktype",
    "html": "See Also\nCreating an ink object\ninit(PKInk.InkType, color: UIColor)\nCreates a new ink, specifying its type and color.\ninit(PKInk.InkType, color: NSColor)\nCreates a new ink, specifying its type and color."
  },
  {
    "title": "init(_:color:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkink/3603649-init",
    "html": "Parameters\ninkType\n\nThe type of ink represented by one of the available PKInkingTool.InkType enumerations.\n\ncolor\n\nThe color of the ink, defaults to black.\n\nSee Also\nCreating an ink object\ninit(PKInk.InkType, color: UIColor)\nCreates a new ink, specifying its type and color.\ntypealias PKInk.InkType\nA type alias referring to the ink type of an inking tool."
  },
  {
    "title": "init(_:color:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkink/3595082-init",
    "html": "Parameters\ninkType\n\nThe type of ink represented by one of the available PKInkingTool.InkType enumerations.\n\ncolor\n\nThe color of the ink; the default is black.\n\nSee Also\nCreating an ink object\ninit(PKInk.InkType, color: NSColor)\nCreates a new ink, specifying its type and color.\ntypealias PKInk.InkType\nA type alias referring to the ink type of an inking tool."
  },
  {
    "title": "init(location:timeOffset:size:opacity:force:azimuth:altitude:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepointreference/3566688-init",
    "html": "Parameters\nlocation\n\nThe location of this point.\n\ntimeOffset\n\nThe time offset since the start of this stoke path in seconds.\n\nsize\n\nThe size of this point.\n\nopacity\n\nThe opacity of this point, ranging from 0 to 2.\n\nforce\n\nThe amount of force used to create this point.\n\nazimuth\n\nThe azimuth of this point in radians.\n\naltitude\n\nThe altitude of this point in radians.\n\nSee Also\nCreating a stroke point object\ninit(location: CGPoint, timeOffset: TimeInterval, size: CGSize, opacity: CGFloat, force: CGFloat, azimuth: CGFloat, altitude: CGFloat, secondaryScale: CGFloat)"
  },
  {
    "title": "randomSeed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/4113996-randomseed",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe Ink, which is a combination of a tool used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar mask: NSBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [ClosedRange<CGFloat>]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering."
  },
  {
    "title": "renderBounds | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/3595092-renderbounds",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe Ink, which is a combination of a tool used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar mask: NSBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [ClosedRange<CGFloat>]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32"
  },
  {
    "title": "path | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/3595091-path",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe Ink, which is a combination of a tool used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar mask: NSBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [ClosedRange<CGFloat>]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32"
  },
  {
    "title": "maskedPathRanges | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/3595090-maskedpathranges",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe Ink, which is a combination of a tool used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar mask: NSBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32"
  },
  {
    "title": "mask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/3603653-mask",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe Ink, which is a combination of a tool used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [ClosedRange<CGFloat>]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32"
  },
  {
    "title": "init(ink:path:transform:mask:randomSeed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/4077545-init",
    "html": "Parameters\nink\n\nThe PKInkReference the framework uses to render this stroke.\n\npath\n\nThe B-spline path that describes this stroke.\n\ntransform\n\nThe CGAffineTransform to apply to this stroke. Defaults to CGAffineTransformIdentity.\n\nmask\n\nThe pretransform mask the framework uses to clip the rendering of the stroke.\n\nrandomSeed\n\nThe random seed for the stroke.\n\nSee Also\nCreating a stroke object\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?)\nCreates a stroke with the line properties, path, transform, and mask that you specify.\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: NSBezierPath?)\nCreates a stroke with the line properties, path, transform, and mask that you specify.\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: NSBezierPath?, randomSeed: UInt32)\nCreates a macOS stroke with the line properties, path, transform, mask, and random seed that you specify."
  },
  {
    "title": "init(ink:path:transform:mask:randomSeed:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/4077865-init",
    "html": "Parameters\nink\n\nThe PKInkReference the framework uses to render this stroke.\n\npath\n\nThe B-spline path that describes this stroke.\n\ntransform\n\nThe CGAffineTransform to apply to this stroke. Defaults to CGAffineTransformIdentity.\n\nmask\n\nThe pretransform mask the framework uses to clip the rendering of the stroke.\n\nrandomSeed\n\nThe random seed for the stroke.\n\nSee Also\nCreating a stroke object\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?)\nCreates a stroke with the line properties, path, transform, and mask that you specify.\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: NSBezierPath?)\nCreates a stroke with the line properties, path, transform, and mask that you specify.\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?, randomSeed: UInt32)\nCreates a stroke with the line properties, path, transform, mask, and random seed that you specify."
  },
  {
    "title": "mask | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/3595089-mask",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe Ink, which is a combination of a tool used to render this stroke.\nvar mask: NSBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [ClosedRange<CGFloat>]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32"
  },
  {
    "title": "ink | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/3595088-ink",
    "html": "See Also\nGetting the stroke properties\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar mask: NSBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [ClosedRange<CGFloat>]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32"
  },
  {
    "title": "init(ink:path:transform:mask:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/3603652-init",
    "html": "Parameters\nink\n\nThe PKInk the framework uses to render this stroke.\n\npath\n\nThe B-spline path that describes this stroke.\n\ntransform\n\nThe CGAffineTransform to apply to this stroke.\n\nmask\n\nThe pretransform mask the framework uses to clip the rendering of the stroke.\n\nSee Also\nCreating a stroke object\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?)\nCreates a stroke with the line properties, path, transform, and mask that you specify.\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?, randomSeed: UInt32)\nCreates a stroke with the line properties, path, transform, mask, and random seed that you specify.\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: NSBezierPath?, randomSeed: UInt32)\nCreates a macOS stroke with the line properties, path, transform, mask, and random seed that you specify."
  },
  {
    "title": "opacity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepoint/3595304-opacity",
    "html": "Discussion\n\nThe opacity of a PKStrokePoint has a range of 0-2, which is a multiplier of the PKInk opacity.\n\nSee Also\nGetting the point’s drawing data\nvar size: CGSize\nThe size of this point.\nvar secondaryScale: CGFloat"
  },
  {
    "title": "secondaryScale | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepoint/4195917-secondaryscale",
    "html": "See Also\nGetting the point’s drawing data\nvar size: CGSize\nThe size of this point.\nvar opacity: CGFloat\nOpacity of the point."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/erasertype/3358571-hash",
    "html": "Parameters\nhasher\n\nA reference to a Hasher structure.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing eraser types\nstatic func == (PKEraserTool.EraserType, PKEraserTool.EraserType) -> Bool\nReturns a Boolean value that indicates whether the two eraser types are the same.\nstatic func != (PKEraserTool.EraserType, PKEraserTool.EraserType) -> Bool\nReturns a Boolean value that indicates whether the two eraser types aren’t the same.\nvar hashValue: Int\nThe hash value representing this eraser tool."
  },
  {
    "title": "eraserType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/3281900-erasertype",
    "html": "See Also\nGetting the eraser type\nenum PKEraserTool.EraserType\nConstants that indicate the behavior of the eraser."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/3281901-init",
    "html": "Parameters\neraserType\n\nA constant that determines how the eraser affects drawn content. For a list of possible values, see PKEraserTool.EraserType.\n\nReturn Value\n\nA new eraser tool object.\n\nSee Also\nCreating an eraser tool\ninit(PKEraserTool.EraserType, width: CGFloat)\nCreates an eraser tool object with the specified width."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pklassotool/3281918",
    "html": "Parameters\nlhs\n\nThe first lasso tool.\n\nrhs\n\nThe second lasso tool.\n\nReturn Value\n\ntrue if the objects aren’t equal ; false if they are.\n\nSee Also\nComparing lasso tools\nstatic func == (PKLassoTool, PKLassoTool) -> Bool\nReturns a Boolean value that indicates whether the two lasso tools are equivalent."
  },
  {
    "title": "init(_:width:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool/4123238-init",
    "html": "See Also\nCreating an eraser tool\ninit(PKEraserTool.EraserType)\nCreates an eraser tool object that removes objects wholly or partially from a canvas view."
  },
  {
    "title": "PKLassoToolReference | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pklassotoolreference",
    "html": "Overview\n\nA PKLassoToolReference object supports the selection of content on a PKCanvasView. When active, the canvas uses incoming touch events to determine what content to add to the selection.\n\nCreate a lasso tool programmatically or display a PKToolPicker object from which the user selects the tool. Assign the resulting object to the tool property of your PKCanvasView object. The canvas uses any subsequent touch sequences to select content on the canvas.\n\nTopics\nCreating a lasso tool\ninit()\nCreates a lasso tool object for selecting content on a canvas view."
  },
  {
    "title": "tool | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasview/3229953-tool",
    "html": "See Also\nConfiguring the drawing environment\nrulerActive\nA Boolean value that indicates whether a ruler view is visible on the canvas.\nallowsFingerDrawing\nA Boolean value that indicates whether the canvas accepts input from the user’s finger in addition to Apple Pencil.\nDeprecated\ndrawingPolicy\nThe policy that controls the types of touches allowed when drawing on the canvas.\nPKCanvasViewDrawingPolicy\nConstants that you use to specify the type of drawing gestures your app permits while the user draws on the canvas."
  },
  {
    "title": "size | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepoint/3595305-size",
    "html": "See Also\nGetting the point’s drawing data\nvar opacity: CGFloat\nOpacity of the point.\nvar secondaryScale: CGFloat"
  },
  {
    "title": "altitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepoint/3595299-altitude",
    "html": "See Also\nGetting the point’s touch data\nvar azimuth: CGFloat\nThe azimuth of this point in radians.\nvar force: CGFloat\nThe amount of force applied by the touch."
  },
  {
    "title": "azimuth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepoint/3595300-azimuth",
    "html": "See Also\nGetting the point’s touch data\nvar altitude: CGFloat\nThe altitude of this point in radians.\nvar force: CGFloat\nThe amount of force applied by the touch."
  },
  {
    "title": "location | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepoint/3595303-location",
    "html": "See Also\nGetting the point’s location\nvar timeOffset: TimeInterval\nThe time offset since the start of the stroke path in seconds."
  },
  {
    "title": "timeOffset | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepoint/3595306-timeoffset",
    "html": "See Also\nGetting the point’s location\nvar location: CGPoint\nThe location of this point."
  },
  {
    "title": "Protocol implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/protocol_implementations",
    "html": "Topics\nMapping elements\nfunc map<T>((PKStrokePoint) -> T) -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc flatMap<SegmentOfResult>((PKStrokePoint) -> SegmentOfResult) -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nDeprecated\nFiltering elements\nfunc compactMap<ElementOfResult>((PKStrokePoint) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc filter((PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc filter(Predicate<PKStrokePoint>) -> [PKStrokePoint]\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (PKStrokePoint) -> Bool) -> [Slice<PKStrokePath>]\nReturns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.\nfunc trimmingPrefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReducing elements\nfunc reduce<Result>(Result, (Result, PKStrokePoint) -> Result) -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, PKStrokePoint) -> ()) -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nIterating elements\nfunc enumerated() -> EnumeratedSequence<PKStrokePath>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc forEach((PKStrokePoint) -> Void)\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc makeIterator() -> IndexingIterator<PKStrokePath>\nReturns an iterator over the elements of the collection.\nSorting elements\nfunc sorted(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> [PKStrokePoint]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [PKStrokePoint]\nfunc sorted<S, Comparator>(using: S) -> [PKStrokePoint]\nfunc reversed() -> ReversedCollection<PKStrokePath>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffled() -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [PKStrokePoint]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness.\nApplying mathematical operations on elements\nfunc max(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min(by: (PKStrokePoint, PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements.\nApplying matching criteria to elements\nfunc allSatisfy((PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (PKStrokePoint, PossiblePrefix.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (PKStrokePoint, PKStrokePoint) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.\nApplying sequence operations to elements\nfunc drop(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Slice<PKStrokePath>\nReturns a subsequence containing all but the specified number of final elements.\nfunc prefix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (PKStrokePoint) -> Bool) -> Slice<PKStrokePath>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Slice<PKStrokePath>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Int) -> Slice<PKStrokePath>\nReturns a subsequence from the specified position to the end of the collection.\nSelecting specific elements\nfunc first(where: (PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc last(where: (PKStrokePoint) -> Bool) -> PKStrokePoint?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc randomElement() -> PKStrokePoint?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> PKStrokePoint?\nReturns a random element of the collection, using the given generator as a source for randomness.\nWorking with element indices\nfunc firstIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc lastIndex(where: (PKStrokePoint) -> Bool) -> Int?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc index(Int, offsetBy: Int, limitedBy: Int) -> Int?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Int, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Int, offsetBy: Int, limitedBy: Int) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Int)\nReplaces the given index with its successor.\nfunc formIndex(before: inout Int)\nReplaces the given index with its predecessor.\nComparing elements\nfunc compare<Comparator>(Comparator.Compared, Comparator.Compared) -> ComparisonResult\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (PKStrokePoint, OtherSequence.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc difference<C>(from: C, by: (C.Element, PKStrokePoint) -> Bool) -> CollectionDifference<PKStrokePoint>\nReturns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test.\nFormatting elements\nfunc formatted<S>(S) -> S.FormatOutput\nWorking with underlying data\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<PKStrokePoint>) -> R) -> R?\nExecutes a closure on the sequence’s contiguous storage."
  },
  {
    "title": "PKStrokePath.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/iterator",
    "html": "See Also\nSupporting types\nstruct PKStrokePath.InterpolatedSlice\nA struct representing an interpolated slice of stroke points with a specific stride across a range of this stroke data.\ntypealias PKStrokePath.Element\nA type that represents the sequence’s elements.\ntypealias PKStrokePath.Index\nA type that represents a position in the collection.\ntypealias PKStrokePath.Indices\nA type that represents the indices that are valid for subscripting the collection, in ascending order.\ntypealias PKStrokePath.SubSequence\nA type that represents a contiguous subrange of this collection’s elements."
  },
  {
    "title": "PKStrokePath.InterpolatedSlice | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/interpolatedslice",
    "html": "Topics\nGetting the slice data\nvar lazy: LazySequence<PKStrokePath.InterpolatedSlice>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.\nvar publisher: Publishers.Sequence<PKStrokePath.InterpolatedSlice, Never>\nA publisher of interpolated slices of stroke path elements.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the sequence, calculated nondestructively.\nTraversing slices\nenum PKStrokePath.InterpolatedSlice.Stride\nThe stride between elements of this slice.\nSupporting types\ntypealias PKStrokePath.InterpolatedSlice.Element\nA type that represents the sequence’s elements.\ntypealias PKStrokePath.InterpolatedSlice.Iterator\nA type that provides the collection’s iteration interface and encapsulates its iteration state.\nSupporting protocol requirements\nProtocol implementations\nAccess the interpolated slice’s implementations of protocol methods.\nRelationships\nConforms To\nIteratorProtocol\nSequence\nSee Also\nSupporting types\ntypealias PKStrokePath.Element\nA type that represents the sequence’s elements.\ntypealias PKStrokePath.Index\nA type that represents a position in the collection.\ntypealias PKStrokePath.Indices\nA type that represents the indices that are valid for subscripting the collection, in ascending order.\ntypealias PKStrokePath.Iterator\nA type that provides the collection’s iteration interface and encapsulates its iteration state.\ntypealias PKStrokePath.SubSequence\nA type that represents a contiguous subrange of this collection’s elements."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595288-subscript",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity: O(1)\n\nSee Also\nAccessing and interpolating points\nfunc interpolatedPoints(in: ClosedRange<CGFloat>?, by: PKStrokePath.InterpolatedSlice.Stride) -> PKStrokePath.InterpolatedSlice\nReturns the slice on-curve points using the floating point range and stride that you specify.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetBy: PKStrokePath.InterpolatedSlice.Stride) -> CGFloat\nsubscript(PKStrokePath.Index) -> PKStrokePoint\nAccess the stroke point at the provided index.\nsubscript<R>(R) -> Slice<PKStrokePath>\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Slice<PKStrokePath>"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595281-subscript",
    "html": "Relationships\nFrom Protocol\nBidirectionalCollection\nCollection\nRandomAccessCollection\nSee Also\nAccessing and interpolating points\nfunc interpolatedPoints(in: ClosedRange<CGFloat>?, by: PKStrokePath.InterpolatedSlice.Stride) -> PKStrokePath.InterpolatedSlice\nReturns the slice on-curve points using the floating point range and stride that you specify.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetBy: PKStrokePath.InterpolatedSlice.Stride) -> CGFloat\nsubscript<R>(R) -> Slice<PKStrokePath>\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Slice<PKStrokePath>\nsubscript(Range<Int>) -> Slice<PKStrokePath>\nAccesses a contiguous subrange of the collection’s elements."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595286-subscript",
    "html": "See Also\nAccessing and interpolating points\nfunc interpolatedPoints(in: ClosedRange<CGFloat>?, by: PKStrokePath.InterpolatedSlice.Stride) -> PKStrokePath.InterpolatedSlice\nReturns the slice on-curve points using the floating point range and stride that you specify.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetBy: PKStrokePath.InterpolatedSlice.Stride) -> CGFloat\nsubscript(PKStrokePath.Index) -> PKStrokePoint\nAccess the stroke point at the provided index.\nsubscript<R>(R) -> Slice<PKStrokePath>\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript(Range<Int>) -> Slice<PKStrokePath>\nAccesses a contiguous subrange of the collection’s elements."
  },
  {
    "title": "interpolatedLocation(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595220-interpolatedlocation",
    "html": "Parameters\nparametricValue\n\nThe on-curve location [0, count-1] where interpolation occurs.\n\nReturn Value\n\nA CGPoint interpolated from the supplied parametricValue.\n\nSee Also\nAccessing and interpolating points\nfunc interpolatedPoints(in: ClosedRange<CGFloat>?, by: PKStrokePath.InterpolatedSlice.Stride) -> PKStrokePath.InterpolatedSlice\nReturns the slice on-curve points using the floating point range and stride that you specify.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetBy: PKStrokePath.InterpolatedSlice.Stride) -> CGFloat\nsubscript(PKStrokePath.Index) -> PKStrokePoint\nAccess the stroke point at the provided index.\nsubscript<R>(R) -> Slice<PKStrokePath>\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Slice<PKStrokePath>\nsubscript(Range<Int>) -> Slice<PKStrokePath>\nAccesses a contiguous subrange of the collection’s elements."
  },
  {
    "title": "interpolatedPoints(in:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595222-interpolatedpoints",
    "html": "Parameters\nrange\n\nThe floating point range for the points of interest.\n\nstride\n\nThe stride component of the current slice.\n\nReturn Value\n\nAn interpolated slice whose points are within the specified range.\n\nSee Also\nAccessing and interpolating points\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetBy: PKStrokePath.InterpolatedSlice.Stride) -> CGFloat\nsubscript(PKStrokePath.Index) -> PKStrokePoint\nAccess the stroke point at the provided index.\nsubscript<R>(R) -> Slice<PKStrokePath>\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Slice<PKStrokePath>\nsubscript(Range<Int>) -> Slice<PKStrokePath>\nAccesses a contiguous subrange of the collection’s elements."
  },
  {
    "title": "publisher | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595250-publisher",
    "html": "See Also\nGetting the stroke path data\nvar lazy: LazySequence<PKStrokePath>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595276-startindex",
    "html": "Relationships\nFrom Protocol\nBidirectionalCollection\nCollection\nRandomAccessCollection\nSee Also\nGetting the stroke path properties\nvar count: Int\nThe number of elements in the collection.\nvar creationDate: Date\nThe creation date and time of this stroke path.\nvar endIndex: Int\nThe index of the last item in the collection.\nvar first: PKStrokePoint?\nThe first element of the collection.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar last: PKStrokePoint?\nThe last element of the collection.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595178-count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nSee Also\nGetting the stroke path properties\nvar creationDate: Date\nThe creation date and time of this stroke path.\nvar endIndex: Int\nThe index of the last item in the collection.\nvar first: PKStrokePoint?\nThe first element of the collection.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar last: PKStrokePoint?\nThe last element of the collection.\nvar startIndex: Int\nThe index of the first item in the collection.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection."
  },
  {
    "title": "lazy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595231-lazy",
    "html": "See Also\nGetting the stroke path data\nvar publisher: Publishers.Sequence<PKStrokePath, Never>\nA publisher of stroke path sequences."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595195-first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n\nSee Also\nGetting the stroke path properties\nvar count: Int\nThe number of elements in the collection.\nvar creationDate: Date\nThe creation date and time of this stroke path.\nvar endIndex: Int\nThe index of the last item in the collection.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar last: PKStrokePoint?\nThe last element of the collection.\nvar startIndex: Int\nThe index of the first item in the collection.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595188-endindex",
    "html": "Relationships\nFrom Protocol\nBidirectionalCollection\nCollection\nRandomAccessCollection\nSee Also\nGetting the stroke path properties\nvar count: Int\nThe number of elements in the collection.\nvar creationDate: Date\nThe creation date and time of this stroke path.\nvar first: PKStrokePoint?\nThe first element of the collection.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar last: PKStrokePoint?\nThe last element of the collection.\nvar startIndex: Int\nThe index of the first item in the collection.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection."
  },
  {
    "title": "appending(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3281876-appending",
    "html": "Parameters\ntoAppend\n\nA drawing object that contains additional content.\n\nReturn Value\n\nA new drawing created by merging the content from the current object with the content in the drawing parameter.\n\nSee Also\nModifying the drawing\nfunc transform(using: CGAffineTransform)\nApplies the specified transform to the contents of this drawing.\nfunc transformed(using: CGAffineTransform) -> PKDrawing\nApplies the specified transform and returns a new drawing.\nfunc append(PKDrawing)\nAppends the contents of the specified drawing object to an existing drawing object that you provide."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595223-isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity: O(1)\n\nSee Also\nGetting the stroke path properties\nvar count: Int\nThe number of elements in the collection.\nvar creationDate: Date\nThe creation date and time of this stroke path.\nvar endIndex: Int\nThe index of the last item in the collection.\nvar first: PKStrokePoint?\nThe first element of the collection.\nvar last: PKStrokePoint?\nThe last element of the collection.\nvar startIndex: Int\nThe index of the first item in the collection.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection."
  },
  {
    "title": "init(controlPoints:creationDate:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595219-init",
    "html": "Parameters\ncontrolPoints\n\nAn array of control points for a cubic B-spline.\n\ncreationDate\n\nThe creation time of this path. The timeOffset of points in this stroke path is relative to this date.\n\nSee Also\nCreating a new stroke path\ninit()\nCreates an empty stroke path."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3281874",
    "html": "Parameters\nlhs\n\nThe first drawing object.\n\nrhs\n\nThe second drawing object.\n\nReturn Value\n\nReturns true if the objects aren’t equal, or false if they are.\n\nSee Also\nComparing drawing objects\nstatic func == (PKDrawing, PKDrawing) -> Bool\nReturns a Boolean value that indicates whether the two drawing objects are equivalent."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3358556",
    "html": "Parameters\na\n\nThe first drawing.\n\nb\n\nThe second drawing.\n\nReturn Value\n\nReturns true if the objects are equal, or false if they aren’t.\n\nSee Also\nComparing drawing objects\nstatic func != (PKDrawing, PKDrawing) -> Bool\nReturns a Boolean value that indates whether the two drawing objects aren’t equivalent."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595218-init",
    "html": "See Also\nCreating a new stroke path\ninit<T>(controlPoints: T, creationDate: Date)\nCreates a stroke path with the cubic B-spline control points and a date that you specify."
  },
  {
    "title": "PKAppleDrawingTypeIdentifier | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkappledrawingtypeidentifier",
    "html": "Discussion\n\nUse this type when reading or writing drawing data. For example, use this type to determine if you can read data from the pasteboard.\n\nSee Also\nGetting the drawing data\nvar strokes: [PKStroke]\nThe array of strokes that make up the drawing.\nfunc dataRepresentation() -> Data\nReturns a raw data representation of the rendered content."
  },
  {
    "title": "transformed(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3335017-transformed",
    "html": "Parameters\ntransform\n\nThe CGAffineTransform to apply to the contents of this drawing.\n\nReturn Value\n\nA new drawing with the provided transform applied.\n\nSee Also\nModifying the drawing\nfunc transform(using: CGAffineTransform)\nApplies the specified transform to the contents of this drawing.\nfunc append(PKDrawing)\nAppends the contents of the specified drawing object to an existing drawing object that you provide.\nfunc appending(PKDrawing) -> PKDrawing\nReturns a new drawing created by appending the current drawing with another drawing you provide."
  },
  {
    "title": "transform(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3335016-transform",
    "html": "Parameters\ntransform\n\nThe CGAffineTransform to apply when transforming the contents of this drawing.\n\nSee Also\nModifying the drawing\nfunc transformed(using: CGAffineTransform) -> PKDrawing\nApplies the specified transform and returns a new drawing.\nfunc append(PKDrawing)\nAppends the contents of the specified drawing object to an existing drawing object that you provide.\nfunc appending(PKDrawing) -> PKDrawing\nReturns a new drawing created by appending the current drawing with another drawing you provide."
  },
  {
    "title": "dataRepresentation() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3281878-datarepresentation",
    "html": "Return Value\n\nA new NSData object that contains the entire contents of the drawing.\n\nSee Also\nGetting the drawing data\nvar strokes: [PKStroke]\nThe array of strokes that make up the drawing.\nlet PKAppleDrawingTypeIdentifier: CFString\nThe uniform type identifier for data associated with a drawing object."
  },
  {
    "title": "strokes | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3595078-strokes",
    "html": "See Also\nGetting the drawing data\nfunc dataRepresentation() -> Data\nReturns a raw data representation of the rendered content.\nlet PKAppleDrawingTypeIdentifier: CFString\nThe uniform type identifier for data associated with a drawing object."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3281881-init",
    "html": "Return Value\n\nA new canvas object that doesn’t contain any data.\n\nSee Also\nCreating a drawing object\ninit<S>(strokes: S)\nCreates a drawing object and populates it with a sequence of strokes the user provides.\ninit(data: Data)\nCreates a drawing object and populates it with previously drawn content.\ninit(from: Decoder)\nCreates a drawing object and populates it with previously drawn content stored on disk."
  },
  {
    "title": "PKDrawingReference | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawingreference",
    "html": "Overview\n\nA PKDrawingReference object stores the user-drawn content from a PKCanvasView object. You use drawing objects to store the data associated with your user’s drawings. You can save this data with the rest of your app’s content, and you can use that saved data to create a new drawing object later. You can also generate an image based on the drawn content.\n\nTopics\nCreating a drawing object\ninit(data: Data)\nCreates a drawing object and populates it with previously drawn content.\ninit(strokes: [PKStroke])\nCreates a drawing object with the strokes you supply.\ninit()\nCreates an empty drawing object.\nGetting the canvas bounds\nvar bounds: CGRect\nThe smallest rectangle used to represent the content’s bounds, taking into account line widths of that content.\nGenerating an image\nfunc image(from: CGRect, scale: CGFloat) -> UIImage\nReturns an image object that contains the specified portion of the drawing.\nGetting the drawing data\nvar strokes: [PKStroke]\nAn array of strokes used to represent the drawing.\nfunc dataRepresentation() -> Data\nReturns a representation of the rendered content as data.\nlet PKAppleDrawingTypeIdentifier: CFString\nThe uniform type identifier for data associated with a drawing object.\nModifying the drawing\nfunc applying(CGAffineTransform) -> PKDrawing\nReturns a new drawing object by applying the specified transform to a copy of the current object’s contents.\nfunc appendingStrokes([PKStroke]) -> PKDrawing\nReturns a copy of the current drawing with the strokes you provide appended.\nfunc appending(PKDrawing) -> PKDrawing\nReturns a new drawing created by appending the current drawing with another drawing you provide.\nSupporting backward compatibility\nvar requiredContentVersion: PKContentVersion\nThe version of PencilKit necessary to use the drawing.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSSecureCoding"
  },
  {
    "title": "PKCanvasViewDrawingPolicy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasviewdrawingpolicy",
    "html": "Topics\nDrawing policies\ncase `default`\nThe default input type to use for drawing on a canvas.\ncase anyInput\nAllows drawing on the canvas from any input source.\ncase pencilOnly\nPencil touches are the only input that draw on the canvas.\nRelationships\nConforms To\nSendable\nSee Also\nConfiguring the drawing environment\nvar tool: PKTool\nThe currently selected tool used for drawing.\nvar isRulerActive: Bool\nA Boolean value that indicates whether a ruler view is visible on the canvas.\nvar allowsFingerDrawing: Bool\nA Boolean value that indicates whether the canvas accepts input from the user’s finger in addition to Apple Pencil.\nDeprecated\nvar drawingPolicy: PKCanvasViewDrawingPolicy\nThe policy that controls the types of touches allowed when drawing on the canvas."
  },
  {
    "title": "drawingPolicy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasview/3552388-drawingpolicy",
    "html": "See Also\nConfiguring the drawing environment\nvar tool: PKTool\nThe currently selected tool used for drawing.\nvar isRulerActive: Bool\nA Boolean value that indicates whether a ruler view is visible on the canvas.\nvar allowsFingerDrawing: Bool\nA Boolean value that indicates whether the canvas accepts input from the user’s finger in addition to Apple Pencil.\nDeprecated\nenum PKCanvasViewDrawingPolicy\nConstants that you use to specify the type of drawing gestures your app permits while the user draws on the canvas."
  },
  {
    "title": "allowsFingerDrawing | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasview/3229948-allowsfingerdrawing",
    "html": "See Also\nConfiguring the drawing environment\nvar tool: PKTool\nThe currently selected tool used for drawing.\nvar isRulerActive: Bool\nA Boolean value that indicates whether a ruler view is visible on the canvas.\nvar drawingPolicy: PKCanvasViewDrawingPolicy\nThe policy that controls the types of touches allowed when drawing on the canvas.\nenum PKCanvasViewDrawingPolicy\nConstants that you use to specify the type of drawing gestures your app permits while the user draws on the canvas."
  },
  {
    "title": "PKInkingTool.InkType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype",
    "html": "Topics\nChoosing ink types\ncase marker\nAn inking tool that creates the appearance of a felt-tip marker.\ncase pen\nAn inking tool that creates the appearance of a pen-based drawing.\ncase pencil\nAn inking tool that creates the appearance of a narrow line from a pencil.\ncase monoline\nAn inking tool that creates the appearance of a monoline pen.\ncase fountainPen\nAn inking tool that creates the appearance of a calligraphy pen.\ncase watercolor\nAn inking tool that creates the appearance of a watercolor brush.\ncase crayon\nAn inking tool that creates the appearance of a crayon.\nvar rawValue: String\nThe raw string value of a given enumeration case.\nCreating ink types\ninit?(rawValue: String)\nCreate a new ink type using a string.\ntypealias PKInkingTool.InkType.RawValue\nThe raw type to represent values of the ink type.\nGetting the width information\nvar defaultWidth: CGFloat\nThe default line width for the specified tool type.\nvar validWidthRange: ClosedRange<CGFloat>\nThe range of widths allowed for an ink of this type.\nComparing ink types\nstatic func != (PKInkingTool.InkType, PKInkingTool.InkType) -> Bool\nReturns a Boolean value that indicates whether the two ink types aren’t the same.\nfunc hash(into: inout Hasher)\nGenerates hash values into a hasher structure reference that you provide.\nvar hashValue: Int\nThe hash value representing this ink type.\nSupporting backward compatibility\nvar requiredContentVersion: PKContentVersion\nThe version of PencilKit necessary to use the ink type.\nSee Also\nGetting the tool type\nvar inkType: PKInkingTool.InkType\nThe tool type that determines the shape of the rendered content."
  },
  {
    "title": "isRulerActive | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasview/3229952-isruleractive",
    "html": "See Also\nConfiguring the drawing environment\nvar tool: PKTool\nThe currently selected tool used for drawing.\nvar allowsFingerDrawing: Bool\nA Boolean value that indicates whether the canvas accepts input from the user’s finger in addition to Apple Pencil.\nDeprecated\nvar drawingPolicy: PKCanvasViewDrawingPolicy\nThe policy that controls the types of touches allowed when drawing on the canvas.\nenum PKCanvasViewDrawingPolicy\nConstants that you use to specify the type of drawing gestures your app permits while the user draws on the canvas."
  },
  {
    "title": "PKCanvasViewDelegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasviewdelegate",
    "html": "Overview\n\nImplement the methods of the PKCanvasViewDelegate protocol to monitor drawing events in a PKCanvasView object. Specifically, determine the start- and end-of-event sequences using the currently selected tool, and determine when those events affect the drawn content.\n\nTopics\nResponding to drawing-related changes\nfunc canvasViewDrawingDidChange(PKCanvasView)\nTells the delegate that the contents of the current drawing changed.\nfunc canvasViewDidFinishRendering(PKCanvasView)\nTells the delegate that the previously drawn content is ready to display.\nResponding to new event sequences\nfunc canvasViewDidBeginUsingTool(PKCanvasView)\nTells the delegate that the user started a new drawing sequence with the currently selected tool.\nfunc canvasViewDidEndUsingTool(PKCanvasView)\nTells the delegate that the user ended a drawing sequence with the tool they were using.\nRelationships\nInherits From\nNSObjectProtocol\nUIScrollViewDelegate\nSee Also\nResponding to drawing-related changes\nvar delegate: PKCanvasViewDelegate?\nThe object you use to respond to changes in the drawn content or with the selected tool."
  },
  {
    "title": "tool | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasview/3281892-tool",
    "html": "See Also\nConfiguring the drawing environment\nvar isRulerActive: Bool\nA Boolean value that indicates whether a ruler view is visible on the canvas.\nvar allowsFingerDrawing: Bool\nA Boolean value that indicates whether the canvas accepts input from the user’s finger in addition to Apple Pencil.\nDeprecated\nvar drawingPolicy: PKCanvasViewDrawingPolicy\nThe policy that controls the types of touches allowed when drawing on the canvas.\nenum PKCanvasViewDrawingPolicy\nConstants that you use to specify the type of drawing gestures your app permits while the user draws on the canvas."
  },
  {
    "title": "delegate | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasview/3229949-delegate",
    "html": "See Also\nResponding to drawing-related changes\nprotocol PKCanvasViewDelegate\nMethods for monitoring drawing related changes in a canvas view."
  },
  {
    "title": "inkType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/3281915-inktype",
    "html": "See Also\nGetting the tool type\nenum PKInkingTool.InkType\nThe type that defines the shape of stroked lines."
  },
  {
    "title": "PKContentVersion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcontentversion",
    "html": "Topics\nLatest version\nstatic var latest: PKContentVersion\nA property that returns latest version of PencilKit, which supports all currently available inks.\nSpecific versions\ncase version1\nThe PencilKit version that supports inks from iPadOS 14 and earlier, including marker, pen, and pencil.\ncase version2\nThe PencilKit version that supports inks from iPadOS 17 and earlier, including marker, pen, pencil, monoline, fountain pen, watercolor, and crayon.\nRelationships\nConforms To\nSendable\nSee Also\nBackward compatibility\nSupporting backward compatibility for ink types\nLeverage the latest PencilKit features while providing a good user experience in earlier versions of the OS that don’t support those features."
  },
  {
    "title": "Supporting backward compatibility for ink types | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/supporting_backward_compatibility_for_ink_types",
    "html": "Overview\n\nIn iPadOS 17, PencilKit becomes even more expressive by introducing the monoline, fountain pen, watercolor, and crayon inks. Earlier versions of the OS can’t render PKDrawing objects that use these inks because the system doesn’t contain a version of PencilKit that supports them. As a result, earlier versions of the OS throw an error when attempting to load a PKDrawing object that contains these inks from data.\n\nYou can handle this situation in your app in one of two ways:\n\nSupport backward compatibility. Let people use the new inks when your app runs in the latest version of the OS. Before you save a drawing and sync the data to other devices, check its required content version to determine if it uses the new inks. If it does, provide a good fallback experience for devices that can’t load that drawing, like syncing a fallback drawing that’s compatible with the earlier version of PencilKit.\n\nRestrict the use of new features. Limit which inks are available when your app runs in any version of the OS. This approach ensures that the PencilKit data your app saves is compatible with the earlier version of PencilKit, but it doesn’t let people take advantage of the new inks.\n\nSupport backward compatibility using the required content version\n\nTo support backward compatibility, PencilKit introduces content versioning through PKContentVersion. Data model types like PKDrawing, PKStroke, PKInkingTool, and PKInk contain a requiredContentVersion property that PencilKit populates automatically. The value of this property indicates which version of PencilKit is required to load the underlying data:\n\nPKContentVersion.version1 indicates that the data only contains inks introduced in iPadOS 14, and requires the device to run iPadOS 14 or later.\n\nPKContentVersion.version2 indicates that the data contains inks introduced in iPadOS 17, and requires the device to run iPadOS 17 or later.\n\nBefore you save these data model types, check their requiredContentVersion to avoid syncing incompatible data to devices with earlier versions of the OS. For example, instead of syncing a PKDrawing that features new inks, you can sync a fallback drawing and show a message that suggests updating the device’s OS to edit the latest drawing.\n\nfunc updateDrawing(_ drawing: PKDrawing, at index: Int) {\n    if #available(iOS 17.0, *) {\n        // Before saving, check if this drawing uses new inks and requires a later\n        // version of PencilKit than might be available on a person’s other devices.\n        switch drawing.requiredContentVersion {\n        case .version2:\n            // This drawing is incompatible with the earlier version of PencilKit.\n            // Sync a backward-compatible drawing to display on devices with earlier OS versions.\n            dataModel.drawings[index] = fallbackDrawing\n        default:\n            // This drawing is compatible with the earlier version of PencilKit.\n            // Sync the current drawing since there's no need to provide a \n            // backward-compatible drawing instead.\n            dataModel.drawings[index] = drawing\n        }\n    } else {\n        dataModel.drawings[index] = drawing\n    }\n    saveDataModel()\n}\n\n\nLimit available inks using the maximum supported content version\n\nIf your app is unable to support backward compatibility for different versions of the OS, use the maximumSupportedContentVersion property to limit which inks are available in your app. This limitation ensures that the data your app saves is compatible with the earlier version of PencilKit so you can load it on devices with earlier versions of the OS.\n\nIf you take this approach, you need to set maximumSupportedContentVersion on both PKCanvasView and PKToolPicker. For example, set this property to PKContentVersion.version1 to limit which kinds of edits the canvas views offers and which tools are available for a person to select when they create PencilKit content in your app.\n\n// Set the maximum supported content version for the canvas view and any tool pickers.\n@IBOutlet weak var canvasView: PKCanvasView!\nvar toolPicker = PKToolPicker()\n\n\n// The canvas view limits the edits that a person can make so they’re compatible with the \n// the earlier version of PencilKit.\ncanvasView.maximumSupportedContentVersion = .version1\n\n\n// The tool picker limits the tools that are available so they’re compatible with  \n// the earlier version of PencilKit.\ntoolPicker.maximumSupportedContentVersion = .version1\n\n\nRelated sessions from WWDC23\n\nSession 10055: What’s new in UIKit\n\nSee Also\nBackward compatibility\nenum PKContentVersion\nConstants that represent versions of PencilKit for backward compatibility."
  },
  {
    "title": "validWidthRange | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool/inktype/3281912-validwidthrange",
    "html": "See Also\nGetting the width information\nvar defaultWidth: CGFloat\nThe default line width for the specified tool type."
  },
  {
    "title": "PKToolPicker | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktoolpicker",
    "html": "Overview\n\nA PKToolPicker manages a draggable palette that displays drawing tools, colors, and additional options. You add a tool picker to your interface and configure it to display its palette at appropriate times. While onscreen, the user may reposition the palette anywhere within the current window. When the user interacts with the palette, the tool picker notifies registered observers of the changes so that they can respond.\n\nImportant\n\nThe tool picker doesn’t display in Mac apps built with Mac Catalyst.\n\nWhen configuring your interface, call the setVisible(_:forFirstResponder:) method to associate the tool picker with one or more views in your interface. Each window manages its own tool picker, and the window’s first responder determines the visibility of that tool picker. When one of the registered objects becomes first responder, the tool picker automatically adds its palette view to the current window. When there isn’t a registered object is first responder, the tool picker hides its palette view.\n\nPKCanvasView implements the observer protocol for detecting tool picker changes. Adding your canvas view as an observer to a tool picker automatically updates the current drawing tools. For more information about implementing custom observer objects, see PKToolPickerObserver.\n\nTopics\nCreating a new picker\ninit()\nReturns a new instance of a tool picker.\nGetting the shared tool picker\nclass func shared(for: UIWindow) -> PKToolPicker?\nReturns the tool picker object to use for the specified window.\nDeprecated\nDetecting changes to the picker\nfunc addObserver(PKToolPickerObserver)\nAdds the specified object to the list of objects to notify when the picker configuration changes.\nfunc removeObserver(PKToolPickerObserver)\nRemoves the specified object from the list of objects to notify when the picker configuration changes.\nprotocol PKToolPickerObserver\nAn interface you use to detect when the user changes the selected tools and drawing characteristics of a tool picker object.\nCoordinating the visibility of the picker\nfunc setVisible(Bool, forFirstResponder: UIResponder)\nSets the visibility for the tool picker, based on when the specified responder object becomes active.\nvar isVisible: Bool\nA Boolean value that indicates whether the tool picker is currently visible.\nfunc frameObscured(in: UIView) -> CGRect\nReturns the portion of the specified view that the tool picker obscures.\nGetting the tool configuration\nvar selectedTool: PKTool\nThe currently selected tool in this tool picker.\nvar colorUserInterfaceStyle: UIUserInterfaceStyle\nThe user interface style for this tool picker.\nvar isRulerActive: Bool\nA Boolean value that indicates whether the ruler is visible on the canvas.\nvar overrideUserInterfaceStyle: UIUserInterfaceStyle\nThe specific user interface style to apply to this tool picker.\nvar showsDrawingPolicyControls: Bool\nA Boolean value that indicates whether the default drawing policy UI is visible.\nvar stateAutosaveName: String?\nThe name used to automatically save the tool picker’s state in the defaults system.\nSupporting PencilKit versions\nvar maximumSupportedContentVersion: PKContentVersion\nThe maximum version of PencilKit to support.\nRelationships\nInherits From\nNSObject\nSee Also\nTools\nstruct PKInkingTool\nA structure that defines the drawing characteristics (width, color, pen style) to use when drawing lines on a canvas view.\nstruct PKEraserTool\nA tool for erasing previously drawn content in a canvas view.\nstruct PKLassoTool\nA tool for selecting stroked lines and shapes in a canvas view.\nprotocol PKTool\nAn interface adopted by drawing and writing tools used by a canvas view."
  },
  {
    "title": "PKInkReference | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkreference",
    "html": "Topics\nCreating an ink\ninit(inkType: __PKInkType, color: UIColor)\nCreate a new ink, specifying its type, color.\nGetting the ink attributes\nvar color: UIColor\nThe base color for this ink.\nvar inkType: __PKInkType\nThe type of ink, such as pen or pencil, as defined in the PKInkType enumeration.\nSupporting backward compatibility\nvar requiredContentVersion: PKContentVersion\nThe version of PencilKit necessary to use the ink.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying"
  },
  {
    "title": "inkType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkink/3595083-inktype",
    "html": "See Also\nGetting the ink attributes\nvar color: UIColor\nThe color of this ink.\nvar color: NSColor\nThe color of this ink."
  },
  {
    "title": "PKStrokeReference | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokereference",
    "html": "Topics\nCreating a stroke object\ninit(ink: PKInk, strokePath: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?)\nCreates a stroke with the line properties, path, transform, and mask that you specify.\ninit(ink: PKInk, strokePath: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?, randomSeed: UInt32)\nCreates a stroke with the line properties, path, transform, mask, and random seed that you specify.\nGetting the stroke properties\nvar ink: PKInk\nThe line properties used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [__PKFloatRange]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32\nAn unsigned 32-bit integer to use as a random seed for drawing strokes that use randomized effects.\nSupporting backward compatibility\nvar requiredContentVersion: PKContentVersion\nThe version of PencilKit necessary to use the stroke.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying"
  },
  {
    "title": "transform | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke/3595093-transform",
    "html": "See Also\nGetting the stroke properties\nvar ink: PKInk\nThe Ink, which is a combination of a tool used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar mask: NSBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [ClosedRange<CGFloat>]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar randomSeed: UInt32"
  },
  {
    "title": "PKStrokePointReference | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepointreference",
    "html": "Topics\nCreating a stroke point object\ninit(location: CGPoint, timeOffset: TimeInterval, size: CGSize, opacity: CGFloat, force: CGFloat, azimuth: CGFloat, altitude: CGFloat)\nCreates a new point with the provided properties.\ninit(location: CGPoint, timeOffset: TimeInterval, size: CGSize, opacity: CGFloat, force: CGFloat, azimuth: CGFloat, altitude: CGFloat, secondaryScale: CGFloat)\nGetting the point’s location\nvar location: CGPoint\nThe location of this point.\nvar timeOffset: TimeInterval\nThe time offset since the start of the stroke path in seconds.\nGetting the point’s touch data\nvar altitude: CGFloat\nThe altitude of this point in radians.\nvar azimuth: CGFloat\nThe azimuth of this point in radians.\nvar force: CGFloat\nThe amount of force applied by the touch.\nGetting the point’s drawing data\nvar size: CGSize\nThe size of the point.\nvar opacity: CGFloat\nOpacity of the point.\nvar secondaryScale: CGFloat\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying"
  },
  {
    "title": "force | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepoint/3595301-force",
    "html": "Discussion\n\nThis is a value predetermined by the system and isn’t user specific. A value of 1.0 represents the force of an average touch.\n\nSee Also\nGetting the point’s touch data\nvar altitude: CGFloat\nThe altitude of this point in radians.\nvar azimuth: CGFloat\nThe azimuth of this point in radians."
  },
  {
    "title": "PKStrokePath.Indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/indices",
    "html": "See Also\nSupporting types\nstruct PKStrokePath.InterpolatedSlice\nA struct representing an interpolated slice of stroke points with a specific stride across a range of this stroke data.\ntypealias PKStrokePath.Element\nA type that represents the sequence’s elements.\ntypealias PKStrokePath.Index\nA type that represents a position in the collection.\ntypealias PKStrokePath.Iterator\nA type that provides the collection’s iteration interface and encapsulates its iteration state.\ntypealias PKStrokePath.SubSequence\nA type that represents a contiguous subrange of this collection’s elements."
  },
  {
    "title": "PKStrokePath.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/element",
    "html": "See Also\nSupporting types\nstruct PKStrokePath.InterpolatedSlice\nA struct representing an interpolated slice of stroke points with a specific stride across a range of this stroke data.\ntypealias PKStrokePath.Index\nA type that represents a position in the collection.\ntypealias PKStrokePath.Indices\nA type that represents the indices that are valid for subscripting the collection, in ascending order.\ntypealias PKStrokePath.Iterator\nA type that provides the collection’s iteration interface and encapsulates its iteration state.\ntypealias PKStrokePath.SubSequence\nA type that represents a contiguous subrange of this collection’s elements."
  },
  {
    "title": "parametricValue(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3650441-parametricvalue",
    "html": "See Also\nAccessing and interpolating points\nfunc interpolatedPoints(in: ClosedRange<CGFloat>?, by: PKStrokePath.InterpolatedSlice.Stride) -> PKStrokePath.InterpolatedSlice\nReturns the slice on-curve points using the floating point range and stride that you specify.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nsubscript(PKStrokePath.Index) -> PKStrokePoint\nAccess the stroke point at the provided index.\nsubscript<R>(R) -> Slice<PKStrokePath>\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Slice<PKStrokePath>\nsubscript(Range<Int>) -> Slice<PKStrokePath>\nAccesses a contiguous subrange of the collection’s elements."
  },
  {
    "title": "interpolatedPoint(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595221-interpolatedpoint",
    "html": "Parameters\nparametricValue\n\nThe on-curve location [0, count-1] where interpolation occurs.\n\nReturn Value\n\nA PKStrokePoint interpolated from the supplied parametricValue.\n\nSee Also\nAccessing and interpolating points\nfunc interpolatedPoints(in: ClosedRange<CGFloat>?, by: PKStrokePath.InterpolatedSlice.Stride) -> PKStrokePath.InterpolatedSlice\nReturns the slice on-curve points using the floating point range and stride that you specify.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc parametricValue(CGFloat, offsetBy: PKStrokePath.InterpolatedSlice.Stride) -> CGFloat\nsubscript(PKStrokePath.Index) -> PKStrokePoint\nAccess the stroke point at the provided index.\nsubscript<R>(R) -> Slice<PKStrokePath>\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Slice<PKStrokePath>\nsubscript(Range<Int>) -> Slice<PKStrokePath>\nAccesses a contiguous subrange of the collection’s elements."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath/3595296-underestimatedcount",
    "html": "Discussion\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nSee Also\nGetting the stroke path properties\nvar count: Int\nThe number of elements in the collection.\nvar creationDate: Date\nThe creation date and time of this stroke path.\nvar endIndex: Int\nThe index of the last item in the collection.\nvar first: PKStrokePoint?\nThe first element of the collection.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar last: PKStrokePoint?\nThe last element of the collection.\nvar startIndex: Int\nThe index of the first item in the collection."
  },
  {
    "title": "append(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3281875-append",
    "html": "Parameters\ntoAppend\n\nA drawing object that contains additional content.\n\nSee Also\nModifying the drawing\nfunc transform(using: CGAffineTransform)\nApplies the specified transform to the contents of this drawing.\nfunc transformed(using: CGAffineTransform) -> PKDrawing\nApplies the specified transform and returns a new drawing.\nfunc appending(PKDrawing) -> PKDrawing\nReturns a new drawing created by appending the current drawing with another drawing you provide."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing/3281883-init",
    "html": "Parameters\ndecoder\n\nA decoder that conforms to Decodable.\n\nReturn Value\n\nA new canvas object containing the specified data.\n\nRelationships\nFrom Protocol\nDecodable\nSee Also\nCreating a drawing object\ninit<S>(strokes: S)\nCreates a drawing object and populates it with a sequence of strokes the user provides.\ninit(data: Data)\nCreates a drawing object and populates it with previously drawn content.\ninit()\nCreates an empty drawing object."
  },
  {
    "title": "Inspecting, Modifying, and Constructing PencilKit Drawings | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/inspecting_modifying_and_constructing_pencilkit_drawings",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC20 session 10148: Inspect, Modify, and Construct PencilKit Drawings.\n\nThis sample code project must be run on a physical device with Apple Pencil.\n\nSee Also\nCanvas\nDrawing with PencilKit\nAdd expressive, low-latency drawing to your app using PencilKit.\nCustomizing Scribble with Interactions\nEnable writing on a non-text-input view by adding interactions.\nclass PKCanvasView\nA view that captures Apple Pencil input and displays the rendered results in an iOS app.\nstruct PKDrawing\nA structure representing the drawing information captured by a canvas view.\nstruct PKStroke\nA structure that represents the paths, boundaries, and other properties of a stroke drawn on a canvas.\nstruct PKStrokePath\nA structure that captures the components of a stroke and provides methods to find and interpolate points along the stroke’s path.\nstruct PKStrokePoint\nA structure that represents the properties of a specific point along a stroke’s path.\nstruct PKInk\nA structure that represents an ink that specifies its type, color, and width."
  },
  {
    "title": "maximumSupportedContentVersion | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasview/4195354-maximumsupportedcontentversion",
    "html": "Discussion\n\nThe default value is latest.\n\nIf you set this property to a value less than latest, the canvas view limits the edits that a person can make so they’re compatible with the version of PencilKit you specify.\n\nIf you set this property, also set maximumSupportedContentVersion on any PKToolPicker you use."
  },
  {
    "title": "PKEraserTool | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkerasertool",
    "html": "Overview\n\nA PKEraserTool object supports the deletion of content from a PKCanvasView object. The eraser tool’s type determines whether the canvas removes entire items or just the portion of an item that it touches.\n\nCreate an eraser tool programmatically or display a PKToolPicker object and let the user select the eraser. Assign the resulting object to the tool property of your PKCanvasView object. The canvas uses any subsequent touch sequences to erase content on the canvas.\n\nTopics\nCreating an eraser tool\ninit(PKEraserTool.EraserType)\nCreates an eraser tool object that removes objects wholly or partially from a canvas view.\ninit(PKEraserTool.EraserType, width: CGFloat)\nCreates an eraser tool object with the specified width.\nGetting the eraser type\nvar eraserType: PKEraserTool.EraserType\nThe behavior adopted by the eraser when deleting content.\nenum PKEraserTool.EraserType\nConstants that indicate the behavior of the eraser.\nSpecifying the width\nvar width: CGFloat\nThe width of the eraser.\nComparing eraser tools\nstatic func == (PKEraserTool, PKEraserTool) -> Bool\nReturns a Boolean value that indicates whether the two eraser tools are the same.\nstatic func != (PKEraserTool, PKEraserTool) -> Bool\nReturns a Boolean value that indicates whether the two eraser tools aren’t the same.\nfunc hash(into: inout Hasher)\nGenerates hash values into a hasher structure reference that you provide.\nvar hashValue: Int\nThe hash value representing this eraser tool.\nUsing reference types\nclass PKEraserToolReference\nA tool for erasing previously drawn content in a canvas view.\nRelationships\nConforms To\nPKTool\nSee Also\nTools\nclass PKToolPicker\nA tool palette that displays a selection of drawing tools and colors for tools and colors that a user can choose from.\nstruct PKInkingTool\nA structure that defines the drawing characteristics (width, color, pen style) to use when drawing lines on a canvas view.\nstruct PKLassoTool\nA tool for selecting stroked lines and shapes in a canvas view.\nprotocol PKTool\nAn interface adopted by drawing and writing tools used by a canvas view."
  },
  {
    "title": "PKLassoTool | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pklassotool",
    "html": "Overview\n\nA PKLassoTool object supports the selection of content on a PKCanvasView. When active, the canvas uses incoming touch events to determine what content to add to the selection.\n\nCreate a lasso tool programmatically or display a PKToolPicker object from which the user selects the tool. Assign the resulting object to the tool property of your PKCanvasView object. The canvas uses any subsequent touch sequences to select content on the canvas.\n\nTopics\nCreating a lasso tool\ninit()\nCreates a lasso tool for selecting content on a canvas view.\nComparing lasso tools\nstatic func == (PKLassoTool, PKLassoTool) -> Bool\nReturns a Boolean value that indicates whether the two lasso tools are equivalent.\nstatic func != (PKLassoTool, PKLassoTool) -> Bool\nReturns a Boolean value that indicates whether the two lasso tools are equivalent.\nUsing reference types\nclass PKLassoToolReference\nA tool for selecting stroked lines and shapes in a canvas view.\nRelationships\nConforms To\nPKTool\nSee Also\nTools\nclass PKToolPicker\nA tool palette that displays a selection of drawing tools and colors for tools and colors that a user can choose from.\nstruct PKInkingTool\nA structure that defines the drawing characteristics (width, color, pen style) to use when drawing lines on a canvas view.\nstruct PKEraserTool\nA tool for erasing previously drawn content in a canvas view.\nprotocol PKTool\nAn interface adopted by drawing and writing tools used by a canvas view."
  },
  {
    "title": "PKTool | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pktool",
    "html": "Overview\n\nDrawing and writing tools associated with a PKCanvasView adopt the PKTool protocol. Tools are user-facing, and the selected tool determines how the canvas interprets incoming gestures.\n\nDon’t adopt this protocol in your own objects. Instead, create a tool object to provide users with the desired the tool behavior.\n\nRelationships\nConforming Types\nPKEraserTool\nPKInkingTool\nPKLassoTool\nSee Also\nTools\nclass PKToolPicker\nA tool palette that displays a selection of drawing tools and colors for tools and colors that a user can choose from.\nstruct PKInkingTool\nA structure that defines the drawing characteristics (width, color, pen style) to use when drawing lines on a canvas view.\nstruct PKEraserTool\nA tool for erasing previously drawn content in a canvas view.\nstruct PKLassoTool\nA tool for selecting stroked lines and shapes in a canvas view."
  },
  {
    "title": "PKInkingTool | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkinkingtool",
    "html": "Overview\n\nA PKInkingTool object supports the creation of new content on a PKCanvasView. With an inking tool, the canvas turns touch input from the user into a continuously rendered stroke. The value in the width property determines the base width of that stroke; however, that base value also depends on input from Apple Pencil, including force, azimuth, and angle data.\n\nCreate an inking tool programmatically, or display a PKToolPicker object and from which a user can select a tool. Assign the resulting object to the tool property of your PKCanvasView object. The canvas uses any subsequent touch sequences to draw new content on the canvas. Assigning a new inking tool doesn’t change the characteristics for any previously drawn strokes.\n\nTopics\nCreating an inking tool\ninit(PKInkingTool.InkType, color: UIColor, width: CGFloat?)\nCreates an ink tool object with the specified color and line width values.\ninit(PKInkingTool.InkType, color: NSColor, width: CGFloat?)\nCreates an ink tool object with the specified color and line width values.\ninit(ink: PKInk, width: CGFloat)\nCreate an inking tool with the specified ink and width.\nGetting the width information\nvar defaultWidth: CGFloat\nThe default line width for the specified tool type.\nvar validWidthRange: ClosedRange<CGFloat>\nThe range of widths allowed for an ink of this type.\nGetting the inking tool attributes\nvar color: UIColor\nThe color of the ink.\nvar color: NSColor\nThe color of the ink.\nvar width: CGFloat\nThe width of the ink.\nvar rawValue: String\nThe raw string value of a given enumeration case.\nvar ink: PKInk\nThe ink used by this inking tool.\nGetting the tool type\nvar inkType: PKInkingTool.InkType\nThe tool type that determines the shape of the rendered content.\nenum PKInkingTool.InkType\nThe type that defines the shape of stroked lines.\nComparing inking tool types\nstatic func == (PKInkingTool, PKInkingTool) -> Bool\nReturns a Boolean value that indicates whether the two inking tools are the same.\nstatic func != (PKInkingTool, PKInkingTool) -> Bool\nReturns a Boolean value that indicates whether the two inking tools aren’t equivalent.\nstatic func != (PKInkingTool.InkType, PKInkingTool.InkType) -> Bool\nReturns a Boolean value that indicates whether the two ink types aren’t the same.\nWorking with colors\nstatic func convertColor(UIColor, from: UIUserInterfaceStyle, to: UIUserInterfaceStyle) -> UIColor\nConvert a color from one user interface style to another.\nSupporting backward compatibility\nvar requiredContentVersion: PKContentVersion\nThe version of PencilKit necessary to use the inking tool.\nUsing reference types\nclass PKInkingToolReference\nAn object that defines the drawing characteristics (width, color, pen style) to use when drawing lines on a canvas view.\nRelationships\nConforms To\nPKTool\nSee Also\nTools\nclass PKToolPicker\nA tool palette that displays a selection of drawing tools and colors for tools and colors that a user can choose from.\nstruct PKEraserTool\nA tool for erasing previously drawn content in a canvas view.\nstruct PKLassoTool\nA tool for selecting stroked lines and shapes in a canvas view.\nprotocol PKTool\nAn interface adopted by drawing and writing tools used by a canvas view."
  },
  {
    "title": "PKInk | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkink",
    "html": "Topics\nCreating an ink object\ninit(PKInk.InkType, color: UIColor)\nCreates a new ink, specifying its type and color.\ninit(PKInk.InkType, color: NSColor)\nCreates a new ink, specifying its type and color.\ntypealias PKInk.InkType\nA type alias referring to the ink type of an inking tool.\nGetting the ink attributes\nvar color: UIColor\nThe color of this ink.\nvar color: NSColor\nThe color of this ink.\nvar inkType: PKInk.InkType\nThe line presentation to use for this Ink.\nComparing ink types\nstatic func != (PKInkingTool.InkType, PKInkingTool.InkType) -> Bool\nReturns a Boolean value that indicates whether the two ink types aren’t the same.\nSupporting backward compatibility\nvar requiredContentVersion: PKContentVersion\nThe version of PencilKit necessary to use the ink.\nUsing reference types\nclass PKInkReference\nProvides a description of the creation and rendering of marks on a canvas.\nSee Also\nCanvas\nDrawing with PencilKit\nAdd expressive, low-latency drawing to your app using PencilKit.\nCustomizing Scribble with Interactions\nEnable writing on a non-text-input view by adding interactions.\nInspecting, Modifying, and Constructing PencilKit Drawings\nScore users’ ability to match PencilKit drawings generated from text, by accessing the strokes and points inside PencilKit drawings.\nclass PKCanvasView\nA view that captures Apple Pencil input and displays the rendered results in an iOS app.\nstruct PKDrawing\nA structure representing the drawing information captured by a canvas view.\nstruct PKStroke\nA structure that represents the paths, boundaries, and other properties of a stroke drawn on a canvas.\nstruct PKStrokePath\nA structure that captures the components of a stroke and provides methods to find and interpolate points along the stroke’s path.\nstruct PKStrokePoint\nA structure that represents the properties of a specific point along a stroke’s path."
  },
  {
    "title": "PKStroke | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstroke",
    "html": "Topics\nCreating a stroke object\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?)\nCreates a stroke with the line properties, path, transform, and mask that you specify.\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: NSBezierPath?)\nCreates a stroke with the line properties, path, transform, and mask that you specify.\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: UIBezierPath?, randomSeed: UInt32)\nCreates a stroke with the line properties, path, transform, mask, and random seed that you specify.\ninit(ink: PKInk, path: PKStrokePath, transform: CGAffineTransform, mask: NSBezierPath?, randomSeed: UInt32)\nCreates a macOS stroke with the line properties, path, transform, mask, and random seed that you specify.\nGetting the stroke properties\nvar ink: PKInk\nThe Ink, which is a combination of a tool used to render this stroke.\nvar mask: UIBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar mask: NSBezierPath?\nThe pretransform mask used to clip the rendering of the stroke.\nvar maskedPathRanges: [ClosedRange<CGFloat>]\nThe range of points in the stroke path reference that intersect the stroke’s mask.\nvar path: PKStrokePath\nThe B-spline path that describes this stroke.\nvar renderBounds: CGRect\nThe bounds of the rendered stroke, including the width and line properties of the stroke after applying the transform.\nvar transform: CGAffineTransform\nThe affine transform of the stroke after rendering.\nvar randomSeed: UInt32\nSupporting backward compatibility\nvar requiredContentVersion: PKContentVersion\nThe version of PencilKit necessary to use the stroke.\nUsing reference types\nclass PKStrokeReference\nA class that represents the paths, boundaries and other properties of a stroke drawn on a canvas.\nSee Also\nCanvas\nDrawing with PencilKit\nAdd expressive, low-latency drawing to your app using PencilKit.\nCustomizing Scribble with Interactions\nEnable writing on a non-text-input view by adding interactions.\nInspecting, Modifying, and Constructing PencilKit Drawings\nScore users’ ability to match PencilKit drawings generated from text, by accessing the strokes and points inside PencilKit drawings.\nclass PKCanvasView\nA view that captures Apple Pencil input and displays the rendered results in an iOS app.\nstruct PKDrawing\nA structure representing the drawing information captured by a canvas view.\nstruct PKStrokePath\nA structure that captures the components of a stroke and provides methods to find and interpolate points along the stroke’s path.\nstruct PKStrokePoint\nA structure that represents the properties of a specific point along a stroke’s path.\nstruct PKInk\nA structure that represents an ink that specifies its type, color, and width."
  },
  {
    "title": "PKStrokePoint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepoint",
    "html": "Topics\nCreating a stroke point object\ninit(location: CGPoint, timeOffset: TimeInterval, size: CGSize, opacity: CGFloat, force: CGFloat, azimuth: CGFloat, altitude: CGFloat)\nCreates a new point with the provided properties.\ninit(location: CGPoint, timeOffset: TimeInterval, size: CGSize, opacity: CGFloat, force: CGFloat, azimuth: CGFloat, altitude: CGFloat, secondaryScale: CGFloat)\nGetting the point’s location\nvar location: CGPoint\nThe location of this point.\nvar timeOffset: TimeInterval\nThe time offset since the start of the stroke path in seconds.\nGetting the point’s touch data\nvar altitude: CGFloat\nThe altitude of this point in radians.\nvar azimuth: CGFloat\nThe azimuth of this point in radians.\nvar force: CGFloat\nThe amount of force applied by the touch.\nGetting the point’s drawing data\nvar size: CGSize\nThe size of this point.\nvar opacity: CGFloat\nOpacity of the point.\nvar secondaryScale: CGFloat\nUsing reference types\nclass PKStrokePointReference\nA class that represents the properties of a specific point along a stroke’s path.\nSee Also\nCanvas\nDrawing with PencilKit\nAdd expressive, low-latency drawing to your app using PencilKit.\nCustomizing Scribble with Interactions\nEnable writing on a non-text-input view by adding interactions.\nInspecting, Modifying, and Constructing PencilKit Drawings\nScore users’ ability to match PencilKit drawings generated from text, by accessing the strokes and points inside PencilKit drawings.\nclass PKCanvasView\nA view that captures Apple Pencil input and displays the rendered results in an iOS app.\nstruct PKDrawing\nA structure representing the drawing information captured by a canvas view.\nstruct PKStroke\nA structure that represents the paths, boundaries, and other properties of a stroke drawn on a canvas.\nstruct PKStrokePath\nA structure that captures the components of a stroke and provides methods to find and interpolate points along the stroke’s path.\nstruct PKInk\nA structure that represents an ink that specifies its type, color, and width."
  },
  {
    "title": "PKStrokePath | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkstrokepath",
    "html": "Topics\nCreating a new stroke path\ninit()\nCreates an empty stroke path.\ninit<T>(controlPoints: T, creationDate: Date)\nCreates a stroke path with the cubic B-spline control points and a date that you specify.\nGetting the stroke path properties\nvar count: Int\nThe number of elements in the collection.\nvar creationDate: Date\nThe creation date and time of this stroke path.\nvar endIndex: Int\nThe index of the last item in the collection.\nvar first: PKStrokePoint?\nThe first element of the collection.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar last: PKStrokePoint?\nThe last element of the collection.\nvar startIndex: Int\nThe index of the first item in the collection.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection.\nGetting the stroke path data\nvar lazy: LazySequence<PKStrokePath>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.\nvar publisher: Publishers.Sequence<PKStrokePath, Never>\nA publisher of stroke path sequences.\nAccessing and interpolating points\nfunc interpolatedPoints(in: ClosedRange<CGFloat>?, by: PKStrokePath.InterpolatedSlice.Stride) -> PKStrokePath.InterpolatedSlice\nReturns the slice on-curve points using the floating point range and stride that you specify.\nfunc interpolatedLocation(at: CGFloat) -> CGPoint\nReturns the on-curve point for the floating point parametric value.\nfunc interpolatedPoint(at: CGFloat) -> PKStrokePoint\nReturns the on-curve point for the provided floating point parameter.\nfunc parametricValue(CGFloat, offsetBy: PKStrokePath.InterpolatedSlice.Stride) -> CGFloat\nsubscript(PKStrokePath.Index) -> PKStrokePoint\nAccess the stroke point at the provided index.\nsubscript<R>(R) -> Slice<PKStrokePath>\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Slice<PKStrokePath>\nsubscript(Range<Int>) -> Slice<PKStrokePath>\nAccesses a contiguous subrange of the collection’s elements.\nSupporting types\nstruct PKStrokePath.InterpolatedSlice\nA struct representing an interpolated slice of stroke points with a specific stride across a range of this stroke data.\ntypealias PKStrokePath.Element\nA type that represents the sequence’s elements.\ntypealias PKStrokePath.Index\nA type that represents a position in the collection.\ntypealias PKStrokePath.Indices\nA type that represents the indices that are valid for subscripting the collection, in ascending order.\ntypealias PKStrokePath.Iterator\nA type that provides the collection’s iteration interface and encapsulates its iteration state.\ntypealias PKStrokePath.SubSequence\nA type that represents a contiguous subrange of this collection’s elements.\nSupporting protocol requirements\nProtocol implementations\nAccess the stroke path’s implementations of protocol methods.\nUsing reference types\nclass PKStrokePathReference\nA class that captures the components of a stroke and provides methods to find and interpolate points along the stroke’s path.\nRelationships\nConforms To\nRandomAccessCollection\nSee Also\nCanvas\nDrawing with PencilKit\nAdd expressive, low-latency drawing to your app using PencilKit.\nCustomizing Scribble with Interactions\nEnable writing on a non-text-input view by adding interactions.\nInspecting, Modifying, and Constructing PencilKit Drawings\nScore users’ ability to match PencilKit drawings generated from text, by accessing the strokes and points inside PencilKit drawings.\nclass PKCanvasView\nA view that captures Apple Pencil input and displays the rendered results in an iOS app.\nstruct PKDrawing\nA structure representing the drawing information captured by a canvas view.\nstruct PKStroke\nA structure that represents the paths, boundaries, and other properties of a stroke drawn on a canvas.\nstruct PKStrokePoint\nA structure that represents the properties of a specific point along a stroke’s path.\nstruct PKInk\nA structure that represents an ink that specifies its type, color, and width."
  },
  {
    "title": "PKDrawing | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkdrawing",
    "html": "Overview\n\nA PKDrawing object stores the user-drawn content from a PKCanvasView object. You use drawing objects to store the data associated with your user’s drawings. You can save this data with the rest of your app’s content, and you can use that saved data to create a new drawing object later. You can also generate an image based on the drawn content that you can copy to the pasteboard, save to disk, or share.\n\nTopics\nCreating a drawing object\ninit<S>(strokes: S)\nCreates a drawing object and populates it with a sequence of strokes the user provides.\ninit(data: Data)\nCreates a drawing object and populates it with previously drawn content.\ninit()\nCreates an empty drawing object.\ninit(from: Decoder)\nCreates a drawing object and populates it with previously drawn content stored on disk.\nGetting the canvas bounds\nvar bounds: CGRect\nThe smallest rectangle used to represent the content’s bounds, taking into account line widths of that content.\nGenerating an image\nfunc image(from: CGRect, scale: CGFloat) -> UIImage\nReturns an image object that contains the specified portion of the drawing.\nfunc image(from: CGRect, scale: CGFloat) -> NSImage\nReturns an image object that contains the specified portion of the drawing.\nGetting the drawing data\nvar strokes: [PKStroke]\nThe array of strokes that make up the drawing.\nfunc dataRepresentation() -> Data\nReturns a raw data representation of the rendered content.\nlet PKAppleDrawingTypeIdentifier: CFString\nThe uniform type identifier for data associated with a drawing object.\nModifying the drawing\nfunc transform(using: CGAffineTransform)\nApplies the specified transform to the contents of this drawing.\nfunc transformed(using: CGAffineTransform) -> PKDrawing\nApplies the specified transform and returns a new drawing.\nfunc append(PKDrawing)\nAppends the contents of the specified drawing object to an existing drawing object that you provide.\nfunc appending(PKDrawing) -> PKDrawing\nReturns a new drawing created by appending the current drawing with another drawing you provide.\nEncoding the drawing object\nfunc encode(to: Encoder)\nSupporting backward compatibility\nvar requiredContentVersion: PKContentVersion\nThe version of PencilKit necessary to use the drawing.\nComparing drawing objects\nstatic func == (PKDrawing, PKDrawing) -> Bool\nReturns a Boolean value that indicates whether the two drawing objects are equivalent.\nstatic func != (PKDrawing, PKDrawing) -> Bool\nReturns a Boolean value that indates whether the two drawing objects aren’t equivalent.\nUsing reference types\nclass PKDrawingReference\nA data structure that contains the drawing information captured by a canvas view.\nRelationships\nConforms To\nDecodable\nEncodable\nSee Also\nCanvas\nDrawing with PencilKit\nAdd expressive, low-latency drawing to your app using PencilKit.\nCustomizing Scribble with Interactions\nEnable writing on a non-text-input view by adding interactions.\nInspecting, Modifying, and Constructing PencilKit Drawings\nScore users’ ability to match PencilKit drawings generated from text, by accessing the strokes and points inside PencilKit drawings.\nclass PKCanvasView\nA view that captures Apple Pencil input and displays the rendered results in an iOS app.\nstruct PKStroke\nA structure that represents the paths, boundaries, and other properties of a stroke drawn on a canvas.\nstruct PKStrokePath\nA structure that captures the components of a stroke and provides methods to find and interpolate points along the stroke’s path.\nstruct PKStrokePoint\nA structure that represents the properties of a specific point along a stroke’s path.\nstruct PKInk\nA structure that represents an ink that specifies its type, color, and width."
  },
  {
    "title": "PKCanvasView | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/pkcanvasview",
    "html": "Overview\n\nA PKCanvasView object captures content drawn using Apple Pencil or the user’s finger and displays it in your app. The canvas view handles all of the touch events and data coming from Apple Pencil, and renders that information using the tool you specify. The canvas stores the captured input in a PKDrawingReference object.\n\nPKCanvasView is a scroll view, so you can make the drawable area bigger than the canvas view’s frame rectangle. To do that, set the inherited contentSize property to the size you want. The canvas view automatically scales its underlying content to match the size you specify. Users scroll around the canvas using a two-finger pan gesture. (If the allowsFingerDrawing property is false, users scroll with only one finger.)\n\nA canvas view conforms to the PKToolPickerObserver protocol, so you can add it as an observer of the window’s tool picker. The tool picker displays a floating palette of tools that the user can choose from. As the user interacts with items in the palette, such as changing ink colors, or line widths, the canvas automatically updates its drawing environment accordingly.\n\nTopics\nResponding to drawing-related changes\nvar delegate: PKCanvasViewDelegate?\nThe object you use to respond to changes in the drawn content or with the selected tool.\nprotocol PKCanvasViewDelegate\nMethods for monitoring drawing related changes in a canvas view.\nConfiguring the drawing environment\nvar tool: PKTool\nThe currently selected tool used for drawing.\nvar isRulerActive: Bool\nA Boolean value that indicates whether a ruler view is visible on the canvas.\nvar allowsFingerDrawing: Bool\nA Boolean value that indicates whether the canvas accepts input from the user’s finger in addition to Apple Pencil.\nDeprecated\nvar drawingPolicy: PKCanvasViewDrawingPolicy\nThe policy that controls the types of touches allowed when drawing on the canvas.\nenum PKCanvasViewDrawingPolicy\nConstants that you use to specify the type of drawing gestures your app permits while the user draws on the canvas.\nGetting the drawing gesture recognizer\nvar drawingGestureRecognizer: UIGestureRecognizer\nThe gesture recognizer that the canvas uses to track touch events.\nGetting the captured data\nvar drawing: PKDrawing\nThe data object that the canvas uses to store drawn content.\nSupporting PencilKit versions\nvar maximumSupportedContentVersion: PKContentVersion\nThe maximum version of PencilKit to support.\nRelationships\nInherits From\nUIScrollView\nConforms To\nPKToolPickerObserver\nSee Also\nCanvas\nDrawing with PencilKit\nAdd expressive, low-latency drawing to your app using PencilKit.\nCustomizing Scribble with Interactions\nEnable writing on a non-text-input view by adding interactions.\nInspecting, Modifying, and Constructing PencilKit Drawings\nScore users’ ability to match PencilKit drawings generated from text, by accessing the strokes and points inside PencilKit drawings.\nstruct PKDrawing\nA structure representing the drawing information captured by a canvas view.\nstruct PKStroke\nA structure that represents the paths, boundaries, and other properties of a stroke drawn on a canvas.\nstruct PKStrokePath\nA structure that captures the components of a stroke and provides methods to find and interpolate points along the stroke’s path.\nstruct PKStrokePoint\nA structure that represents the properties of a specific point along a stroke’s path.\nstruct PKInk\nA structure that represents an ink that specifies its type, color, and width."
  },
  {
    "title": "Customizing Scribble with Interactions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/customizing_scribble_with_interactions",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC20 session 10106: Meet Scribble for iPad.\n\nThis sample code project must be run on a physical device with Apple Pencil.\n\nSee Also\nCanvas\nDrawing with PencilKit\nAdd expressive, low-latency drawing to your app using PencilKit.\nInspecting, Modifying, and Constructing PencilKit Drawings\nScore users’ ability to match PencilKit drawings generated from text, by accessing the strokes and points inside PencilKit drawings.\nclass PKCanvasView\nA view that captures Apple Pencil input and displays the rendered results in an iOS app.\nstruct PKDrawing\nA structure representing the drawing information captured by a canvas view.\nstruct PKStroke\nA structure that represents the paths, boundaries, and other properties of a stroke drawn on a canvas.\nstruct PKStrokePath\nA structure that captures the components of a stroke and provides methods to find and interpolate points along the stroke’s path.\nstruct PKStrokePoint\nA structure that represents the properties of a specific point along a stroke’s path.\nstruct PKInk\nA structure that represents an ink that specifies its type, color, and width."
  },
  {
    "title": "Drawing with PencilKit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit/drawing_with_pencilkit",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC19 session 221: Introducing PencilKit and WWDC20 session 10107: What’s New in PencilKit.\n\nThis sample code project must be run on a physical device with Apple Pencil.\n\nSee Also\nCanvas\nCustomizing Scribble with Interactions\nEnable writing on a non-text-input view by adding interactions.\nInspecting, Modifying, and Constructing PencilKit Drawings\nScore users’ ability to match PencilKit drawings generated from text, by accessing the strokes and points inside PencilKit drawings.\nclass PKCanvasView\nA view that captures Apple Pencil input and displays the rendered results in an iOS app.\nstruct PKDrawing\nA structure representing the drawing information captured by a canvas view.\nstruct PKStroke\nA structure that represents the paths, boundaries, and other properties of a stroke drawn on a canvas.\nstruct PKStrokePath\nA structure that captures the components of a stroke and provides methods to find and interpolate points along the stroke’s path.\nstruct PKStrokePoint\nA structure that represents the properties of a specific point along a stroke’s path.\nstruct PKInk\nA structure that represents an ink that specifies its type, color, and width."
  },
  {
    "title": "PencilKit | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/pencilkit",
    "html": "Overview\n\nPencilKit makes it easy to incorporate hand-drawn content into your iPadOS or macOS apps. PencilKit provides a drawing environment for your iOS app that receives input from Apple Pencil or the user’s finger, and turns it into images you display in iPadOS, iOS, or macOS. The environment comes with tools for creating, erasing, and selecting lines.\n\nYou capture content in your iPad app using a PKCanvasView object that you integrate into your existing view hierarchy. It supports the low-latency capture of touches originating from Apple Pencil or your finger. The canvas object sends final results as a PKDrawing object, whose contents you can save with your app’s content. You can also convert the drawn content into an image for display in iOS or macOS app.\n\nFor information about handling user interactions on Apple Pencil in your UIKit app, see Pencil interactions.\n\nTopics\nCanvas\nDrawing with PencilKit\nAdd expressive, low-latency drawing to your app using PencilKit.\nCustomizing Scribble with Interactions\nEnable writing on a non-text-input view by adding interactions.\nInspecting, Modifying, and Constructing PencilKit Drawings\nScore users’ ability to match PencilKit drawings generated from text, by accessing the strokes and points inside PencilKit drawings.\nclass PKCanvasView\nA view that captures Apple Pencil input and displays the rendered results in an iOS app.\nstruct PKDrawing\nA structure representing the drawing information captured by a canvas view.\nstruct PKStroke\nA structure that represents the paths, boundaries, and other properties of a stroke drawn on a canvas.\nstruct PKStrokePath\nA structure that captures the components of a stroke and provides methods to find and interpolate points along the stroke’s path.\nstruct PKStrokePoint\nA structure that represents the properties of a specific point along a stroke’s path.\nstruct PKInk\nA structure that represents an ink that specifies its type, color, and width.\nTools\nclass PKToolPicker\nA tool palette that displays a selection of drawing tools and colors for tools and colors that a user can choose from.\nstruct PKInkingTool\nA structure that defines the drawing characteristics (width, color, pen style) to use when drawing lines on a canvas view.\nstruct PKEraserTool\nA tool for erasing previously drawn content in a canvas view.\nstruct PKLassoTool\nA tool for selecting stroked lines and shapes in a canvas view.\nprotocol PKTool\nAn interface adopted by drawing and writing tools used by a canvas view.\nBackward compatibility\nSupporting backward compatibility for ink types\nLeverage the latest PencilKit features while providing a good user experience in earlier versions of the OS that don’t support those features.\nenum PKContentVersion\nConstants that represent versions of PencilKit for backward compatibility."
  }
]
