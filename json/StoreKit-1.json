[
  {
    "title": "SKProductStorePromotionVisibility.hide",
    "url": "https://developer.apple.com/documentation/storekit/skproductstorepromotionvisibility/hide",
    "html": "See Also\nEnumeration cases\ncase `default`\nIndicates product visibility is the same as the default value set in App Store Connect.\ncase show\nIndicates product is shown."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/priceincreasestatus/3822286-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and Hashing Status\nstatic func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "PurchaseIntent.PurchaseIntents.AsyncIterator.Element",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/asynciterator/element",
    "html": "See Also\nGetting the next element\nfunc next() -> PurchaseIntent.PurchaseIntents.Element?\nAdvances to and returns the next element, if it exists."
  },
  {
    "title": "Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/priceincreasestatus/agreed",
    "html": "Discussion\n\nThere are two types of price increases for auto-renewable subscriptions: those that require customer consent, and those that don’t require customer consent. For a price increase that requires customer consent, this value indicates that the customer consented to the price increase. For a price increase that doesn’t require customer consent, this value indicates that the App Store informed the customer of the price increase and the subscription is subject to the price increase.\n\nFor more information about this value, see Managing Price Increases for Auto-Renewable Subscriptions.\n\nSee Also\nGetting Price Increase Status\ncase noIncreasePending\nThere’s no pending price increase for the auto-renewable subscription.\ncase pending\nThe customer hasn’t yet responded to an auto-renewable subscription price increase that requires customer consent."
  },
  {
    "title": "price",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/2936871-price",
    "html": "Discussion\n\nUse the priceLocale to format the price.\n\nSee Also\nGetting Price and Payment Mode\nvar priceLocale: Locale\nThe locale used to format the discount price of the product.\nvar paymentMode: SKProductDiscount.PaymentMode\nThe payment mode for this product discount.\nenum SKProductDiscount.PaymentMode\nValues representing the payment modes for a product discount."
  },
  {
    "title": "Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/priceincreasestatus/pending",
    "html": "Discussion\n\nFor more information about this value, see Managing Price Increases for Auto-Renewable Subscriptions.\n\nSee Also\nGetting Price Increase Status\ncase noIncreasePending\nThere’s no pending price increase for the auto-renewable subscription.\ncase agreed\nThe auto-renewable subscription is subject to a price increase."
  },
  {
    "title": "SKProductDiscount.Type.subscription",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/type/subscription",
    "html": "Discussion\n\nFor more information about promotional offers, see Implementing promotional offers in your app.\n\nSee Also\nTypes of Offers\ncase introductory\nA constant indicating the discount type is an introductory offer."
  },
  {
    "title": "SKProductDiscount.Type.introductory",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/type/introductory",
    "html": "Discussion\n\nFor more information, see Implementing introductory offers in your app.\n\nSee Also\nTypes of Offers\ncase subscription\nA constant indicating the discount type is a promotional offer."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason/3749462-init",
    "html": "Parameters\nrawValue\n\nAn integer that represents an expiration reason.\n\nDiscussion\n\nTypically, you get an expiration reason from the expirationReason property of Product.SubscriptionInfo.RenewalInfo and you don’t need to instantiate it yourself.\n\nHowever, if you use the jsonRepresentation property of Product.SubscriptionInfo.RenewalInfo, you can use raw values and the initializer to help parse the JSON data. The data contains the integer representation of the ownership type, which is its raw value. Call init(rawValue:) to create your own instance from that raw value. Alternatively, you can compare the JSON data directly to the expiration reason’s rawValue.\n\nRelationships\nFrom Protocol\nRawRepresentable"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason/3749455",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing expiration reasons\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/paymentmode/4307060",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing payment modes\nvar hashValue: Int\nThe hash value.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": ">(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/4179064",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable.\n\nSee Also\nInherited operators\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func < (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nstatic func <= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func >= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "..<(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/4179057",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition: maximum must compare equal to itself (i.e. cannot be NaN).\n\nSee Also\nInherited operators\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func < (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nstatic func <= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func > (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func >= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason/3749460-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nSee Also\nComparing and hashing expiration reasons\nstatic func != (Product.SubscriptionInfo.RenewalInfo.ExpirationReason, Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "<(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/4179062",
    "html": "Relationships\nFrom Protocol\nComparable\nSee Also\nInherited operators\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func <= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func > (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func >= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/priceincreasestatus/3822284",
    "html": "See Also\nComparing and Hashing Status\nstatic func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "productUnavailable",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason/3749463-productunavailable",
    "html": "See Also\nGetting the expiration reason\nstatic let autoRenewDisabled: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because the customer voluntarily canceled their subscription.\nstatic let billingError: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because of a billing error.\nstatic let didNotConsentToPriceIncrease: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe subscription expired because the customer didn’t consent to an auto-renewable subscription price increase that requires customer consent.\nstatic let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired for an unknown reason."
  },
  {
    "title": "freeTrial",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/paymentmode/4307062-freetrial",
    "html": "Discussion\n\nWith a Free trial payment mode, customers pay nothing during the discount period.\n\nSee Also\nGetting payment modes\nstatic let payAsYouGo: Transaction.Offer.PaymentMode\nA payment mode of a product discount that’s billed over a single or multiple billing periods.\nstatic let payUpFront: Transaction.Offer.PaymentMode\nA payment mode of a product discount that’s paid up front."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/paymentmode/4307065-init",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nInitializing payment modes\nlet rawValue: String\nA string that represents a payment mode."
  },
  {
    "title": "payAsYouGo",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/paymentmode/4307066-payasyougo",
    "html": "Discussion\n\nWith a Pay As You Go payment mode, subscribers pay a discounted price for each billing period for the duration of the discount.\n\nSee Also\nGetting payment modes\nstatic let freeTrial: Transaction.Offer.PaymentMode\nA payment mode of a product discount that indicates a free trial.\nstatic let payUpFront: Transaction.Offer.PaymentMode\nA payment mode of a product discount that’s paid up front."
  },
  {
    "title": "payUpFront",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/paymentmode/4307067-payupfront",
    "html": "Discussion\n\nWith a Pay Up Front payment mode, subscribers pay a one-time discounted price for a specific duration.\n\nSee Also\nGetting payment modes\nstatic let freeTrial: Transaction.Offer.PaymentMode\nA payment mode of a product discount that indicates a free trial.\nstatic let payAsYouGo: Transaction.Offer.PaymentMode\nA payment mode of a product discount that’s billed over a single or multiple billing periods."
  },
  {
    "title": "Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason/rawvalue",
    "html": "See Also\nAccessing the raw value\nlet rawValue: Int\nThe raw value that represents an expiration reason."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/paymentmode/4307068-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nInitializing payment modes\ninit(rawValue: String)\nCreates a payment mode."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/paymentmode/4307063-hash",
    "html": "See Also\nComparing payment modes\nvar hashValue: Int\nThe hash value.\nstatic func != (Transaction.Offer.PaymentMode, Transaction.Offer.PaymentMode) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "renewal",
    "url": "https://developer.apple.com/documentation/storekit/transaction/reason/4193538-renewal",
    "html": "See Also\nTransaction reasons\nstatic let purchase: Transaction.Reason\nA transaction reason that indicates a purchase is initiated by a customer."
  },
  {
    "title": "autoRenewDisabled",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason/3803201-autorenewdisabled",
    "html": "See Also\nGetting the expiration reason\nstatic let billingError: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because of a billing error.\nstatic let didNotConsentToPriceIncrease: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe subscription expired because the customer didn’t consent to an auto-renewable subscription price increase that requires customer consent.\nstatic let productUnavailable: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because the product was unavailable for purchase at the time of the renewal.\nstatic let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired for an unknown reason."
  },
  {
    "title": "productsRequest(_:didReceive:)",
    "url": "https://developer.apple.com/documentation/storekit/skproductsrequestdelegate/1506070-productsrequest",
    "html": "Required\n\nParameters\nrequest\n\nThe product request sent to the Apple App Store.\n\nresponse\n\nDetailed information about the list of products.\n\nSee Also\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/priceincreasestatus/3822287-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and Hashing Status\nstatic func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": ">=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/4179065",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable.\n\nSee Also\nInherited operators\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func < (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nstatic func <= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func > (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument."
  },
  {
    "title": "<=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/4179063",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable.\n\nSee Also\nInherited operators\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func < (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nstatic func > (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func >= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/priceincreasestatus/3822283",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and Hashing Status\nstatic func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "next()",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/asynciterator/3868406-next",
    "html": "Relationships\nFrom Protocol\nAsyncIteratorProtocol\nSee Also\nGetting the Next Element\ntypealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element\nThe type of element the iterator produces."
  },
  {
    "title": "next()",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/asynciterator/4123335-next",
    "html": "Return Value\n\nThe next element in the underlying sequence, if a next element exists; otherwise, nil.\n\nRelationships\nFrom Protocol\nAsyncIteratorProtocol\nSee Also\nGetting the next element\ntypealias PurchaseIntent.PurchaseIntents.AsyncIterator.Element\nThe type of element the iterator produces."
  },
  {
    "title": "SKProductDiscount.PaymentMode.payAsYouGo",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/paymentmode/payasyougo",
    "html": "Discussion\n\nWith a pay as you go payment mode, users pay the discounted price at each billing period during the discount period.\n\nSee Also\nDiscount Price Payment Modes\ncase payUpFront\nA constant indicating that the payment mode of a product discount is paid up front.\ncase freeTrial\nA constant that indicates that the payment mode is a free trial."
  },
  {
    "title": "unit",
    "url": "https://developer.apple.com/documentation/storekit/skproductsubscriptionperiod/2936885-unit",
    "html": "Discussion\n\nThe units used to specify a subscription period include day, week, month, and year, as defined in SKProduct.PeriodUnit.\n\nTo calculate the duration of one subscription period, multiply the unit by the number of units (numberOfUnits).\n\nSee Also\nGetting Subscription Period Details\nvar numberOfUnits: Int\nThe number of units per subscription period.\nenum SKProduct.PeriodUnit\nValues representing the duration of an interval, from a day up to a year."
  },
  {
    "title": "...(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/4179052",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition: maximum must compare equal to itself (i.e. cannot be NaN).\n\nSee Also\nInherited operators\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func < (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nstatic func <= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func > (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func >= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/priceincreasestatus/noincreasepending",
    "html": "Discussion\n\nFor more information about this value, see Managing Price Increases for Auto-Renewable Subscriptions.\n\nSee Also\nGetting Price Increase Status\ncase agreed\nThe auto-renewable subscription is subject to a price increase.\ncase pending\nThe customer hasn’t yet responded to an auto-renewable subscription price increase that requires customer consent."
  },
  {
    "title": "next()",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/asynciterator/3851121-next",
    "html": "Return Value\n\nThe next element in the underlying sequence, if a next element exists; otherwise, nil.\n\nRelationships\nFrom Protocol\nAsyncIteratorProtocol\nSee Also\nGetting the Next Element\ntypealias Storefront.Storefronts.AsyncIterator.Element\nThe type of element produced by this iterator.\ntypealias Storefront.Storefronts.Element\nA type that represents the element of a storefront sequence."
  },
  {
    "title": "..<(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/4179060",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition: minimum <= maximum.\n\nSee Also\nInherited operators\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, but not including, its upper bound.\nstatic func < (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nstatic func <= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func > (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func >= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "Storefront.Storefronts.Element",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/element",
    "html": "See Also\nGetting the Next Element\nfunc next() -> Storefront?\nAdvances to the next element and returns either the element or nil if there isn’t a next element.\ntypealias Storefront.Storefronts.AsyncIterator.Element\nThe type of element produced by this iterator."
  },
  {
    "title": "...(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/4179049",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition: minimum must compare equal to itself (i.e. cannot be NaN).\n\nSee Also\nInherited operators\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func < (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nstatic func <= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func > (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func >= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "Storefront.Storefronts.AsyncIterator.Element",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/asynciterator/element",
    "html": "Discussion\n\nThe iterator produces Storefront elements.\n\nSee Also\nGetting the Next Element\nfunc next() -> Storefront?\nAdvances to the next element and returns either the element or nil if there isn’t a next element.\ntypealias Storefront.Storefronts.Element\nA type that represents the element of a storefront sequence."
  },
  {
    "title": "...(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/4179055",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition: minimum <= maximum.\n\nSee Also\nInherited operators\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, and including, its upper bound.\nstatic func ..< (Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func < (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nstatic func <= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func > (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func >= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason/3749461-hashvalue",
    "html": "See Also\nComparing and hashing expiration reasons\nstatic func != (Product.SubscriptionInfo.RenewalInfo.ExpirationReason, Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "SKProductStorePromotionVisibility.default",
    "url": "https://developer.apple.com/documentation/storekit/skproductstorepromotionvisibility/default",
    "html": "See Also\nEnumeration cases\ncase hide\nIndicates product is hidden.\ncase show\nIndicates product is shown."
  },
  {
    "title": "identifier",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentdiscount/3043528-identifier",
    "html": "Discussion\n\nYou set up offers and their identifiers in App Store Connect. If the identifier is not valid, an SKError.Code.invalidOfferIdentifier error can result.\n\nSee Also\nIdentifying the Discount\nvar keyIdentifier: String\nA string that identifies the key used to generate the signature."
  },
  {
    "title": "identifier",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/3043535-identifier",
    "html": "Discussion\n\nYou set up offers and their identifiers in App Store Connect.\n\nSee Also\nIdentifying the Discount\nvar type: SKProductDiscount.`Type`\nThe type of discount offer.\nenum SKProductDiscount.Type\nValues representing the types of discount offers an app can present."
  },
  {
    "title": "signature",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentdiscount/3043532-signature",
    "html": "Discussion\n\nThe signature is a string signed with your private key that represents the properties of a specific promotional offer. To keep your private key secure, generate the signature on a server.\n\nGenerate the signature using the Elliptic Curve Digital Signature Algorithm (ECDSA) with SHA 256. For more information, see Generating a signature for promotional offers.\n\nSee Also\nValidating the Discount\nvar nonce: UUID\nA universally unique ID (UUID) value that you define.\nvar timestamp: NSNumber\nThe date and time of the signature's creation in milliseconds, formatted in Unix epoch time."
  },
  {
    "title": "SKProductDiscount.PaymentMode.freeTrial",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/paymentmode/freetrial",
    "html": "Discussion\n\nWith a free trial payment mode, the price is 0, so users pay nothing during the discount period.\n\nSee Also\nDiscount Price Payment Modes\ncase payAsYouGo\nA constant indicating that the payment mode of a product discount is billed over a single or multiple billing periods.\ncase payUpFront\nA constant indicating that the payment mode of a product discount is paid up front."
  },
  {
    "title": "SKProductDiscount.PaymentMode",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/paymentmode",
    "html": "Overview\n\nThe payment mode indicates if the discount price is charged one time, multiple times, or if the discount is a free trial.\n\nThe payment mode may determine the wording you choose to phrase the offer in your app's UI.\n\nTopics\nDiscount Price Payment Modes\ncase payAsYouGo\nA constant indicating that the payment mode of a product discount is billed over a single or multiple billing periods.\ncase payUpFront\nA constant indicating that the payment mode of a product discount is paid up front.\ncase freeTrial\nA constant that indicates that the payment mode is a free trial.\nRelationships\nConforms To\nSendable\nSee Also\nGetting Price and Payment Mode\nvar price: NSDecimalNumber\nThe discount price of the product in the local currency.\nvar priceLocale: Locale\nThe locale used to format the discount price of the product.\nvar paymentMode: SKProductDiscount.PaymentMode\nThe payment mode for this product discount."
  },
  {
    "title": "SKProductDiscount.PaymentMode.payUpFront",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/paymentmode/payupfront",
    "html": "Discussion\n\nWith a pay up front payment mode, users pay the discounted price one time, and receive the product for duration of the discount period.\n\nSee Also\nDiscount Price Payment Modes\ncase payAsYouGo\nA constant indicating that the payment mode of a product discount is billed over a single or multiple billing periods.\ncase freeTrial\nA constant that indicates that the payment mode is a free trial."
  },
  {
    "title": "SKProduct.PeriodUnit.month",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/periodunit/month",
    "html": "See Also\nPeriod Units\ncase day\nAn interval lasting one day.\ncase week\nAn interval lasting one week.\ncase year\nAn interval lasting one year."
  },
  {
    "title": "SKProduct.PeriodUnit.year",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/periodunit/year",
    "html": "See Also\nPeriod Units\ncase day\nAn interval lasting one day.\ncase month\nAn interval lasting one month.\ncase week\nAn interval lasting one week."
  },
  {
    "title": "SKProduct.PeriodUnit.week",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/periodunit/week",
    "html": "See Also\nPeriod Units\ncase day\nAn interval lasting one day.\ncase month\nAn interval lasting one month.\ncase year\nAn interval lasting one year."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/reason/4193531",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing\nvar hashValue: Int\nThe hash value.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/reason/4193535-init",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating transaction reasons\nlet rawValue: String\nThe corresponding value of the raw type.\ntypealias Transaction.Reason.RawValue\nA type that represents the raw value of a transaction reason."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/reason/4193533-hash",
    "html": "See Also\nComparing and hashing\nvar hashValue: Int\nThe hash value.\nstatic func != (Transaction.Reason, Transaction.Reason) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "Transaction.Reason.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/reason/rawvalue",
    "html": "See Also\nCreating transaction reasons\ninit(rawValue: String)\nReturns a new transaction reason with the specified raw value.\nlet rawValue: String\nThe corresponding value of the raw type."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/ownershiptype/3749657-rawvalue",
    "html": "Discussion\n\nUse the raw value to help parse the jsonRepresentation property of Transaction. The JSON data contains a string representation of the transaction ownership type, which is its raw value. You can compare the JSON data directly to the ownership type’s rawValue.\n\nYou can also use the rawValue to create a transaction ownership type instance by calling init(rawValue:).\n\nRelationships\nFrom Protocol\nRawRepresentable\nSee Also\nAccessing the raw value\ntypealias Transaction.OwnershipType.RawValue\nThe type that represents the raw value of a transaction’s ownership type."
  },
  {
    "title": "purchase",
    "url": "https://developer.apple.com/documentation/storekit/transaction/reason/4193536-purchase",
    "html": "Discussion\n\nThe customer initiated the purchase, which may be for any in-app purchase type: consumable, non-consumable, non-renewing subscription, or auto-renewable subscription.\n\nSee Also\nTransaction reasons\nstatic let renewal: Transaction.Reason\nA transaction reason that indicates the App Store server initiated a purchase transaction to renew an auto-renewable subscription."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/reason/4193537-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating transaction reasons\ninit(rawValue: String)\nReturns a new transaction reason with the specified raw value.\ntypealias Transaction.Reason.RawValue\nA type that represents the raw value of a transaction reason."
  },
  {
    "title": "locale(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044340-locale",
    "html": "Relationships\nFrom Protocol\nFormatStyle\nSee Also\nFormatting subscription period units\nfunc format(Product.SubscriptionPeriod.Unit) -> String\nfunc encode(to: any Encoder)"
  },
  {
    "title": "purchased",
    "url": "https://developer.apple.com/documentation/storekit/transaction/ownershiptype/3749656-purchased",
    "html": "See Also\nGetting ownership types\nstatic let familyShared: Transaction.OwnershipType\nThe transaction belongs to a family member who benefits from the service."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/reason/4193534-hashvalue",
    "html": "See Also\nComparing and hashing\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nstatic func != (Transaction.Reason, Transaction.Reason) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "init(from:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044337-init",
    "html": "Relationships\nFrom Protocol\nDecodable"
  },
  {
    "title": "list(memberStyle:type:width:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044338-list",
    "html": "See Also\nApplying list styles\nstatic func list<Base>(type: ListFormatStyle<StringStyle, Base>.ListType, width: ListFormatStyle<StringStyle, Base>.Width) -> ListFormatStyle<StringStyle, Base>"
  },
  {
    "title": "list(type:width:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044339-list",
    "html": "See Also\nApplying list styles\nstatic func list<MemberStyle, Base>(memberStyle: MemberStyle, type: ListFormatStyle<MemberStyle, Base>.ListType, width: ListFormatStyle<MemberStyle, Base>.Width) -> ListFormatStyle<MemberStyle, Base>"
  },
  {
    "title": "billingError",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason/3749457-billingerror",
    "html": "Discussion\n\nCheck the value of isInBillingRetry to determine whether an auto-renewable subscription is in a billing retry state.\n\nSee Also\nGetting the expiration reason\nstatic let autoRenewDisabled: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because the customer voluntarily canceled their subscription.\nstatic let didNotConsentToPriceIncrease: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe subscription expired because the customer didn’t consent to an auto-renewable subscription price increase that requires customer consent.\nstatic let productUnavailable: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because the product was unavailable for purchase at the time of the renewal.\nstatic let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired for an unknown reason."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason/3749464-rawvalue",
    "html": "Discussion\n\nUse raw values to help parse the jsonRepresentation property of the Product.SubscriptionInfo.RenewalInfo.\n\nWhen subscription renewal information has an expirationReason value, its jsonRepresentation contains an integer that represents the expiration reason, which is its raw value. Compare the JSON data directly to the expiration reason’s rawValue.\n\nYou can also use the rawValue to create an expiration reason instance by calling init(rawValue:).\n\nRelationships\nFrom Protocol\nRawRepresentable\nSee Also\nAccessing the raw value\ntypealias Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue\nA type that represents the raw value of a subscription expiration reason."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/offertype/3749539",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and Hashing Offer Types\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "unknown",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason/3749465-unknown",
    "html": "See Also\nGetting the expiration reason\nstatic let autoRenewDisabled: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because the customer voluntarily canceled their subscription.\nstatic let billingError: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because of a billing error.\nstatic let didNotConsentToPriceIncrease: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe subscription expired because the customer didn’t consent to an auto-renewable subscription price increase that requires customer consent.\nstatic let productUnavailable: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because the product was unavailable for purchase at the time of the renewal."
  },
  {
    "title": "SKProductStorePromotionVisibility.show",
    "url": "https://developer.apple.com/documentation/storekit/skproductstorepromotionvisibility/show",
    "html": "See Also\nEnumeration cases\ncase `default`\nIndicates product visibility is the same as the default value set in App Store Connect.\ncase hide\nIndicates product is hidden."
  },
  {
    "title": "introductory",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/offertype/3749544-introductory",
    "html": "Discussion\n\nFor more information about introductory offers, see Set an introductory offer for an auto-renewable subscription.\n\nSee Also\nGetting the Offer Types\nstatic let promotional: Product.SubscriptionOffer.OfferType\nA promotional offer."
  },
  {
    "title": "didNotConsentToPriceIncrease",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason/3749459-didnotconsenttopriceincrease",
    "html": "See Also\nGetting the expiration reason\nstatic let autoRenewDisabled: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because the customer voluntarily canceled their subscription.\nstatic let billingError: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because of a billing error.\nstatic let productUnavailable: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because the product was unavailable for purchase at the time of the renewal.\nstatic let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired for an unknown reason."
  },
  {
    "title": "next()",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/asynciterator/3868409-next",
    "html": "Return Value\n\nThe next element in the underlying sequence, if a next element exists; otherwise, nil.\n\nRelationships\nFrom Protocol\nAsyncIteratorProtocol\nSee Also\nGetting the Next Element\ntypealias Transaction.Transactions.AsyncIterator.Element\nThe type of element produced by this iterator."
  },
  {
    "title": "other",
    "url": "https://developer.apple.com/documentation/storekit/transaction/revocationreason/3803217-other",
    "html": "Discussion\n\nOther reasons may include, for example, an accidental purchase.\n\nSee Also\nRevocation reasons\nstatic let developerIssue: Transaction.RevocationReason\nThe value that indicates a customer canceled the transaction due to an actual or perceived issue within your app.\ntypealias Transaction.RevocationReason.RawValue\nThe type that represents the raw value of a transaction revocation reason."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/revocationreason/3803218-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nComparing and hashing reasons\nstatic func != (Transaction.RevocationReason, Transaction.RevocationReason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "measurement(width:usage:hidesScaleName:numberFormatStyle:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044341-measurement",
    "html": "See Also\nApplying measurement styles\nstatic func measurement<UnitType>(width: Measurement<UnitType>.FormatStyle.UnitWidth, usage: MeasurementFormatUnitUsage<UnitType>, numberFormatStyle: FloatingPointFormatStyle<Double>?) -> Measurement<UnitType>.FormatStyle"
  },
  {
    "title": "Product.SubscriptionOffer.PaymentMode.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/paymentmode/rawvalue",
    "html": "See Also\nAccessing the raw value\nlet rawValue: String\nThe raw string value that represents a payment mode for a subscription offer."
  },
  {
    "title": "SKProductDiscount.Type",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/type",
    "html": "Topics\nTypes of Offers\ncase introductory\nA constant indicating the discount type is an introductory offer.\ncase subscription\nA constant indicating the discount type is a promotional offer.\nRelationships\nConforms To\nSendable\nSee Also\nIdentifying the Discount\nvar identifier: String?\nA string used to uniquely identify a discount offer for a product.\nvar type: SKProductDiscount.`Type`\nThe type of discount offer."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/paymentmode/3749548",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing payment modes\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "keyIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentdiscount/3043530-keyidentifier",
    "html": "Discussion\n\nYou generate and download keys from App Store Connect. See the “KEY ID” column in App Store Connect to use as the keyIdentifier.\n\nSee Also\nIdentifying the Discount\nvar identifier: String\nA string used to uniquely identify a discount offer for a product."
  },
  {
    "title": "currency(code:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044331-currency",
    "html": "See Also\nApplying currency styles\nstatic func currency<V>(code: String) -> IntegerFormatStyle<V>.Currency"
  },
  {
    "title": "nonce",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentdiscount/3043531-nonce",
    "html": "Discussion\n\nYour server generates a unique nonce when it creates the signature string for the payment discount. The string representation of the nonce must be lowercase.\n\nYou can use a nonce one time; generate a new one for every buy request.\n\nSee Also\nValidating the Discount\nvar signature: String\nA string representing the properties of a specific promotional offer, cryptographically signed.\nvar timestamp: NSNumber\nThe date and time of the signature's creation in milliseconds, formatted in Unix epoch time."
  },
  {
    "title": "measurement(width:usage:numberFormatStyle:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044342-measurement",
    "html": "See Also\nApplying measurement styles\nstatic func measurement(width: Measurement<UnitTemperature>.FormatStyle.UnitWidth, usage: MeasurementFormatUnitUsage<UnitTemperature>, hidesScaleName: Bool, numberFormatStyle: FloatingPointFormatStyle<Double>?) -> Measurement<UnitTemperature>.FormatStyle"
  },
  {
    "title": "timestamp",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentdiscount/3043533-timestamp",
    "html": "Discussion\n\nThe timestamp keeps the payment discount active for 24 hours.\n\nSee Also\nValidating the Discount\nvar nonce: UUID\nA universally unique ID (UUID) value that you define.\nvar signature: String\nA string representing the properties of a specific promotional offer, cryptographically signed."
  },
  {
    "title": "priceLocale",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/2936869-pricelocale",
    "html": "Discussion\n\nUse the locale to format the price.\n\nSee Also\nGetting Price and Payment Mode\nvar price: NSDecimalNumber\nThe discount price of the product in the local currency.\nvar paymentMode: SKProductDiscount.PaymentMode\nThe payment mode for this product discount.\nenum SKProductDiscount.PaymentMode\nValues representing the payment modes for a product discount."
  },
  {
    "title": "paymentMode",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/2936874-paymentmode",
    "html": "Discussion\n\nThe payment mode indicates how the product discount price is charged:\n\nOne or more times, for SKProductDiscount.PaymentMode.payAsYouGo mode\n\nOnce in advance, for SKProductDiscount.PaymentMode.payUpFront mode\n\nNo initial charge, for SKProductDiscount.PaymentMode.freeTrial mode.\n\nUse the payment mode to display an accurate description of the product discount in your UI. For design guidance, see Human Interface Guidelines > In-App Purchase.\n\nSee Also\nGetting Price and Payment Mode\nvar price: NSDecimalNumber\nThe discount price of the product in the local currency.\nvar priceLocale: Locale\nThe locale used to format the discount price of the product.\nenum SKProductDiscount.PaymentMode\nValues representing the payment modes for a product discount."
  },
  {
    "title": "type",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/3043536-type",
    "html": "See Also\nIdentifying the Discount\nvar identifier: String?\nA string used to uniquely identify a discount offer for a product.\nenum SKProductDiscount.Type\nValues representing the types of discount offers an app can present."
  },
  {
    "title": "freeTrial",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/paymentmode/3749550-freetrial",
    "html": "Discussion\n\nWith a Free trial payment mode, customers pay nothing during the discount period.\n\nSee Also\nGetting the payment modes\nstatic let payAsYouGo: Product.SubscriptionOffer.PaymentMode\nA payment mode of a product discount that indicates the discount applies over a single billing period or multiple billing periods.\nstatic let payUpFront: Product.SubscriptionOffer.PaymentMode\nA payment mode of a product discount that indicates the system applies the discount up front."
  },
  {
    "title": "makeBody(configuration:)",
    "url": "https://developer.apple.com/documentation/storekit/compactproductviewstyle/4200764-makebody",
    "html": "Relationships\nFrom Protocol\nProductViewStyle\nSee Also\nCreating the style\ntypealias CompactProductViewStyle.Body\ninit()"
  },
  {
    "title": "body",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyleconfiguration/icon/4202663-body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing product view style configurations\ntypealias ProductViewStyleConfiguration.Icon.Body"
  },
  {
    "title": "numberOfPeriods",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/2936875-numberofperiods",
    "html": "Discussion\n\nA product discount may be available for one or more periods. The period, defined in subscriptionPeriod, is a set number of days, weeks, months, or years.\n\nThe total length of time that a product discount is available is calculated by multiplying the numberOfPeriods by the period.\n\nNote that the discount period is independent of the product subscription period.\n\nSee Also\nGetting the Discount Duration\nvar subscriptionPeriod: SKProductSubscriptionPeriod\nAn object that defines the period for the product discount."
  },
  {
    "title": "subscriptionPeriod",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount/2936870-subscriptionperiod",
    "html": "Discussion\n\nThis object represents the duration of a single subscription period. A period is described as a number of units, where a unit can be a SKProduct.PeriodUnit.day, SKProduct.PeriodUnit.month, SKProduct.PeriodUnit.week, or SKProduct.PeriodUnit.year.\n\nTo calculate the total amount of time that the discount price is available to the user, multiply the subscriptionPeriod by numberOfPeriods.\n\nNote\n\nThe subscription period for the discount is independent of the product's regular subscription period, and does not have to match in units or duration.\n\nSee Also\nGetting the Discount Duration\nvar numberOfPeriods: Int\nAn integer that indicates the number of periods the product discount is available."
  },
  {
    "title": "SKProduct.PeriodUnit.day",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/periodunit/day",
    "html": "See Also\nPeriod Units\ncase month\nAn interval lasting one month.\ncase week\nAn interval lasting one week.\ncase year\nAn interval lasting one year."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/ownershiptype/3749650",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing types\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/formatoutput",
    "html": "See Also\nGetting data types\ntypealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/3749566",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing units\nstatic func == (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044328",
    "html": "See Also\nComparing and hashing period unit formats\nstatic func != (Product.SubscriptionPeriod.Unit.FormatStyle, Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/ownershiptype/3749653-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nSee Also\nComparing and hashing types\nstatic func != (Transaction.OwnershipType, Transaction.OwnershipType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "format(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044334-format",
    "html": "Relationships\nFrom Protocol\nFormatStyle\nSee Also\nFormatting subscription period units\nfunc locale(Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle\nfunc encode(to: any Encoder)"
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/ownershiptype/3749655-init",
    "html": "Parameters\nrawValue\n\nA string that represents a transaction ownership type.\n\nDiscussion\n\nTypically, you get a transaction ownership type from the ownershipType property in a Transaction, and you don’t need to instantiate it yourself.\n\nHowever, if you use the jsonRepresentation property of Transaction, you can use raw values and the initializer to help parse the JSON. The JSON contains the string representation of the ownership type, which is its raw value. Call init(rawValue:) to create your own instance from that raw value. Alternatively, you can compare the JSON data directly to the ownership type’s rawValue.\n\nRelationships\nFrom Protocol\nRawRepresentable"
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/ownershiptype/3749654-hashvalue",
    "html": "See Also\nComparing and hashing types\nstatic func != (Transaction.OwnershipType, Transaction.OwnershipType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/formatinput",
    "html": "See Also\nGetting data types\ntypealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044327",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing period unit formats\nstatic func == (Product.SubscriptionPeriod.Unit.FormatStyle, Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/3749571-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing units\nstatic func != (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044336-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing period unit formats\nstatic func != (Product.SubscriptionPeriod.Unit.FormatStyle, Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionPeriod.Unit.FormatStyle, Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "currency(code:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044332-currency",
    "html": "See Also\nApplying currency styles\nstatic func currency<Value>(code: String) -> FloatingPointFormatStyle<Value>.Currency"
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044335-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing period unit formats\nstatic func != (Product.SubscriptionPeriod.Unit.FormatStyle, Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionPeriod.Unit.FormatStyle, Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "encode(to:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle/4044333-encode",
    "html": "Relationships\nFrom Protocol\nEncodable\nSee Also\nFormatting subscription period units\nfunc format(Product.SubscriptionPeriod.Unit) -> String\nfunc locale(Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle"
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/3749570-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing units\nstatic func != (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/3749567",
    "html": "See Also\nComparing and hashing units\nstatic func != (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "Product.SubscriptionPeriod.Unit.week",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/week",
    "html": "See Also\nGetting the subscription period units\ncase day\nA subscription period unit of a day.\ncase month\nA subscription period unit of a month.\ncase year\nA subscription period unit of a year."
  },
  {
    "title": "Operators",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/operators",
    "html": "Topics\nInherited operators\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeFrom<Product.SubscriptionPeriod.Unit>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Product.SubscriptionPeriod.Unit) -> PartialRangeThrough<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> ClosedRange<Product.SubscriptionPeriod.Unit>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Product.SubscriptionPeriod.Unit) -> PartialRangeUpTo<Product.SubscriptionPeriod.Unit>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Range<Product.SubscriptionPeriod.Unit>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func < (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nstatic func <= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func > (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func >= (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/revocationreason/3803214-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nSee Also\nComparing and hashing reasons\nstatic func != (Transaction.RevocationReason, Transaction.RevocationReason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value.\nlet rawValue: Int\nThe raw value of a transaction revocation reason."
  },
  {
    "title": "developerIssue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/revocationreason/3803213-developerissue",
    "html": "See Also\nRevocation reasons\nstatic let other: Transaction.RevocationReason\nThe value that indicates a customer canceled the transaction for other reasons.\ntypealias Transaction.RevocationReason.RawValue\nThe type that represents the raw value of a transaction revocation reason."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/revocationreason/3803215-hashvalue",
    "html": "See Also\nComparing and hashing reasons\nstatic func != (Transaction.RevocationReason, Transaction.RevocationReason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nlet rawValue: Int\nThe raw value of a transaction revocation reason."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/revocationreason/3803216-init",
    "html": "Relationships\nFrom Protocol\nRawRepresentable"
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/paymentmode/3749553-init",
    "html": "Parameters\nrawValue\n\nA string that represents a payment mode for a subscription offer.\n\nDiscussion\n\nTypically, you get a payment mode from the paymentMode property in subscription offer information, and you don’t need to instantiate it yourself.\n\nHowever, if you use the jsonRepresentation property of Product, you can use raw values and the initializer to help parse the JSON. If the product is a subscription with an offer, the JSON contains the string representation of the payment mode, which is its raw value. Call init(rawValue:) to create your own instance from that raw value. Alternatively, you can compare the JSON data directly to the payment mode’s rawValue.\n\nRelationships\nFrom Protocol\nRawRepresentable"
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/paymentmode/3749552-hashvalue",
    "html": "See Also\nComparing and hashing payment modes\nstatic func != (Product.SubscriptionOffer.PaymentMode, Product.SubscriptionOffer.PaymentMode) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/paymentmode/3749551-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nSee Also\nComparing and hashing payment modes\nstatic func != (Product.SubscriptionOffer.PaymentMode, Product.SubscriptionOffer.PaymentMode) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/subscriptionrenewalbehavior/4280902-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nDefault implementations\nvar hashValue: Int\nThe hash value.\nstatic func == (Product.PurchaseOption.SubscriptionRenewalBehavior, Product.PurchaseOption.SubscriptionRenewalBehavior) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc encode(to: any Encoder)\nEncodes this value into the given encoder."
  },
  {
    "title": "Transaction.Transactions.AsyncIterator.Element",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/asynciterator/element",
    "html": "See Also\nGetting the Next Element\nfunc next() -> VerificationResult<Transaction>?\nAdvances to the next element and returns either the element or nil if there isn’t a next element."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/offertype/3749541-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nSee Also\nComparing and Hashing Offer Types\nstatic func != (Product.SubscriptionOffer.OfferType, Product.SubscriptionOffer.OfferType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "payAsYouGo",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/paymentmode/3749554-payasyougo",
    "html": "Discussion\n\nWith a Pay As You Go payment mode, subscribers pay a discounted price for each billing period for the duration of the discount.\n\nSee Also\nGetting the payment modes\nstatic let freeTrial: Product.SubscriptionOffer.PaymentMode\nA payment mode of a product discount that indicates a free trial offer.\nstatic let payUpFront: Product.SubscriptionOffer.PaymentMode\nA payment mode of a product discount that indicates the system applies the discount up front."
  },
  {
    "title": "payUpFront",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/paymentmode/3749555-payupfront",
    "html": "Discussion\n\nWith a Pay Up Front payment mode, subscribers pay a one-time discounted price for a specific duration.\n\nSee Also\nGetting the payment modes\nstatic let freeTrial: Product.SubscriptionOffer.PaymentMode\nA payment mode of a product discount that indicates a free trial offer.\nstatic let payAsYouGo: Product.SubscriptionOffer.PaymentMode\nA payment mode of a product discount that indicates the discount applies over a single billing period or multiple billing periods."
  },
  {
    "title": "privacyPolicy",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorepolicykind/4211626-privacypolicy",
    "html": "See Also\nGetting policy types\nstatic var termsOfService: SubscriptionStorePolicyKind\nThe terms of service policy type."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/offertype/3749546-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating an Offer Type\ninit(rawValue: String)\nA raw value representing a subscription offer type.\ntypealias Product.SubscriptionOffer.OfferType.RawValue"
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/offertype/3749543-init",
    "html": "Parameters\nrawValue\n\nA string representing the offer type.\n\nRelationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating an Offer Type\ntypealias Product.SubscriptionOffer.OfferType.RawValue\nlet rawValue: String\nA string representing the raw value of the subscription offer type."
  },
  {
    "title": "promotional",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/offertype/3749545-promotional",
    "html": "Discussion\n\nFor more information about promotional offers, see Set up promotional offers for auto-renewable subscriptions.\n\nSee Also\nGetting the Offer Types\nstatic let introductory: Product.SubscriptionOffer.OfferType\nAn introductory offer for a subscription."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorepolicykind/4211624-hash",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing policy types\nvar hashValue: Int\nstatic func != (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) -> Bool"
  },
  {
    "title": "Product.SubscriptionOffer.OfferType.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/offertype/rawvalue",
    "html": "See Also\nCreating an Offer Type\ninit(rawValue: String)\nA raw value representing a subscription offer type.\nlet rawValue: String\nA string representing the raw value of the subscription offer type."
  },
  {
    "title": "termsOfService",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorepolicykind/4211627-termsofservice",
    "html": "See Also\nGetting policy types\nstatic var privacyPolicy: SubscriptionStorePolicyKind\nThe privacy policy type."
  },
  {
    "title": "ProductIconPhase.success(_:)",
    "url": "https://developer.apple.com/documentation/storekit/producticonphase/success",
    "html": "See Also\nGetting the promotional image's load phases\ncase loading\nThe promotional image is in the process of loading.\ncase unavailable\nThe promotional image isn’t available for download.\ncase failure(any Error)\nThe promotional image failed to load, with an error."
  },
  {
    "title": "body",
    "url": "https://developer.apple.com/documentation/storekit/automaticproductplaceholdericon/4247675-body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing an automatic product placeholder icon\ntypealias AutomaticProductPlaceholderIcon.Body"
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851081-compactmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n\nSee Also\nTransforming elements\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Product.SubscriptionInfo.Status) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "max(by:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851104-max",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n\nSee Also\nFiltering and matching elements\nfunc allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc filter((Product.SubscriptionInfo.Status) -> Bool) -> AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc min(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorebuttonlabel/4203687",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing button labels\nfunc hash(into: inout Hasher)\nstatic func == (SubscriptionStoreButtonLabel, SubscriptionStoreButtonLabel) -> Bool"
  },
  {
    "title": "debugDescription",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/3791966-debugdescription",
    "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible\nSee Also\nGetting localized and debug descriptions\nvar localizedDescription: String\nThe localized text that describes the subscription period unit."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851097-flatmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n\nSee Also\nTransforming elements\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Product.SubscriptionInfo.Status) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851100-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nTransforming elements\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Product.SubscriptionInfo.Status) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "min(by:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851106-min",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n\nSee Also\nFiltering and matching elements\nfunc allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc filter((Product.SubscriptionInfo.Status) -> Bool) -> AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc max(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "formatted(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/4044343-formatted",
    "html": "See Also\nGetting the formatted description\nstruct Product.SubscriptionPeriod.Unit.FormatStyle"
  },
  {
    "title": "filter(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851091-filter",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n\nSee Also\nFiltering and matching elements\nfunc allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851095-flatmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n\nSee Also\nTransforming elements\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Product.SubscriptionInfo.Status) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "localizedDescription",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/3916875-localizeddescription",
    "html": "See Also\nGetting localized and debug descriptions\nvar debugDescription: String\nA string that contains the name of the subscription period unit, suitable for debugging."
  },
  {
    "title": "Product.SubscriptionPeriod.Unit.day",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/day",
    "html": "See Also\nGetting the subscription period units\ncase month\nA subscription period unit of a month.\ncase week\nA subscription period unit of a week.\ncase year\nA subscription period unit of a year."
  },
  {
    "title": "Product.SubscriptionPeriod.Unit.year",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/year",
    "html": "See Also\nGetting the subscription period units\ncase day\nA subscription period unit of a day.\ncase month\nA subscription period unit of a month.\ncase week\nA subscription period unit of a week."
  },
  {
    "title": "makeBody(configuration:)",
    "url": "https://developer.apple.com/documentation/storekit/regularproductviewstyle/4203105-makebody",
    "html": "Relationships\nFrom Protocol\nProductViewStyle\nSee Also\nCreating the style\ntypealias RegularProductViewStyle.Body\ninit()"
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/storekit/automaticproductviewstyle/4278705-init",
    "html": "See Also\nCreating automatic product view styles\nfunc makeBody(configuration: AutomaticProductViewStyle.Configuration) -> View\ntypealias AutomaticProductViewStyle.Body"
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/storekit/largeproductviewstyle/4201938-init",
    "html": "See Also\nCreating the style\nfunc makeBody(configuration: LargeProductViewStyle.Configuration) -> View\ntypealias LargeProductViewStyle.Body"
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/storekit/pickersubscriptionstorecontrolstyle/4240615-init",
    "html": "See Also\nCreating the style\nfunc makeBody(configuration: PickerSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of a picker subscription store.\ntypealias PickerSubscriptionStoreControlStyle.Body\nA type that represents the body of a picker subscription store control style."
  },
  {
    "title": "makeBody(configuration:)",
    "url": "https://developer.apple.com/documentation/storekit/pickersubscriptionstorecontrolstyle/4240616-makebody",
    "html": "Parameters\nconfiguration\n\nThe properties of a picker subscription store control.\n\nRelationships\nFrom Protocol\nSubscriptionStoreControlStyle\nSee Also\nCreating the style\ntypealias PickerSubscriptionStoreControlStyle.Body\nA type that represents the body of a picker subscription store control style.\ninit()\nCreates a picker subscription store control style."
  },
  {
    "title": "PickerSubscriptionStoreControlStyle.Body",
    "url": "https://developer.apple.com/documentation/storekit/pickersubscriptionstorecontrolstyle/body",
    "html": "Relationships\nFrom Protocol\nSubscriptionStoreControlStyle\nSee Also\nCreating the style\nfunc makeBody(configuration: PickerSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of a picker subscription store.\ninit()\nCreates a picker subscription store control style."
  },
  {
    "title": "ProductViewStyleConfiguration.Icon.Body",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyleconfiguration/icon/body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing product view style configurations\nvar body: View"
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/storekit/compactproductviewstyle/4200763-init",
    "html": "See Also\nCreating the style\nfunc makeBody(configuration: CompactProductViewStyle.Configuration) -> View\ntypealias CompactProductViewStyle.Body"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/revocationreason/3803211",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing reasons\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nlet rawValue: Int\nThe raw value of a transaction revocation reason."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/paymentmode/3749556-rawvalue",
    "html": "Discussion\n\nUse the raw value to help parse the jsonRepresentation property of Product. If a product is a subscription with an offer, the JSON contains a string representation of the payment mode, which is its raw value. You can compare the JSON data directly to the payment mode’s rawValue.\n\nYou can also use the rawValue to create a payment mode instance by calling init(rawValue:).\n\nRelationships\nFrom Protocol\nRawRepresentable\nSee Also\nAccessing the raw value\ntypealias Product.SubscriptionOffer.PaymentMode.RawValue\nA type that represents the raw value of a payment mode for a subscription offer."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/subscriptionrenewalbehavior/4280900",
    "html": "Parameters\na\n\nA value to compare.\n\nb\n\nAnother value to compare.\n\nSee Also\nDefault implementations\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nfunc encode(to: any Encoder)\nEncodes this value into the given encoder."
  },
  {
    "title": "init(from:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/subscriptionrenewalbehavior/4280904-init",
    "html": "Relationships\nFrom Protocol\nDecodable"
  },
  {
    "title": "Product.PurchaseOption.SubscriptionRenewalBehavior.cancelImmediately",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/subscriptionrenewalbehavior/cancelimmediately",
    "html": "Discussion\n\nChoose this option for test cases that require an auto-renewable subscription that won't renew.\n\nSee Also\nRenewal behaviors in the testing environment\ncase renewUntilNow\nA subscription-renewal behavior in the testing environment that allows the subscription to renew continuously, up to the current date."
  },
  {
    "title": "Product.PurchaseOption.SubscriptionRenewalBehavior.renewUntilNow",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/subscriptionrenewalbehavior/renewuntilnow",
    "html": "Discussion\n\nChoose this option to create test cases that require an auto-renewable subscription that continues to renew. If you set the purchase date in purchaseDate(_:renewalBehavior:)to the past, the testing environment generates transactions for all the subscription renewals up to the current date.\n\nSee Also\nRenewal behaviors in the testing environment\ncase cancelImmediately\nA subscription-renewal behavior in the testing environment that cancels the subscription, resulting in only one subscription period."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/offertype/3749542-hashvalue",
    "html": "See Also\nComparing and Hashing Offer Types\nstatic func != (Product.SubscriptionOffer.OfferType, Product.SubscriptionOffer.OfferType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offertype/3822306-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nSee Also\nComparing and hashing offer types\nstatic func != (Transaction.OfferType, Transaction.OfferType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "LargeProductViewStyle.Body",
    "url": "https://developer.apple.com/documentation/storekit/largeproductviewstyle/body",
    "html": "Relationships\nFrom Protocol\nProductViewStyle\nSee Also\nCreating the style\nfunc makeBody(configuration: LargeProductViewStyle.Configuration) -> View\ninit()"
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/entitlementtaskstate/4211566-flatmap",
    "html": "See Also\nHelper methods\nfunc flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nfunc map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nfunc map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful."
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/storekit/buttonssubscriptionstorecontrolstyle/4240609-init",
    "html": "See Also\nCreating the style\nfunc makeBody(configuration: ButtonsSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of a button subscription store.\ntypealias ButtonsSubscriptionStoreControlStyle.Body\nA type that represents the body of a button subscription store control style."
  },
  {
    "title": "makeBody(configuration:)",
    "url": "https://developer.apple.com/documentation/storekit/largeproductviewstyle/4201940-makebody",
    "html": "Relationships\nFrom Protocol\nProductViewStyle\nSee Also\nCreating the style\ntypealias LargeProductViewStyle.Body\ninit()"
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/entitlementtaskstate/4211565-flatmap",
    "html": "Parameters\ntransform\n\nSee Also\nHelper methods\nfunc flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nfunc map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nfunc map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/entitlementtaskstate/4211568-map",
    "html": "See Also\nHelper methods\nfunc flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nfunc flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nfunc map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful."
  },
  {
    "title": "ProductIconPhase.failure(_:)",
    "url": "https://developer.apple.com/documentation/storekit/producticonphase/failure",
    "html": "Parameters\nError\n\nThe reason that the promotional image failed to load.\n\nSee Also\nGetting the promotional image's load phases\ncase loading\nThe promotional image is in the process of loading.\ncase success(Image)\nThe promotional image successfully loaded.\ncase unavailable\nThe promotional image isn’t available for download."
  },
  {
    "title": "ProductIconPhase.unavailable",
    "url": "https://developer.apple.com/documentation/storekit/producticonphase/unavailable",
    "html": "Discussion\n\nYou set up promotional images for in-app purchases in App Store Connect.\n\nSee Also\nGetting the promotional image's load phases\ncase loading\nThe promotional image is in the process of loading.\ncase success(Image)\nThe promotional image successfully loaded.\ncase failure(any Error)\nThe promotional image failed to load, with an error."
  },
  {
    "title": "AutomaticProductPlaceholderIcon.Body",
    "url": "https://developer.apple.com/documentation/storekit/automaticproductplaceholdericon/body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing an automatic product placeholder icon\nvar body: View"
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorebuttonlabel/4203694-hash",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing button labels\nstatic func != (SubscriptionStoreButtonLabel, SubscriptionStoreButtonLabel) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (SubscriptionStoreButtonLabel, SubscriptionStoreButtonLabel) -> Bool"
  },
  {
    "title": "Product.SubscriptionInfo.Status.Statuses.Element",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/element",
    "html": "See Also\nIterating over the status\nfunc makeAsyncIterator() -> Product.SubscriptionInfo.Status.Statuses.AsyncIterator\nCreates the iterator that produces elements of the asynchronous sequence.\nstruct Product.SubscriptionInfo.Status.Statuses.AsyncIterator\nAn iterator that produces elements of the asynchronous sequence.\ntypealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element\nThe type of element the iterator produces."
  },
  {
    "title": "promotional",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offertype/3822310-promotional",
    "html": "Discussion\n\nFor more information about promotional offers, see Set up promotional offers for auto-renewable subscriptions.\n\nSee Also\nGetting offer types\nstatic let introductory: Transaction.OfferType\nAn introductory offer for an auto-renewable subscription.\nstatic let code: Transaction.OfferType\nAn offer with a subscription offer code, for an auto-renewable subscription."
  },
  {
    "title": "prefix(_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123368-prefix",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence.\n\nSee Also\nTransforming purchase intents\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc prefix(while: (PurchaseIntent) -> Bool) -> AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123362-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nTransforming purchase intents\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (PurchaseIntent) -> Bool) -> AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/signature/4319984",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/signature/4319987-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable"
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/signature/4319986-hash",
    "html": "Relationships\nFrom Protocol\nHashable"
  },
  {
    "title": "RegularProductViewStyle.Body",
    "url": "https://developer.apple.com/documentation/storekit/regularproductviewstyle/body",
    "html": "Relationships\nFrom Protocol\nProductViewStyle\nSee Also\nCreating the style\nfunc makeBody(configuration: RegularProductViewStyle.Configuration) -> View\ninit()"
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/storekit/regularproductviewstyle/4203104-init",
    "html": "See Also\nCreating the style\nfunc makeBody(configuration: RegularProductViewStyle.Configuration) -> View\ntypealias RegularProductViewStyle.Body"
  },
  {
    "title": "makeBody(configuration:)",
    "url": "https://developer.apple.com/documentation/storekit/automaticsubscriptionstorecontrolstyle/4240605-makebody",
    "html": "Parameters\nconfiguration\n\nThe properties of an automatic subscription store control.\n\nRelationships\nFrom Protocol\nSubscriptionStoreControlStyle\nSee Also\nCreating the style\ntypealias AutomaticSubscriptionStoreControlStyle.Body\nA type that represents the body of an automatic subscription store control style.\ninit()\nCreates an automatic subscription store control style."
  },
  {
    "title": "AutomaticSubscriptionStoreControlStyle.Body",
    "url": "https://developer.apple.com/documentation/storekit/automaticsubscriptionstorecontrolstyle/body",
    "html": "Relationships\nFrom Protocol\nSubscriptionStoreControlStyle\nSee Also\nCreating the style\nfunc makeBody(configuration: AutomaticSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of an automatic subscription store control style.\ninit()\nCreates an automatic subscription store control style."
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/storekit/automaticsubscriptionstorecontrolstyle/4240604-init",
    "html": "See Also\nCreating the style\nfunc makeBody(configuration: AutomaticSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of an automatic subscription store control style.\ntypealias AutomaticSubscriptionStoreControlStyle.Body\nA type that represents the body of an automatic subscription store control style."
  },
  {
    "title": "makeBody(configuration:)",
    "url": "https://developer.apple.com/documentation/storekit/automaticproductviewstyle/4278706-makebody",
    "html": "Relationships\nFrom Protocol\nProductViewStyle\nSee Also\nCreating automatic product view styles\ntypealias AutomaticProductViewStyle.Body\ninit()"
  },
  {
    "title": "AutomaticProductViewStyle.Body",
    "url": "https://developer.apple.com/documentation/storekit/automaticproductviewstyle/body",
    "html": "Relationships\nFrom Protocol\nProductViewStyle\nSee Also\nCreating automatic product view styles\nfunc makeBody(configuration: AutomaticProductViewStyle.Configuration) -> View\ninit()"
  },
  {
    "title": "CompactProductViewStyle.Body",
    "url": "https://developer.apple.com/documentation/storekit/compactproductviewstyle/body",
    "html": "Relationships\nFrom Protocol\nProductViewStyle\nSee Also\nCreating the style\nfunc makeBody(configuration: CompactProductViewStyle.Configuration) -> View\ninit()"
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851102-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n\nSee Also\nTransforming elements\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Product.SubscriptionInfo.Status) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "prefix(while:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851110-prefix",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n\nSee Also\nTransforming elements\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Product.SubscriptionInfo.Status) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "dropFirst(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851089-dropfirst",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nSee Also\nExcluding elements\nfunc drop(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncDropWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements."
  },
  {
    "title": "drop(while:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851087-drop",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is.\n\nSee Also\nExcluding elements\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Product.SubscriptionInfo.Status.Statuses>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements."
  },
  {
    "title": "prefix(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851108-prefix",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence.\n\nSee Also\nTransforming elements\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc prefix(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Product.SubscriptionInfo.Status) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "reduce(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851112-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n\nSee Also\nTransforming elements\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(into: Result, (inout Result, Product.SubscriptionInfo.Status) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "reduce(into:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851114-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary.\n\nSee Also\nTransforming elements\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure."
  },
  {
    "title": "prefix(while:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123370-prefix",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n\nSee Also\nTransforming purchase intents\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123360-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n\nSee Also\nTransforming purchase intents\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (PurchaseIntent) -> Bool) -> AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123355-flatmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n\nSee Also\nTransforming purchase intents\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (PurchaseIntent) -> Bool) -> AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "error",
    "url": "https://developer.apple.com/documentation/storekit/producticonphase/4201942-error",
    "html": "Discussion\n\nThe error value is nil while the icon is loading, if the icon successfully loads, or if you haven’t set up a promotional image for the in-app purchase in App Store Connect. Use this value as a convenience to access the error value in code that assumes you’ve set up a promotional image."
  },
  {
    "title": "promotionalIcon",
    "url": "https://developer.apple.com/documentation/storekit/producticonphase/4201945-promotionalicon",
    "html": "Discussion\n\nThis value is nil while the image is loading, or if the system can’t access the promotional image for any reason. Use this value as a convenience to access the image in code that doesn’t depend on the reason an image may not be accessible.\n\nFor information about setting up promotional images, see Promote in-app purchases."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851079-compactmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nTransforming elements\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Product.SubscriptionInfo.Status) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "first(where:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851093-first",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFiltering and matching elements\nfunc allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc filter((Product.SubscriptionInfo.Status) -> Bool) -> AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc max(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorebuttonlabel/4203688",
    "html": "See Also\nComparing and hashing button labels\nfunc hash(into: inout Hasher)\nstatic func != (SubscriptionStoreButtonLabel, SubscriptionStoreButtonLabel) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/4307071-id",
    "html": "Discussion\n\nThis value is nil if the subscription offer is an introductory offer.\n\nIf the offer type is promotional, this value contains the promotional offer identifier you set up in App Store Connect. For more information about promotional offers, see Set up promotional offers for auto-renewable subscriptions.\n\nIf the offer type is code, this value contains the reference name of the offer code you set up in App Store Connect. For more information about offer codes, see Set up offer codes.\n\nSee Also\nGetting offer details\nlet type: Transaction.OfferType\nThe type of subscription offer that applies to the transaction.\nstruct Transaction.OfferType\nThe types of offers for auto-renewable subscriptions.\nstruct Transaction.Offer.PaymentMode\nThe payment modes for subscription offers that apply to a transaction."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/4307058",
    "html": "See Also\nComparing offers\nstatic func != (Transaction.Offer, Transaction.Offer) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/entitlementtaskstate/4211569-map",
    "html": "See Also\nHelper methods\nfunc flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nfunc flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nfunc map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful."
  },
  {
    "title": "ButtonsSubscriptionStoreControlStyle.Body",
    "url": "https://developer.apple.com/documentation/storekit/buttonssubscriptionstorecontrolstyle/body",
    "html": "Relationships\nFrom Protocol\nSubscriptionStoreControlStyle\nSee Also\nCreating the style\nfunc makeBody(configuration: ButtonsSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of a button subscription store.\ninit()\nCreates a button subscription store control style."
  },
  {
    "title": "type",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/4307073-type",
    "html": "Discussion\n\nThe offer types are introductory, promotional, and code.\n\nFor more information about introductory offers, see Set an introductory offer for an auto-renewable subscription.\n\nFor more information about promotional offers, see Set up promotional offers for auto-renewable subscriptions.\n\nFor more information about offer codes, see Set up offer codes.\n\nSee Also\nGetting offer details\nlet id: String?\nA string that identifies the subscription offer that applies to the transaction.\nstruct Transaction.OfferType\nThe types of offers for auto-renewable subscriptions.\nstruct Transaction.Offer.PaymentMode\nThe payment modes for subscription offers that apply to a transaction."
  },
  {
    "title": "Transaction.Offer.PaymentMode",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/paymentmode",
    "html": "Overview\n\nIf your app supports subscription offers and the customer redeems an offer, the transaction contains the information in the offer parameter. The payment modes are the same as Product.SubscriptionOffer.PaymentMode, and include Free Trial, Pay As You Go, and Pay Up Front.\n\nFor more information about the payment modes, see Pricing and availability.\n\nTopics\nGetting payment modes\nstatic let freeTrial: Transaction.Offer.PaymentMode\nA payment mode of a product discount that indicates a free trial.\nstatic let payAsYouGo: Transaction.Offer.PaymentMode\nA payment mode of a product discount that’s billed over a single or multiple billing periods.\nstatic let payUpFront: Transaction.Offer.PaymentMode\nA payment mode of a product discount that’s paid up front.\nGetting the type alias\ntypealias Transaction.Offer.PaymentMode.RawValue\nA type that represents the subscription offer payment mode of a transaction.\nInitializing payment modes\ninit(rawValue: String)\nCreates a payment mode.\nlet rawValue: String\nA string that represents a payment mode.\nComparing payment modes\nvar hashValue: Int\nThe hash value.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nstatic func != (Transaction.Offer.PaymentMode, Transaction.Offer.PaymentMode) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSendable\nSee Also\nGetting offer details\nlet id: String?\nA string that identifies the subscription offer that applies to the transaction.\nlet type: Transaction.OfferType\nThe type of subscription offer that applies to the transaction.\nstruct Transaction.OfferType\nThe types of offers for auto-renewable subscriptions."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offertype/3822307-hashvalue",
    "html": "See Also\nComparing and hashing offer types\nstatic func != (Transaction.OfferType, Transaction.OfferType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/4307069-hash",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing offers\nstatic func == (Transaction.Offer, Transaction.Offer) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nstatic func != (Transaction.Offer, Transaction.Offer) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/4307057",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing offers\nstatic func == (Transaction.Offer, Transaction.Offer) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "makeBody(configuration:)",
    "url": "https://developer.apple.com/documentation/storekit/buttonssubscriptionstorecontrolstyle/4240610-makebody",
    "html": "Parameters\nconfiguration\n\nThe properties of a button subscription store control.\n\nRelationships\nFrom Protocol\nSubscriptionStoreControlStyle\nSee Also\nCreating the style\ntypealias ButtonsSubscriptionStoreControlStyle.Body\nA type that represents the body of a button subscription store control style.\ninit()\nCreates a button subscription store control style."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorepolicykind/4211625-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing policy types\nfunc hash(into: inout Hasher)\nstatic func != (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) -> Bool"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorepolicykind/4211622",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing policy types\nvar hashValue: Int\nfunc hash(into: inout Hasher)\nstatic func == (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) -> Bool"
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorepolicykind/4211623",
    "html": "See Also\nComparing and hashing policy types\nvar hashValue: Int\nfunc hash(into: inout Hasher)\nstatic func != (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "cancellation",
    "url": "https://developer.apple.com/documentation/storekit/storebuttonkind/4203108-cancellation",
    "html": "See Also\nGetting button types for store views\nstatic var restorePurchases: StoreButtonKind\nA type of button that people use to restore purchases."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorebuttonlabel/4203695-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable"
  },
  {
    "title": "signIn",
    "url": "https://developer.apple.com/documentation/storekit/storebuttonkind/4203112-signin",
    "html": "See Also\nGetting additional button types for subscription store views\nstatic var redeemCode: StoreButtonKind\nA type of button that people use to redeem an offer code.\nstatic var policies: StoreButtonKind\nA type of button that people use to display store policies."
  },
  {
    "title": "policies",
    "url": "https://developer.apple.com/documentation/storekit/storebuttonkind/4203109-policies",
    "html": "See Also\nGetting additional button types for subscription store views\nstatic var signIn: StoreButtonKind\nA type of button that people use to sign in.\nstatic var redeemCode: StoreButtonKind\nA type of button that people use to redeem an offer code."
  },
  {
    "title": "redeemCode",
    "url": "https://developer.apple.com/documentation/storekit/storebuttonkind/4203110-redeemcode",
    "html": "See Also\nGetting additional button types for subscription store views\nstatic var signIn: StoreButtonKind\nA type of button that people use to sign in.\nstatic var policies: StoreButtonKind\nA type of button that people use to display store policies."
  },
  {
    "title": "ProductIconPhase.loading",
    "url": "https://developer.apple.com/documentation/storekit/producticonphase/loading",
    "html": "See Also\nGetting the promotional image's load phases\ncase success(Image)\nThe promotional image successfully loaded.\ncase unavailable\nThe promotional image isn’t available for download.\ncase failure(any Error)\nThe promotional image failed to load, with an error."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer/4307070-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing offers\nstatic func == (Transaction.Offer, Transaction.Offer) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nstatic func != (Transaction.Offer, Transaction.Offer) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "max(by:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123364-max",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n\nSee Also\nFiltering and matching purchase intents\nfunc allSatisfy((PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(PurchaseIntent) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc filter((PurchaseIntent) -> Bool) -> AsyncFilterSequence<PurchaseIntent.PurchaseIntents>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123357-flatmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n\nSee Also\nTransforming purchase intents\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (PurchaseIntent) -> Bool) -> AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "min(by:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123366-min",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n\nSee Also\nFiltering and matching purchase intents\nfunc allSatisfy((PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(PurchaseIntent) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc filter((PurchaseIntent) -> Bool) -> AsyncFilterSequence<PurchaseIntent.PurchaseIntents>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123341-compactmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nTransforming purchase intents\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (PurchaseIntent) -> Bool) -> AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123339-compactmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n\nSee Also\nTransforming purchase intents\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (PurchaseIntent) -> Bool) -> AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "filter(_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123351-filter",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n\nSee Also\nFiltering and matching purchase intents\nfunc allSatisfy((PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(PurchaseIntent) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "contains(where:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123345-contains",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFiltering and matching purchase intents\nfunc allSatisfy((PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(PurchaseIntent) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc filter((PurchaseIntent) -> Bool) -> AsyncFilterSequence<PurchaseIntent.PurchaseIntents>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "first(where:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123353-first",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFiltering and matching purchase intents\nfunc allSatisfy((PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(PurchaseIntent) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc filter((PurchaseIntent) -> Bool) -> AsyncFilterSequence<PurchaseIntent.PurchaseIntents>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123343-contains",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n\nSee Also\nFiltering and matching purchase intents\nfunc allSatisfy((PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(where: (PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc filter((PurchaseIntent) -> Bool) -> AsyncFilterSequence<PurchaseIntent.PurchaseIntents>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "allSatisfy(_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123337-allsatisfy",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true.\n\nSee Also\nFiltering and matching purchase intents\nfunc contains(PurchaseIntent) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc filter((PurchaseIntent) -> Bool) -> AsyncFilterSequence<PurchaseIntent.PurchaseIntents>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "PurchaseIntent.PurchaseIntents.Element",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/element",
    "html": "See Also\nIterating over purchase intents\nfunc makeAsyncIterator() -> PurchaseIntent.PurchaseIntents.AsyncIterator\nCreates the iterator that produces elements of the asynchronous sequence.\nstruct PurchaseIntent.PurchaseIntents.AsyncIterator\nAn iterator that produces elements of the asynchronous purchase intents sequence."
  },
  {
    "title": "value",
    "url": "https://developer.apple.com/documentation/storekit/entitlementtaskstate/4211572-value",
    "html": "Discussion\n\nThis value is nil while the value is loading, or if it fails to load for any reason.\n\nUse value as a convenience to access the entitlement value in code that doesn’t depend on the reason the value can’t be accessed if it fails to load.\n\nSee Also\nGetting the transaction with the entitlement\nvar transaction: VerificationResult<Transaction>?\nThe transaction value if the task is successful.\nAvailable when Value is VerificationResult<Transaction>?."
  },
  {
    "title": "makeBody(configuration:)",
    "url": "https://developer.apple.com/documentation/storekit/prominentpickersubscriptionstorecontrolstyle/4243444-makebody",
    "html": "Parameters\nconfiguration\n\nThe properties of a prominent picker subscription store control.\n\nRelationships\nFrom Protocol\nSubscriptionStoreControlStyle\nSee Also\nCreating the style\ntypealias ProminentPickerSubscriptionStoreControlStyle.Body\nA type that represents the body of a prominent picker subscription store control style.\ninit()\nCreates a prominent picker subscription store control style."
  },
  {
    "title": "transaction",
    "url": "https://developer.apple.com/documentation/storekit/entitlementtaskstate/4211571-transaction",
    "html": "Discussion\n\nUse transaction as a convenience to access the transaction value in code that doesn’t depend on the reason a transaction isn’t available. The value is nil while the transaction is loading, if it fails to load for any reason, or if the customer isn’t entitled to the product.\n\nSee Also\nGetting the transaction with the entitlement\nvar value: Value?\nThe entitlement value if the task is successful."
  },
  {
    "title": "ProminentPickerSubscriptionStoreControlStyle.Body",
    "url": "https://developer.apple.com/documentation/storekit/prominentpickersubscriptionstorecontrolstyle/body",
    "html": "Relationships\nFrom Protocol\nSubscriptionStoreControlStyle\nSee Also\nCreating the style\nfunc makeBody(configuration: ProminentPickerSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of a prominent picker subscription store.\ninit()\nCreates a prominent picker subscription store control style."
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/storekit/prominentpickersubscriptionstorecontrolstyle/4243443-init",
    "html": "See Also\nCreating the style\nfunc makeBody(configuration: ProminentPickerSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of a prominent picker subscription store.\ntypealias ProminentPickerSubscriptionStoreControlStyle.Body\nA type that represents the body of a prominent picker subscription store control style."
  },
  {
    "title": "Transaction.OfferType",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offertype",
    "html": "Overview\n\nWhen a customer redeems a subscription offer, the offer information appears in the offer property of the transaction.\n\nYou don’t create offer types in Transaction.OfferType. The static values indicate the offer types that the system reports for a transaction.\n\nTopics\nGetting offer types\nstatic let introductory: Transaction.OfferType\nAn introductory offer for an auto-renewable subscription.\nstatic let promotional: Transaction.OfferType\nA promotional offer for an auto-renewable subscription.\nstatic let code: Transaction.OfferType\nAn offer with a subscription offer code, for an auto-renewable subscription.\nGetting a localized description\nvar localizedDescription: String\nThe localized text that describes the offer type.\nCreating an offer type\ninit(rawValue: Int)\nCreate an offer type from a raw value.\nlet rawValue: Int\nThe offer type as a raw value.\ntypealias Transaction.OfferType.RawValue\nA type representing the raw value of an offer type.\nComparing and hashing offer types\nstatic func != (Transaction.OfferType, Transaction.OfferType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSee Also\nGetting offer details\nlet id: String?\nA string that identifies the subscription offer that applies to the transaction.\nlet type: Transaction.OfferType\nThe type of subscription offer that applies to the transaction.\nstruct Transaction.Offer.PaymentMode\nThe payment modes for subscription offers that apply to a transaction."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offertype/3822308-init",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating an offer type\nlet rawValue: Int\nThe offer type as a raw value.\ntypealias Transaction.OfferType.RawValue\nA type representing the raw value of an offer type."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offertype/3822311-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating an offer type\ninit(rawValue: Int)\nCreate an offer type from a raw value.\ntypealias Transaction.OfferType.RawValue\nA type representing the raw value of an offer type."
  },
  {
    "title": "Transaction.OfferType.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offertype/rawvalue",
    "html": "See Also\nCreating an offer type\ninit(rawValue: Int)\nCreate an offer type from a raw value.\nlet rawValue: Int\nThe offer type as a raw value."
  },
  {
    "title": "EntitlementTaskState.failure(_:)",
    "url": "https://developer.apple.com/documentation/storekit/entitlementtaskstate/failure",
    "html": "See Also\nGetting the task state\ncase loading\nThe task is loading the entitlement in the background.\ncase success(Value)\nThe task successfully loaded the entitlement."
  },
  {
    "title": "EntitlementTaskState.loading",
    "url": "https://developer.apple.com/documentation/storekit/entitlementtaskstate/loading",
    "html": "See Also\nGetting the task state\ncase success(Value)\nThe task successfully loaded the entitlement.\ncase failure(any Error)\nThe task failed to load the entitlement, with an error."
  },
  {
    "title": "EntitlementTaskState.success(_:)",
    "url": "https://developer.apple.com/documentation/storekit/entitlementtaskstate/success",
    "html": "See Also\nGetting the task state\ncase loading\nThe task is loading the entitlement in the background.\ncase failure(any Error)\nThe task failed to load the entitlement, with an error."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offertype/3822303",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing offer types\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "SKError.Code.invalidOfferIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skerror/code/invalidofferidentifier",
    "html": "Discussion\n\nThe offer identifier is not valid. For example, you have not set up an offer with that identifier in the App Store, or you have revoked the offer."
  },
  {
    "title": "SKError.Code.invalidSignature",
    "url": "https://developer.apple.com/documentation/storekit/skerror/code/invalidsignature",
    "html": "Discussion\n\nThe signature is not valid."
  },
  {
    "title": "environment",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3963917-environment",
    "html": "See Also\nGetting the environment\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var environmentStringRepresentation: String\nThe string representation of the server environment that signs the renewal information for an auto-renewable subscription.\nDeprecated"
  },
  {
    "title": "offerType",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3822291-offertype",
    "html": "Discussion\n\nIf this value is nil, there’s no offer applied.\n\nSee Also\nGetting subscription offers\nlet offerID: String?\nA string that identifies an offer applied to the next subscription period."
  },
  {
    "title": "recentSubscriptionStartDate",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3976513-recentsubscriptionstartdate",
    "html": "Discussion\n\nImportant\n\nDon’t use the recentSubscriptionStartDate date to calculate days of paid service. For more information about paid days of service, see Net revenue after a year."
  },
  {
    "title": "allSatisfy(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851077-allsatisfy",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true.\n\nSee Also\nFiltering and matching elements\nfunc contains(Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc filter((Product.SubscriptionInfo.Status) -> Bool) -> AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc max(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "unsupportedPlatform",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3689489-unsupportedplatform",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay."
  },
  {
    "title": "overlayPresentedInBackgroundScene",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3738427-overlaypresentedinbackgroundscen",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/asynciterator/element",
    "html": "Discussion\n\nThis iterator produces Product.SubscriptionInfo.Status elements.\n\nSee Also\nGetting the Next Element\nfunc next() -> Product.SubscriptionInfo.Status.Statuses.Element?"
  },
  {
    "title": "overlayInvalidConfiguration",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3656407-overlayinvalidconfiguration",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "overlayCancelled",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3656298-overlaycancelled",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "overlayTimeout",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3656408-overlaytimeout",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "Product.SubscriptionInfo.Status.Statuses.AsyncIterator",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/asynciterator",
    "html": "Topics\nGetting the Next Element\nfunc next() -> Product.SubscriptionInfo.Status.Statuses.Element?\ntypealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element\nThe type of element the iterator produces.\nRelationships\nFrom Protocol\nAsyncSequence\nConforms To\nAsyncIteratorProtocol\nSee Also\nIterating over the status\nfunc makeAsyncIterator() -> Product.SubscriptionInfo.Status.Statuses.AsyncIterator\nCreates the iterator that produces elements of the asynchronous sequence.\ntypealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element\nThe type of element the iterator produces.\ntypealias Product.SubscriptionInfo.Status.Statuses.Element\nThe type of element the iterator traverses."
  },
  {
    "title": "ineligibleForOffer",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3663443-ineligibleforoffer",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "invalidSignature",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3043607-invalidsignature",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "missingOfferParams",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3088938-missingofferparams",
    "html": "Discussion\n\nThis error appears if all parameters of SKPaymentDiscount are not present.\n\nSee Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "makeAsyncIterator()",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851099-makeasynciterator",
    "html": "Return Value\n\nAn instance of Product.SubscriptionInfo.Status.Statuses.AsyncIterator used to produce elements of the asynchronous sequence.\n\nRelationships\nFrom Protocol\nAsyncSequence\nSee Also\nIterating over the status\nstruct Product.SubscriptionInfo.Status.Statuses.AsyncIterator\nAn iterator that produces elements of the asynchronous sequence.\ntypealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element\nThe type of element the iterator produces.\ntypealias Product.SubscriptionInfo.Status.Statuses.Element\nThe type of element the iterator traverses."
  },
  {
    "title": "invalidOfferPrice",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3088937-invalidofferprice",
    "html": "Discussion\n\nAn offer price can become invalid if you change the price of the base subscription such that it is lower than the offer price. Offers must always represent a discounted price.\n\nSee Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "errorUserInfo",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2887426-erroruserinfo",
    "html": "See Also\nError properties\nvar errorCode: Int\nThe error code that this instance represents.\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar code: Code\nvar userInfo: [String : Any]"
  },
  {
    "title": "invalidOfferIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3043606-invalidofferidentifier",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "localizedDescription",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2887429-localizeddescription",
    "html": "See Also\nError properties\nvar errorCode: Int\nThe error code that this instance represents.\nvar errorUserInfo: [String : Any]\nAn info dictionary for providing additional details about an error.\nvar code: Code\nvar userInfo: [String : Any]"
  },
  {
    "title": "errorCode",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2887428-errorcode",
    "html": "See Also\nError properties\nvar errorUserInfo: [String : Any]\nAn info dictionary for providing additional details about an error.\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar code: Code\nvar userInfo: [String : Any]"
  },
  {
    "title": "code",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3726684-code",
    "html": "See Also\nError properties\nvar errorCode: Int\nThe error code that this instance represents.\nvar errorUserInfo: [String : Any]\nAn info dictionary for providing additional details about an error.\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar userInfo: [String : Any]"
  },
  {
    "title": "reduce(into:_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123374-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary.\n\nSee Also\nTransforming purchase intents\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (PurchaseIntent) -> Bool) -> AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure."
  },
  {
    "title": "introductory",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offertype/3822309-introductory",
    "html": "Discussion\n\nFor more information about introductory offers, see Set up introductory offers for auto-renewable subscriptions.\n\nSee Also\nGetting offer types\nstatic let promotional: Transaction.OfferType\nA promotional offer for an auto-renewable subscription.\nstatic let code: Transaction.OfferType\nAn offer with a subscription offer code, for an auto-renewable subscription."
  },
  {
    "title": "drop(while:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123347-drop",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is.\n\nSee Also\nExcluding purchase intents\nfunc dropFirst(Int) -> AsyncDropFirstSequence<PurchaseIntent.PurchaseIntents>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements."
  },
  {
    "title": "dropFirst(_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123349-dropfirst",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nSee Also\nExcluding purchase intents\nfunc drop(while: (PurchaseIntent) -> Bool) -> AsyncDropWhileSequence<PurchaseIntent.PurchaseIntents>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements."
  },
  {
    "title": "reduce(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123372-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n\nSee Also\nTransforming purchase intents\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (PurchaseIntent) -> Bool) -> AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "body",
    "url": "https://developer.apple.com/documentation/storekit/automaticsubscriptionstoremarketingcontent/4248279-body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing automatic marketing content\ntypealias AutomaticSubscriptionStoreMarketingContent.Body\nA type that represents the body of automatic subscription store marketing content."
  },
  {
    "title": "AutomaticSubscriptionStoreMarketingContent.Body",
    "url": "https://developer.apple.com/documentation/storekit/automaticsubscriptionstoremarketingcontent/body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing automatic marketing content\nvar body: View\nThe content and behavior of the view."
  },
  {
    "title": "makeAsyncIterator()",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/4123359-makeasynciterator",
    "html": "Relationships\nFrom Protocol\nAsyncSequence\nSee Also\nIterating over purchase intents\nstruct PurchaseIntent.PurchaseIntents.AsyncIterator\nAn iterator that produces elements of the asynchronous purchase intents sequence.\ntypealias PurchaseIntent.PurchaseIntents.Element\nA type that represents a purchase intents element."
  },
  {
    "title": "PurchaseIntent.PurchaseIntents.AsyncIterator",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents/asynciterator",
    "html": "Topics\nGetting the next element\nfunc next() -> PurchaseIntent.PurchaseIntents.Element?\nAdvances to and returns the next element, if it exists.\ntypealias PurchaseIntent.PurchaseIntents.AsyncIterator.Element\nThe type of element the iterator produces.\nRelationships\nFrom Protocol\nAsyncSequence\nConforms To\nAsyncIteratorProtocol\nSee Also\nIterating over purchase intents\nfunc makeAsyncIterator() -> PurchaseIntent.PurchaseIntents.AsyncIterator\nCreates the iterator that produces elements of the asynchronous sequence.\ntypealias PurchaseIntent.PurchaseIntents.Element\nA type that represents a purchase intents element."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851141-flatmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, Storefront) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Storefront) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/priceincreasestatus",
    "html": "Overview\n\nFor more information, see Managing Price Increases for Auto-Renewable Subscriptions.\n\nTopics\nGetting Price Increase Status\ncase noIncreasePending\nThere’s no pending price increase for the auto-renewable subscription.\ncase agreed\nThe auto-renewable subscription is subject to a price increase.\ncase pending\nThe customer hasn’t yet responded to an auto-renewable subscription price increase that requires customer consent.\nComparing and Hashing Status\nstatic func != (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus, Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nGetting a Localized Description\nvar localizedDescription: String\nA string containing the localized description of the price increase status.\nRelationships\nConforms To\nHashable\nSee Also\nGetting the price increase status\nManaging Price Increases for Auto-Renewable Subscriptions\nIdentify the price increase status for auto-renewable subscriptions, in your app and on your server.\nlet priceIncreaseStatus: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus\nThe status that indicates whether the auto-renewable subscription is subject to a price increase."
  },
  {
    "title": "unknown",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2330534-unknown",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "Managing Price Increases for Auto-Renewable Subscriptions",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/managing_price_increases_for_auto-renewable_subscriptions",
    "html": "Overview\n\nIf you increase the price of an auto-renewable subscription in App Store Connect, the priceIncreaseStatus in the renewalInfo object indicates if the subscription is subject to the price increase. Auto-renewable subscriptions have two types of price increases: those that require customer consent, and those that don’t require customer consent.\n\nFor price increases that require customer consent, look for the following status values in your app:\n\nProduct.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending\n\n\t\n\nIndicates there’s no price increase for this auto-renewable subscription.\n\n\n\n\nProduct.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending\n\n\t\n\nIndicates there’s a pending price increase for the auto-renewable subscription that requires customer consent, and the customer hasn’t yet consented.\n\nIf the customer doesn’t consent, the auto-renewable subscription expires at the end of the billing cycle. When it expires, your app gets a status update in updates with an expirationReason of didNotConsentToPriceIncrease.\n\n\n\n\nProduct.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed\n\n\t\n\nIndicates that the customer consented to a price increase for the auto-renewable subscription.\n\nFor price increases that don’t require customer consent, look for the following status values in your app:\n\nProduct.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.noIncreasePending\n\n\t\n\nDoesn’t apply.\n\n\n\n\nProduct.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.pending\n\n\t\n\nDoesn’t apply.\n\n\n\n\nProduct.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus.agreed\n\n\t\n\nIndicates that the App Store informed the customer of the price increase for the auto-renewable subscription, and the subscription is subject to the price increase.\n\nIf the customer cancels the auto-renewable subscription, your app gets a status update in updates with an expirationReason of autoRenewDisabled.\n\nFor more information about managing subscription prices in App Store Connect, see Managing Prices.\n\nReceive Notifications for Price Increase Status Events\n\nIf you’ve enabled App Store Server Notifications V2, your server receives notifications for events related to auto-renewable subscription price increases.\n\nFor auto-renewable subscription price increases that require customer consent, look for the following notifications:\n\nNotification type\n\n\t\n\nSubtype\n\n\t\n\nDescription\n\n\n\n\nPRICE_INCREASE\n\n\t\n\nPENDING\n\n\t\n\nIndicates that the App Store informed the customer of the price increase for the auto-renewable subscription, and the customer hasn’t yet responded.\n\n\n\n\nPRICE_INCREASE\n\n\t\n\nACCEPTED\n\n\t\n\nIndicates that the customer consented to the price increase for the auto-renewable subscription.\n\n\n\n\nEXPIRED\n\n\t\n\nPRICE_INCREASE\n\n\t\n\nIndicates that the auto-renewable subscription expired because the customer didn’t consent to the price increase, and allowed the subscription to expire.\n\n\n\n\nEXPIRED\n\n\t\n\nVOLUNTARY\n\n\t\n\nIndicates that the customer voluntarily canceled the auto-renewable subscription. (Note: This notification type and subtype isn’t specific to price increases.)\n\nFor auto-renewable subscription price increases that don’t require customer consent, look for the following notifications:\n\nNotification type\n\n\t\n\nSubtype\n\n\t\n\nDescription\n\n\n\n\nPRICE_INCREASE\n\n\t\n\nACCEPTED\n\n\t\n\nIndicates that the App Store informed the customer of the auto-renewable subscription price increase, and the subscription is subject to the price increase.\n\n\n\n\nEXPIRED\n\n\t\n\nVOLUNTARY\n\n\t\n\nIndicates that the customer voluntarily canceled the auto-renewable subscription. (Note: This notification type and subtype isn't specific to price increases.)\n\nFor more information about App Store Server Notifications, see Enabling App Store Server Notifications. For more information about notification types and subtypes, see notificationType and subtype.\n\nSee Also\nGetting the price increase status\nlet priceIncreaseStatus: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus\nThe status that indicates whether the auto-renewable subscription is subject to a price increase.\nenum Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus\nStatus values that indicate whether an auto-renewable subscription is subject to a price increase."
  },
  {
    "title": "userInfo",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3726688-userinfo",
    "html": "See Also\nError properties\nvar errorCode: Int\nThe error code that this instance represents.\nvar errorUserInfo: [String : Any]\nAn info dictionary for providing additional details about an error.\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar code: Code"
  },
  {
    "title": "isInBillingRetry",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3749502-isinbillingretry",
    "html": "Discussion\n\nThis field indicates whether Apple is attempting to automatically renew an expired subscription. If a subscription expires due to a billing issue, a value of true indicates that Apple is still trying to renew the subscription. If the subscription is in a billing grace period, the optional gracePeriodExpirationDate contains a date.\n\nUse the isInBillingRetry value along with expirationReason for more insight, as the following table shows:\n\nValues\n\n\t\n\nDescription\n\n\n\n\nisInBillingRetry is false,\n\nexpirationReason is nil\n\n\t\n\nThe auto-renewable subscription is active and not in a billing retry period.\n\nThe subscription is entitled to service.\n\n\n\n\nisInBillingRetry is true,\n\nexpirationReason is billingError,\n\ngracePeriodExpirationDate has a date\n\n\t\n\nThe auto-renewable subscription is in a billing grace period.\n\nThe subscription is entitled to service until the date in gracePeriodExpirationDate.\n\n\n\n\nisInBillingRetry is true,\n\nexpirationReason is billingError,\n\ngracePeriodExpirationDate is nil\n\n\t\n\nThe auto-renewable subscription is in a billing retry period.\n\nThe subscription is not entitled to service.\n\n\n\n\nisInBillingRetry is false,\n\nexpirationReason is billingError\n\n\t\n\nThe auto-renewable subscription expired and billing retry wasn’t able to recover the subscription.\n\nThe subscription is not entitled to service.\n\nSee Also\nGetting billing status\nlet gracePeriodExpirationDate: Date?\nThe date the billing grace period expires for the auto-renewable subscription."
  },
  {
    "title": "productIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skmutablepayment/1505983-productidentifier",
    "html": "Discussion\n\nThe product identifier is a string previously agreed on between your app and the Apple App Store.\n\nSee Also\nGetting and Setting Attributes\nvar quantity: Int\nThe number of items the user wants to purchase.\nvar requestData: Data?\nReserved for future use.\nvar applicationUsername: String?\nA string that associates the transaction with a user account on your service.\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "productIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skpayment/1506155-productidentifier",
    "html": "Discussion\n\nThe product identifier is a string previously agreed on between your app and the Apple App Store.\n\nSee Also\nGetting Payment Details\nvar quantity: Int\nThe number of items the user wants to purchase.\nvar requestData: Data?\nReserved for future use.\nvar applicationUsername: String?\nA string that associates the transaction with a user account on your service."
  },
  {
    "title": "clientInvalid",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2330533-clientinvalid",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "paymentInvalid",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2330536-paymentinvalid",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "paymentNotAllowed",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2330535-paymentnotallowed",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "unauthorizedRequestData",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3140733-unauthorizedrequestdata",
    "html": "Discussion\n\nTo use requestData, an app must have a required entitlement.\n\nSee Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "storeProductNotAvailable",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2335084-storeproductnotavailable",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "cloudServicePermissionDenied",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2335083-cloudservicepermissiondenied",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "privacyAcknowledgementRequired",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3112592-privacyacknowledgementrequired",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "cloudServiceRevoked",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2838457-cloudservicerevoked",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "cloudServiceNetworkConnectionFailed",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2335082-cloudservicenetworkconnectionfai",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "SKError.Code.invalidOfferPrice",
    "url": "https://developer.apple.com/documentation/storekit/skerror/code/invalidofferprice",
    "html": "Discussion\n\nAn offer price can become invalid if you change the price of the base subscription such that it is lower than the offer price. Offers must always represent a discounted price."
  },
  {
    "title": "SKError.Code.missingOfferParams",
    "url": "https://developer.apple.com/documentation/storekit/skerror/code/missingofferparams",
    "html": "Discussion\n\nThis error appears if all parameters of SKPaymentDiscount are not present."
  },
  {
    "title": "jsonRepresentation",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3868404-jsonrepresentation",
    "html": "Discussion\n\nThe information in jsonRepresentation is the same information that’s in the properties of the same instance of Product.SubscriptionInfo.RenewalInfo."
  },
  {
    "title": "autoRenewPreference",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3749495-autorenewpreference",
    "html": "Discussion\n\nThis value is the product ID of the auto-renewable subscription that will renew after the current period expires. The value may be:\n\nThe same as currentProductID if the subscription will renew with the same product.\n\nAnother product ID value if the subscription will renew to a different product.\n\nnil if the subscription won’t renew in the next period. This may occur for several reasons, including when the person disables auto-renew for the subscription, the subscription lapses due to a billing issue, or you increase the subscription price and the person doesn't accept the increase.\n\nSee Also\nGetting the renewal or expiration state\nlet state: Product.SubscriptionInfo.RenewalState\nThe renewal state of the auto-renewable subscription.\nlet willAutoRenew: Bool\nA Boolean value that indicates whether the subscription will automatically renew in the next period.\nlet expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?\nThe reason the auto-renewable subscription expired.\nstruct Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe reasons for auto-renewable subscription expirations.\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var renewalDate: Date?\nThe UNIX time, in milliseconds, that the most recent auto-renewable subscription purchase expires."
  },
  {
    "title": "willAutoRenew",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3749512-willautorenew",
    "html": "See Also\nGetting the renewal or expiration state\nlet state: Product.SubscriptionInfo.RenewalState\nThe renewal state of the auto-renewable subscription.\nlet autoRenewPreference: String?\nThe product ID of the auto-renewable subscription that will automatically renew.\nlet expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?\nThe reason the auto-renewable subscription expired.\nstruct Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe reasons for auto-renewable subscription expirations.\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var renewalDate: Date?\nThe UNIX time, in milliseconds, that the most recent auto-renewable subscription purchase expires."
  },
  {
    "title": "contains(where:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851085-contains",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFiltering and matching elements\nfunc allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc first(where: (Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc filter((Product.SubscriptionInfo.Status) -> Bool) -> AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc max(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses/3851083-contains",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n\nSee Also\nFiltering and matching elements\nfunc allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc filter((Product.SubscriptionInfo.Status) -> Bool) -> AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc max(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3726685-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nSee Also\nError code comparisons and hash\nstatic func != (SKError, SKError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (SKError, SKError) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3726683",
    "html": "See Also\nError code comparisons and hash\nstatic func != (SKError, SKError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/skerror/3726686-hashvalue",
    "html": "See Also\nError code comparisons and hash\nstatic func != (SKError, SKError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (SKError, SKError) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "Product.PromotionInfo.Visibility.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/visibility/rawvalue",
    "html": "See Also\nCreating visibility states\ninit?(rawValue: Int)\nCreates a visibility state.\nvar rawValue: Int\nThe raw value that represents the visiblity state of a promoted in-app purchase."
  },
  {
    "title": "familyShared",
    "url": "https://developer.apple.com/documentation/storekit/transaction/ownershiptype/3749652-familyshared",
    "html": "Discussion\n\nFor more information about Family Sharing, see Turn on Family Sharing for in-app purchases.\n\nSee Also\nGetting ownership types\nstatic let purchased: Transaction.OwnershipType\nThe transaction belongs to the purchaser."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2947101",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nError code comparisons and hash\nstatic func == (SKError, SKError) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "errorDomain",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2887427-errordomain",
    "html": "See Also\nError domain\nlet SKErrorDomain: String\nThe error domain name for StoreKit errors."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/visibility/4115009",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing visibility\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/visibility/4115016-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating visibility states\ninit?(rawValue: Int)\nCreates a visibility state.\ntypealias Product.PromotionInfo.Visibility.RawValue\nA type that represents the raw value of the visibility state of a promoted in-app purchase."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/visibility/4115012-hash",
    "html": "See Also\nComparing and hashing visibility\nstatic func != (Product.PromotionInfo.Visibility, Product.PromotionInfo.Visibility) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/visibility/4115015-init",
    "html": "Parameters\nrawValue\n\nThe raw value that represents the visibility of a promoted in-app purchase.\n\nRelationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating visibility states\ntypealias Product.PromotionInfo.Visibility.RawValue\nA type that represents the raw value of the visibility state of a promoted in-app purchase.\nvar rawValue: Int\nThe raw value that represents the visiblity state of a promoted in-app purchase."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/visibility/4115013-hashvalue",
    "html": "See Also\nComparing and hashing visibility\nstatic func != (Product.PromotionInfo.Visibility, Product.PromotionInfo.Visibility) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851139-flatmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, Storefront) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Storefront) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "Product.PromotionInfo.Visibility.visible",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/visibility/visible",
    "html": "Discussion\n\nA promoted in-app purchase with this visibility setting is visible on the App Store on a user’s device.\n\nSee Also\nGetting visibility states\ncase appStoreConnectDefault\nA visibility value for a promoted in-app purchase that uses the visibility setting from App Store Connect.\ncase hidden\nA visibility value that hides a promoted in-app purchase on the App Store on a user’s device."
  },
  {
    "title": "paymentQueueShouldShowPriceConsent(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueuedelegate/3521328-paymentqueueshouldshowpriceconse",
    "html": "Discussion\n\nThis method applies only to auto-renewable subscription price increases that require customer consent.\n\nThe default return value for this optional method is true. By default, the system displays the price consent sheet when you increase the subscription price in App Store Connect and the subscriber hasn’t yet taken action.\n\nThe system calls your delegate’s method, if appropriate, when you add the first observer to SKPaymentQueue, and any time the app comes to foreground.\n\nIf you return false, the system won’t show the price consent sheet. You can choose to display it later by calling showPriceConsentIfNeeded(). You may want to delay showing the sheet if it would interrupt your user’s interaction in your app.\n\nNote\n\nWhen you increase the price of an auto-renewable subscription and it requires customer consent, Apple informs affected subscribers through an email, push notification, and an in-app price consent sheet and asks them to agree to the new price. If they don’t agree or take no action, their subscription expires at the end of their current billing cycle. For more information, see Managing Prices and Manage pricing for auto-renewable subscriptions.\n\nIn Mac apps built with Mac Catalyst, the system doesn’t show the price consent sheet regardless of the return value.\n\nSee Also\nRelated Documentation\nfunc showPriceConsentIfNeeded()\nAsks the system to display the price consent sheet if the user hasn’t yet responded to a subscription price increase."
  },
  {
    "title": "allSatisfy(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851123-allsatisfy",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true.\n\nSee Also\nFinding elements\nfunc contains(where: (Storefront) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Storefront) -> Bool) -> Storefront?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Storefront, Storefront) -> Bool) -> Storefront?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Storefront, Storefront) -> Bool) -> Storefront?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "contains(where:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851129-contains",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFinding elements\nfunc allSatisfy((Storefront) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc first(where: (Storefront) -> Bool) -> Storefront?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Storefront, Storefront) -> Bool) -> Storefront?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Storefront, Storefront) -> Bool) -> Storefront?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "Storefront.Storefronts.AsyncIterator",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/asynciterator",
    "html": "Topics\nGetting the Next Element\nfunc next() -> Storefront?\nAdvances to the next element and returns either the element or nil if there isn’t a next element.\ntypealias Storefront.Storefronts.AsyncIterator.Element\nThe type of element produced by this iterator.\ntypealias Storefront.Storefronts.Element\nA type that represents the element of a storefront sequence.\nRelationships\nFrom Protocol\nAsyncSequence\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> Storefront.Storefronts.AsyncIterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence."
  },
  {
    "title": "first(where:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851137-first",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFinding elements\nfunc allSatisfy((Storefront) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(where: (Storefront) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc max(by: (Storefront, Storefront) -> Bool) -> Storefront?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Storefront, Storefront) -> Bool) -> Storefront?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "SKCloudServiceSetupAction",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupaction",
    "html": "Topics\nInitializers\ninit(rawValue: String)\nInitializes a setup action to offer for a cloud service using the specified value.\nType Properties\nstatic let subscribe: SKCloudServiceSetupAction\nA subscribe action in a cloud service setup view, such as an offer to subscribe to Apple Music.\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nIndicating Setup Options\nstatic let action: SKCloudServiceSetupOptionsKey\nA key that specifies the action for a setup entry point.\nstatic let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store item that the user is trying to access through the service.\nstatic let affiliateToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate token.\nstatic let campaignToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate campaign token.\nstatic let messageIdentifier: SKCloudServiceSetupOptionsKey\nA key that is used to select the main message presented to the user for this setup view.\nstruct SKCloudServiceSetupMessageIdentifier\nIdentifiers for the available messages the setup view can present to the user."
  },
  {
    "title": "reduce(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851156-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(into: Result, (inout Result, Storefront) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "prefix(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851152-prefix",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence.\n\nSee Also\nSelecting elements\nfunc prefix(while: (Storefront) -> Bool) -> AsyncPrefixWhileSequence<Storefront.Storefronts>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "makeAsyncIterator()",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851143-makeasynciterator",
    "html": "Relationships\nFrom Protocol\nAsyncSequence\nSee Also\nCreating an iterator\nstruct Storefront.Storefronts.AsyncIterator\nThe iterator that produces elements of the asynchronous sequence."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851144-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, Storefront) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Storefront) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "campaignToken",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupoptionskey/2838456-campaigntoken",
    "html": "See Also\nIndicating Setup Options\nstatic let action: SKCloudServiceSetupOptionsKey\nA key that specifies the action for a setup entry point.\nstruct SKCloudServiceSetupAction\nA string used to specify the type of setup action to offer for a cloud service.\nstatic let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store item that the user is trying to access through the service.\nstatic let affiliateToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate token.\nstatic let messageIdentifier: SKCloudServiceSetupOptionsKey\nA key that is used to select the main message presented to the user for this setup view.\nstruct SKCloudServiceSetupMessageIdentifier\nIdentifiers for the available messages the setup view can present to the user."
  },
  {
    "title": "max(by:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851148-max",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n\nSee Also\nFinding elements\nfunc allSatisfy((Storefront) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(where: (Storefront) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Storefront) -> Bool) -> Storefront?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (Storefront, Storefront) -> Bool) -> Storefront?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "SKProductStorePromotionVisibility",
    "url": "https://developer.apple.com/documentation/storekit/skproductstorepromotionvisibility",
    "html": "Topics\nEnumeration cases\ncase `default`\nIndicates product visibility is the same as the default value set in App Store Connect.\ncase hide\nIndicates product is hidden.\ncase show\nIndicates product is shown.\nRelationships\nConforms To\nSendable\nSee Also\nManaging promoted product visibility\nfunc fetchStorePromotionVisibility(for: SKProduct, completionHandler: ((SKProductStorePromotionVisibility, (any Error)?) -> Void)?)\nReads the visibility setting of a promoted product in the App Store for this device.\nfunc update(storePromotionVisibility: SKProductStorePromotionVisibility, for: SKProduct, completionHandler: (((any Error)?) -> Void)?)\nUpdates the visibility of the product on the App Store, per device."
  },
  {
    "title": "min(by:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851150-min",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n\nSee Also\nFinding elements\nfunc allSatisfy((Storefront) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(where: (Storefront) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Storefront) -> Bool) -> Storefront?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Storefront, Storefront) -> Bool) -> Storefront?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "gracePeriodExpirationDate",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3749500-graceperiodexpirationdate",
    "html": "Discussion\n\nThis value is nil if the subscription is not in a billing grace period.\n\nThis date is present if you enable Billing Grace Period for your app and the subscription is in the billing grace period. Ensure that your app provides full service for the subscription throughout the grace period, which ends on the gracePeriodExpirationDate.\n\nA billing grace period occurs at the start of a billing retry state. Throughout the billing grace period, the value of isInBillingRetry is true, which indicates that Apple is attempting to automatically renew the subscription.\n\nFor information about supporting Billing Grace Period, see Enable Billing Grace Period for auto-renewable subscriptions and Reducing Involuntary Subscriber Churn.\n\nSee Also\nGetting billing status\nlet isInBillingRetry: Bool\nA Boolean value that indicates whether an auto-renewable subscription is in the billing retry period."
  },
  {
    "title": "Product.SubscriptionInfo.RenewalInfo.ExpirationReason",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/expirationreason",
    "html": "Topics\nGetting the expiration reason\nstatic let autoRenewDisabled: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because the customer voluntarily canceled their subscription.\nstatic let billingError: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because of a billing error.\nstatic let didNotConsentToPriceIncrease: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe subscription expired because the customer didn’t consent to an auto-renewable subscription price increase that requires customer consent.\nstatic let productUnavailable: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired because the product was unavailable for purchase at the time of the renewal.\nstatic let unknown: Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe auto-renewable subscription expired for an unknown reason.\nGetting a localized description\nvar localizedDescription: String\nThe localized text that describes the expiration reason.\nAccessing the raw value\nlet rawValue: Int\nThe raw value that represents an expiration reason.\ntypealias Product.SubscriptionInfo.RenewalInfo.ExpirationReason.RawValue\nA type that represents the raw value of a subscription expiration reason.\nCreating an expiration reason\ninit(rawValue: Int)\nCreates an expiration reason instance from a raw value.\nComparing and hashing expiration reasons\nstatic func != (Product.SubscriptionInfo.RenewalInfo.ExpirationReason, Product.SubscriptionInfo.RenewalInfo.ExpirationReason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSee Also\nGetting the renewal or expiration state\nlet state: Product.SubscriptionInfo.RenewalState\nThe renewal state of the auto-renewable subscription.\nlet autoRenewPreference: String?\nThe product ID of the auto-renewable subscription that will automatically renew.\nlet willAutoRenew: Bool\nA Boolean value that indicates whether the subscription will automatically renew in the next period.\nlet expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?\nThe reason the auto-renewable subscription expired.\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var renewalDate: Date?\nThe UNIX time, in milliseconds, that the most recent auto-renewable subscription purchase expires."
  },
  {
    "title": "expirationReason",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3749499-expirationreason",
    "html": "Discussion\n\nThis optional value is nil if the auto-renewable subscription is active and hasn’t expired.\n\nSee Also\nGetting the renewal or expiration state\nlet state: Product.SubscriptionInfo.RenewalState\nThe renewal state of the auto-renewable subscription.\nlet autoRenewPreference: String?\nThe product ID of the auto-renewable subscription that will automatically renew.\nlet willAutoRenew: Bool\nA Boolean value that indicates whether the subscription will automatically renew in the next period.\nstruct Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe reasons for auto-renewable subscription expirations.\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var renewalDate: Date?\nThe UNIX time, in milliseconds, that the most recent auto-renewable subscription purchase expires."
  },
  {
    "title": "priceIncreaseStatus",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3822292-priceincreasestatus",
    "html": "Discussion\n\nFor more information about price increase status, see Managing Price Increases for Auto-Renewable Subscriptions.\n\nSee Also\nGetting the price increase status\nManaging Price Increases for Auto-Renewable Subscriptions\nIdentify the price increase status for auto-renewable subscriptions, in your app and on your server.\nenum Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus\nStatus values that indicate whether an auto-renewable subscription is subject to a price increase."
  },
  {
    "title": "expectedContentLength",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/3182428-expectedcontentlength",
    "html": "See Also\nGetting Content Information\nvar contentIdentifier: String\nA string that uniquely identifies the downloadable content.\nDeprecated\nvar contentVersion: String\nA string that identifies which version of the content is available for download.\nDeprecated\nvar transaction: SKPaymentTransaction\nThe transaction associated with the downloadable file.\nDeprecated\nvar contentLength: Int64\nThe length of the downloadable content, in bytes.\nDeprecated"
  },
  {
    "title": "signedDate",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3822293-signeddate",
    "html": "Discussion\n\nUse the signedDate to verify whether the certificate used to sign the transaction was valid when the App Store signed the transaction.\n\nSee Also\nVerifying subscription renewal information\nlet deviceVerification: Data\nThe device verification value to use to verify whether the renewal information belongs to the device.\nlet deviceVerificationNonce: UUID\nThe UUID to use to compute the device verification value."
  },
  {
    "title": "SKReceiptPropertyIsExpired",
    "url": "https://developer.apple.com/documentation/storekit/skreceiptpropertyisexpired",
    "html": "Discussion\n\nThis key’s value is an instance of NSNumber that the system interprets as a Boolean value that indicates whether the receipt is in an expired state.\n\nSee Also\nReceipt Properties and Keys\nvar receiptProperties: [String : Any]?\nThe properties of the receipt.\nlet SKReceiptPropertyIsRevoked: String\nA key with a value that indicates whether the receipt is in a revoked state.\nlet SKReceiptPropertyIsVolumePurchase: String\nA key with a value that indicates whether the receipt is a Volume Purchase Plan receipt."
  },
  {
    "title": "SKReceiptPropertyIsRevoked",
    "url": "https://developer.apple.com/documentation/storekit/skreceiptpropertyisrevoked",
    "html": "Discussion\n\nThis key’s value is an instance of NSNumber that the system interprets as a Boolean value that indicates whether the receipt is in a revoked state.\n\nSee Also\nReceipt Properties and Keys\nvar receiptProperties: [String : Any]?\nThe properties of the receipt.\nlet SKReceiptPropertyIsExpired: String\nA key with a value that indicates whether the receipt is in an expired state.\nlet SKReceiptPropertyIsVolumePurchase: String\nA key with a value that indicates whether the receipt is a Volume Purchase Plan receipt."
  },
  {
    "title": "SKReceiptPropertyIsVolumePurchase",
    "url": "https://developer.apple.com/documentation/storekit/skreceiptpropertyisvolumepurchase",
    "html": "Discussion\n\nThis key’s value is an instance of NSNumber that the system interprets as a Boolean value that indicates whether the receipt is a Volume Purchase Plan receipt.\n\nSee Also\nReceipt Properties and Keys\nvar receiptProperties: [String : Any]?\nThe properties of the receipt.\nlet SKReceiptPropertyIsExpired: String\nA key with a value that indicates whether the receipt is in an expired state.\nlet SKReceiptPropertyIsRevoked: String\nA key with a value that indicates whether the receipt is in a revoked state."
  },
  {
    "title": "init(product:)",
    "url": "https://developer.apple.com/documentation/storekit/skpayment/1506008-init",
    "html": "Parameters\nproduct\n\nThe product the user wishes to purchase.\n\nReturn Value\n\nA new payment object.\n\nDiscussion\n\nThis Object creation uses the productIdentifier property obtained from the product parameter to create and return a new payment with that identifier. The quantity property defaults to 1.\n\nTo create a SKPayment object with a quantity greater than 1, create a SKMutablePayment object, adjust its quantity property and then add it to the payment queue.\n\nSKMutablePayment *myPayment = [SKMutablePayment paymentWithProduct: myProduct];\nmyPayment.quantity = 2;\n[[SKPaymentQueue defaultQueue] addPayment:myPayment];\n\nSee Also\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "requestData",
    "url": "https://developer.apple.com/documentation/storekit/skpayment/1506159-requestdata",
    "html": "Discussion\n\nThe default value is nil. If requestData is not nil, your payment request will be rejected.\n\nSee Also\nGetting Payment Details\nvar productIdentifier: String\nA string used to identify a product that can be purchased from within your app.\nvar quantity: Int\nThe number of items the user wants to purchase.\nvar applicationUsername: String?\nA string that associates the transaction with a user account on your service."
  },
  {
    "title": "payment",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransaction/1411286-payment",
    "html": "Discussion\n\nEach payment transaction is created in response to a payment that your application added to the payment queue.\n\nSee Also\nGetting Transaction Information\nvar transactionIdentifier: String?\nA string that uniquely identifies a successful payment transaction.\nvar transactionDate: Date?\nThe date the transaction was added to the App Store’s payment queue.\nvar original: SKPaymentTransaction?\nThe transaction that was restored by the App Store.\nvar error: (any Error)?\nAn object describing the error that occurred while processing the transaction.\nvar transactionReceipt: Data?\nA signed receipt that records all information about a successful payment transaction."
  },
  {
    "title": "quantity",
    "url": "https://developer.apple.com/documentation/storekit/skpayment/1506077-quantity",
    "html": "Discussion\n\nThe default value is 1, the minimum value is 1, and the maximum value is 10.\n\nSee Also\nGetting Payment Details\nvar productIdentifier: String\nA string used to identify a product that can be purchased from within your app.\nvar requestData: Data?\nReserved for future use.\nvar applicationUsername: String?\nA string that associates the transaction with a user account on your service."
  },
  {
    "title": "applicationUsername",
    "url": "https://developer.apple.com/documentation/storekit/skpayment/1506116-applicationusername",
    "html": "Discussion\n\nFor more information on how to set and use this property, see applicationUsername.\n\nSee Also\nGetting Payment Details\nvar productIdentifier: String\nA string used to identify a product that can be purchased from within your app.\nvar quantity: Int\nThe number of items the user wants to purchase.\nvar requestData: Data?\nReserved for future use."
  },
  {
    "title": "quantity",
    "url": "https://developer.apple.com/documentation/storekit/skmutablepayment/1506170-quantity",
    "html": "Discussion\n\nThe quantity property must be greater than 0.\n\nSee Also\nGetting and Setting Attributes\nvar productIdentifier: String\nA string that identifies a product that can be purchased from within your app.\nvar requestData: Data?\nReserved for future use.\nvar applicationUsername: String?\nA string that associates the transaction with a user account on your service."
  },
  {
    "title": "transactionIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransaction/1411288-transactionidentifier",
    "html": "Discussion\n\nThe contents of this property are undefined except when transactionState is set to SKPaymentTransactionState.purchased or SKPaymentTransactionState.restored. The transactionIdentifier is a string that uniquely identifies an interaction between the user's device and the App Store, such as a purchase or restore.\n\nThis value has the same format as the transaction’s transaction_id in the receipt; however, the values may not be the same.\n\nSee Also\nGetting Transaction Information\nvar payment: SKPayment\nThe payment for the transaction.\nvar transactionDate: Date?\nThe date the transaction was added to the App Store’s payment queue.\nvar original: SKPaymentTransaction?\nThe transaction that was restored by the App Store.\nvar error: (any Error)?\nAn object describing the error that occurred while processing the transaction.\nvar transactionReceipt: Data?\nA signed receipt that records all information about a successful payment transaction."
  },
  {
    "title": "requestData",
    "url": "https://developer.apple.com/documentation/storekit/skmutablepayment/1505974-requestdata",
    "html": "Discussion\n\nThe default value is nil. If requestData is not nil, your payment will be rejected by the Apple App Store.\n\nSee Also\nGetting and Setting Attributes\nvar productIdentifier: String\nA string that identifies a product that can be purchased from within your app.\nvar quantity: Int\nThe number of items the user wants to purchase.\nvar applicationUsername: String?\nA string that associates the transaction with a user account on your service."
  },
  {
    "title": "paymentDiscount",
    "url": "https://developer.apple.com/documentation/storekit/skpayment/3043526-paymentdiscount",
    "html": "See Also\nGetting Discount Details\nclass SKPaymentDiscount\nThe signed discount to apply to a payment."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3791918",
    "html": "See Also\nComparing and hashing renewal information\nstatic func != (Product.SubscriptionInfo.RenewalInfo, Product.SubscriptionInfo.RenewalInfo) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3791923-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing renewal information\nstatic func != (Product.SubscriptionInfo.RenewalInfo, Product.SubscriptionInfo.RenewalInfo) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo.RenewalInfo, Product.SubscriptionInfo.RenewalInfo) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3791917",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing renewal information\nstatic func == (Product.SubscriptionInfo.RenewalInfo, Product.SubscriptionInfo.RenewalInfo) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3791922-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing renewal information\nstatic func != (Product.SubscriptionInfo.RenewalInfo, Product.SubscriptionInfo.RenewalInfo) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo.RenewalInfo, Product.SubscriptionInfo.RenewalInfo) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "debugDescription",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3791921-debugdescription",
    "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
  },
  {
    "title": "environmentStringRepresentation",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3976512-environmentstringrepresentation",
    "html": "See Also\nGetting the environment\nlet environment: AppStore.Environment\nThe server environment that signs the renewal information for an auto-renewable subscription."
  },
  {
    "title": "SKError.Code.unauthorizedRequestData",
    "url": "https://developer.apple.com/documentation/storekit/skerror/code/unauthorizedrequestdata",
    "html": "Discussion\n\nTo use requestData, an app must have a required entitlement."
  },
  {
    "title": "Generating a Promotional Offer Signature on the Server",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/generating_a_promotional_offer_signature_on_the_server",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC 2019 session 305: Subscription Offers Best Practices.\n\nThis sample code is a simple server written using JavaScript and Node.js. It demonstrates how to generate a signature for promotional offers. The sample demonstrates:\n\nReceiving a request.\n\nGenerating a cryptographic signature using your private key.\n\nSending back a response with the signature.\n\nAll of the work is done in routes/index.js. You set up environment variables for your key ID and your private key in the start-server file.\n\nConfigure the Sample Code Project\n\nInstall the latest stable version of Node.js.\n\nOpen Terminal.app and navigate to the sample code directory.\n\nRun npm install from the command line, and make sure it completes successfully.\n\nThe start-server file contains a key ID and private key PEM string. The values provided in the sample are for example purposes only and will not generate signatures that are valid for your apps. You can optionally open start-server with a text editor and replace the example key ID and private key PEM string with your own key ID and private key PEM string that you received from App Store Connect.\n\nRun a Test on Your Local Server\n\nTo test the code on your local machine, from the command line:\n\nNavigate to the sample code source folder and run ./start-server from the command line. The server is now running locally and is ready to accept connections on port 3000.\n\nOpen another terminal window and use the curl command to send a request. This example command uses the same data listed in the JSON example below:\n\ncurl -X GET -H \"Content-type: application/json\" -d '{\"appBundleID\": \"com.example.yourapp\", \"productIdentifier\": \"com.example.yoursubscription\", \"offerID\": \"your_offer_id\", \"applicationUsername\": \"8E3DC5F16E13537ADB45FB0F980ACDB6B55839870DBCE7E346E1826F5B0296CA\"}' http://127.0.0.1:3000/offer\n\n\nYou will get a response that includes the signature.\n\nSend a Request\n\nTo run this sample code, send a request to this URL: GET http://<yourdomain>/offer, where <yourdomain> is the domain name or IP address of the server this sample code is running on.\n\nThe request must have a Content-type header of application/json, and JSON body data with the following format:\n\n{\n    \"appBundleID\": \"com.example.yourapp\",\n    \"productIdentifier\": \"com.example.yoursubscription\",\n    \"offerID\": \"your_offer_id\",\n    \"applicationUsername\": \"8E3DC5F16E13537ADB45FB0F980ACDB6B55839870DBCE7E346E1826F5B0296CA\"\n}\n\nSee Also\nPromotional offers\nSetting up promotional offers\nGenerate a key and configure offers for auto-renewable subscriptions in App Store Connect.\nImplementing promotional offers in your app\nOffer discounted pricing for auto-renewable subscription products to eligible subscribers.\nGenerating a signature for promotional offers\nCreate a signature to validate a promotional offer using your private key.\nclass SKPaymentDiscount\nThe signed discount to apply to a payment."
  },
  {
    "title": "localizedTitle",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/1506001-localizedtitle",
    "html": "Discussion\n\nThe title's language is determined by the storefront that the user's device is connected to, not the preferred language set on the device.\n\nSee Also\nGetting Product Attributes\nvar localizedDescription: String\nA description of the product.\nvar contentVersion: String\nA string that identifies the version of the content.\nvar isFamilyShareable: Bool\nA Boolean value that indicates whether the product is available for Family Sharing in App Store Connect.\nvar contentLengths: [NSNumber]\nThe total size of the content, in bytes.\nDeprecated\nRelated Documentation\nclass SKStorefront\nAn object containing the location and unique identifier of an Apple App Store storefront."
  },
  {
    "title": "downloadContentVersion",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/1615754-downloadcontentversion",
    "html": "Discussion\n\nThe version string is formatted as a series of integers separated by periods.\n\nSee Also\nGetting Downloadable Content Information\nvar isDownloadable: Bool\nA Boolean value that indicates whether the App Store has downloadable content for this product.\nvar downloadContentLengths: [NSNumber]\nThe lengths of the downloadable files available for this product.\nvar downloadable: Bool\nA Boolean value that indicates whether the App Store has downloadable content for this product.\nDeprecated"
  },
  {
    "title": "SKRequestDelegate",
    "url": "https://developer.apple.com/documentation/storekit/skrequestdelegate",
    "html": "Topics\nCompleting Requests\nfunc requestDidFinish(SKRequest)\nTells the delegate that the request has completed.\nHandling Errors\nfunc request(SKRequest, didFailWithError: any Error)\nTells the delegate that the request failed to execute.\nRelationships\nInherits From\nNSObjectProtocol\nInherited By\nSKProductsRequestDelegate\nSee Also\nAccessing the Delegate\nvar delegate: (any SKRequestDelegate)?\nThe delegate of the request object."
  },
  {
    "title": "filter(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851135-filter",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n\nSee Also\nExcluding elements\nfunc drop(while: (Storefront) -> Bool) -> AsyncDropWhileSequence<Storefront.Storefronts>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Storefront.Storefronts>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements."
  },
  {
    "title": "SKError.Code.storeProductNotAvailable",
    "url": "https://developer.apple.com/documentation/storekit/skerror/code/storeproductnotavailable",
    "html": "Discussion\n\nSee SKStorefront for more information."
  },
  {
    "title": "SKProductsRequestDelegate",
    "url": "https://developer.apple.com/documentation/storekit/skproductsrequestdelegate",
    "html": "Overview\n\nThe SKProductsRequestDelegate protocol declares methods that are implemented by the delegate of an SKProductsRequest object. The delegate receives the product information that the product request referred to. Your app uses this information when presenting products to users in its in-app store.\n\nWarning\n\nResponses received by the SKProductsRequestDelegate may not be returned on a specific thread. If you make assumptions about which queue will handle delegate responses, you may encounter unintended performance and compatibility issues in the future.\n\nTopics\nReceiving the Response\nfunc productsRequest(SKProductsRequest, didReceive: SKProductsResponse)\nAccepts the App Store response that contains the app-requested product information.\n\nRequired\n\nRelationships\nInherits From\nSKRequestDelegate\nSee Also\nSetting the Delegate\nvar delegate: (any SKProductsRequestDelegate)?\nThe delegate that receives the response of the app's products request."
  },
  {
    "title": "delegate",
    "url": "https://developer.apple.com/documentation/storekit/skrequest/1385530-delegate",
    "html": "Discussion\n\nThe delegate must adopt the SKRequestDelegate protocol, although most subclasses of SKRequest provide a more specific protocol to implement.\n\nSee Also\nAccessing the Delegate\nprotocol SKRequestDelegate\nCommon methods that are implemented by delegates for any subclass of the SKRequest abstract class."
  },
  {
    "title": "delegate",
    "url": "https://developer.apple.com/documentation/storekit/skproductsrequest/1506142-delegate",
    "html": "See Also\nSetting the Delegate\nprotocol SKProductsRequestDelegate\nA set of methods the delegate implements so it receives the product information your app requests."
  },
  {
    "title": "cancel()",
    "url": "https://developer.apple.com/documentation/storekit/skrequest/1385526-cancel",
    "html": "Discussion\n\nWhen you cancel a request, the delegate is not called with an error.\n\nSee Also\nControlling the Request\nfunc start()\nSends the request to the Apple App Store."
  },
  {
    "title": "start()",
    "url": "https://developer.apple.com/documentation/storekit/skrequest/1385534-start",
    "html": "Discussion\n\nThe results for a request are sent to the request’s delegate.\n\nSee Also\nControlling the Request\nfunc cancel()\nCancels a previously started request.\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "SKCloudServiceSetupMessageIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupmessageidentifier",
    "html": "Topics\nInitializing Identifiers\ninit(rawValue: String)\nInitializes a cloud service setup message identifier based on the provided raw value.\nMessage Identifiers\nstatic let addMusic: SKCloudServiceSetupMessageIdentifier\nMessage identifier for adding music.\nstatic let connect: SKCloudServiceSetupMessageIdentifier\nMessage identifier for connecting.\nstatic let join: SKCloudServiceSetupMessageIdentifier\nMessage identifier for joining.\nstatic let playMusic: SKCloudServiceSetupMessageIdentifier\nMessage identifier for playing music.\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nIndicating Setup Options\nstatic let action: SKCloudServiceSetupOptionsKey\nA key that specifies the action for a setup entry point.\nstruct SKCloudServiceSetupAction\nA string used to specify the type of setup action to offer for a cloud service.\nstatic let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store item that the user is trying to access through the service.\nstatic let affiliateToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate token.\nstatic let campaignToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate campaign token.\nstatic let messageIdentifier: SKCloudServiceSetupOptionsKey\nA key that is used to select the main message presented to the user for this setup view."
  },
  {
    "title": "iTunesItemIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupoptionskey/2609448-itunesitemidentifier",
    "html": "Discussion\n\nThe only iTunes Store items that are supported are song, video, playlist, and album.\n\nSee Also\nIndicating Setup Options\nstatic let action: SKCloudServiceSetupOptionsKey\nA key that specifies the action for a setup entry point.\nstruct SKCloudServiceSetupAction\nA string used to specify the type of setup action to offer for a cloud service.\nstatic let affiliateToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate token.\nstatic let campaignToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate campaign token.\nstatic let messageIdentifier: SKCloudServiceSetupOptionsKey\nA key that is used to select the main message presented to the user for this setup view.\nstruct SKCloudServiceSetupMessageIdentifier\nIdentifiers for the available messages the setup view can present to the user."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851146-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, Storefront) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Storefront) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "reduce(into:_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851158-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary.\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, Storefront) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure."
  },
  {
    "title": "paymentQueue(_:updatedDownloads:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver/1506073-paymentqueue",
    "html": "Parameters\nqueue\n\nThe payment queue that updated the downloads.\n\ndownloads\n\nThe download objects that were updated.\n\nDiscussion\n\nWhen a download object is updated, its downloadState property describes how it changed."
  },
  {
    "title": "update(storePromotionVisibility:for:completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skproductstorepromotioncontroller/2915868-update",
    "html": "Discussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc update(promotionVisibility: SKProductStorePromotionVisibility, for product: SKProduct) async throws\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nAn in-app purchase product's default visibility setting is set up in App Store Connect. You can override the default setting, or return it to the default set in App Store Connect using the values in SKProductStorePromotionVisibility.\n\nVisibility settings apply per device.\n\nSee Also\nManaging promoted product visibility\nfunc fetchStorePromotionVisibility(for: SKProduct, completionHandler: ((SKProductStorePromotionVisibility, (any Error)?) -> Void)?)\nReads the visibility setting of a promoted product in the App Store for this device.\nenum SKProductStorePromotionVisibility\nThe visibility settings that determine if an in-app purchase is visible on a device."
  },
  {
    "title": "renewalDate",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/4193529-renewaldate",
    "html": "Discussion\n\nThe renewalDate is a value that’s always present for auto-renewable subscriptions, even for expired subscriptions. This date indicates the expiration date of the most recent auto-renewable subscription purchase, including renewals, and may be in the past. For subscriptions that renew successfully, the renewalDate is the date when the subscription renews.\n\nSee Also\nGetting the renewal or expiration state\nlet state: Product.SubscriptionInfo.RenewalState\nThe renewal state of the auto-renewable subscription.\nlet autoRenewPreference: String?\nThe product ID of the auto-renewable subscription that will automatically renew.\nlet willAutoRenew: Bool\nA Boolean value that indicates whether the subscription will automatically renew in the next period.\nlet expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?\nThe reason the auto-renewable subscription expired.\nstruct Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe reasons for auto-renewable subscription expirations."
  },
  {
    "title": "error",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1458914-error",
    "html": "Discussion\n\nThe value of this property is valid only when the downloadState property is set to SKDownloadState.failed.\n\nSee Also\nAccessing a Completed Download\nvar contentURL: URL?\nThe local location of the downloaded file.\nDeprecated"
  },
  {
    "title": "state",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1458937-state",
    "html": "Discussion\n\nAfter you queue a download object, the payment queue object calls your transaction observer when the state of the download object changes. Your transaction observer should read the state property and use it to determine how to proceed. For more information on the different states, see SKDownloadState.\n\nSee Also\nGetting State Information\nvar progress: Float\nA value that indicates how much of the file has been downloaded.\nDeprecated\nvar timeRemaining: TimeInterval\nAn estimated time, in seconds, to finish downloading the content.\nDeprecated\nvar SKDownloadTimeRemainingUnknown: TimeInterval\nIndicates that the system cannot determine how much time is needed to finish downloading the content.\nDeprecated\nenum SKDownloadState\nThe states that a download operation can be in.\nDeprecated\nvar downloadState: SKDownloadState\nThe current state of the download object.\nDeprecated"
  },
  {
    "title": "contentURL(forProductID:)",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1458924-contenturl",
    "html": "Parameters\nproductID\n\nThe product identifier.\n\nReturn Value\n\nThe local location for the previously downloaded flie.\n\nDiscussion\n\nUse this method to locate the content on subsequent launches of your app.\n\nSee Also\nManaging Downloaded Content\nclass func deleteContent(forProductID: String)\nDeletes the previously downloaded file.\nDeprecated"
  },
  {
    "title": "contentURL",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1458930-contenturl",
    "html": "Discussion\n\nThe value of this property is valid only when the downloadState property is set to SKDownloadState.finished. The URL becomes invalid after the transaction object associated with the download is finalized.\n\nSee Also\nAccessing a Completed Download\nvar error: (any Error)?\nThe error that prevented the content from being downloaded.\nDeprecated"
  },
  {
    "title": "contentLength",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1458932-contentlength",
    "html": "Deprecated\n\nUse expectedContentLength instead.\n\nSee Also\nGetting Content Information\nvar expectedContentLength: Int64\nThe length of the downloadable content, in bytes.\nDeprecated\nvar contentIdentifier: String\nA string that uniquely identifies the downloadable content.\nDeprecated\nvar contentVersion: String\nA string that identifies which version of the content is available for download.\nDeprecated\nvar transaction: SKPaymentTransaction\nThe transaction associated with the downloadable file.\nDeprecated"
  },
  {
    "title": "timeRemaining",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1458943-timeremaining",
    "html": "Discussion\n\nThe system attempts to estimate how long it will take to finish downloading the file. If it cannot create a good estimate, the value of this property is set to SKDownloadTimeRemainingUnknown.\n\nSee Also\nGetting State Information\nvar state: SKDownloadState\nThe current state of the download object.\nDeprecated\nvar progress: Float\nA value that indicates how much of the file has been downloaded.\nDeprecated\nvar SKDownloadTimeRemainingUnknown: TimeInterval\nIndicates that the system cannot determine how much time is needed to finish downloading the content.\nDeprecated\nenum SKDownloadState\nThe states that a download operation can be in.\nDeprecated\nvar downloadState: SKDownloadState\nThe current state of the download object.\nDeprecated"
  },
  {
    "title": "contentIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1458941-contentidentifier",
    "html": "Discussion\n\nEach piece of downloadable content associated with a product has its own unique identifier. The content identifier is specified in App Store Connect when you add the content.\n\nSee Also\nGetting Content Information\nvar expectedContentLength: Int64\nThe length of the downloadable content, in bytes.\nDeprecated\nvar contentVersion: String\nA string that identifies which version of the content is available for download.\nDeprecated\nvar transaction: SKPaymentTransaction\nThe transaction associated with the downloadable file.\nDeprecated\nvar contentLength: Int64\nThe length of the downloadable content, in bytes.\nDeprecated\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "receiptProperties",
    "url": "https://developer.apple.com/documentation/storekit/skreceiptrefreshrequest/1506029-receiptproperties",
    "html": "Discussion\n\nReceipt properties include SKReceiptPropertyIsExpired, SKReceiptPropertyIsRevoked, and SKReceiptPropertyIsVolumePurchase.\n\nSee Also\nReceipt Properties and Keys\nlet SKReceiptPropertyIsExpired: String\nA key with a value that indicates whether the receipt is in an expired state.\nlet SKReceiptPropertyIsRevoked: String\nA key with a value that indicates whether the receipt is in a revoked state.\nlet SKReceiptPropertyIsVolumePurchase: String\nA key with a value that indicates whether the receipt is a Volume Purchase Plan receipt."
  },
  {
    "title": "contentVersion",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1458916-contentversion",
    "html": "Discussion\n\nThe version string must be formatted as a series of integers separated by periods.\n\nSee Also\nGetting Content Information\nvar expectedContentLength: Int64\nThe length of the downloadable content, in bytes.\nDeprecated\nvar contentIdentifier: String\nA string that uniquely identifies the downloadable content.\nDeprecated\nvar transaction: SKPaymentTransaction\nThe transaction associated with the downloadable file.\nDeprecated\nvar contentLength: Int64\nThe length of the downloadable content, in bytes.\nDeprecated"
  },
  {
    "title": "progress",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1458945-progress",
    "html": "Discussion\n\nThe value of this property is a floating point number between 0.0 and 1.0, inclusive, where 0.0 means no data has been download and 1.0 means all the data has been downloaded. Typically, your app uses the value of this property to update a user interface element, such as a progress bar, that displays how much of the file has been downloaded.\n\nDo not use the value of this property to determine whether the download has completed. Instead, use the downloadState property.\n\nSee Also\nGetting State Information\nvar state: SKDownloadState\nThe current state of the download object.\nDeprecated\nvar timeRemaining: TimeInterval\nAn estimated time, in seconds, to finish downloading the content.\nDeprecated\nvar SKDownloadTimeRemainingUnknown: TimeInterval\nIndicates that the system cannot determine how much time is needed to finish downloading the content.\nDeprecated\nenum SKDownloadState\nThe states that a download operation can be in.\nDeprecated\nvar downloadState: SKDownloadState\nThe current state of the download object.\nDeprecated"
  },
  {
    "title": "SKDownloadState",
    "url": "https://developer.apple.com/documentation/storekit/skdownloadstate",
    "html": "Topics\nConstants\ncase waiting\nIndicates that the download has not started yet.\ncase active\nIndicates that the content is currently being downloaded.\ncase paused\nIndicates that your app paused the download.\ncase finished\nIndicates that the content was successfully downloaded.\ncase failed\nIndicates that an error occurred while the file was being downloaded.\ncase cancelled\nIndicates that your app canceled the download.\nRelationships\nConforms To\nSendable\nSee Also\nGetting State Information\nvar state: SKDownloadState\nThe current state of the download object.\nDeprecated\nvar progress: Float\nA value that indicates how much of the file has been downloaded.\nDeprecated\nvar timeRemaining: TimeInterval\nAn estimated time, in seconds, to finish downloading the content.\nDeprecated\nvar SKDownloadTimeRemainingUnknown: TimeInterval\nIndicates that the system cannot determine how much time is needed to finish downloading the content.\nDeprecated\nvar downloadState: SKDownloadState\nThe current state of the download object.\nDeprecated"
  },
  {
    "title": "requestDidFinish(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skrequestdelegate/1385532-requestdidfinish",
    "html": "Parameters\nrequest\n\nThe request that completed.\n\nDiscussion\n\nThis method is called after all processing of the request has been completed. Typically, subclasses of SKRequest require the delegate to implement additional methods to receive the response. When this method is called, your delegate receives no further communication from the request and can release it.\n\nSee Also\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "SKDownloadTimeRemainingUnknown",
    "url": "https://developer.apple.com/documentation/storekit/skdownloadtimeremainingunknown",
    "html": "See Also\nGetting State Information\nvar state: SKDownloadState\nThe current state of the download object.\nDeprecated\nvar progress: Float\nA value that indicates how much of the file has been downloaded.\nDeprecated\nvar timeRemaining: TimeInterval\nAn estimated time, in seconds, to finish downloading the content.\nDeprecated\nenum SKDownloadState\nThe states that a download operation can be in.\nDeprecated\nvar downloadState: SKDownloadState\nThe current state of the download object.\nDeprecated"
  },
  {
    "title": "deleteContent(forProductID:)",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1458926-deletecontent",
    "html": "Parameters\nproductID\n\nThe product identifier.\n\nSee Also\nManaging Downloaded Content\nclass func contentURL(forProductID: String) -> URL?\nReturns the local location for the previously downloaded flie.\nDeprecated"
  },
  {
    "title": "downloadState",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1620412-downloadstate",
    "html": "Discussion\n\nAfter you queue a download object, the payment queue object calls your transaction observer when the state of the download object changes. Your transaction observer should read the downloadState property and use it to determine how to proceed. For more information on the different states, see SKDownloadState.\n\nSee Also\nGetting State Information\nvar state: SKDownloadState\nThe current state of the download object.\nDeprecated\nvar progress: Float\nA value that indicates how much of the file has been downloaded.\nDeprecated\nvar timeRemaining: TimeInterval\nAn estimated time, in seconds, to finish downloading the content.\nDeprecated\nvar SKDownloadTimeRemainingUnknown: TimeInterval\nIndicates that the system cannot determine how much time is needed to finish downloading the content.\nDeprecated\nenum SKDownloadState\nThe states that a download operation can be in.\nDeprecated"
  },
  {
    "title": "transaction",
    "url": "https://developer.apple.com/documentation/storekit/skdownload/1458949-transaction",
    "html": "Discussion\n\nA download object is always associated with a payment transaction. The download object may only be queued after payment is processed and before the transaction is finished.\n\nSee Also\nGetting Content Information\nvar expectedContentLength: Int64\nThe length of the downloadable content, in bytes.\nDeprecated\nvar contentIdentifier: String\nA string that uniquely identifies the downloadable content.\nDeprecated\nvar contentVersion: String\nA string that identifies which version of the content is available for download.\nDeprecated\nvar contentLength: Int64\nThe length of the downloadable content, in bytes.\nDeprecated"
  },
  {
    "title": "request(_:didFailWithError:)",
    "url": "https://developer.apple.com/documentation/storekit/skrequestdelegate/1385536-request",
    "html": "Parameters\nrequest\n\nThe request that failed.\n\nerror\n\nThe error that caused the request to fail.\n\nDiscussion\n\nWhen the request fails, your application should release the request. The requestDidFinish(_:) method is not called after this method is called."
  },
  {
    "title": "error",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransaction/1411269-error",
    "html": "Discussion\n\nThe error property is undefined except when transactionState is set to SKPaymentTransactionState.failed. Your application can read the error property to determine why the transaction failed. For a list of error constants, see SKErrorDomain in StoreKit Constants.\n\nSee Also\nGetting Transaction Information\nvar payment: SKPayment\nThe payment for the transaction.\nvar transactionIdentifier: String?\nA string that uniquely identifies a successful payment transaction.\nvar transactionDate: Date?\nThe date the transaction was added to the App Store’s payment queue.\nvar original: SKPaymentTransaction?\nThe transaction that was restored by the App Store.\nvar transactionReceipt: Data?\nA signed receipt that records all information about a successful payment transaction.\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "PaymentMethodBinding.PaymentMethodBindingError.invalidPinningID",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/invalidpinningid",
    "html": "Discussion\n\nFor more information about the identifier, see id.\n\nSee Also\nGetting error codes\ncase failed\nThe initialization or binding operation failed.\ncase notEligible\nThe user isn’t eligible."
  },
  {
    "title": "PaymentMethodBinding.PaymentMethodBindingError.notEligible",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/noteligible",
    "html": "See Also\nGetting error codes\ncase failed\nThe initialization or binding operation failed.\ncase invalidPinningID\nThe in-app binding identifier is invalid or expired."
  },
  {
    "title": "localizedDescription",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/4143412-localizeddescription",
    "html": "See Also\nGetting error descriptions\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA string that describes the reason for the failure.\nvar helpAnchor: String?\nA localized message that provides additional information if the user requests help.\nvar recoverySuggestion: String?\nA message that contains a suggestion for recovering from the error."
  },
  {
    "title": "helpAnchor",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/4143411-helpanchor",
    "html": "See Also\nGetting error descriptions\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA string that describes the reason for the failure.\nvar localizedDescription: String\nA localized message that describes the error.\nvar recoverySuggestion: String?\nA message that contains a suggestion for recovering from the error."
  },
  {
    "title": "failureReason",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/4143427-failurereason",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nGetting error descriptions\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar helpAnchor: String?\nA localized message that provides additional information if the user requests help.\nvar localizedDescription: String\nA localized message that describes the error.\nvar recoverySuggestion: String?\nA message that contains a suggestion for recovering from the error."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/4143408",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing errors\nstatic func == (PaymentMethodBinding.PaymentMethodBindingError, PaymentMethodBinding.PaymentMethodBindingError) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "paymentQueue(_:restoreCompletedTransactionsFailedWithError:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver/1506063-paymentqueue",
    "html": "Parameters\nqueue\n\nThe payment queue that was restoring transactions.\n\nerror\n\nThe error that occurred.\n\nSee Also\nRestoring transactions\nfunc paymentQueueRestoreCompletedTransactionsFinished(SKPaymentQueue)\nTells the observer that the payment queue has finished sending restored transactions."
  },
  {
    "title": "recoverySuggestion",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/4143432-recoverysuggestion",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nGetting error descriptions\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA string that describes the reason for the failure.\nvar helpAnchor: String?\nA localized message that provides additional information if the user requests help.\nvar localizedDescription: String\nA localized message that describes the error."
  },
  {
    "title": "paymentQueue(_:removedTransactions:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver/1505994-paymentqueue",
    "html": "Parameters\nqueue\n\nThe payment queue that updated the transactions.\n\ntransactions\n\nAn array of the transactions that were removed.\n\nDiscussion\n\nYour application does not typically need to implement this method but might implement it to update its own user interface to reflect that a transaction has been completed.\n\nSee Also\nHandling transactions\nfunc paymentQueue(SKPaymentQueue, updatedTransactions: [SKPaymentTransaction])\nTells an observer that one or more transactions have been updated.\n\nRequired"
  },
  {
    "title": "Implementing offer codes in your app",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/implementing_offer_codes_in_your_app",
    "html": "Overview\n\nTo help you acquire, retain, and win back subscribers, you can use offer codes.\n\nNote\n\nIf your app uses the In-App Purchase API and manages transactions using the Transaction class, see Supporting subscription offer codes in your app instead, which describes an app’s transaction processing using Transaction rather than receipts.\n\nOffer codes are alphanumeric codes that provide subscriptions at a discount or for free for a specific duration. Configure the offers and create offer codes in App Store Connect, and distribute them to your customers. Customers can redeem offer codes in the App Store, using offer code redemption URLs, or in your app if you’ve implemented one of the following APIs:\n\nofferCodeRedemption(isPresented:onCompletion:) or presentOfferCodeRedeemSheet(in:), which are available in iOS 16 and later and iPadOS 16 and later\n\npresentCodeRedemptionSheet(), which is available in iOS 14 and later and iPadOS 14 and later.\n\nWhen customers redeem a valid offer code, your app receives a successful transaction on the payment queue, and you receive a server notification if you’ve enabled App Store Server Notifications. The receipt contains an offer_code_ref_name field that identifies the offer.\n\nFor information on subscription offer types and choosing the offer type to suit your business needs, see Providing subscription offers.\n\nSet up offer codes in App Store Connect\n\nConfigure offers and manage your offer codes in App Store Connect. You can have up to 10 active offers per subscription, and create codes for a maximum of 1,000,000 redemptions per app, per quarter. There are two types of offer codes: one-time use codes, and custom codes. The offer code redemption APIs support both.\n\nDownload the offer codes from App Store Connect to distribute them to your customers. For more information on creating and distributing offer codes, and to learn which type of offer code may work for your campaign, see Set up offer codes.\n\nRedeem offer codes in your app\n\nTo display the system sheet for customers to redeem offer codes within your app, call one of the redemption APIs, depending on your app’s UI implementation:\n\nCall offerCodeRedemption(isPresented:onCompletion:) if your app uses SwiftUI.\n\nCall presentOfferCodeRedeemSheet(in:) if your app uses UIKit.\n\nCall presentCodeRedemptionSheet() for apps running on devices prior to iOS 16 and iPadOS 16.\n\nThe redemption sheet takes care of the redemption flow, including alerting users about invalid entries, as appropriate. Invalid entries may include, for example, expired offer codes, invalid codes, or codes that would result in a subscription downgrade.\n\nIncluding the redemption sheet in your app is recommended, but optional. For more guidance on supporting offer code redemption within your app, see Human Interface Guidelines > In-app purchase.\n\nSupport offer codes redeemed outside your app\n\nCustomers may redeem subscription offer codes outside your app. If a customer doesn’t have your app, the App Store prompts them to download it as part of the redemption flow.\n\nTo handle offer codes — and other transactions that can occur outside of your app – you need to set up a transaction observer at app launch. For more information on this best practice, see Setting up the transaction observer for the payment queue. Check that your app’s user-onboarding experience verifies the receipt and provides subscription service. Update your records if you keep a backend system to manage your subscribers.\n\nIdentify subscriptions purchased with offer codes, in receipts\n\nWhen a customer successfully redeems a subscription offer code, the receipt contains a transaction with the field: offer_code_ref_name. This field’s value is the offer reference name that you configured in App Store Connect. The field appears in the responseBody.Latest_receipt_info and responseBody.Pending_renewal_info objects for receipts, and in the unified_receipt.Latest_receipt_info and unified_receipt.Pending_renewal_info objects for server notifications.\n\nProvide subscription service to existing and new customers\n\nWhen an existing customer redeems an offer code, your app receives a transaction on the payment queue (paymentQueue(_:updatedTransactions:) in the SKPaymentTransactionState.purchased state. This flow is the same as a typical subscription purchase flow, but the receipt contains the offer code reference. Your app follows these steps:\n\nValidates the receipt. For more information, see Validating receipts with the App Store.\n\nLooks for the offer_code_ref_name field in the receipt to determine if the subscription is from an offer code.\n\nProvides the subscription service based on the offer.\n\nCalls finishTransaction(_:).\n\nWhen you acquire new customers with an offer code, they open your app for the first time already having a subscription. In addition to providing subscription service, you may need to update your backend system’s records. Your app follows these steps:\n\nWhen the app first launches, validate the receipt.\n\nIn the receipt, look for a transaction with the offer_code_ref_name field to determine if the subscription is from an offer code.\n\nProvide the subscription service based on the offer.\n\nGuide the customer through your new-user experience as needed. Update your backend system’s records.\n\nCall finishTransaction(_:)."
  },
  {
    "title": "Determining service entitlement on the server",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/determining_service_entitlement_on_the_server",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC22 session 110404: Implement proactive in-app purchase restore.\n\nIt’s also associated with WWDC 2020 session 10671: Architecting for Subscriptions.\n\nWhen your app provides a subscription service, you receive data in the form of in-app receipts and App Store server notifications that provide a subscription’s state. After reading this data, your app determines whether to allow or restrict the user’s access to service, products, offers, and messages.\n\nThis server-side sample code project analyzes a receipt to help the app determine entitlement by systematically examining all potential subscription states that affect service entitlement, such as offers periods and billing states. The output from this sample’s REST API endpoints is a response that indicates whether the app can enable service or needs to perform other steps to retain or communicate with customers. You can extend this code and customize the response based on your own business logic. The sample code contains two endpoints:\n\nURL: localhost:3000/simulate — Use /simulate for testing using real or artificial receipts. This endpoint requires no special configuration.\n\nURL: localhost:3000/entitle — Use /entitle with real Base64-encoded receipts. This endpoint requires additional configuration.\n\nConfigure the sample code project\n\nFollow these steps to run the sample code project:\n\nInstall the latest stable version of Node.js.\n\nOpen the Terminal app (/Applications/Utilities).\n\nNavigate to the sample code /Sample directory.\n\nIn Terminal, enter npm install and press Return. Make sure it completes successfully.\n\nIn Terminal, copy the example environment file: cp env.example.\n\nIn Terminal, enter npm start and press Return to start the server. The server runs in your Terminal window. To stop the server, press Control-C while in Terminal.\n\nIn Terminal, choose Shell > New Windows > New Window with Profile to open a second Teminal window to use to send the requests.\n\nSend a request using sample receipt data\n\nThe requests to the service entitlement engine take JSON data from a receipt. The data must be in the same JSON format that you receive by calling the /verifyReceipt endpoint when you pass it a valid receipt. The example file flatJSONExample in the Source/Example directory contains sample receipt data in the correct format for the requests.\n\nTo run the request, switch to the second Terminal window and type the following curl command. Replace the <FLAT JSON DATA> with the flatJSONExample.\n\n    curl -XPOST -H \"Content-type: application/json\" -d '<FLAT JSON DATA>' 'localhost:3000/simulate'\n\n\nIf the mocked JSON receipt data is in the correct format, the response contains the analyzed data the entitlement engine produces based on the receipt data.\n\nIf you have real receipt data, replace the <FLAT JSON DATA> in the command with your receipt data.\n\nReceive the sample response\n\nThe response contains the result of the engine’s analysis of the receipt data. Use it to determine whether a customer has the necessary entitlements to service, offers, or other messaging. The response object contains an array of subscription objects organized by product ID, each containing fields that provide insights for that subscription.\n\nThe following example response shows a customer who was previously subscribed and then resubscribed. The customer is in state 5, which indicates an active subscription with autorenew still in an enabled state.\n\n{\n    \"products\": [\n        {\n            \"product_id\": \"com.example.monthly\",\n            \"entitlementCode\": 5,\n            \"expiration\": 1599391591000,\n            \"totalRenewals\": 7,\n            \"groupID\": \"13472270\",\n            \"originalTransactions\": [\n                {\n                    \"originalTX\": \"190000625698817\",\n                    \"start\": 1564455960000,\n                    \"expiration\": 1599391591000,\n                    \"renewals\": 7\n                }\n            ],\n            \"trialConsumed\": true\n        }\n    ],\n    \"trialConsumedForGroup\": [\n        \"13472270\"\n    ]\n}\n\n\nIn this case, the sample app issues an offer for a yearly subscription to the customer because they’re in state 5, and they have a history of seven total renewals."
  },
  {
    "title": "connect",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupmessageidentifier/2909048-connect",
    "html": "See Also\nMessage Identifiers\nstatic let addMusic: SKCloudServiceSetupMessageIdentifier\nMessage identifier for adding music.\nstatic let join: SKCloudServiceSetupMessageIdentifier\nMessage identifier for joining.\nstatic let playMusic: SKCloudServiceSetupMessageIdentifier\nMessage identifier for playing music."
  },
  {
    "title": "SKPaymentDiscount",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentdiscount",
    "html": "Overview\n\nThe SKPaymentDiscount contains the details of a promotional offer discount that you want to apply to a SKMutablePayment.\n\nInclude the signature that you generated in this object. For guidance, see Generating a signature for promotional offers. The App Store uses this signature and the parameters to validate the promotional offer. Keep in mind that the signature must correspond to the parameters in the payment for a transaction to be successful.\n\nTopics\nInitializing a Payment Discount\ninit(identifier: String, keyIdentifier: String, nonce: UUID, signature: String, timestamp: NSNumber)\nInitializes the payment discount with a signature and the parameters used by the signature.\nIdentifying the Discount\nvar identifier: String\nA string used to uniquely identify a discount offer for a product.\nvar keyIdentifier: String\nA string that identifies the key used to generate the signature.\nValidating the Discount\nvar nonce: UUID\nA universally unique ID (UUID) value that you define.\nvar signature: String\nA string representing the properties of a specific promotional offer, cryptographically signed.\nvar timestamp: NSNumber\nThe date and time of the signature's creation in milliseconds, formatted in Unix epoch time.\nRelationships\nInherits From\nNSObject\nConforms To\nSendable\nSee Also\nGetting Discount Details\nvar paymentDiscount: SKPaymentDiscount?\nThe details of the discount offer to apply to the payment."
  },
  {
    "title": "applicationUsername",
    "url": "https://developer.apple.com/documentation/storekit/skmutablepayment/1506088-applicationusername",
    "html": "Discussion\n\nConsider assigning a UUID to the applicationUsername property. When this value is a UUID, the App Store server stores it as an appAccountToken. In this scenario, the following happens:\n\nIn the App Store Server API, the JWSTransactionDecodedPayload object returns the applicationUsername value in the appAccountToken field.\n\nIn App Store Server Notifications, the JWSTransactionDecodedPayload object returns the applicationUsername value in the appAccountToken field.\n\nWhen you call the verifyReceipt endpoint to verify an App Store receipt, the App Store server returns the applicationUsername value in the app_account_token field of the responseBody.Latest_receipt_info.\n\nThe sample code below shows how to assign a UUID value to applicationUsername. You may choose to generate the UUID on your server. Assign the value before adding the payment to the payment queue.\n\nlet payment = SKMutablePayment(product: product)\npayment.applicationUsername = uuidString\n\n\nSKPaymentQueue.default().add(payment)\n\n\nIf you don’t assign a UUID string value to applicationUsername, the App Store server doesn’t persist the value. The value won’t appear in the app_account_token fields in notifications or receipts.\n\nImportant\n\nAn applicationUsername property that isn’t a UUID isn’t guaranteed to persist between the time when you add the payment transaction to the queue and when the queue updates the transaction.\n\nSee Also\nGetting and Setting Attributes\nvar productIdentifier: String\nA string that identifies a product that can be purchased from within your app.\nvar quantity: Int\nThe number of items the user wants to purchase.\nvar requestData: Data?\nReserved for future use."
  },
  {
    "title": "Generating a signature for promotional offers",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/generating_a_signature_for_promotional_offers",
    "html": "Overview\n\nBefore you can create a signature on your server, you need to complete the one-time setup to generate a private key in App Store Connect, as Setting up promotional offers describes. Always use a secure connection when sending data, including the signature, between your app and server. For more information on ensuring your data’s security, see Preventing Insecure Network Connections.\n\nTo create the signature, you use parameters that identify the product and the offer, parameters your server generates, and your private key. To generate the signature, you combine the required parameters, then sign and encode the resulting string.\n\nCombine the parameters\n\nIn the first step of generating the signature, you need the following parameters, most of which you also supply for SKPaymentDiscount:\n\nappBundleID\n\nThe app bundle identifier.\n\nkeyIdentifier\n\nA string that identifies the private key you use to generate the signature. You can find this identifier in App Store Connect Users and Access > Keys in the Key ID column for the subscription key you generate.\n\nproductIdentifier\n\nThe subscription product identifier, productIdentifier. The app can provide this value.\n\nofferIdentifier\n\nThe subscription discount identifier, identifier. The app can provide this value.\n\napplicationUsername or appAccountToken\n\nAn optional string value that you define; may be an empty string. If your app uses applicationUsername, provide applicationUsername. If your app uses appAccountToken, provide appAccountToken. The string representation of the appAccountToken must be lowercase.\n\nnonce\n\nA one-time UUID value that your server generates. Generate a new nonce for every signature. The string representation of the nonce you use in the signature must be lowercase.\n\ntimestamp\n\nA timestamp your server generates in UNIX time format, in milliseconds. The timestamp keeps the offer active for 24 hours.\n\nImportant\n\nUse lowercase for the string representation of the nonce and the appAccountToken.\n\nCombine the parameters into a UTF-8 string with an invisible separator ('\\u2063') between them in the same order as the following example:\n\nappBundleId + '\\u2063' + keyIdentifier + '\\u2063' + productIdentifier + '\\u2063' + offerIdentifier + '\\u2063' + appAccountToken + '\\u2063' + nonce + '\\u2063' + timestamp\n\n\nIf you provide applicationUsername instead of appAccountToken, replace it accordingly in the UTF-8 string above.\n\nSign the combined string\n\nSign the combined UTF-8 string with the following key and algorithm:\n\nYour PKCS #8 private key (downloaded from App Store Connect) that corresponds to the keyIdentifier in the UTF-8 string\n\nThe Elliptic Curve Digital Signature Algorithm (ECDSA) with a SHA-256 hash\n\nThe result is a Digital Encoding Rules (DER)-formatted binary value, which is the signature.\n\nValidate locally and encode the signature\n\nConsider validating your signatures locally to ensure your signing process works correctly. You can create a public key derivative of your private key to test against. One way to create this key is by running the openSSL command from the terminal app, as the example below shows:\n\nopenssl ec -in {downloaded_private_key} -pubout -out public_key.pem\n\n\nUse Base64 encoding for the binary signature you generated to obtain the final signature string to send to the App Store for validation. The signature string resembles the following:\n\nMEQCIEQlmZRNfYzKBSE8QnhLTIHZZZWCFgZpRqRxHss65KoFAiAJgJKjdrWdkLUOCCjuEx2RmFS7daRzSVZRVZ8RyMyUXg==\n\n\nRespond to the request\n\nRespond to the app’s request for the signature over a secure connection, providing the encoded signature string, the nonce, the timestamp, and the keyIdentifier. Note that each payload, signature, and nonce is only valid for one buy request, even if the buy fails.\n\nSee Create a Signature for information about the app’s request and how it uses the signature.\n\nSee Also\nPromotional offers\nSetting up promotional offers\nGenerate a key and configure offers for auto-renewable subscriptions in App Store Connect.\nImplementing promotional offers in your app\nOffer discounted pricing for auto-renewable subscription products to eligible subscribers.\nGenerating a Promotional Offer Signature on the Server\nGenerate a signature using your private key and lightweight cryptography libraries.\nclass SKPaymentDiscount\nThe signed discount to apply to a payment."
  },
  {
    "title": "Reducing Involuntary Subscriber Churn",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/reducing_involuntary_subscriber_churn",
    "html": "Overview\n\nAfter acquiring new customers for your subscription service, you can minimize subscriber loss, known as churn, by keeping them engaged as active subscribers. However, irregular billing events can occur throughout the lifecycle of a subscription that can impact your customer's subscription status.\n\nInvoluntary churn occurs when users do not intend to leave your service but their subscription fails to renew, usually due to billing issues. Because involuntary churn is not related to customer satisfaction, consider creating a user experience that avoids subscriber loss due to a failed renewal. For business guidance on retaining subscribers, see Keeping Subscribers.\n\nBilling-related issues trigger a subscription to automatically enter a billing retry state, where the App Store attempts to recover the subscription. While the App Store tries to recover these customers, you have the option to prompt users to update their billing information or implement a grace period, or both, to assist in recovery efforts. Enabling a grace period and providing uninterrupted service provides a great customer experience, and avoids interrupting your days of paid service and revenue loss if Apple is able to recover the subscription within the grace period. For information on auto-renewable subscription proceeds and days of paid service, see Net Revenue After a Year.\n\nReact to Billing Issues\n\nIf the customer's billing is invalid, the renewal fails and the user's subscription enters a billing retry state, where the App Store attempts to collect payment for up to 60 days. This billing retry lowers the rate of involuntary churn and prevents the need to re-acquire subscribers if they churned. If the user is recovered within the 60 days, the new billing date is established on the date of recovery and subsequent renewal dates are based on this new billing date, as shown in the figure below.\n\nFigure 1 An example timeline for a monthly subscription that enters a billing retry state\n\nFor example, if the user’s payment information is no longer valid, the first renewal attempt fails. If you have server-to-server notifications enabled, you receive a server notification of type DID_FAIL_TO_RENEW. You can check the expiration_intent and is_in_billing_retry_period values in the verifyReceipt response or unified_receipt object in the server notification to validate the reason for the subscription to lapse and monitor the retry status of the subscription. If the user is recovered during this period, you receive a server notification of types RENEWAL and DID_RECOVER when the retry is successful. For more information on server-to-server notifications, see App Store Server Notifications.\n\nImportant\n\nThe RENEWAL notification type is scheduled for deprecation. Update any existing code to rely on the identical DID_RECOVER notification type instead.\n\nYour app may optionally present in-app messaging that informs users they can avoid losing access to paid service by taking action and resolving their billing error. If you choose to prompt the user, ensure your app's subscription logic can handle different values of expiration_intent along with expires_date_ms, to show the appropriate message. An invalid payment method could be due to a number of things, such as a low balance on a stored value card or an expired credit card. Your app should be ready to react immediately to a billing information update. Your app can deep link customers to the Manage Payments page on their account settings by opening this URL:\n\nhttps://apps.apple.com/account/billing\n\n\nNote\n\nThis URL is only supported for iOS and macOS.\n\nFor more general guidance on handling subscriptions that enter a billing retry state, see WWDC 2018 > Engineering Subscriptions. You can also agree to provide a grace period for subscribers in a billing retry state. Billing error recoveries made within the set grace period automatically recover subscribers onto their current billing cycle, also providing revenue continuity.\n\nEnable Billing Grace Period\n\nTo avoid interrupting days of paid service, you can enable Billing Grace Period in App Store Connect, which allows subscribers to retain full access to your app’s paid content while Apple attempts to collect payment. For guidance on opting in to enable Billing Grace Period for your app, see Enable Billing Grace Period for Auto-Renewable Subscriptions.\n\nBilling Grace Period is applied at the time of a billing error when it's enabled for subscriptions in the app, and cannot be altered once assigned to a user. Grace period durations are dependent on the subscription period length as follows:\n\n6 days for a weekly subscription\n\n16 days for monthly and longer subscriptions\n\nIf you choose to enable Billing Grace Period, ensure that you provide full service for the subscription throughout the grace period. You can check the grace_period_expires_date_ms field in the responseBody.Pending_renewal_info array of the verifyReceipt response or unified_receipt object in the server notification to determine the end of this grace period duration. For more information on reducing involuntary churn using a grace period, see WWDC 2019 > In-App Purchases and Using Server-to-Server Notifications.\n\nIf the user is recovered within this grace period, neither the subscriber's days of paid service, nor your revenue for auto-renewable subscriptions will be interrupted. Billing error recoveries made after the grace period expires, but within the overall billing retry period, will maintain existing behavior and renew on the recovery date, starting a new billing cycle. Payment for the provided full service during the grace period would not be collected.\n\nFigure 2 Example timelines for a monthly subscription that enters a billing retry state, in an app with Billing Grace Period enabled\n\nWhen implementing Billing Grace Period, use the verifyReceipt JSON response and server-to-server notifications. Consider using expiration_intent, is_in_billing_retry_period, and grace_period_expires_date_ms of the unified_receipt object in the server notifications of type RENEWAL and DID_RECOVER to identify whether the subscription is in a grace period.\n\nThe expiration_intent value can tell you if a subscription renewal failed due to a billing error, or simply because the user chose to cancel service. You can also see if the App Store is actively trying to recover a subscription by looking for an active is_in_billing_retry_period flag.\n\nConsider all scenarios for subscription recovery:\n\nIf the subscription renews before the time specified in grace_period_expires_date_ms, the grace_period_expires_date fields are removed along with the is_in_billing_retry_period indicator. You can look up a past transaction’s purchase_date_ms and expires_date_ms values to determine if a user’s subscription renewed after a lapse.\n\nIf the subscription renews after the time specified in grace_period_expires_date_ms while still in the billing retry state, the grace_period_expires_date fields are removed along with the is_in_billing_retry_period indicator. You can use the expires_date_ms value for a past transaction to determine the lapse period.\n\nIf attempts to renew the subscription fail, the grace_period_expires_date fields persist along with a value of 0 for the auto_renew_status and is_in_billing_retry_period indicators.\n\nRestore Service\n\nWhen users update their payment information, the App Store immediately attempts to renew the payment. Once the App Store successfully bills the customer in a billing retry state, the App Store notifies your server with notifications of types RENEWAL and DID_RECOVER, and a new receipt is generated for the successful transaction. A new value appears in the expires_date_ms field in the app transaction receipt, based on the date of recovery, to mark the next renewal date of the subscription.\n\nStoreKit adds a new transaction for the renewal to the transaction queue on the device. Your app can check the transaction queue on launch and handle the renewal the same way as any other transaction. If your app is already running when the subscription renews, the transaction observer is not called; your app finds out about the renewal the next time the app launches. Restore service once the subscription is renewed if needed.\n\nSee Also\nEssentials\nHandling Subscriptions Billing\nBuild logic around the date and time constraints of subscription products, while planning for all scenarios where you control access to content.\nEnabling App Store Server Notifications\nConfigure your server and provide an HTTPS URL to receive notifications about in-app purchase events and unreported external purchase tokens.\nOffering a Subscription Across Multiple Apps\nSupport a single auto-renewable subscription across multiple apps."
  },
  {
    "title": "Setting up promotional offers",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/setting_up_promotional_offers",
    "html": "Overview\n\nYou can offer a discounted or free period of service for auto-renewable subscription products on macOS, iOS, and tvOS using promotional offers. Limited-time, discounted promotional offers can be effective in winning back lapsed subscribers or retaining current subscribers.\n\nBefore you can provide promotional offers in your app, you must first generate a subscription key and set up the offers in your App Store Connect account.\n\nNote\n\nIf your goal is to attract new users, use introductory offers and promote the in-app purchase on the App Store. Redeeming an introductory offer doesn’t affect a user’s eligibility for a promotional offer. For more information, see Implementing introductory offers in your app.\n\nGenerate a Private Key\n\nYou generate a private key in App Store Connect that you use on your server to sign promotional offers. This key allows Apple to authenticate and validate subscription requests.\n\nKeys don’t expire, and you can use them with any apps in your account. To get started, generate a subscriptions access key in App Store Connect.\n\nDownload and Store the Private Key\n\nOnce you’ve generated your subscription key, you’re given the opportunity to download the private half of the key. You can only download this key one time.\n\nThe keys are provided in base64-encoded PEM format. Apple doesn’t keep a copy of the private key.\n\nImportant\n\nStore your private subscription key in a safe place. You should never share your keys, store keys in a code repository, or include keys in apps or client-side code.\n\nIf the key becomes lost or compromised, revoke it immediately and update your promotional offers. See Revoke a subscription key for more information.\n\nConfigure Promotional Offers\n\nYou configure promotional offers in App Store Connect, providing details such as a reference name, payment mode, duration, and price. To configure your offer, see Set up promotional offers for auto-renewable subscriptions. You can have up to 10 promotional offers active at any given time per subscription.\n\nFor business guidance on using promotional offers, see Auto-renewable Subscriptions > Providing Subscription Offers.\n\nSee Also\nPromotional offers\nImplementing promotional offers in your app\nOffer discounted pricing for auto-renewable subscription products to eligible subscribers.\nGenerating a signature for promotional offers\nCreate a signature to validate a promotional offer using your private key.\nGenerating a Promotional Offer Signature on the Server\nGenerate a signature using your private key and lightweight cryptography libraries.\nclass SKPaymentDiscount\nThe signed discount to apply to a payment."
  },
  {
    "title": "Offering a Subscription Across Multiple Apps",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/offering_a_subscription_across_multiple_apps",
    "html": "Overview\n\nYou can offer customers auto-renewable subscription services that are accessible through multiple apps across one or more operating systems.\n\nTo offer this functionality, your server must grant access to the subscription content across all apps, despite the user having purchased the subscription within a specific app. You can use a unified account management database along with server-side receipt validation to validate a user’s purchase and handle in-app transactions. By entitling subscription access from your server, you can provide users the ability to access your subscription across multiple apps.\n\nCreate the Subscription for Each App\n\nTo get started, use App Store Connect to create a separate and equivalent auto-renewable subscription for each app that offers the multi-app subscription so that users can subscribe from any app. For design guidance, see Human Interface Guidelines > In-App Purchase.\n\nTip\n\nUse an app bundle to group apps that share auto-renewable subscriptions on the same platform in a single App Store product page. An app bundle enables customers to view and download apps in a single purchase.\n\nThe following image illustrates the steps for implementing a multi-app subscription:\n\nAuthenticate the User\n\nWhen providing auto-renewable subscription access across multiple apps, you must authenticate the user in a way that correlates across apps. Authenticating users using a login allows you to determine if the user has access to the content. To provide a consistent user experience, ensure that the login process is similar across your apps.\n\nTo provide an easy and secure login, take advantage of Sign in with Apple. Sign in with Apple allows you to identify a user across your apps, while maintaining user privacy and protecting your app against fraud. You can store and retrieve user account data across your apps and the user’s devices, and use that data to unlock access appropriately.\n\nCheck Billing Status\n\nAfter authenticating the user, determine whether to grant access to the content based on their transaction history in the receipt.\n\nCheck if the user has purchased any subscription products before showing a subscription offer in the app. If there’s a subscription purchase from any app, verify if the subscription is active by looking at the subscription expiration date in the receipt.\n\nPresent users who don’t have an active subscription with the subscription for purchase. Consider all potential billing scenarios within your account database when determining eligibility and granting access to a user.\n\nImportant\n\nIf the user has purchased the subscription from an app, you must propagate the purchase across all the apps that provide the subscription service. Failing to persist the purchase to the other apps opens the possibility of a user paying multiple times for the same service.\n\nValidate Subscription Status\n\nA user’s subscription status can change any time. Validate the receipt and check the latest subscription expiration date to maintain the billing status for each user and reflect any changes.\n\nEnabling App Store Server Notifications keeps your server aware of changes made to a customer’s subscription status. Update your records to keep users' subscription status and content current. The billing status must be accurate in your account database to provide the expected user experience across all apps.\n\nEnable Access to Purchased Content\n\nAfter determining that the user should have access, you can enable access in each app based on the subscription expiration date. The user can access the subscription within any app that offers the same service. Repeat the previous steps as necessary across each app or user’s session to unlock the subscription.\n\nSee Also\nEssentials\nHandling Subscriptions Billing\nBuild logic around the date and time constraints of subscription products, while planning for all scenarios where you control access to content.\nEnabling App Store Server Notifications\nConfigure your server and provide an HTTPS URL to receive notifications about in-app purchase events and unreported external purchase tokens.\nReducing Involuntary Subscriber Churn\nPrevent unintentional loss of subscribers due to billing issues."
  },
  {
    "title": "Handling Subscriptions Billing",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/handling_subscriptions_billing",
    "html": "Overview\n\nApps that offer subscriptions have some unique behaviors and considerations. Because subscriptions involve an element of time, your app must be able to determine whether the subscription is currently active and determine the subscription states for past dates. Your app must also react to new, renewed, and lapsed subscriptions, and properly handle expired auto-renewable subscriptions that may be in a billing retry state.\n\nTo validate changes in and identify the status of a subscription, you can use the different values in the receipt, which provides details on app and in-app purchases. For information about server-side receipt validation, see Validating receipts with the App Store.\n\nNote\n\nEach subscription has a unique product identifier associated with a single app. Apps with an iOS and a macOS version have separate products, with a unique product identifier on each platform. You could let users who have a subscription in an iOS app access the content from a macOS app, or vice versa, but implementing that functionality is your responsibility. In order to support cross-platform subscription products, you would need a system to identify users and keep track of the content to which they subscribe. For more information, see Offering a Subscription Across Multiple Apps.\n\nThere are two types of subscriptions you can offer in your app: non-renewing and auto-renewable. Non-renewing subscriptions differ from auto-renewable subscriptions in a few key ways. These differences give your app the flexibility to implement the correct behavior for a non-renewing subscription, as follows:\n\nYour app is responsible for calculating the time period that the subscription is active and determining what content needs to be made available to the user.\n\nYour app is responsible for detecting that a non-renewing subscription is approaching its expiration date and prompting the user to renew the subscription by purchasing the same product again.\n\nYour app is responsible for making purchased subscriptions available across all the user’s devices and for letting users restore past purchases. For example, most subscriptions are provided by a server; your server would need some mechanism to identify users and associate subscription purchases with the user who purchased them.\n\nThe following sections provide guidance for handling auto-renewable subscriptions. To quickly react to changes in users' auto-renewable subscriptions, you can choose to receive status update notifications on your server. Status update notifications inform you of real-time changes in a user's subscription status and are only supported for auto-renewable subscriptions. For more information on setting up and handling server notifications, see Enabling App Store Server Notifications.\n\nCalculate a Subscription's Promotional Offer Status\n\nYou can set up promotional offers in App Store Connect to provide users with free or discounted service for a subscription. All new and eligible subscribers can redeem an introductory offer, and all lapsed and existing subscribers can redeem a subscription offer. There are multiple types of introductory and subscription offers, each with different billing cycles. Customers who redeem a free trial introductory offer or a downgrade subscription offer will not be billed for the subscription until the end of the free trial period. For more information, see Implementing introductory offers in your app and Implementing promotional offers in your app.\n\nCheck the is_in_intro_offer_period or is_trial_period field from each receipt entry to validate whether the user redeemed an introductory offer at the beginning of their subscription. You can use this information to accurately present subscription products from the same subscription group at the end of the introductory offer period for that user. Check the promotional_offer_id field from each receipt entry to validate whether the user redeemed a subscription offer. You can use this information to determine eligibility for this user to redeem subscription offers in the future.\n\nCalculate a Subscription’s Active Period\n\nYour app needs to determine which content the user has access to based on the period of time their auto-renewable subscription is active. To provide the customer access to the content to which they are entitled, keep a record of the date that each piece of content is published. Read the original_purchase_date, purchase_date, and expires_date field from each receipt entry to determine the start and end dates of each subscription period. The user has access to all content published between each subscription start and end date in addition to the content that was initially unlocked when the subscription was purchased.\n\nFor example, because purchasing a subscription always unlocks content, a user who purchases a monthly subscription mid-month to a magazine that publishes a new issue on the first day of every month gets access to two issues in their first month of subscribing: the most recently published issue, which is unlocked at the time that the subscription is purchased, and the issue you publish on the subsequent first day of the month, which is unlocked at the time you publish it.\n\nImportant\n\nDon’t calculate the subscription period by adding a subscription duration to the purchase date. That approach fails to take into account the free trial period, the marketing opt-in period, and the content made available immediately after the user purchased the subscription.\n\nIf the subscription lapsed, there will be multiple periods of time during which the subscription was active, and there will be pieces of content unlocked at the beginning of a subscription period. To identify lapses in a subscription, compare the expires_date field from each receipt entry to the purchase_date field of the previous receipt entry for all entries in the receipt.\n\nDetect an Expiration or Renewal\n\nThe subscription renewal process begins in the 10 days before the expiration date. During those 10 days, the App Store checks for any billing issues that might delay or prevent the subscription from being automatically renewed, for example, whether:\n\nThe customer’s payment method is active.\n\nThe product increased in price since the user bought the subscription.\n\nThe product is no longer available.\n\nThe App Store notifies users of any issue so that they can resolve it before the subscription expires and avoid an interruption in their service.\n\nDuring the 24-hour period before the subscription expires, the App Store starts trying to renew it automatically. The App Store makes several attempts to automatically renew the subscription over a period of time but eventually stops if there are too many failed attempts.\n\nHandle Lapsed Subscriptions\n\nThe App Store renews the subscription slightly before it expires, to prevent any lapse in the subscription. However, lapses are still possible. For example, if the user’s payment information is no longer valid, the first renewal attempt fails. Billing-related issues trigger the subscription to enter a billing retry state where the App Store attempts to renew the subscription for up to 60 days. You can check the expiration_intent and is_in_billing_retry_period values to monitor the retry status of the subscription. During this period, your app may optionally offer a grace period to the user and show them a message in the app to update their payment information. Additionally, your app can deep link customers to the payment details page within App Store on their device by opening this URL\n\nhttps://apps.apple.com/account/billing\n\n\nThe user can also cancel their subscription by disabling auto-renew and intentionally letting their subscription lapse. This action triggers the App Store to send your server a status update notification of type DID_CHANGE_RENEWAL_STATUS. Your server can parse the auto_renew_status and the auto_renew_status_change_date to determine the current renewal status of the subscription.\n\nYou can also check the expiration_intent field in the receipt to further validate the reason for the subscription to lapse. Make sure your app’s subscription logic can handle different values of expiration_intent along with expires_date to show the appropriate message to the user.\n\nDetect a Refund\n\nUsers pay for a subscription when they purchase it, and they can receive a refund by contacting Apple customer service. For example, if the user accidentally buys the wrong product and requests a refund, customer support can cancel the subscription and issue a full or partial refund. Customers may cancel a subscription in the middle of a subscription period, but the subscription remains paid through the end of the same period. Additionally, users may also receive a refund when they upgrade their subscription to another subscription product at a higher level in the same subscription group.\n\nTo identify whether a subscription has been refunded, look for the cancellation_date field in the receipt. The App Store notifies your server of refunds with a status update notification of type CANCEL, at which point you can handle the refund. For example, if the user upgraded the subscription, immediately unlock service for the higher level subscription product purchased.\n\nIdentify a Renewed Subscription After a Lapse\n\nA user-initiated payment information update for an auto-renewable subscription in the billing retry period triggers an automatic renewal attempt to succeed. For this event, the App Store notifies your server with a notification of type RENEWAL and a new receipt will be generated for the successful transaction. You can look for a new value of the expires_date field to know the next renewal date of the subscription.\n\nStoreKit adds a new transaction for the renewal to the transaction queue on the device. Your app can check the transaction queue on launch and handle the renewal the same way as any other transaction. If your app is already running when the subscription renews, the transaction observer is not called; your app finds out about the renewal the next time the app launches.\n\nDetect Upgrades or Plan Changes\n\nUsers can manage their auto-renewable subscriptions in their App Store settings on-device or within your app’s interface. For each subscription purchased by the user, the App Store shows all the renewal options that the subscription group offers. Users can easily change their service levels and choose to upgrade, downgrade, or cross-grade as often as they like. Upgrades of any duration or cross-grades with same durations go into effect immediately. Downgrades of any duration or cross-grades with different durations go into effect at the next renewal date.\n\nYou can check the receipt’s auto_renew_product_id field to learn about any plan changes the user selected that will go into effect at the next renewal date. Additionally, you can also use the notification of type DID_CHANGE_RENEWAL_PREF to get notified for any user initiated plan changes that will go into effect at the next renewal date.\n\nManage Subscription Price Consent\n\nWhen you increase the price of a subscription, the App Store informs the affected subscribers with an email, push notification, and in-app price consent sheet, and asks your subscribers to agree to the new price. In the app, the system asks your delegate’s function paymentQueueShouldShowPriceConsent(_:) whether to immediately display the price consent sheet, or to delay displaying the sheet until later. For example, you may want to delay showing the sheet if it would interrupt a multistep user interaction, such as setting up a user account. Return false in paymentQueueShouldShowPriceConsent(_:) to prevent the dialog from displaying immediately.\n\nTo show the price consent sheet after a delay, call showPriceConsentIfNeeded(), which shows the sheet only if the user hasn’t responded to the price increase notifications.\n\nIf users don’t agree to the subscription price increase or take no action, their subscription expires at the end of their current billing cycle. App Store attempts to notify users in the app twice. For a notification schedule, see Increase the price of an auto-renewable subscription.\n\nNote\n\nThe price consent sheet appears only on devices running iOS. All affected subscribers receive an email and push notification.\n\nEnable Users to Manage Subscriptions\n\nConsider building auto-renewable subscription management UI in the app for subscribers to easily move between different subscription levels in their subscription group. Use the subscriptionGroupIdentifier property of SKProduct to determine which products to display in the UI. For users who wish to cancel their subscription, your app can open the following URL:\n\nhttps://apps.apple.com/account/subscriptions\n\n\nOpening this URL launches iTunes or iTunes Store and displays the Manage Subscriptions page where the user can upgrade, downgrade, or cancel their subscription by disabling auto-renew. If you configure your backend server to receive status update notifications, your server receives a DID_CHANGE_RENEWAL_STATUS notification if the user cancels their subscription.\n\nSee Also\nEssentials\nEnabling App Store Server Notifications\nConfigure your server and provide an HTTPS URL to receive notifications about in-app purchase events and unreported external purchase tokens.\nOffering a Subscription Across Multiple Apps\nSupport a single auto-renewable subscription across multiple apps.\nReducing Involuntary Subscriber Churn\nPrevent unintentional loss of subscribers due to billing issues."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/producttype/3749417",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and Hashing Product Types\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/producttype/3749421-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nSee Also\nComparing and Hashing Product Types\nstatic func != (Product.ProductType, Product.ProductType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "init(receiptProperties:)",
    "url": "https://developer.apple.com/documentation/storekit/skreceiptrefreshrequest/1506038-init",
    "html": "Parameters\nproperties\n\nIn the test environment, the properties that the new receipt is to have. For keys, see Receipt Properties and Keys.\n\nIn the production environment, set this parameter to nil.\n\nReturn Value\n\nThe initialized request.\n\nDiscussion\n\nIn the sandbox environment, you can initialize a receipt with any combination of properties to test the state transitions related to Volume Purchase Plan receipts. Set the properties when you call this initializer."
  },
  {
    "title": "Product.ProductType.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/producttype/rawvalue",
    "html": "See Also\nCreating a Product Type\ninit(rawValue: String)\nlet rawValue: String\nThe value for product type as a backing value."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/producttype/3749426-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating a Product Type\ninit(rawValue: String)\ntypealias Product.ProductType.RawValue"
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/product/producttype/3749423-init",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating a Product Type\nlet rawValue: String\nThe value for product type as a backing value.\ntypealias Product.ProductType.RawValue"
  },
  {
    "title": "autoRenewable",
    "url": "https://developer.apple.com/documentation/storekit/product/producttype/3749419-autorenewable",
    "html": "See Also\nGetting the Product Type\nstatic let consumable: Product.ProductType\nA consumable in-app purchase.\nstatic let nonConsumable: Product.ProductType\nA non-consumable in-app purchase.\nstatic let nonRenewable: Product.ProductType\nA non-renewing subscription."
  },
  {
    "title": "nonRenewable",
    "url": "https://developer.apple.com/documentation/storekit/product/producttype/3749425-nonrenewable",
    "html": "See Also\nGetting the Product Type\nstatic let consumable: Product.ProductType\nA consumable in-app purchase.\nstatic let nonConsumable: Product.ProductType\nA non-consumable in-app purchase.\nstatic let autoRenewable: Product.ProductType\nAn auto-renewable subscription."
  },
  {
    "title": "nonConsumable",
    "url": "https://developer.apple.com/documentation/storekit/product/producttype/3749424-nonconsumable",
    "html": "See Also\nGetting the Product Type\nstatic let consumable: Product.ProductType\nA consumable in-app purchase.\nstatic let nonRenewable: Product.ProductType\nA non-renewing subscription.\nstatic let autoRenewable: Product.ProductType\nAn auto-renewable subscription."
  },
  {
    "title": "consumable",
    "url": "https://developer.apple.com/documentation/storekit/product/producttype/3749420-consumable",
    "html": "See Also\nGetting the Product Type\nstatic let nonConsumable: Product.ProductType\nA non-consumable in-app purchase.\nstatic let nonRenewable: Product.ProductType\nA non-renewing subscription.\nstatic let autoRenewable: Product.ProductType\nAn auto-renewable subscription."
  },
  {
    "title": "downloadable",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/1506161-downloadable",
    "html": "Deprecated\n\nUse isDownloadable instead.\n\nDiscussion\n\nYou can associate a set of data files with the App Store Connect record you created for a product. The value of this property is true if at least one file has been associated with the product.\n\nSee Also\nGetting Downloadable Content Information\nvar isDownloadable: Bool\nA Boolean value that indicates whether the App Store has downloadable content for this product.\nvar downloadContentLengths: [NSNumber]\nThe lengths of the downloadable files available for this product.\nvar downloadContentVersion: String\nA string that identifies which version of the content is available for download."
  },
  {
    "title": "SKProductDiscount",
    "url": "https://developer.apple.com/documentation/storekit/skproductdiscount",
    "html": "Overview\n\nYou set up introductory and promotional offers in App Store Connect. SKProductDiscount contains the offer information as retrieved from the App Store.\n\nFor more information about setting up offers, see Set an introductory offer for an auto-renewable subscription and Set up promotional offers for auto-renewable subscriptions.\n\nTopics\nIdentifying the Discount\nvar identifier: String?\nA string used to uniquely identify a discount offer for a product.\nvar type: SKProductDiscount.`Type`\nThe type of discount offer.\nenum SKProductDiscount.Type\nValues representing the types of discount offers an app can present.\nGetting Price and Payment Mode\nvar price: NSDecimalNumber\nThe discount price of the product in the local currency.\nvar priceLocale: Locale\nThe locale used to format the discount price of the product.\nvar paymentMode: SKProductDiscount.PaymentMode\nThe payment mode for this product discount.\nenum SKProductDiscount.PaymentMode\nValues representing the payment modes for a product discount.\nGetting the Discount Duration\nvar numberOfPeriods: Int\nAn integer that indicates the number of periods the product discount is available.\nvar subscriptionPeriod: SKProductSubscriptionPeriod\nAn object that defines the period for the product discount.\nRelationships\nInherits From\nNSObject\nConforms To\nSendable\nSee Also\nIntroductory offers\nImplementing introductory offers in your app\nOffer introductory pricing for auto-renewable subscriptions to eligible users.\nTesting introductory offers\nTest your introductory pricing in a variety of user scenarios."
  },
  {
    "title": "price",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/1506094-price",
    "html": "Discussion\n\nYour app can format the price using a number formatter, as shown in the following sample code:\n\nlet numberFormatter = NumberFormatter()\nnumberFormatter.numberStyle = .currency\nnumberFormatter.locale = product.priceLocale\nlet formattedString = numberFormatter.string(from: product.price)\n\n\nSee Also\nGetting Pricing Information\nvar priceLocale: Locale\nThe locale used to format the price of the product.\nvar introductoryPrice: SKProductDiscount?\nThe object containing introductory price information for the product.\nvar discounts: [SKProductDiscount]\nAn array of subscription offers available for the auto-renewable subscription.\nclass SKProductDiscount\nThe details of an introductory offer or a promotional offer for an auto-renewable subscription."
  },
  {
    "title": "contentLengths",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/1506157-contentlengths",
    "html": "See Also\nGetting Product Attributes\nvar localizedDescription: String\nA description of the product.\nvar localizedTitle: String\nThe name of the product.\nvar contentVersion: String\nA string that identifies the version of the content.\nvar isFamilyShareable: Bool\nA Boolean value that indicates whether the product is available for Family Sharing in App Store Connect."
  },
  {
    "title": "paymentQueue(_:shouldContinue:in:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueuedelegate/3242935-paymentqueue",
    "html": "Discussion\n\nStoreKit calls this delegate method if the storefront changes while processing a transaction.\n\nReturn true if you wish to continue the transaction within the updated storefront.\n\nReturn false to stop the transaction. The transaction will fail with the error SKError.Code.storeProductNotAvailable. In this case, consider displaying a message to the user indicating that the product isn't available in the current storefront.\n\nIf the delegate isn't implemented, paymentQueue(_:shouldContinue:in:) defaults to true.\n\nThis call times out after approximately one second, defaulting to false and causing the transaction to fail. The delegate should return as quickly as possible. Don't perform any networking calls in this method. Your app should cache product availability information locally before starting a transaction.\n\nSee SKStorefront for more information."
  },
  {
    "title": "localizedDescription",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/1506040-localizeddescription",
    "html": "Discussion\n\nThe description's language is determined by the storefront that the user's device is connected to, not the preferred language set on the device.\n\nSee Also\nGetting Product Attributes\nvar localizedTitle: String\nThe name of the product.\nvar contentVersion: String\nA string that identifies the version of the content.\nvar isFamilyShareable: Bool\nA Boolean value that indicates whether the product is available for Family Sharing in App Store Connect.\nvar contentLengths: [NSNumber]\nThe total size of the content, in bytes.\nDeprecated\nRelated Documentation\nclass SKStorefront\nAn object containing the location and unique identifier of an Apple App Store storefront."
  },
  {
    "title": "contentVersion",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/1505996-contentversion",
    "html": "See Also\nGetting Product Attributes\nvar localizedDescription: String\nA description of the product.\nvar localizedTitle: String\nThe name of the product.\nvar isFamilyShareable: Bool\nA Boolean value that indicates whether the product is available for Family Sharing in App Store Connect.\nvar contentLengths: [NSNumber]\nThe total size of the content, in bytes.\nDeprecated"
  },
  {
    "title": "transactionReceipt",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransaction/1617722-transactionreceipt",
    "html": "Deprecated\n\nUse the app receipt instead, as described in Receipt Validation Programming Guide.\n\nDiscussion\n\nThe contents of this property are undefined except when transactionState is set to SKPaymentTransactionState.purchased.\n\nThe receipt is a signed chunk of data that can be sent to the App Store to verify that the payment was successfully processed. This is most useful when designing a store that uses a server separate from the iPhone to verify that payment was processed. For more information on verifying receipts, see Receipt Validation Programming Guide.\n\nSee Also\nGetting Transaction Information\nvar payment: SKPayment\nThe payment for the transaction.\nvar transactionIdentifier: String?\nA string that uniquely identifies a successful payment transaction.\nvar transactionDate: Date?\nThe date the transaction was added to the App Store’s payment queue.\nvar original: SKPaymentTransaction?\nThe transaction that was restored by the App Store.\nvar error: (any Error)?\nAn object describing the error that occurred while processing the transaction."
  },
  {
    "title": "paymentQueueDidChangeStorefront(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver/3242936-paymentqueuedidchangestorefront",
    "html": "Discussion\n\nSee SKStorefront for more information."
  },
  {
    "title": "countryCode",
    "url": "https://developer.apple.com/documentation/storekit/skstorefront/3182435-countrycode",
    "html": "Discussion\n\nThis property uses the ISO 3166-1 Alpha-3 country code representation.\n\nSee Also\nIdentifying the Storefront\nvar identifier: String\nA value defined by Apple that uniquely identifies an App Store storefront."
  },
  {
    "title": "init(productIdentifiers:)",
    "url": "https://developer.apple.com/documentation/storekit/skproductsrequest/1506172-init",
    "html": "Parameters\nproductIdentifiers\n\nThe list of product identifiers for the products you wish to retrieve descriptions of.\n\nReturn Value\n\nThe initialized request object.\n\nSee Also\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "transactionDate",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransaction/1411273-transactiondate",
    "html": "Discussion\n\nThe contents of this property are undefined except when transactionState is set to SKPaymentTransactionState.purchased or SKPaymentTransactionState.restored.\n\nSee Also\nGetting Transaction Information\nvar payment: SKPayment\nThe payment for the transaction.\nvar transactionIdentifier: String?\nA string that uniquely identifies a successful payment transaction.\nvar original: SKPaymentTransaction?\nThe transaction that was restored by the App Store.\nvar error: (any Error)?\nAn object describing the error that occurred while processing the transaction.\nvar transactionReceipt: Data?\nA signed receipt that records all information about a successful payment transaction."
  },
  {
    "title": "transactionState",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransaction/1411275-transactionstate",
    "html": "See Also\nGetting Transaction State\nenum SKPaymentTransactionState\nValues representing the state of a transaction."
  },
  {
    "title": "downloads",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransaction/1411282-downloads",
    "html": "Discussion\n\nThe contents of this property are undefined except when transactionState is set to SKPaymentTransactionState.purchased. The SKDownload objects stored in this property must be used to download the transaction’s content before the transaction is finished. After the transaction is finished, the download objects are no longer queueable."
  },
  {
    "title": "custom(key:value:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3875424-custom",
    "html": "Parameters\nkey\n\nThe key for this custom option.\n\nvalue\n\nThe numerical value you assign to this custom option.\n\nDiscussion\n\nCustom purchase options don’t have any effect and are reserved for future use.\n\nSee Also\nSetting custom purchase options\nstatic func custom(key: String, value: Data) -> Product.PurchaseOption\nAdds data for a custom key to a purchase.\nstatic func custom(key: String, value: String) -> Product.PurchaseOption\nAdds a string for a custom key to a purchase.\nstatic func custom(key: String, value: Bool) -> Product.PurchaseOption\nAdds a Boolean value for a custom key to a purchase."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851125-compactmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, Storefront) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Storefront) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851127-compactmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, Storefront) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Storefront) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "dropFirst(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851133-dropfirst",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nSee Also\nExcluding elements\nfunc drop(while: (Storefront) -> Bool) -> AsyncDropWhileSequence<Storefront.Storefronts>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc filter((Storefront) -> Bool) -> AsyncFilterSequence<Storefront.Storefronts>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "prefix(while:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851154-prefix",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n\nSee Also\nSelecting elements\nfunc prefix(Int) -> AsyncPrefixSequence<Storefront.Storefronts>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence."
  },
  {
    "title": "drop(while:)",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts/3851131-drop",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is.\n\nSee Also\nExcluding elements\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Storefront.Storefronts>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Storefront) -> Bool) -> AsyncFilterSequence<Storefront.Storefronts>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "purchasedQuantity",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749711-purchasedquantity",
    "html": "See Also\nGetting purchase details\nlet isUpgraded: Bool\nA Boolean that indicates whether the user upgraded to another subscription.\nlet ownershipType: Transaction.OwnershipType\nA value that indicates whether the transaction was purchased by the user, or is made available to them through Family Sharing.\ntypealias Transaction.OwnershipType.RawValue\nThe type that represents the raw value of a transaction’s ownership type.\nstruct Transaction.OwnershipType\nThe types the system uses to describe whether the user purchased the product or it’s available to them through Family Sharing."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/3749429",
    "html": "See Also\nComparing Errors\nstatic func != (Product.PurchaseError, Product.PurchaseError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nfunc hash(into: inout Hasher)"
  },
  {
    "title": "Implementing promotional offers in your app",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/implementing_promotional_offers_in_your_app",
    "html": "Overview\n\nPromotional offers can be effective in winning back lapsed subscribers or retaining current subscribers. You can provide lapsed or current subscribers a limited-time offer of a discounted or free period of service for auto-renewable subscriptions on macOS, iOS, and tvOS. To implement the offers, first complete the setup on App Store Connect, including generating a private key. See Setting up promotional offers for more details.\n\nYou decide the criteria for which subscribers qualify for an offer. In your app, the details of the offers you set up in App Store Connect appear in the discounts array in SKProduct. To indicate the offer you want to give to a user, include a signed paymentDiscount in the SKMutablePayment object.\n\nFor business guidance on using promotional offers, see Auto-renewable Subscriptions > Providing Subscription Offers.\n\nNote\n\nIf your goal is to attract new users, you can use introductory offers and promote the in-app purchase on the App Store. Users are eligible to receive only one introductory offer, but redeeming an introductory offer doesn’t affect their eligibility for a promotional offer. For more information on introductory offers, see Implementing introductory offers in your app.\n\nPrepare Your Offer\n\nTo present a promotional offer, first determine the subscriber’s eligibility, get the product details from the App Store, and generate a signature on your server.\n\nFigure 1 Steps for determining a user's eligibility and preparing the offer\n\nDetermine Eligibility\n\nThere are two aspects to determining a user’s eligibility for promotional offers:\n\nThe App Store deems all customers with an existing or expired subscription in the app eligible to redeem a promotional offer. You can check whether the receipt contains any existing or expired subscription purchases to identify these current or lapsed subscribers.\n\nYou determine any additional eligibility criteria for a specific promotional offer. Eligibility can be contingent on a wide range of business logic determined by your business needs.\n\nConsider using the App Store server notification DID_CHANGE_RENEWAL_STATUS to determine eligibility. This notification is triggered by changes in a subscription’s auto-renew status. For example, you receive a notification when a subscriber disables auto-renew in Manage Subscriptions or contacts AppleCare to cancel their subscription. For more information on server notifications, see App Store Server Notifications. Your server can notify your app if the user is eligible for an offer so the app can present it to the customer.\n\nNote\n\nCustomers can redeem promotional offers only on devices running iOS 12.2 and later, macOS 10.14.4 and later, and tvOS 12.2 and later. Consider providing messaging prompting your customer to update their OS if they try to redeem a promotional offer in your app on a device running an older OS version.\n\nConsider also implementing DeviceCheck to keep track of devices that have previously redeemed offers. TwoBitKit allows you to maintain user privacy while defining parameters you use to determine eligibility.\n\nRequest Product Details\n\nOnce you determine that the subscriber is eligible for an offer, the next step is requesting the product details, including offers, from the App Store. To fetch the details, use SKProductsRequest with the subscription’s product identifier.\n\nIn response, the App Store returns the localized information in SKProduct. The discounts array of SKProduct contains all promotional offers you configured in App Store Connect for that product. The SKProductDiscount object contains offer details including the localized price.\n\nYou determine which offer from the discounts array to present to the user.\n\nCreate a Signature\n\nA signature is a unique string that your server generates using specified parameters and your private key. You include it in the signature parameter of SKPaymentDiscount, and the App Store uses it to validate the promotional offer. The signature is time sensitive, unique per offer, and redeemable only once.\n\nTo generate the signature, send a secure request to your server. The server will need to know the applicationUsername, productIdentifier, and identifier. Your app should supply these parameters in the request if the server doesn’t already know them. See Generating a signature for promotional offers for more information.\n\nYour server should respond with the signature string and the additional values it used to generate the signature: a nonce, timestamp, and the keyIdentifier. Use these values to complete the parameters in the SKPaymentDiscount object nested in the SKMutablePayment object representing the offer. If the App Store determines that the signature isn’t a match for the parameters in the payment, the transaction fails.\n\nTip\n\nTo minimize latency, consider generating the signature when you display the offer.\n\nThe following code example shows how to request a signature from your server and prepare the discount offer.\n\n// Fetch the signature from your server to be applied to the offer.\n// At this point you know the user and the product the offer is for, and which offer you want to display.\npublic func prepareOffer(usernameHash: String, productIdentifier: String, offerIdentifier: String, completion: (SKPaymentDiscount) -> Void) {\n\n\n    // Make a secure request to your server, providing the username, product, and discount data\n    // Your server will use these values to generate the signature and return it, along with the nonce, timestamp, and key identifier that it uses to generate the signature.\n    YourServer.fetchOfferDetails(username: usernameHash, productIdentifier: productIdentifier, offerIdentifier: offerIdentifier, completion: { (nonce: UUID, timestamp: NSNumber, keyIdentifier: String, signature: String) in \n\n\n        // Create an SKPaymentDiscount to be used later when the user initiates the purchase\n        let discountOffer = SKPaymentDiscount(identifier: offerIdentifier, keyIdentifier: keyIdentifier, nonce: nonce, signature: discountsignature, timestamp: timestamp)\n\n\n        completion(discountOffer)\n    })\n}\n\n\nPresent Your Offer\n\nYou can present offers to users through various channels, such as email, but they must interact with the offer inside your app’s UI. Display the offer in your app at the time you choose, using the pricing and terms from the SKProductDiscount object. By using the details from this object, you ensure that the offer displayed to the user accurately reflects the offer you intend to give. For design guidance, see Auto-Renewable Subscriptions > Clearly Describing Subscriptions.\n\nPresent offers to eligible subscribers only, to avoid misleading or confusing users.\n\nComplete the Transaction\n\nAfter a user chooses to buy the promotional offer, submit the payment request, verify the receipt, and unlock the offer.\n\nFigure 2 Steps for creating a payment request with a signed offer, verifying the receipt, and unlocking the service\n\nCreate a Payment Request\n\nWhen the user initiates a buy of the offer in the app, send an SKMutablePayment to the App Store with the signed offer. Create an SKPaymentDiscount object that includes the signature you generated and its identifier, keyIdentifier, nonce (one-time use), and timestamp parameters. Add this object as the paymentDiscount property to the SKMutablePayment object.\n\nInclude in the SKMutablePayment object the same applicationUsername, often a unique hash of the username, that the signature contains. Add the SKMutablePayment object to the queue.\n\n// An example function that makes a buy request with a promotional offer attached.\npublic func buyProduct(productIdentifier: SKProduct, forUser usernameHash: String, withOffer discountOffer: SKPaymentDiscount) {\n\n\n    // The original product being purchased.\n    let payment = SKMutablePayment(product: product)\n\n\n    // You must set applicationUsername to be the same as the one used to generate the signature.\n    payment.applicationUsername = usernameHash\n\n\n    // Add the offer to the payment.\n    payment.paymentDiscount = discountOffer\n\n\n    // Add the payment to the queue for purchase.\n    SKPaymentQueue.default().add(payment)\n}\n\n\nNotify the User of the Transaction State\n\nOnce the App Store validates the offer, it processes your payment request and generates an SKPaymentTransaction. Your app uses it to validate the transaction and unlock content accordingly.\n\nHandle the transaction state of the payment request and notify the customer as needed. If the transaction is successful, the App Store automatically updates the app receipt with the transaction in the SKPaymentTransactionState.purchased state. Base64-encode the receipt on-device and securely send the receipt data to your server.\n\nNote\n\nIf the transaction fails with a state of SKPaymentTransactionState.failed, you must generate a new signature and a new payment request for any further attempts to purchase the offer.\n\nVerify the Receipt\n\nAs you do for all purchases, verify the receipt with the App Store by calling the verifyReceipt endpoint from your server. The App Store sends a JSON response containing information about the user’s purchase. See Validating Receipts With the App Store for more information.\n\nWhen a subscriber redeems an offer, the receipt contains a promotional_offer_id in the purchase transaction. This receipt field is a string containing the offer ID that you configured in App Store Connect. You can look at past transactions in the receipt to identify the offers the customer redeemed.\n\nUnlock the Service\n\nAfter validating that the user has purchased the subscription product, unlock the subscription service in the app for the user. Update the customer’s eligibility criteria for offers, as needed.\n\nWhen a customer redeems a promotional offer, the offer period starts at the next billing event.\n\nFor upgrades or crossgrades to a different subscription with the same duration, the promotional offer triggers a billing event and goes into effect immediately.\n\nFor downgrades or crossgrades to a different subscription with different durations, the promotional offer period goes into effect at the next renewal date.\n\nFor the same subscription in an introductory offer, this promotional offer period goes into effect at the next scheduled billing event.\n\nOnce the offer period concludes, a promotional offer auto-renews at the standard price.\n\nA user can redeem and have active only one promotional offer at a time. If the user accepts another offer before a current offer ends, the current offer is canceled in the following billing event and the new offer takes effect.\n\nSee Also\nPromotional offers\nSetting up promotional offers\nGenerate a key and configure offers for auto-renewable subscriptions in App Store Connect.\nGenerating a signature for promotional offers\nCreate a signature to validate a promotional offer using your private key.\nGenerating a Promotional Offer Signature on the Server\nGenerate a signature using your private key and lightweight cryptography libraries.\nclass SKPaymentDiscount\nThe signed discount to apply to a payment."
  },
  {
    "title": "startFrame",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/transitioncontext/3566725-startframe",
    "html": "See Also\nAdding an Animation\nfunc addAnimation(() -> Void)\nAdds a closure you can use to animate view properties.\nvar endFrame: CGRect\nThe size and location of the overlay at the end of the transition."
  },
  {
    "title": "Product.PurchaseError.invalidOfferIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/invalidofferidentifier",
    "html": "See Also\nGetting Purchase Error Codes\ncase productUnavailable\nThe product isn’t available.\ncase purchaseNotAllowed\nThe user isn’t allowed to make purchases.\ncase ineligibleForOffer\nThe user isn't eligible for the offer.\ncase invalidOfferPrice\nThe price of the offer isn't valid.\ncase invalidOfferSignature\nThe offer signature isn't valid.\ncase invalidQuantity\nThe quantity to purchase is invalid.\ncase missingOfferParameters\nThe offer parameters are missing."
  },
  {
    "title": "identifier",
    "url": "https://developer.apple.com/documentation/storekit/skstorefront/3182436-identifier",
    "html": "See Also\nIdentifying the Storefront\nvar countryCode: String\nThe three-letter code representing the country or region associated with the App Store storefront."
  },
  {
    "title": "formatted(_:referenceDate:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/4044345-formatted",
    "html": "Parameters\nformat\n\nA format style that has a date range input. The format style for a product is subscriptionPeriodFormatStyle.\n\nreferenceDate\n\nThe lower bound date for a date range representing the subscription period. The default value is now.\n\nDiscussion\n// Get a human-readable representation of a subscription period.\nsubscriptionPeriod.formatted(product.subscriptionPeriodFormatStyle, referenceDate: /* some date */)\n\n\n\n\nSee Also\nFormatting the subscription period\nfunc formatted<S>(S, referenceDate: Date) -> S.FormatOutput\nFormats the subscription period using a format style that takes a duration as an input."
  },
  {
    "title": "SKPaymentTransactionState",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionstate",
    "html": "Topics\nConstants\ncase purchasing\nA transaction that is being processed by the App Store.\ncase purchased\nA successfully processed transaction.\ncase failed\nA failed transaction.\ncase restored\nA transaction that restores content previously purchased by the user.\ncase deferred\nA transaction that is in the queue, but its final status is pending external action such as Ask to Buy.\nRelationships\nConforms To\nSendable\nSee Also\nGetting Transaction State\nvar transactionState: SKPaymentTransactionState\nThe current state of the transaction."
  },
  {
    "title": "canMakePayments()",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1506139-canmakepayments",
    "html": "Discussion\n\nThe Boolean value that this method returns is identical to the value of the type property canMakePayments in the AppStore object. For more information about using and interpreting this value, see the type property page canMakePayments."
  },
  {
    "title": "transactionObservers",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/3578317-transactionobservers",
    "html": "See Also\nAdding, Getting, and Removing Observers\nfunc add(any SKPaymentTransactionObserver)\nAdds an observer to the payment queue.\nfunc remove(any SKPaymentTransactionObserver)\nRemoves an observer from the payment queue."
  },
  {
    "title": "SKPaymentTransactionState.restored",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionstate/restored",
    "html": "Discussion\n\nRead the original property to obtain information about the original purchase."
  },
  {
    "title": "SKPaymentTransactionState.deferred",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionstate/deferred",
    "html": "Discussion\n\nUpdate your UI to show the deferred state, and wait for another callback that indicates the final status."
  },
  {
    "title": "products",
    "url": "https://developer.apple.com/documentation/storekit/skproductsresponse/1506047-products",
    "html": "Discussion\n\nThe array consists of a list of SKProduct objects.\n\nSee Also\nResponse Information\nvar invalidProductIdentifiers: [String]\nAn array of product identifier strings that the App Store doesn’t recognize.\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "invalidProductIdentifiers",
    "url": "https://developer.apple.com/documentation/storekit/skproductsresponse/1505985-invalidproductidentifiers",
    "html": "Discussion\n\nThe App Store may not recognize your product identifiers unless you meet following criteria, as applicable:\n\nAgree to the latest Apple Developer Program License Agreement.\n\nComplete all the financial agreements as described in the Agreements, Tax, and Banking Overview. When you renew your developer membership, see if you need to make updates to your agreements. When your developer membership expires, your financial agreements expire as well.\n\nYour app uses an explicit App ID.\n\nClear the in-app purchases for sale in App Store Connect. See Set availability for in-app purchase.\n\nModified in-app purchases are available to the App Store servers.\n\nThe product identifier specified in App Store Connect matches the identifier used by the SKProductsRequest object in your app.\n\nUpload the content of your product to App Store Connect. See Upload in-app purchase content to App Store Connect.\n\nFor more troubleshooting information, see Fetching product information from the App Store.\n\nSee Also\nResponse Information\nvar products: [SKProduct]\nA list of products, one product for each valid product identifier provided in the original request."
  },
  {
    "title": "remove(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1506165-remove",
    "html": "Parameters\nobserver\n\nThe observer to remove.\n\nDiscussion\n\nIf there are no observers attached to the queue, the payment queue does not synchronize its list of pending transactions with the Apple App Store, because there is no observer to respond to updated transactions.\n\nSee Also\nAdding, Getting, and Removing Observers\nfunc add(any SKPaymentTransactionObserver)\nAdds an observer to the payment queue.\nvar transactionObservers: [any SKPaymentTransactionObserver]\nAn array of all active payment queue observers.\nRelated Documentation\nvar transactions: [SKPaymentTransaction]\nReturns an array of pending transactions."
  },
  {
    "title": "storefront",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/3182430-storefront",
    "html": "Discussion\n\nThe storefront information tells you the device's App Store region. You can use this information to display products that your app makes available in specific regions. You maintain your own list of product identifiers and the storefronts in which you make them available.\n\nIf the storefront changes during a transaction, StoreKit notifies your app by calling the paymentQueueDidChangeStorefront(_:) method of the SKPaymentTransactionObserver protocol. Implement paymentQueue(_:shouldContinue:in:) to indicate whether the transaction should continue with the new storefront.\n\nImportant\n\nstorefront is a synchronous API that may take significant time to return. Don't use storefront in a time-sensitive thread, such as during app launch. To get asynchronous behavior, dispatch it to a separate queue, or use the asynchronous current property of Storefront instead."
  },
  {
    "title": "restoreCompletedTransactions(withApplicationUsername:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1505992-restorecompletedtransactions",
    "html": "Parameters\nusername\n\nAn opaque identifier for the user’s account on your system.\n\nSee Also\nRestoring Purchases\nfunc restoreCompletedTransactions()\nAsks the payment queue to restore previously completed purchases.\nRelated Documentation\nvar applicationUsername: String?\nA string that associates the transaction with a user account on your service."
  },
  {
    "title": "default()",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1505990-default",
    "html": "Return Value\n\nThe default payment queue.\n\nDiscussion\n\nApps do not create a payment queue. Instead, they retrieve the queue by calling this class method.\n\nSpecial Considerations\n\nThe payment queue is not available in Simulator. Attempting to retrieve the payment queue logs a warning."
  },
  {
    "title": "PaymentMethodBinding.PaymentMethodBindingError.failed",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/failed",
    "html": "Discussion\n\nThe methods of the PaymentMethodBinding struct can fail if the app isn’t entitled to use this API, or if other errors occur.\n\nSee Also\nGetting error codes\ncase invalidPinningID\nThe in-app binding identifier is invalid or expired.\ncase notEligible\nThe user isn’t eligible."
  },
  {
    "title": "errorDescription",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/4143425-errordescription",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nGetting error descriptions\nvar failureReason: String?\nA string that describes the reason for the failure.\nvar helpAnchor: String?\nA localized message that provides additional information if the user requests help.\nvar localizedDescription: String\nA localized message that describes the error.\nvar recoverySuggestion: String?\nA message that contains a suggestion for recovering from the error."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/4143424",
    "html": "See Also\nComparing and hashing errors\nstatic func != (PaymentMethodBinding.PaymentMethodBindingError, PaymentMethodBinding.PaymentMethodBindingError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "paymentQueueRestoreCompletedTransactionsFinished(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver/1506101-paymentqueuerestorecompletedtran",
    "html": "Parameters\nqueue\n\nThe payment queue that restored the transactions.\n\nDiscussion\n\nThis method is called after all restorable transactions have been processed by the payment queue. Your application is not required to do anything in this method.\n\nSee Also\nRestoring transactions\nfunc paymentQueue(SKPaymentQueue, restoreCompletedTransactionsFailedWithError: any Error)\nTells the observer that an error occurred while restoring transactions."
  },
  {
    "title": "original",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransaction/1411284-original",
    "html": "Discussion\n\nThe contents of this property are undefined except when transactionState is set to SKPaymentTransactionState.restored. When a transaction is restored, the current transaction holds a new transaction identifier, receipt, and so on. Your application will read this property to retrieve the restored transaction.\n\nSee Also\nGetting Transaction Information\nvar payment: SKPayment\nThe payment for the transaction.\nvar transactionIdentifier: String?\nA string that uniquely identifies a successful payment transaction.\nvar transactionDate: Date?\nThe date the transaction was added to the App Store’s payment queue.\nvar error: (any Error)?\nAn object describing the error that occurred while processing the transaction.\nvar transactionReceipt: Data?\nA signed receipt that records all information about a successful payment transaction."
  },
  {
    "title": "Implementing introductory offers in your app",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/implementing_introductory_offers_in_your_app",
    "html": "Overview\n\nApps with auto-renewable subscriptions can offer a discounted introductory price, including a free trial, to eligible users. You can make introductory offers to customers who haven’t previously received an introductory offer for the given product, or for any products in the same subscription group.\n\nStart by setting up introductory offers in App Store Connect. Then, in your app, determine if the user is eligible to receive an introductory offer. When the app queries the App Store for a list of available products, display the introductory pricing if the user is eligible to receive them.\n\nSet Up Introductory Offers\n\nBefore you can display introductory offers in your app, you must first configure the offers in App Store Connect. For more information, see Set an introductory offer for an auto-renewable subscription.\n\nChoose from one of three types of introductory offers, which differ in their mode of payment. All subscriptions renew at the regular price when the introductory period is over. The offer types are “pay as you go”, “pay up front”, and “free trial”.\n\nPay As You Go\n\nThe SKProductDiscount.PaymentMode.payAsYouGo value represents the pay as you go offer type. In this introductory offer, new subscribers pay an introductory price each billing period for a specific duration (for example, $1.99 per month for 3 months).\n\nPay Up Front\n\nThe SKProductDiscount.PaymentMode.payUpFront value represents the pay up front offer type. In this introductory offer, new subscribers pay a one-time introductory price for a specific duration (for example, $1.99 for 2 months).\n\nFree Trial\n\nThe SKProductDiscount.PaymentMode.freeTrial value represents a free trial offer type. In this introductory offer, new subscribers access content for free for a specified duration. Subscriptions begin immediately, but subscribers won’t be billed until the free trial period is over.\n\nDetermine Eligibility\n\nTo determine if a user is eligible for an introductory offer, check their receipt:\n\nValidate the receipt as described in Validating receipts with the App Store.\n\nIn the receipt, check the values of the is_trial_period and the is_in_intro_offer_period for all in-app purchase transactions. If either of these fields are true for a given subscription, the user is not eligible for an introductory offer on that subscription product or any other products within the same subscription group. Use subscription_group_identifier in the responseBody.Pending_renewal_info array to determine the subscription group to which the subscription belongs.\n\nTypically, you check the user's eligibility from your server. Determine eligibility early—for example, on the first launch of the app, if possible.\n\nBased on the receipt, you will find that new and returning customers are eligible for introductory offers, including free trials:\n\nNew subscribers are always eligible.\n\nLapsed subscribers who renew are eligible if they haven't previously used an introductory offer for the given product (or any product within the same subscription group).\n\nExisting subscribers are not eligible for an introductory offer for any product within the same subscription group. For example, customers are not eligible if they are upgrading, downgrading, or crossgrading their subscription from another product, regardless of whether they consumed an introductory offer in the past.\n\nDisplay the Introductory Offer\n\nOnce you determine the user is eligible for an introductory offer, query the App Store for available products, and present the offer to the user:\n\nRetrieve localized information from the App Store about a specified list of subscription products using the SKProductsRequest class. Products that have an available discount defined in App Store Connect always include an introductoryPrice object.\n\nUse the properties in the introductoryPrice object to display the discounted price for the subscription. Based on the type of the introductory offer (represented by SKProductDiscount.PaymentMode), display a UI that describes the offer accordingly.\n\nFor design guidance, see Human Interface Guidelines > In-App Purchase.\n\nSee Also\nIntroductory offers\nTesting introductory offers\nTest your introductory pricing in a variety of user scenarios.\nclass SKProductDiscount\nThe details of an introductory offer or a promotional offer for an auto-renewable subscription.\nRelated Documentation\nReceipt Validation Programming Guide"
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/producttype/3749422-hashvalue",
    "html": "See Also\nComparing and Hashing Product Types\nstatic func != (Product.ProductType, Product.ProductType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "SKProduct.PeriodUnit",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/periodunit",
    "html": "Overview\n\nThe period unit represents the duration of an interval. Period units are used with the number of units to determine one period in SKProductSubscriptionPeriod.\n\nTopics\nPeriod Units\ncase day\nAn interval lasting one day.\ncase month\nAn interval lasting one month.\ncase week\nAn interval lasting one week.\ncase year\nAn interval lasting one year.\nRelationships\nConforms To\nSendable\nSee Also\nGetting Subscription Information\nvar subscriptionGroupIdentifier: String?\nThe identifier of the subscription group to which the subscription belongs.\nvar subscriptionPeriod: SKProductSubscriptionPeriod?\nThe period details for products that are subscriptions.\nclass SKProductSubscriptionPeriod\nAn object containing the subscription period duration information."
  },
  {
    "title": "subscriptionPeriod",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/2936884-subscriptionperiod",
    "html": "Discussion\n\nThis read-only property is nil if the product is not a subscription.\n\nA subscription period is described in terms of a unit and the number of units that make up a single period.\n\nSee Also\nGetting Subscription Information\nvar subscriptionGroupIdentifier: String?\nThe identifier of the subscription group to which the subscription belongs.\nclass SKProductSubscriptionPeriod\nAn object containing the subscription period duration information.\nenum SKProduct.PeriodUnit\nValues representing the duration of an interval, from a day up to a year."
  },
  {
    "title": "isDownloadable",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/3328625-isdownloadable",
    "html": "Discussion\n\nYou can associate a set of data files with the App Store Connect record you created for a product. The value of this property is true if at least one file has been associated with the product.\n\nSee Also\nGetting Downloadable Content Information\nvar downloadContentLengths: [NSNumber]\nThe lengths of the downloadable files available for this product.\nvar downloadContentVersion: String\nA string that identifies which version of the content is available for download.\nvar downloadable: Bool\nA Boolean value that indicates whether the App Store has downloadable content for this product.\nDeprecated"
  },
  {
    "title": "SKProductSubscriptionPeriod",
    "url": "https://developer.apple.com/documentation/storekit/skproductsubscriptionperiod",
    "html": "Overview\n\nA subscription period is a duration of time defined as some number of units, where a unit can be a SKProduct.PeriodUnit.day, SKProduct.PeriodUnit.week, SKProduct.PeriodUnit.month, or SKProduct.PeriodUnit.year.\n\nFor example, a subscription period of two weeks has a unit of a SKProduct.PeriodUnit.week, and a numberOfUnits equal to 2.\n\nTopics\nGetting Subscription Period Details\nvar numberOfUnits: Int\nThe number of units per subscription period.\nvar unit: SKProduct.PeriodUnit\nThe increment of time that a subscription period is specified in.\nenum SKProduct.PeriodUnit\nValues representing the duration of an interval, from a day up to a year.\nRelationships\nInherits From\nNSObject\nConforms To\nSendable\nSee Also\nGetting Subscription Information\nvar subscriptionGroupIdentifier: String?\nThe identifier of the subscription group to which the subscription belongs.\nvar subscriptionPeriod: SKProductSubscriptionPeriod?\nThe period details for products that are subscriptions.\nenum SKProduct.PeriodUnit\nValues representing the duration of an interval, from a day up to a year."
  },
  {
    "title": "downloadContentLengths",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/1615752-downloadcontentlengths",
    "html": "Discussion\n\nThe array holds NSNumber objects, each of which holds a long long value that is the size of one of the downloadable files (in bytes).\n\nSee Also\nGetting Downloadable Content Information\nvar isDownloadable: Bool\nA Boolean value that indicates whether the App Store has downloadable content for this product.\nvar downloadContentVersion: String\nA string that identifies which version of the content is available for download.\nvar downloadable: Bool\nA Boolean value that indicates whether the App Store has downloadable content for this product.\nDeprecated"
  },
  {
    "title": "introductoryPrice",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/2936878-introductoryprice",
    "html": "Discussion\n\nIf you've set up introductory prices in App Store Connect, the introductory price property will be populated. This property is nil if the product has no introductory price.\n\nBefore displaying UI that offers the introductory price, you must first determine if the user is eligible to receive it. See Implementing introductory offers in your app for information on determining eligibility and displaying introductory prices.\n\nSee Also\nGetting Pricing Information\nvar price: NSDecimalNumber\nThe cost of the product in the local currency.\nvar priceLocale: Locale\nThe locale used to format the price of the product.\nvar discounts: [SKProductDiscount]\nAn array of subscription offers available for the auto-renewable subscription.\nclass SKProductDiscount\nThe details of an introductory offer or a promotional offer for an auto-renewable subscription."
  },
  {
    "title": "subscriptionGroupIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/2981047-subscriptiongroupidentifier",
    "html": "Discussion\n\nAuto-renewable subscriptions always belong to a subscription group. You create the subscription group identifiers in App Store Connect before you create and add an auto-renewable subscription. For more information about subscription groups, see Offer auto-renewable subscriptions.\n\nThis property is nil if the SKProduct isn’t an auto-renewable subscription.\n\nSee Also\nGetting Subscription Information\nvar subscriptionPeriod: SKProductSubscriptionPeriod?\nThe period details for products that are subscriptions.\nclass SKProductSubscriptionPeriod\nAn object containing the subscription period duration information.\nenum SKProduct.PeriodUnit\nValues representing the duration of an interval, from a day up to a year."
  },
  {
    "title": "discounts",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/3043534-discounts",
    "html": "Discussion\n\nThe discounts array contains all of the introductory offers and promotional offers that you set up in App Store Connect for this subscription (productIdentifier). It's up to the logic in your app to decide which offer to present to the user.\n\nFor more information about offers, see Implementing promotional offers in your app, and Implementing introductory offers in your app.\n\nSee Also\nGetting Pricing Information\nvar price: NSDecimalNumber\nThe cost of the product in the local currency.\nvar priceLocale: Locale\nThe locale used to format the price of the product.\nvar introductoryPrice: SKProductDiscount?\nThe object containing introductory price information for the product.\nclass SKProductDiscount\nThe details of an introductory offer or a promotional offer for an auto-renewable subscription."
  },
  {
    "title": "priceLocale",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/1506145-pricelocale",
    "html": "Discussion\n\nUse the locale to format the price.\n\nSee Also\nGetting Pricing Information\nvar price: NSDecimalNumber\nThe cost of the product in the local currency.\nvar introductoryPrice: SKProductDiscount?\nThe object containing introductory price information for the product.\nvar discounts: [SKProductDiscount]\nAn array of subscription offers available for the auto-renewable subscription.\nclass SKProductDiscount\nThe details of an introductory offer or a promotional offer for an auto-renewable subscription."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3749443-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing purchase options\nstatic func != (Product.PurchaseOption, Product.PurchaseOption) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.PurchaseOption, Product.PurchaseOption) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "custom(key:value:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3875422-custom",
    "html": "Parameters\nkey\n\nThe key for this custom option.\n\nvalue\n\nThe string value you assign to this custom option.\n\nDiscussion\n\nCustom purchase options don’t have any effect and are reserved for future use.\n\nSee Also\nSetting custom purchase options\nstatic func custom(key: String, value: Data) -> Product.PurchaseOption\nAdds data for a custom key to a purchase.\nstatic func custom(key: String, value: Bool) -> Product.PurchaseOption\nAdds a Boolean value for a custom key to a purchase.\nstatic func custom(key: String, value: Double) -> Product.PurchaseOption\nAdds a number for a custom key to a purchase."
  },
  {
    "title": "custom(key:value:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3875423-custom",
    "html": "Parameters\nkey\n\nThe key for this custom option.\n\nvalue\n\nThe Boolean value you assign to this custom option.\n\nDiscussion\n\nCustom purchase options don’t have any effect and are reserved for future use.\n\nSee Also\nSetting custom purchase options\nstatic func custom(key: String, value: Data) -> Product.PurchaseOption\nAdds data for a custom key to a purchase.\nstatic func custom(key: String, value: String) -> Product.PurchaseOption\nAdds a string for a custom key to a purchase.\nstatic func custom(key: String, value: Double) -> Product.PurchaseOption\nAdds a number for a custom key to a purchase."
  },
  {
    "title": "promotionalOffer(id:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/4196326-promotionaloffer",
    "html": "Parameters\nidentifier\n\nThe identifier of the promotional offer to apply to the transaction. You need to set up identifiers in your StoreKit configuration file.\n\nDiscussion\n\nUse this purchase option when you test your app in Xcode using StoreKit Test and call buyProduct(identifier:options:).\n\nSet up the promotional offer identifiers you use in this call in your StoreKit configuration file. For more information, see Setting up StoreKit Testing in Xcode.\n\nWhen you apply this option, the purchase transaction simulates a customer redeeming a promotional offer and includes the promotional offer you specify.\n\nSee Also\nSetting options for StoreKit Testing in Xcode\nstatic func purchaseDate(Date, renewalBehavior: Product.PurchaseOption.SubscriptionRenewalBehavior) -> Product.PurchaseOption\nSets the purchase date for the transaction in the testing environment, and indicates the renewal behavior for an auto-renewable subscription.\nenum Product.PurchaseOption.SubscriptionRenewalBehavior\nRenewal options for auto-renewable subscriptions that you purchase in the testing environment.\nstatic func codeOffer(referenceName: String) -> Product.PurchaseOption\nSets an offer code for the transaction in the testing environment."
  },
  {
    "title": "Transaction.Reason",
    "url": "https://developer.apple.com/documentation/storekit/transaction/reason",
    "html": "Topics\nTransaction reasons\nstatic let purchase: Transaction.Reason\nA transaction reason that indicates a purchase is initiated by a customer.\nstatic let renewal: Transaction.Reason\nA transaction reason that indicates the App Store server initiated a purchase transaction to renew an auto-renewable subscription.\nCreating transaction reasons\ninit(rawValue: String)\nReturns a new transaction reason with the specified raw value.\nlet rawValue: String\nThe corresponding value of the raw type.\ntypealias Transaction.Reason.RawValue\nA type that represents the raw value of a transaction reason.\nComparing and hashing\nvar hashValue: Int\nThe hash value.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nstatic func != (Transaction.Reason, Transaction.Reason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSendable\nSee Also\nGetting transaction reason\nlet reason: Transaction.Reason\nThe cause of the purchase transaction, whether it’s a customer’s purchase or an auto-renewable subscription renewal that the system initiates."
  },
  {
    "title": "custom(key:value:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3875421-custom",
    "html": "Parameters\nkey\n\nThe key for this custom option.\n\nvalue\n\nThe data value you assign to this custom option.\n\nDiscussion\n\nCustom purchase options don’t have any effect and are reserved for future use.\n\nSee Also\nSetting custom purchase options\nstatic func custom(key: String, value: String) -> Product.PurchaseOption\nAdds a string for a custom key to a purchase.\nstatic func custom(key: String, value: Bool) -> Product.PurchaseOption\nAdds a Boolean value for a custom key to a purchase.\nstatic func custom(key: String, value: Double) -> Product.PurchaseOption\nAdds a number for a custom key to a purchase."
  },
  {
    "title": "reason",
    "url": "https://developer.apple.com/documentation/storekit/transaction/4193539-reason",
    "html": "See Also\nGetting transaction reason\nstruct Transaction.Reason\nA cause of a purchase transaction, indicating whether it’s a customer’s purchase or an auto-renewable subscription renewal that the system initiates."
  },
  {
    "title": "subscriptionStatus",
    "url": "https://developer.apple.com/documentation/storekit/transaction/4137250-subscriptionstatus",
    "html": "Discussion\n\nThis value is nil if the product in the transaction isn’t an auto-renewable subscription, specifically, if the productType is anything other than autoRenewable.\n\nThe array can have more than one subscription status, for example, if your subscription supports Family Sharing. Provide the customer with service for the subscription based on the highest level of service where the subscription status is subscribed."
  },
  {
    "title": "Product.CollectionTaskState.loading",
    "url": "https://developer.apple.com/documentation/storekit/product/collectiontaskstate/loading",
    "html": "See Also\nCollection task states\ncase success([Product], unavailable: [Product.ID])\ncase failure(any Error)"
  },
  {
    "title": "ownershipType",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749705-ownershiptype",
    "html": "See Also\nGetting purchase details\nlet isUpgraded: Bool\nA Boolean that indicates whether the user upgraded to another subscription.\ntypealias Transaction.OwnershipType.RawValue\nThe type that represents the raw value of a transaction’s ownership type.\nstruct Transaction.OwnershipType\nThe types the system uses to describe whether the user purchased the product or it’s available to them through Family Sharing.\nlet purchasedQuantity: Int\nThe number of consumable products purchased."
  },
  {
    "title": "Product.CollectionTaskState.success(_:unavailable:)",
    "url": "https://developer.apple.com/documentation/storekit/product/collectiontaskstate/success_unavailable",
    "html": "See Also\nCollection task states\ncase loading\ncase failure(any Error)"
  },
  {
    "title": "Product.CollectionTaskState.failure(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/collectiontaskstate/failure",
    "html": "See Also\nCollection task states\ncase loading\ncase success([Product], unavailable: [Product.ID])"
  },
  {
    "title": "Message.Messages.AsyncIterator.Element",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/asynciterator/element",
    "html": "See Also\nGetting the Next Element\nfunc next() -> Message.Messages.Element?"
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/4143429-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing errors\nstatic func != (PaymentMethodBinding.PaymentMethodBindingError, PaymentMethodBinding.PaymentMethodBindingError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (PaymentMethodBinding.PaymentMethodBindingError, PaymentMethodBinding.PaymentMethodBindingError) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "deviceVerificationNonce",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3749498-deviceverificationnonce",
    "html": "Discussion\n\nFor more information, see deviceVerificationID.\n\nSee Also\nVerifying subscription renewal information\nlet deviceVerification: Data\nThe device verification value to use to verify whether the renewal information belongs to the device.\nlet signedDate: Date\nThe date that the App Store signed the JWS renewal information."
  },
  {
    "title": "next()",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/asynciterator/3954467-next",
    "html": "Relationships\nFrom Protocol\nAsyncIteratorProtocol\nSee Also\nGetting the Next Element\ntypealias Message.Messages.AsyncIterator.Element"
  },
  {
    "title": "endFrame",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/transitioncontext/3566724-endframe",
    "html": "See Also\nAdding an Animation\nfunc addAnimation(() -> Void)\nAdds a closure you can use to animate view properties.\nvar startFrame: CGRect\nThe size and location of the overlay before the transition."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/3749431-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing Errors\nstatic func != (Product.PurchaseError, Product.PurchaseError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.PurchaseError, Product.PurchaseError) -> Bool\nfunc hash(into: inout Hasher)"
  },
  {
    "title": "addAnimation(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/transitioncontext/3583270-addanimation",
    "html": "Parameters\nblock\n\nA closure that sets animatable view properties and runs on the main thread.\n\nSee Also\nAdding an Animation\nvar startFrame: CGRect\nThe size and location of the overlay before the transition.\nvar endFrame: CGRect\nThe size and location of the overlay at the end of the transition."
  },
  {
    "title": "recoverySuggestion",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/3916869-recoverysuggestion",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nGetting Error Properties\nvar localizedDescription: String\nvar errorDescription: String?\nvar failureReason: String?\nvar helpAnchor: String?"
  },
  {
    "title": "gradientMaterial",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolbackground/4203704-gradientmaterial",
    "html": "See Also\nBackground types\nstatic var automatic: SubscriptionStoreControlBackground\nstatic var gradientMaterialOnScroll: SubscriptionStoreControlBackground"
  },
  {
    "title": "gradientMaterialOnScroll",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolbackground/4203705-gradientmaterialonscroll",
    "html": "See Also\nBackground types\nstatic var automatic: SubscriptionStoreControlBackground\nstatic var gradientMaterial: SubscriptionStoreControlBackground"
  },
  {
    "title": "automatic",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolbackground/4203703-automatic",
    "html": "See Also\nBackground types\nstatic var gradientMaterial: SubscriptionStoreControlBackground\nstatic var gradientMaterialOnScroll: SubscriptionStoreControlBackground"
  },
  {
    "title": "localizedDescription",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/3749433-localizeddescription",
    "html": "See Also\nGetting Error Properties\nvar errorDescription: String?\nvar failureReason: String?\nvar helpAnchor: String?\nvar recoverySuggestion: String?"
  },
  {
    "title": "Product.PurchaseError.invalidOfferSignature",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/invalidoffersignature",
    "html": "See Also\nGetting Purchase Error Codes\ncase invalidOfferIdentifier\nThe promotional offer identifier provided in the purchase options is invalid.\ncase productUnavailable\nThe product isn’t available.\ncase purchaseNotAllowed\nThe user isn’t allowed to make purchases.\ncase ineligibleForOffer\nThe user isn't eligible for the offer.\ncase invalidOfferPrice\nThe price of the offer isn't valid.\ncase invalidQuantity\nThe quantity to purchase is invalid.\ncase missingOfferParameters\nThe offer parameters are missing."
  },
  {
    "title": "Product.PurchaseError.invalidQuantity",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/invalidquantity",
    "html": "See Also\nGetting Purchase Error Codes\ncase invalidOfferIdentifier\nThe promotional offer identifier provided in the purchase options is invalid.\ncase productUnavailable\nThe product isn’t available.\ncase purchaseNotAllowed\nThe user isn’t allowed to make purchases.\ncase ineligibleForOffer\nThe user isn't eligible for the offer.\ncase invalidOfferPrice\nThe price of the offer isn't valid.\ncase invalidOfferSignature\nThe offer signature isn't valid.\ncase missingOfferParameters\nThe offer parameters are missing."
  },
  {
    "title": "Product.PurchaseError.missingOfferParameters",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/missingofferparameters",
    "html": "See Also\nGetting Purchase Error Codes\ncase invalidOfferIdentifier\nThe promotional offer identifier provided in the purchase options is invalid.\ncase productUnavailable\nThe product isn’t available.\ncase purchaseNotAllowed\nThe user isn’t allowed to make purchases.\ncase ineligibleForOffer\nThe user isn't eligible for the offer.\ncase invalidOfferPrice\nThe price of the offer isn't valid.\ncase invalidOfferSignature\nThe offer signature isn't valid.\ncase invalidQuantity\nThe quantity to purchase is invalid."
  },
  {
    "title": "Product.PurchaseError.invalidOfferPrice",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/invalidofferprice",
    "html": "See Also\nGetting Purchase Error Codes\ncase invalidOfferIdentifier\nThe promotional offer identifier provided in the purchase options is invalid.\ncase productUnavailable\nThe product isn’t available.\ncase purchaseNotAllowed\nThe user isn’t allowed to make purchases.\ncase ineligibleForOffer\nThe user isn't eligible for the offer.\ncase invalidOfferSignature\nThe offer signature isn't valid.\ncase invalidQuantity\nThe quantity to purchase is invalid.\ncase missingOfferParameters\nThe offer parameters are missing."
  },
  {
    "title": "Product.PurchaseError.ineligibleForOffer",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/ineligibleforoffer",
    "html": "See Also\nGetting Purchase Error Codes\ncase invalidOfferIdentifier\nThe promotional offer identifier provided in the purchase options is invalid.\ncase productUnavailable\nThe product isn’t available.\ncase purchaseNotAllowed\nThe user isn’t allowed to make purchases.\ncase invalidOfferPrice\nThe price of the offer isn't valid.\ncase invalidOfferSignature\nThe offer signature isn't valid.\ncase invalidQuantity\nThe quantity to purchase is invalid.\ncase missingOfferParameters\nThe offer parameters are missing."
  },
  {
    "title": "value",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/3749577-value",
    "html": "Discussion\n\nUse the value and the unit together to determine the subscription period. For example, if the unit is Product.SubscriptionPeriod.Unit.month, and the value is 3, the subscription period is three months.\n\nSee Also\nGetting the subscription period\nlet unit: Product.SubscriptionPeriod.Unit\nThe increment of time for the subscription period.\nenum Product.SubscriptionPeriod.Unit\nUnits of time that describe subscription periods."
  },
  {
    "title": "dateRange(referenceDate:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/4044344-daterange",
    "html": "Parameters\nreferenceDate\n\nA date you provide that indicates the lower bound of the returned date range. The default value is now.\n\nReturn Value\n\nThe subscription period represented by two dates that are the lower bound and upper bound of the subscription period.\n\nDiscussion\n\nThe date range calculates a single subscription period starting from the date you provide in referenceDate.\n\nFor example, if a subscription period is one month, and the referenceDate is February 1, the date range contains February 1 and March 1. If the referenceDate is Feb 15, the date range contains February 15 and March 15.\n\nUse the dateRange(referenceDate:) with a Date.ComponentsFormatStyle to get a human-readable string representation of the subscription period.\n\nGet the format style (Date.ComponentsFormatStyle) corresponding to product’s storefront using the subscriptionPeriodFormatStyle."
  },
  {
    "title": "Product.SubscriptionPeriod.Unit",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit",
    "html": "Topics\nGetting the subscription period units\ncase day\nA subscription period unit of a day.\ncase month\nA subscription period unit of a month.\ncase week\nA subscription period unit of a week.\ncase year\nA subscription period unit of a year.\nGetting localized and debug descriptions\nvar localizedDescription: String\nThe localized text that describes the subscription period unit.\nvar debugDescription: String\nA string that contains the name of the subscription period unit, suitable for debugging.\nGetting the formatted description\nfunc formatted<S>(S) -> S.FormatOutput\nstruct Product.SubscriptionPeriod.Unit.FormatStyle\nComparing and hashing units\nstatic func != (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionPeriod.Unit, Product.SubscriptionPeriod.Unit) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nInherited operators\nOperators\nRelationships\nConforms To\nComparable\nCustomDebugStringConvertible\nHashable\nSee Also\nGetting the subscription period\nlet value: Int\nThe number of period units.\nlet unit: Product.SubscriptionPeriod.Unit\nThe increment of time for the subscription period."
  },
  {
    "title": "unit",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/3749576-unit",
    "html": "Discussion\n\nThe units used to specify a subscription period include day, week, month, and year, as defined in Product.SubscriptionPeriod.Unit.\n\nTo calculate the duration of one subscription period, multiply the unit by the number of units (value).\n\nSee Also\nGetting the subscription period\nlet value: Int\nThe number of period units.\nenum Product.SubscriptionPeriod.Unit\nUnits of time that describe subscription periods."
  },
  {
    "title": "formatted(_:referenceDate:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/4044346-formatted",
    "html": "Parameters\nformat\n\nA format style that has a duration as an input.\n\nreferenceDate\n\nThe starting date of the subscription period. The default value is now.\n\nSee Also\nFormatting the subscription period\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) func formatted<S>(S, referenceDate: Date) -> S.FormatOutput\nFormats the subscription period using a format style that takes a date range as an input."
  },
  {
    "title": "paymentCancelled",
    "url": "https://developer.apple.com/documentation/storekit/skerror/2330537-paymentcancelled",
    "html": "See Also\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "setAdditionalValue(_:forKey:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appconfiguration/3566716-setadditionalvalue",
    "html": "Parameters\nvalue\n\nThe value to associate with the key.\n\nkey\n\nThe string that identifies an additional value.\n\nDiscussion\n\nSet additional values to verify and associate an app installation with an ad campaign. For more information, see SKAdNetwork.\n\nSee Also\nVerifying Advertising Campaigns\nvar campaignToken: String?\nA token you use to represent an ad campaign and measure its effectiveness.\nvar providerToken: String?\nA token that represents the provider of an app promotion campaign, and that you use to measure the campaign’s effectiveness.\nfunc additionalValue(forKey: String) -> Any?\nReturns the object associated with the key."
  },
  {
    "title": "Product.PurchaseError.purchaseNotAllowed",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/purchasenotallowed",
    "html": "See Also\nGetting Purchase Error Codes\ncase invalidOfferIdentifier\nThe promotional offer identifier provided in the purchase options is invalid.\ncase productUnavailable\nThe product isn’t available.\ncase ineligibleForOffer\nThe user isn't eligible for the offer.\ncase invalidOfferPrice\nThe price of the offer isn't valid.\ncase invalidOfferSignature\nThe offer signature isn't valid.\ncase invalidQuantity\nThe quantity to purchase is invalid.\ncase missingOfferParameters\nThe offer parameters are missing."
  },
  {
    "title": "additionalValue(forKey:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appconfiguration/3566711-additionalvalue",
    "html": "Parameters\nkey\n\nThe string that identifies an additional value.\n\nReturn Value\n\nThe associated value of the key.\n\nDiscussion\n\nAdditional values are values you use to verify and associate an app installation with an ad campaign. For more information, see SKAdNetwork.\n\nSee Also\nVerifying Advertising Campaigns\nvar campaignToken: String?\nA token you use to represent an ad campaign and measure its effectiveness.\nvar providerToken: String?\nA token that represents the provider of an app promotion campaign, and that you use to measure the campaign’s effectiveness.\nfunc setAdditionalValue(Any?, forKey: String)\nSets an additional value for a key; for example, a value for measuring the effectiveness of an ad campaign."
  },
  {
    "title": "Product.PurchaseError.productUnavailable",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/productunavailable",
    "html": "See Also\nGetting Purchase Error Codes\ncase invalidOfferIdentifier\nThe promotional offer identifier provided in the purchase options is invalid.\ncase purchaseNotAllowed\nThe user isn’t allowed to make purchases.\ncase ineligibleForOffer\nThe user isn't eligible for the offer.\ncase invalidOfferPrice\nThe price of the offer isn't valid.\ncase invalidOfferSignature\nThe offer signature isn't valid.\ncase invalidQuantity\nThe quantity to purchase is invalid.\ncase missingOfferParameters\nThe offer parameters are missing."
  },
  {
    "title": "paymentQueue(_:updatedTransactions:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver/1506107-paymentqueue",
    "html": "Required\n\nParameters\nqueue\n\nThe payment queue that updated the transactions.\n\ntransactions\n\nAn array of the transactions that were updated.\n\nDiscussion\n\nThe application should process each transaction by examining the transaction’s transactionState property. If transactionState is SKPaymentTransactionState.purchased, payment was successfully received for the desired functionality. The application should make the functionality available to the user. If transactionState is SKPaymentTransactionState.failed, the application can read the transaction’s error property to return a meaningful error to the user.\n\nOnce a transaction is processed, it should be removed from the payment queue by calling the payment queue’s finishTransaction(_:) method, passing the transaction as a parameter.\n\nImportant\n\nOnce the transaction is finished, StoreKit can’t tell you that this item is already purchased. It is important that applications process the transaction completely before calling finishTransaction(_:).\n\nSee Also\nHandling transactions\nfunc paymentQueue(SKPaymentQueue, removedTransactions: [SKPaymentTransaction])\nTells an observer that one or more transactions have been removed from the queue.\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "SKPaymentTransactionState.failed",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionstate/failed",
    "html": "Discussion\n\nCheck the error property to determine what happened."
  },
  {
    "title": "SKPaymentTransactionState.purchased",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionstate/purchased",
    "html": "Discussion\n\nYour application should provide the content the user purchased."
  },
  {
    "title": "resume(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1506096-resume",
    "html": "Parameters\ndownloads\n\nAn array of SKDownload objects to resume.\n\nSee Also\nDownloading Content\nfunc start([SKDownload])\nAdds a set of downloads to the download list.\nDeprecated\nfunc cancel([SKDownload])\nRemoves a set of downloads from the download list.\nDeprecated\nfunc pause([SKDownload])\nPauses a set of downloads.\nDeprecated"
  },
  {
    "title": "pause(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1506053-pause",
    "html": "Parameters\ndownloads\n\nAn array of SKDownload objects to pause.\n\nSee Also\nDownloading Content\nfunc start([SKDownload])\nAdds a set of downloads to the download list.\nDeprecated\nfunc cancel([SKDownload])\nRemoves a set of downloads from the download list.\nDeprecated\nfunc resume([SKDownload])\nResumes a set of downloads.\nDeprecated"
  },
  {
    "title": "add(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1506036-add",
    "html": "Parameters\npayment\n\nA payment request.\n\nDiscussion\n\nAn application should always have at least one observer of the payment queue before adding payment requests.\n\nThe payment request must have a product identifier registered with the Apple App Store and a quantity greater than 0. If either property is invalid, add(_:) throws an exception.\n\nWhen a payment request is added to the queue, the payment queue processes that request with the Apple App Store and arranges for payment from the user. When that transaction is complete or if a failure occurs, the payment queue sends the SKPaymentTransaction object that encapsulates the request to all transaction observers.\n\nSee Also\nManaging Transactions\nvar delegate: (any SKPaymentQueueDelegate)?\nA delegate that provides information needed to complete transactions.\nvar transactions: [SKPaymentTransaction]\nReturns an array of pending transactions.\nfunc finishTransaction(SKPaymentTransaction)\nNotifies the App Store that the app finished processing the transaction."
  },
  {
    "title": "transactions",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1506026-transactions",
    "html": "Discussion\n\nThe value of this property is undefined when there are no observers attached to the payment queue.\n\nSee Also\nManaging Transactions\nvar delegate: (any SKPaymentQueueDelegate)?\nA delegate that provides information needed to complete transactions.\nfunc add(SKPayment)\nAdds a payment request to the queue.\nfunc finishTransaction(SKPaymentTransaction)\nNotifies the App Store that the app finished processing the transaction.\nRelated Documentation\nfunc add(any SKPaymentTransactionObserver)\nAdds an observer to the payment queue."
  },
  {
    "title": "delegate",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/3182429-delegate",
    "html": "Discussion\n\nThis delegate implements the SKPaymentQueueDelegate protocol.\n\nSee Also\nManaging Transactions\nvar transactions: [SKPaymentTransaction]\nReturns an array of pending transactions.\nfunc add(SKPayment)\nAdds a payment request to the queue.\nfunc finishTransaction(SKPaymentTransaction)\nNotifies the App Store that the app finished processing the transaction."
  },
  {
    "title": "restoreCompletedTransactions()",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1506123-restorecompletedtransactions",
    "html": "Discussion\n\nUse this method to restore finished transactions—that is, transactions for which you have already called finishTransaction(_:). You call this method in one of the following situations:\n\nTo install purchases on additional devices\n\nTo restore purchases for an application that the user deleted and reinstalled\n\nWhen you create a new product to be sold in your store, you choose whether that product can be restored or not. See the In-App Purchase Programming Guide for more information.\n\nThe payment queue delivers a new transaction for each previously completed transaction that can be restored. Each transaction includes a copy of the original transaction.\n\nAfter the transactions are delivered, the payment queue calls the observer’s paymentQueueRestoreCompletedTransactionsFinished(_:) method. If an error occurred while restoring transactions, the observer will be notified through its paymentQueue(_:restoreCompletedTransactionsFailedWithError:) method.\n\nThis method has no effect in the following situations:\n\nAll transactions are unfinished.\n\nThe user did not purchase anything that is restorable.\n\nYou tried to restore items that are not restorable, such as a non-renewing subscription or a consumable product.\n\nYour app's build version does not meet the guidelines for the CFBundleVersion key.\n\nImportant\n\nIf you are using the In-App Purchase API and managing transactions using the Transaction API, use currentEntitlements to determine which in-app purchases the customer is currently entitled to. The restoreCompletedTransactions() function doesn't affect transactions in the Transaction API. In rare cases when a user suspects the app isn’t showing all the transactions, call sync() in response to an explicit user action, like tapping a button.\n\nSee Also\nRestoring Purchases\nfunc restoreCompletedTransactions(withApplicationUsername: String?)\nAsks the payment queue to restore previously completed purchases, providing an opaque identifier for the user’s account."
  },
  {
    "title": "start(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1505998-start",
    "html": "Parameters\ndownloads\n\nAn array of SKDownload objects to begin downloading.\n\nDiscussion\n\nIn order for a download object to be queued, it must be associated with a transaction that has been successfully purchased, but not yet finished.\n\nSee Also\nDownloading Content\nfunc cancel([SKDownload])\nRemoves a set of downloads from the download list.\nDeprecated\nfunc pause([SKDownload])\nPauses a set of downloads.\nDeprecated\nfunc resume([SKDownload])\nResumes a set of downloads.\nDeprecated"
  },
  {
    "title": "cancel(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1506092-cancel",
    "html": "Parameters\ndownloads\n\nAn array of SKDownload objects to cancel.\n\nSee Also\nDownloading Content\nfunc start([SKDownload])\nAdds a set of downloads to the download list.\nDeprecated\nfunc pause([SKDownload])\nPauses a set of downloads.\nDeprecated\nfunc resume([SKDownload])\nResumes a set of downloads.\nDeprecated"
  },
  {
    "title": "showPriceConsentIfNeeded()",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/3521327-showpriceconsentifneeded",
    "html": "Discussion\n\nCall this method if the system called your delegate’s paymentQueueShouldShowPriceConsent(_:) method, and you chose to delay showing the price consent sheet.\n\nThis function displays the price consent sheet if both of the following are true:\n\nYou’ve increased the price of the subscription in App Store Connect.\n\nThe subscriber hasn’t yet responded to a price consent query.\n\nOtherwise, this function has no effect.\n\nNote\n\nWhen you increase the price of a subscription, Apple informs affected subscribers through an email, push notification, and in-app price consent sheet and asks them to agree to the new price. If they don’t agree or take no action, their subscription expires at the end of their current billing cycle. For more information, see Managing Prices and Manage pricing for auto-renewable subscriptions.\n\nIn Mac apps built with Mac Catalyst, this function has no effect.\n\nSee Also\nRelated Documentation\nfunc paymentQueueShouldShowPriceConsent(SKPaymentQueue) -> Bool\nAsks the delegate whether to immediately display a price consent sheet."
  },
  {
    "title": "add(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1506042-add",
    "html": "Parameters\nobserver\n\nThe observer to add to the queue.\n\nDiscussion\n\nYour application should add an observer to the payment queue during application initialization. If there are no observers attached to the queue, the payment queue does not synchronize its list of pending transactions with the Apple App Store, because there is no observer to respond to updated transactions.\n\nIf an application quits when transactions are still being processed, those transactions are not lost. The next time the application launches, the payment queue resumes processing the transactions. Your application should always expect to be notified of completed transactions.\n\nIf more than one transaction observer is attached to the payment queue, no guarantees are made as to the order which they will be called. It is safe for multiple observers to call finishTransaction(_:), but not recommended. It is recommended that you use a single observer to process and finish the transaction.\n\nSee Also\nAdding, Getting, and Removing Observers\nvar transactionObservers: [any SKPaymentTransactionObserver]\nAn array of all active payment queue observers.\nfunc remove(any SKPaymentTransactionObserver)\nRemoves an observer from the payment queue.\nRelated Documentation\nvar transactions: [SKPaymentTransaction]\nReturns an array of pending transactions."
  },
  {
    "title": "appBundleID",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749685-appbundleid",
    "html": "See Also\nIdentifying the app and product\nlet productID: String\nThe product identifier of the in-app purchase.\nlet productType: Product.ProductType\nThe type of the in-app purchase.\nlet subscriptionGroupID: String?\nThe identifier of the subscription group that the subscription belongs to."
  },
  {
    "title": "price",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/3749562-price",
    "html": "See Also\nGetting price information\nlet displayPrice: String\nThe localized string representation of the discounted price of the subscription offer.\nlet paymentMode: Product.SubscriptionOffer.PaymentMode\nThe offer's payment mode.\nstruct Product.SubscriptionOffer.PaymentMode\nThe payment modes for subscription offers."
  },
  {
    "title": "debugDescription",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/3791967-debugdescription",
    "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
  },
  {
    "title": "playMusic",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupmessageidentifier/2909047-playmusic",
    "html": "See Also\nMessage Identifiers\nstatic let addMusic: SKCloudServiceSetupMessageIdentifier\nMessage identifier for adding music.\nstatic let connect: SKCloudServiceSetupMessageIdentifier\nMessage identifier for connecting.\nstatic let join: SKCloudServiceSetupMessageIdentifier\nMessage identifier for joining."
  },
  {
    "title": "Transaction.RefundRequestStatus.userCancelled",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequeststatus/usercancelled",
    "html": "See Also\nGetting Refund Request Status\ncase success\nThe App Store has received the refund request."
  },
  {
    "title": "affiliateToken",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupoptionskey/2838455-affiliatetoken",
    "html": "See Also\nIndicating Setup Options\nstatic let action: SKCloudServiceSetupOptionsKey\nA key that specifies the action for a setup entry point.\nstruct SKCloudServiceSetupAction\nA string used to specify the type of setup action to offer for a cloud service.\nstatic let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store item that the user is trying to access through the service.\nstatic let campaignToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate campaign token.\nstatic let messageIdentifier: SKCloudServiceSetupOptionsKey\nA key that is used to select the main message presented to the user for this setup view.\nstruct SKCloudServiceSetupMessageIdentifier\nIdentifiers for the available messages the setup view can present to the user."
  },
  {
    "title": "join",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupmessageidentifier/2909045-join",
    "html": "See Also\nMessage Identifiers\nstatic let addMusic: SKCloudServiceSetupMessageIdentifier\nMessage identifier for adding music.\nstatic let connect: SKCloudServiceSetupMessageIdentifier\nMessage identifier for connecting.\nstatic let playMusic: SKCloudServiceSetupMessageIdentifier\nMessage identifier for playing music."
  },
  {
    "title": "addMusic",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupmessageidentifier/2909050-addmusic",
    "html": "See Also\nMessage Identifiers\nstatic let connect: SKCloudServiceSetupMessageIdentifier\nMessage identifier for connecting.\nstatic let join: SKCloudServiceSetupMessageIdentifier\nMessage identifier for joining.\nstatic let playMusic: SKCloudServiceSetupMessageIdentifier\nMessage identifier for playing music."
  },
  {
    "title": "messageIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupoptionskey/2909049-messageidentifier",
    "html": "Discussion\n\nIf this key is missing, the setup view is configured as if it is using the join key by default.\n\nSee Also\nIndicating Setup Options\nstatic let action: SKCloudServiceSetupOptionsKey\nA key that specifies the action for a setup entry point.\nstruct SKCloudServiceSetupAction\nA string used to specify the type of setup action to offer for a cloud service.\nstatic let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store item that the user is trying to access through the service.\nstatic let affiliateToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate token.\nstatic let campaignToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate campaign token.\nstruct SKCloudServiceSetupMessageIdentifier\nIdentifiers for the available messages the setup view can present to the user."
  },
  {
    "title": "action",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupoptionskey/2609455-action",
    "html": "See Also\nIndicating Setup Options\nstruct SKCloudServiceSetupAction\nA string used to specify the type of setup action to offer for a cloud service.\nstatic let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store item that the user is trying to access through the service.\nstatic let affiliateToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate token.\nstatic let campaignToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate campaign token.\nstatic let messageIdentifier: SKCloudServiceSetupOptionsKey\nA key that is used to select the main message presented to the user for this setup view.\nstruct SKCloudServiceSetupMessageIdentifier\nIdentifiers for the available messages the setup view can present to the user."
  },
  {
    "title": "cloudServiceSetupViewControllerDidDismiss(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupviewcontrollerdelegate/2609449-cloudservicesetupviewcontrollerd",
    "html": "Parameters\ncloudServiceSetupViewController\n\nThe cloud service view controller that was dismissed."
  },
  {
    "title": "debugDescription",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3791910-debugdescription",
    "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3749442-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing purchase options\nstatic func != (Product.PurchaseOption, Product.PurchaseOption) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.PurchaseOption, Product.PurchaseOption) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3749439",
    "html": "See Also\nComparing and hashing purchase options\nstatic func != (Product.PurchaseOption, Product.PurchaseOption) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequeststatus/3749670-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and Hashing Refund Request Status\nstatic func != (Transaction.RefundRequestStatus, Transaction.RefundRequestStatus) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Transaction.RefundRequestStatus, Transaction.RefundRequestStatus) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3749438",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing purchase options\nstatic func == (Product.PurchaseOption, Product.PurchaseOption) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "Transaction.OwnershipType.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/ownershiptype/rawvalue",
    "html": "See Also\nAccessing the raw value\nlet rawValue: String\nThe raw string value that represents a transaction ownership type."
  },
  {
    "title": "Transaction.OwnershipType",
    "url": "https://developer.apple.com/documentation/storekit/transaction/ownershiptype",
    "html": "Topics\nGetting ownership types\nstatic let familyShared: Transaction.OwnershipType\nThe transaction belongs to a family member who benefits from the service.\nstatic let purchased: Transaction.OwnershipType\nThe transaction belongs to the purchaser.\nGetting a localized description\nvar localizedDescription: String\nThe localized text that describes the ownership type.\nAccessing the raw value\nlet rawValue: String\nThe raw string value that represents a transaction ownership type.\ntypealias Transaction.OwnershipType.RawValue\nThe type that represents the raw value of a transaction’s ownership type.\nCreating ownership types\ninit(rawValue: String)\nCreates a transaction ownership type instance from a raw value.\nComparing and hashing types\nstatic func != (Transaction.OwnershipType, Transaction.OwnershipType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSee Also\nGetting purchase details\nlet isUpgraded: Bool\nA Boolean that indicates whether the user upgraded to another subscription.\nlet ownershipType: Transaction.OwnershipType\nA value that indicates whether the transaction was purchased by the user, or is made available to them through Family Sharing.\ntypealias Transaction.OwnershipType.RawValue\nThe type that represents the raw value of a transaction’s ownership type.\nlet purchasedQuantity: Int\nThe number of consumable products purchased."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror/4143428-hash",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing errors\nstatic func != (PaymentMethodBinding.PaymentMethodBindingError, PaymentMethodBinding.PaymentMethodBindingError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (PaymentMethodBinding.PaymentMethodBindingError, PaymentMethodBinding.PaymentMethodBindingError) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "deviceVerification",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3749497-deviceverification",
    "html": "Discussion\n\nFor more information, see deviceVerificationID.\n\nSee Also\nVerifying subscription renewal information\nlet deviceVerificationNonce: UUID\nThe UUID to use to compute the device verification value.\nlet signedDate: Date\nThe date that the App Store signed the JWS renewal information."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/3749428",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Errors\nstatic func == (Product.PurchaseError, Product.PurchaseError) -> Bool\nvar hashValue: Int\nfunc hash(into: inout Hasher)"
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/3749430-hash",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing Errors\nstatic func != (Product.PurchaseError, Product.PurchaseError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.PurchaseError, Product.PurchaseError) -> Bool\nvar hashValue: Int"
  },
  {
    "title": "failureReason",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/3916867-failurereason",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nGetting Error Properties\nvar localizedDescription: String\nvar errorDescription: String?\nvar helpAnchor: String?\nvar recoverySuggestion: String?"
  },
  {
    "title": "errorDescription",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/3916866-errordescription",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nGetting Error Properties\nvar localizedDescription: String\nvar failureReason: String?\nvar helpAnchor: String?\nvar recoverySuggestion: String?"
  },
  {
    "title": "helpAnchor",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror/3916868-helpanchor",
    "html": "See Also\nGetting Error Properties\nvar localizedDescription: String\nvar errorDescription: String?\nvar failureReason: String?\nvar recoverySuggestion: String?"
  },
  {
    "title": "update(storePromotionOrder:completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skproductstorepromotioncontroller/2915874-update",
    "html": "Discussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc update(promotionOrder: [SKProduct]) async throws\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThe default order of promoted in-app purchase products is set in App Store Connect. You can override this order per device. For example, you can promote an in-app purchase product that unlocks a specific level in your game when a user reaches the level immediately before the specified level.\n\nTo override the default product order, put the product information for the subset of products you want to reorder into an array, in the order you want them to appear in. Pass the array to the update(storePromotionOrder:completionHandler:) method. The products in the array are shown at the beginning of the list, followed by the remaining in-app purchase products, which are listed in the same relative order that you set in App Store Connect.\n\nTo cancel order overrides, send an empty product array to the update(storePromotionOrder:completionHandler:) method. The in-app purchase products will be displayed in the default order.\n\nSee Also\nManaging promoted product order\nfunc fetchStorePromotionOrder(completionHandler: (([SKProduct], (any Error)?) -> Void)?)\nReads the product order override that determines the promoted product order on this device."
  },
  {
    "title": "fetchStorePromotionVisibility(for:completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skproductstorepromotioncontroller/2915867-fetchstorepromotionvisibility",
    "html": "Discussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc promotionVisibility(for product: SKProduct) async throws -> SKProductStorePromotionVisibility\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThe default visibility for a promoted product is set in App Store Connect. Call fetchStorePromotionVisibility(for:completionHandler:) to determine if a product's visibility is set to the default value or if it has been overridden to be hidden or shown.\n\nSee Also\nManaging promoted product visibility\nfunc update(storePromotionVisibility: SKProductStorePromotionVisibility, for: SKProduct, completionHandler: (((any Error)?) -> Void)?)\nUpdates the visibility of the product on the App Store, per device.\nenum SKProductStorePromotionVisibility\nThe visibility settings that determine if an in-app purchase is visible on a device."
  },
  {
    "title": "Product.SubscriptionPeriod.Unit.FormatStyle",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/formatstyle",
    "html": "Topics\nCreating a format style\ninit(from: any Decoder)\nFormatting subscription period units\nfunc format(Product.SubscriptionPeriod.Unit) -> String\nfunc locale(Locale) -> Product.SubscriptionPeriod.Unit.FormatStyle\nfunc encode(to: any Encoder)\nComparing and hashing period unit formats\nstatic func != (Product.SubscriptionPeriod.Unit.FormatStyle, Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionPeriod.Unit.FormatStyle, Product.SubscriptionPeriod.Unit.FormatStyle) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nGetting data types\ntypealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatInput\ntypealias Product.SubscriptionPeriod.Unit.FormatStyle.FormatOutput\nApplying list styles\nstatic func list<Base>(type: ListFormatStyle<StringStyle, Base>.ListType, width: ListFormatStyle<StringStyle, Base>.Width) -> ListFormatStyle<StringStyle, Base>\nstatic func list<MemberStyle, Base>(memberStyle: MemberStyle, type: ListFormatStyle<MemberStyle, Base>.ListType, width: ListFormatStyle<MemberStyle, Base>.Width) -> ListFormatStyle<MemberStyle, Base>\nApplying measurement styles\nstatic func measurement<UnitType>(width: Measurement<UnitType>.FormatStyle.UnitWidth, usage: MeasurementFormatUnitUsage<UnitType>, numberFormatStyle: FloatingPointFormatStyle<Double>?) -> Measurement<UnitType>.FormatStyle\nstatic func measurement(width: Measurement<UnitTemperature>.FormatStyle.UnitWidth, usage: MeasurementFormatUnitUsage<UnitTemperature>, hidesScaleName: Bool, numberFormatStyle: FloatingPointFormatStyle<Double>?) -> Measurement<UnitTemperature>.FormatStyle\nApplying currency styles\nstatic func currency<Value>(code: String) -> FloatingPointFormatStyle<Value>.Currency\nstatic func currency<V>(code: String) -> IntegerFormatStyle<V>.Currency\nRelationships\nConforms To\nFormatStyle\nSee Also\nGetting the formatted description\nfunc formatted<S>(S) -> S.FormatOutput"
  },
  {
    "title": "fetchStorePromotionOrder(completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skproductstorepromotioncontroller/2915873-fetchstorepromotionorder",
    "html": "Discussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc promotionOrder() async throws -> [SKProduct]\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nThis function returns an array of promoted products whose order is overridden on the given device.\n\nIf all the products appear in the default order, this method returns an empty array.\n\nSee Also\nManaging promoted product order\nfunc update(storePromotionOrder: [SKProduct], completionHandler: (((any Error)?) -> Void)?)\nOverrides the promoted product order on this device."
  },
  {
    "title": "Product.SubscriptionPeriod.Unit.month",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/unit/month",
    "html": "See Also\nGetting the subscription period units\ncase day\nA subscription period unit of a day.\ncase week\nA subscription period unit of a week.\ncase year\nA subscription period unit of a year."
  },
  {
    "title": "Transaction.Transactions.Element",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/element",
    "html": "See Also\nCreating an Iterator\nfunc makeAsyncIterator() -> Transaction.Transactions.AsyncIterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Transaction.Transactions.AsyncIterator\nThe asynchronous iterator that produces elements of the asynchronous sequence."
  },
  {
    "title": "Transaction.Transactions.AsyncIterator",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/asynciterator",
    "html": "Topics\nGetting the Next Element\nfunc next() -> VerificationResult<Transaction>?\nAdvances to the next element and returns either the element or nil if there isn’t a next element.\ntypealias Transaction.Transactions.AsyncIterator.Element\nThe type of element produced by this iterator.\nRelationships\nFrom Protocol\nAsyncSequence\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an Iterator\nfunc makeAsyncIterator() -> Transaction.Transactions.AsyncIterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\ntypealias Transaction.Transactions.Element\nThe type of element traversed by the iterator."
  },
  {
    "title": "makeAsyncIterator()",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851187-makeasynciterator",
    "html": "Relationships\nFrom Protocol\nAsyncSequence\nSee Also\nCreating an Iterator\nstruct Transaction.Transactions.AsyncIterator\nThe asynchronous iterator that produces elements of the asynchronous sequence.\ntypealias Transaction.Transactions.Element\nThe type of element traversed by the iterator."
  },
  {
    "title": "providerToken",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appconfiguration/3612099-providertoken",
    "html": "Discussion\n\nWhen you set a provider token, you must also set the campaignToken.\n\nWhen promoting your own apps, set your own provider token using providerToken. This allows you to track a promotion’s effectiveness independently from any affiliate campaign that shares the same campaign token.\n\nWhen promoting apps by other developers, set providerToken using their provider token. This allows those developers to track the effectiveness of your App Store Connect Analytics campaign.\n\nSee Also\nVerifying Advertising Campaigns\nvar campaignToken: String?\nA token you use to represent an ad campaign and measure its effectiveness.\nfunc setAdditionalValue(Any?, forKey: String)\nSets an additional value for a key; for example, a value for measuring the effectiveness of an ad campaign.\nfunc additionalValue(forKey: String) -> Any?\nReturns the object associated with the key."
  },
  {
    "title": "period",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/3749560-period",
    "html": "See Also\nGetting the subscription duration\nlet periodCount: Int\nThe number of periods that the subscription offer renews for."
  },
  {
    "title": "type",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/3749563-type",
    "html": "See Also\nGetting the subscription offer type\nstruct Product.SubscriptionOffer.OfferType\nThe types of subscription offers."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851183-flatmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n\nSee Also\nTransforming a Sequence\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncThrowingMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, VerificationResult<Transaction>) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, VerificationResult<Transaction>) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "displayPrice",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/3749557-displayprice",
    "html": "See Also\nGetting price information\nlet price: Decimal\nThe decimal representation of the discounted price of the subscription offer.\nlet paymentMode: Product.SubscriptionOffer.PaymentMode\nThe offer's payment mode.\nstruct Product.SubscriptionOffer.PaymentMode\nThe payment modes for subscription offers."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851169-compactmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n\nSee Also\nTransforming a Sequence\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncThrowingMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, VerificationResult<Transaction>) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, VerificationResult<Transaction>) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851185-flatmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n\nSee Also\nTransforming a Sequence\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncThrowingMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, VerificationResult<Transaction>) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, VerificationResult<Transaction>) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "isUpgraded",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3812954-isupgraded",
    "html": "Discussion\n\nIf isUpgraded is true, the user has upgraded the subscription represented by this transaction to another subscription. This value appears in the transaction only when the value is true. To determine the service that the customer is entitled to, look for another transaction that has a subscription with a higher level of service.\n\nSee Also\nGetting purchase details\nlet ownershipType: Transaction.OwnershipType\nA value that indicates whether the transaction was purchased by the user, or is made available to them through Family Sharing.\ntypealias Transaction.OwnershipType.RawValue\nThe type that represents the raw value of a transaction’s ownership type.\nstruct Transaction.OwnershipType\nThe types the system uses to describe whether the user purchased the product or it’s available to them through Family Sharing.\nlet purchasedQuantity: Int\nThe number of consumable products purchased."
  },
  {
    "title": "expirationDate",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749693-expirationdate",
    "html": "See Also\nGetting purchase and expiration dates\nlet purchaseDate: Date\nThe date that the App Store charged the user’s account for a purchased or restored product, or for a subscription purchase or renewal after a lapse."
  },
  {
    "title": "productID",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749707-productid",
    "html": "Discussion\n\nYou create product identifiers for in-app purchases in App Store Connect.\n\nSee Also\nIdentifying the app and product\nlet appBundleID: String\nThe bundle identifier for the app.\nlet productType: Product.ProductType\nThe type of the in-app purchase.\nlet subscriptionGroupID: String?\nThe identifier of the subscription group that the subscription belongs to."
  },
  {
    "title": "subscriptionGroupID",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749718-subscriptiongroupid",
    "html": "See Also\nIdentifying the app and product\nlet appBundleID: String\nThe bundle identifier for the app.\nlet productID: String\nThe product identifier of the in-app purchase.\nlet productType: Product.ProductType\nThe type of the in-app purchase."
  },
  {
    "title": "productType",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749708-producttype",
    "html": "See Also\nIdentifying the app and product\nlet appBundleID: String\nThe bundle identifier for the app.\nlet productID: String\nThe product identifier of the in-app purchase.\nlet subscriptionGroupID: String?\nThe identifier of the subscription group that the subscription belongs to."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851167-compactmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nTransforming a Sequence\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncThrowingMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, VerificationResult<Transaction>) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, VerificationResult<Transaction>) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749697-id",
    "html": "Discussion\n\nNote\n\nThis documentation comment was inherited from Identifiable.\n\nSee Also\nIdentifying a transaction\nlet id: UInt64\nThe unique identifier for the transaction.\ntypealias Transaction.ID\nA type representing the transaction identifier.\nlet webOrderLineItemID: String?\nA unique ID that identifies subscription purchase events across devices, including subscription renewals."
  },
  {
    "title": "webOrderLineItemID",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749723-weborderlineitemid",
    "html": "See Also\nIdentifying a transaction\nlet id: UInt64\nThe unique identifier for the transaction.\ntypealias Transaction.ID\nA type representing the transaction identifier.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Transaction conforms to AnyObject."
  },
  {
    "title": "Transaction.ID",
    "url": "https://developer.apple.com/documentation/storekit/transaction/id",
    "html": "See Also\nIdentifying a transaction\nlet id: UInt64\nThe unique identifier for the transaction.\nlet webOrderLineItemID: String?\nA unique ID that identifies subscription purchase events across devices, including subscription renewals.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Transaction conforms to AnyObject."
  },
  {
    "title": "filter(_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851179-filter",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n\nSee Also\nExcluding Transactions\nfunc drop(while: (VerificationResult<Transaction>) -> Bool) -> AsyncDropWhileSequence<Transaction.Transactions>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Transaction.Transactions>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements."
  },
  {
    "title": "dropFirst(_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851177-dropfirst",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nSee Also\nExcluding Transactions\nfunc drop(while: (VerificationResult<Transaction>) -> Bool) -> AsyncDropWhileSequence<Transaction.Transactions>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc filter((VerificationResult<Transaction>) -> Bool) -> AsyncFilterSequence<Transaction.Transactions>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "min(by:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851194-min",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n\nSee Also\nFinding Transactions\nfunc allSatisfy((VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(VerificationResult<Transaction>) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/3791964",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing subscription periods\nstatic func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/3791965",
    "html": "See Also\nComparing and hashing subscription periods\nstatic func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "prefix(while:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851198-prefix",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n\nSee Also\nSelecting Transactions\nfunc prefix(Int) -> AsyncPrefixSequence<Transaction.Transactions>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/3791969-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing subscription periods\nstatic func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod/3791968-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing subscription periods\nstatic func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "max(by:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851192-max",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n\nSee Also\nFinding Transactions\nfunc allSatisfy((VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(VerificationResult<Transaction>) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "SKOverlay.Position.bottomRaised",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/position/bottomraised",
    "html": "Discussion\n\nUse this position in case your app uses a UITabBar.\n\nSee Also\nDescribing the Overlay’s Position\ncase bottom\nSpecifies that the overlay is at the bottom of the screen."
  },
  {
    "title": "automatic",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyle/4278709-automatic",
    "html": "See Also\nGetting built-in product view styles\nstatic var compact: CompactProductViewStyle\nAn product view style suitable for layouts where less space is available, or for displaying more items in a small amount of space.\nAvailable when Self is CompactProductViewStyle.\nstatic var large: LargeProductViewStyle\nA product view style suitable for layouts where the in-app purchase content is prominent.\nAvailable when Self is LargeProductViewStyle.\nstatic var regular: RegularProductViewStyle\nA product view style that uses a standard, platform-appropriate layout.\nAvailable when Self is RegularProductViewStyle."
  },
  {
    "title": "SKOverlay.Position.bottom",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/position/bottom",
    "html": "See Also\nDescribing the Overlay’s Position\ncase bottomRaised\nSpecifies that the overlay is at a raised position at the bottom of the screen."
  },
  {
    "title": "productViewControllerDidFinish(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductviewcontrollerdelegate/1620620-productviewcontrollerdidfinish",
    "html": "Parameters\nviewController\n\nThe store view controller whose interface was dismissed by the user.\n\nDiscussion\n\nYour delegate should call the dismissModalViewController(animated:) method on the view controller that originally presented the store screen. If your app paused any other activities before presenting the store, it can restart those services in this method.\n\nSee Also\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "Transaction.RefundRequestStatus.success",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequeststatus/success",
    "html": "See Also\nGetting Refund Request Status\ncase userCancelled\nThe user canceled submission of their refund request."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequeststatus/3749667",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and Hashing Refund Request Status\nstatic func == (Transaction.RefundRequestStatus, Transaction.RefundRequestStatus) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequeststatus/3749669-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and Hashing Refund Request Status\nstatic func != (Transaction.RefundRequestStatus, Transaction.RefundRequestStatus) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Transaction.RefundRequestStatus, Transaction.RefundRequestStatus) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequeststatus/3749668",
    "html": "See Also\nComparing and Hashing Refund Request Status\nstatic func != (Transaction.RefundRequestStatus, Transaction.RefundRequestStatus) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "offerPaymentModeStringRepresentation",
    "url": "https://developer.apple.com/documentation/storekit/transaction/4307077-offerpaymentmodestringrepresenta",
    "html": "Deprecated\n\nUse paymentMode instead.\n\nSee Also\nDeprecated\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var environmentStringRepresentation: String\nA string representation of the server environment.\nDeprecated\nvar offerID: String?\nA string that identifies an offer applied to the current subscription.\nDeprecated\nvar offerType: Transaction.OfferType?\nThe subscription offer type for the current subscription period.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var reasonStringRepresentation: String\nThe string representation of the transaction reason.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var storefrontCountryCode: String\nThe three-letter code that represents the country or region associated with the App Store storefront of the purchase.\nDeprecated"
  },
  {
    "title": "Transaction.Offer",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offer",
    "html": "Overview\n\nSubscription offers include introductory offers, promotional offers, and offer codes. You set up subscription offers in App Store Connect. If a customer redeems an offer, it appears in the offer property of the transaction.\n\nFor more information about subscription offers, see Providing subscription offers.\n\nTopics\nGetting offer details\nlet id: String?\nA string that identifies the subscription offer that applies to the transaction.\nlet type: Transaction.OfferType\nThe type of subscription offer that applies to the transaction.\nstruct Transaction.OfferType\nThe types of offers for auto-renewable subscriptions.\nstruct Transaction.Offer.PaymentMode\nThe payment modes for subscription offers that apply to a transaction.\nComparing offers\nstatic func == (Transaction.Offer, Transaction.Offer) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nstatic func != (Transaction.Offer, Transaction.Offer) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nInstance Properties\nlet paymentMode: Transaction.Offer.PaymentMode?\nRelationships\nConforms To\nHashable\nSendable\nSee Also\nIdentifying subscription offers\nlet offer: Transaction.Offer?\nThe subscription offer that applies to the transaction, including its offer type, payment mode, and ID."
  },
  {
    "title": "environmentStringRepresentation",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3976514-environmentstringrepresentation",
    "html": "Deprecated\n\nUse environment instead.\n\nSee Also\nDeprecated\nvar offerID: String?\nA string that identifies an offer applied to the current subscription.\nDeprecated\n@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2) var offerPaymentModeStringRepresentation: String?\nThe string representation of the payment mode for a subscription offer.\nDeprecated\nvar offerType: Transaction.OfferType?\nThe subscription offer type for the current subscription period.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var reasonStringRepresentation: String\nThe string representation of the transaction reason.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var storefrontCountryCode: String\nThe three-letter code that represents the country or region associated with the App Store storefront of the purchase.\nDeprecated"
  },
  {
    "title": "appAccountToken",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749684-appaccounttoken",
    "html": "Discussion\n\nYou create an appAccountToken(_:) and send it to the App Store when a customer initiates an in-app purchase. The App Store returns the same value in appAccountToken in the transaction information after the customer completes the purchase."
  },
  {
    "title": "storefrontCountryCode",
    "url": "https://developer.apple.com/documentation/storekit/transaction/4193542-storefrontcountrycode",
    "html": "Deprecated\n\nUse storefront instead.\n\nDiscussion\n\nThis property uses the ISO 3166-1 alpha-3 country code representation.\n\nSee Also\nDeprecated\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var environmentStringRepresentation: String\nA string representation of the server environment.\nDeprecated\nvar offerID: String?\nA string that identifies an offer applied to the current subscription.\nDeprecated\n@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2) var offerPaymentModeStringRepresentation: String?\nThe string representation of the payment mode for a subscription offer.\nDeprecated\nvar offerType: Transaction.OfferType?\nThe subscription offer type for the current subscription period.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var reasonStringRepresentation: String\nThe string representation of the transaction reason.\nDeprecated"
  },
  {
    "title": "reasonStringRepresentation",
    "url": "https://developer.apple.com/documentation/storekit/transaction/4193540-reasonstringrepresentation",
    "html": "Deprecated\n\nUse reason instead.\n\nDiscussion\n\nFor more information, see reason.\n\nSee Also\nDeprecated\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var environmentStringRepresentation: String\nA string representation of the server environment.\nDeprecated\nvar offerID: String?\nA string that identifies an offer applied to the current subscription.\nDeprecated\n@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2) var offerPaymentModeStringRepresentation: String?\nThe string representation of the payment mode for a subscription offer.\nDeprecated\nvar offerType: Transaction.OfferType?\nThe subscription offer type for the current subscription period.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var storefrontCountryCode: String\nThe three-letter code that represents the country or region associated with the App Store storefront of the purchase.\nDeprecated"
  },
  {
    "title": "offer",
    "url": "https://developer.apple.com/documentation/storekit/transaction/4307076-offer",
    "html": "Discussion\n\nThis value is nil if the transaction doesn’t include an offer.\n\nSubscription offers include introductory offers, promotional offers, and offer codes. You set up subscription offers in App Store Connect. If a customer redeems an offer, this property contains the offer details, including its type, paymentMode, and id. For more information about the details, see Transaction.Offer.\n\nSee Also\nIdentifying subscription offers\nstruct Transaction.Offer\nThe subscription offers that apply to a transaction."
  },
  {
    "title": "Transaction.RevocationReason.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/revocationreason/rawvalue",
    "html": "See Also\nRevocation reasons\nstatic let developerIssue: Transaction.RevocationReason\nThe value that indicates a customer canceled the transaction due to an actual or perceived issue within your app.\nstatic let other: Transaction.RevocationReason\nThe value that indicates a customer canceled the transaction for other reasons."
  },
  {
    "title": "Transaction.RevocationReason",
    "url": "https://developer.apple.com/documentation/storekit/transaction/revocationreason",
    "html": "Topics\nRevocation reasons\nstatic let developerIssue: Transaction.RevocationReason\nThe value that indicates a customer canceled the transaction due to an actual or perceived issue within your app.\nstatic let other: Transaction.RevocationReason\nThe value that indicates a customer canceled the transaction for other reasons.\ntypealias Transaction.RevocationReason.RawValue\nThe type that represents the raw value of a transaction revocation reason.\nGetting a localized description\nvar localizedDescription: String\nThe localized text that describes the revocation reason.\nComparing and hashing reasons\nstatic func != (Transaction.RevocationReason, Transaction.RevocationReason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nlet rawValue: Int\nThe raw value of a transaction revocation reason.\nInitializing reasons\ninit(rawValue: Int)\nCreates a revocation reason from a raw value.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSee Also\nGetting revocation status\nlet revocationDate: Date?\nThe date that the App Store refunded the transaction or revoked it from Family Sharing.\nlet revocationReason: Transaction.RevocationReason?\nThe reason that the App Store refunded the transaction or revoked it from Family Sharing.\ntypealias Transaction.RevocationReason.RawValue\nThe type that represents the raw value of a transaction revocation reason."
  },
  {
    "title": "codeOffer(referenceName:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/4196325-codeoffer",
    "html": "Parameters\nreferenceName\n\nThe reference name of the offer code to apply to the transaction. You need to set up offer codes in your StoreKit configuration file.\n\nDiscussion\n\nUse this purchase option when you test your app in Xcode using StoreKit Test and call buyProduct(identifier:options:).\n\nSet up the offer codes to use in this call in your StoreKit configuration file. For more information, see Setting up StoreKit Testing in Xcode.\n\nWhen you apply this option, the purchase transaction simulates a customer redeeming an offer code and includes the offer code you specify.\n\nSee Also\nSetting options for StoreKit Testing in Xcode\nstatic func purchaseDate(Date, renewalBehavior: Product.PurchaseOption.SubscriptionRenewalBehavior) -> Product.PurchaseOption\nSets the purchase date for the transaction in the testing environment, and indicates the renewal behavior for an auto-renewable subscription.\nenum Product.PurchaseOption.SubscriptionRenewalBehavior\nRenewal options for auto-renewable subscriptions that you purchase in the testing environment.\nstatic func promotionalOffer(id: String) -> Product.PurchaseOption\nSets a promotional offer for the transaction in the testing environment."
  },
  {
    "title": "Product.PurchaseOption.SubscriptionRenewalBehavior",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/subscriptionrenewalbehavior",
    "html": "Overview\n\nUse the subscription renewal behavior values when you use the purchaseDate option to test your app in Xcode using StoreKit Test.\n\nTopics\nRenewal behaviors in the testing environment\ncase cancelImmediately\nA subscription-renewal behavior in the testing environment that cancels the subscription, resulting in only one subscription period.\ncase renewUntilNow\nA subscription-renewal behavior in the testing environment that allows the subscription to renew continuously, up to the current date.\nCreating renewal behaviors\ninit(from: any Decoder)\nCreates a subscription renewal behavior.\nDefault implementations\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nstatic func == (Product.PurchaseOption.SubscriptionRenewalBehavior, Product.PurchaseOption.SubscriptionRenewalBehavior) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc encode(to: any Encoder)\nEncodes this value into the given encoder.\nRelationships\nConforms To\nDecodable\nEncodable\nHashable\nSendable\nSee Also\nSetting options for StoreKit Testing in Xcode\nstatic func purchaseDate(Date, renewalBehavior: Product.PurchaseOption.SubscriptionRenewalBehavior) -> Product.PurchaseOption\nSets the purchase date for the transaction in the testing environment, and indicates the renewal behavior for an auto-renewable subscription.\nstatic func codeOffer(referenceName: String) -> Product.PurchaseOption\nSets an offer code for the transaction in the testing environment.\nstatic func promotionalOffer(id: String) -> Product.PurchaseOption\nSets a promotional offer for the transaction in the testing environment."
  },
  {
    "title": "onStorefrontChange(shouldContinuePurchase:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3868403-onstorefrontchange",
    "html": "Parameters\nshouldContinuePurchase\n\nA closure that returns a Boolean value to indicate whether the purchase needs to continue when the App Store storefront changes to the storefront value during a transaction.\n\nReturn Value\n\nProduct.PurchaseOption\n\nDiscussion\n\nThe default value is true if this option isn’t added to the purchase.\n\nSee Also\nSetting the purchase options\nstatic func appAccountToken(UUID) -> Product.PurchaseOption\nSets a UUID to associate the purchase with an account in your system.\nstatic func promotionalOffer(offerID: String, keyID: String, nonce: UUID, signature: Data, timestamp: Int) -> Product.PurchaseOption\nApplies a promotional offer for an auto-renewable subscription.\nstatic func quantity(Int) -> Product.PurchaseOption\nIndicates the quantity of items the customer is purchasing."
  },
  {
    "title": "purchaseDate(_:renewalBehavior:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/4196327-purchasedate",
    "html": "Parameters\ndate\n\nThe purchase date for the transaction. Specify a date in the past or the current moment. Dates in the future aren’t valid.\n\nrenewalBehavior\n\nThe renewal behavior for the auto-renewable subscription in this transaction, whether it renews continuously from the purchase date, or it cancels after the first period. By default, the subscription renews.\n\nDiscussion\n\nUse this purchase option when you test your app in Xcode using StoreKit Test and call buyProduct(identifier:options:).\n\nUse this purchase option to create useful transactions for your test cases. For example, use a date in the past with the default renewalBehavior to generate a full history of subscription renewals to test. Or, use a date in the past with the Product.PurchaseOption.SubscriptionRenewalBehavior.cancelImmediately behavior to simulate an account of a customer who canceled their subscription.\n\nSee Also\nSetting options for StoreKit Testing in Xcode\nenum Product.PurchaseOption.SubscriptionRenewalBehavior\nRenewal options for auto-renewable subscriptions that you purchase in the testing environment.\nstatic func codeOffer(referenceName: String) -> Product.PurchaseOption\nSets an offer code for the transaction in the testing environment.\nstatic func promotionalOffer(id: String) -> Product.PurchaseOption\nSets a promotional offer for the transaction in the testing environment."
  },
  {
    "title": "recoverySuggestion",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror/3916885-recoverysuggestion",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nError Descriptions\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar localizedDescription: String\nA localized error description.\nvar failureReason: String?\nA localized message describing the reason for the failure.\nvar helpAnchor: String?\nA message providing “help” text if the user requests help by pressing an alert panel help anchor button."
  },
  {
    "title": "Transaction.RefundRequestError.duplicateRequest",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror/duplicaterequest",
    "html": "Discussion\n\nStoreKit returns this error if the App Store has previously received a refund request for this transaction and the refund decision is still pending, has been previously denied, or has been previously approved.\n\nConsider checking the transaction’s revocationDate or revocationReason before calling beginRefundRequest(for:in:) to identify whether the App Store has already refunded the transaction.\n\nSee Also\nError Enumeration\ncase failed\nThe refund request submission failed."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/3791960",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing subscription offers\nstatic func == (Product.SubscriptionOffer, Product.SubscriptionOffer) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "contains(where:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851173-contains",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFinding Transactions\nfunc allSatisfy((VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(VerificationResult<Transaction>) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc first(where: (VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851171-contains",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n\nSee Also\nFinding Transactions\nfunc allSatisfy((VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(where: (VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "first(where:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851181-first",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFinding Transactions\nfunc allSatisfy((VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(VerificationResult<Transaction>) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc max(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "onInAppPurchaseCompletion(perform:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203485-oninapppurchasecompletion",
    "html": "See Also\nResponding to store events\nfunc inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) -> View\nAdds a function the system calls before it processes a purchase from a store view, which provides a set of purchase options.\nfunc onInAppPurchaseStart(perform: ((Product) -> ())?) -> View\nAdds an action to perform when a user triggers the purchase button on a product within this view.\nenum EntitlementTaskState\nThe state of an entitlement task."
  },
  {
    "title": "body",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203245-body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing store views\ntypealias StoreView.Body\nThe type of view that represents the body of the store view."
  },
  {
    "title": "onInAppPurchaseStart(perform:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203486-oninapppurchasestart",
    "html": "See Also\nResponding to store events\nfunc inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) -> View\nAdds a function the system calls before it processes a purchase from a store view, which provides a set of purchase options.\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, any Error>) -> ())?) -> View\nAdds an action to perform when a purchase the person initiated from within a product view completes.\nenum EntitlementTaskState\nThe state of an entitlement task."
  },
  {
    "title": "allSatisfy(_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851165-allsatisfy",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true.\n\nSee Also\nFinding Transactions\nfunc contains(VerificationResult<Transaction>) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "customProductPageIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appconfiguration/3791476-customproductpageidentifier",
    "html": "Discussion\n\nThe identifier, referred to as the product variant identifier, identifies specific variant product pages from App Store Connect for your app."
  },
  {
    "title": "campaignToken",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appconfiguration/3566713-campaigntoken",
    "html": "Discussion\n\nA campaign token is a 40-byte string that represents an ad campaign. By setting the campaignToken, you can measure the effectiveness of an Apple Services Performance Partners Program link or an App Store Connect Analytics campaign.\n\nFor more information, see Apple Services Performance Partners Program and App Store Connect.\n\nSee Also\nVerifying Advertising Campaigns\nvar providerToken: String?\nA token that represents the provider of an app promotion campaign, and that you use to measure the campaign’s effectiveness.\nfunc setAdditionalValue(Any?, forKey: String)\nSets an additional value for a key; for example, a value for measuring the effectiveness of an ad campaign.\nfunc additionalValue(forKey: String) -> Any?\nReturns the object associated with the key."
  },
  {
    "title": "Product.TaskState.failure(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/taskstate/failure",
    "html": "See Also\nTask states\ncase loading\ncase success(Product)\ncase unavailable"
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851190-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n\nSee Also\nTransforming a Sequence\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncThrowingMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, VerificationResult<Transaction>) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, VerificationResult<Transaction>) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "Product.SubscriptionRelationship.Element",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionrelationship/element",
    "html": "See Also\nUsing type aliases\ntypealias Product.SubscriptionRelationship.ArrayLiteralElement\ntypealias Product.SubscriptionRelationship.RawValue"
  },
  {
    "title": "Product.SubscriptionRelationship.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionrelationship/rawvalue",
    "html": "See Also\nUsing type aliases\ntypealias Product.SubscriptionRelationship.ArrayLiteralElement\ntypealias Product.SubscriptionRelationship.Element"
  },
  {
    "title": "Product.SubscriptionRelationship.ArrayLiteralElement",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionrelationship/arrayliteralelement",
    "html": "See Also\nUsing type aliases\ntypealias Product.SubscriptionRelationship.Element\ntypealias Product.SubscriptionRelationship.RawValue"
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionrelationship/4148724-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating a subscription relationship\ninit(rawValue: Int)"
  },
  {
    "title": "crossgrade",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionrelationship/4148720-crossgrade",
    "html": "See Also\nGetting subscription relationships\nstatic let all: Product.SubscriptionRelationship\nstatic let current: Product.SubscriptionRelationship\nstatic let downgrade: Product.SubscriptionRelationship\nstatic let upgrade: Product.SubscriptionRelationship"
  },
  {
    "title": "upgrade",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionrelationship/4148725-upgrade",
    "html": "See Also\nGetting subscription relationships\nstatic let all: Product.SubscriptionRelationship\nstatic let crossgrade: Product.SubscriptionRelationship\nstatic let current: Product.SubscriptionRelationship\nstatic let downgrade: Product.SubscriptionRelationship"
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionrelationship/4148723-init",
    "html": "Relationships\nFrom Protocol\nOptionSet\nRawRepresentable\nSee Also\nCreating a subscription relationship\nvar rawValue: Int"
  },
  {
    "title": "position",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appconfiguration/3566715-position",
    "html": "See Also\nCreating an App Configuration\ninit(appIdentifier: String, position: SKOverlay.Position)\nCreates an object that represents the attributes of an overlay you use to recommend another app on the App Store.\nvar appIdentifier: String\nThe iTunes identifier of the recommended app.\nenum SKOverlay.Position\nConstants that identify the position of an overlay on the screen."
  },
  {
    "title": "appIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appconfiguration/3566712-appidentifier",
    "html": "See Also\nCreating an App Configuration\ninit(appIdentifier: String, position: SKOverlay.Position)\nCreates an object that represents the attributes of an overlay you use to recommend another app on the App Store.\nvar position: SKOverlay.Position\nThe position of the overlay on the screen.\nenum SKOverlay.Position\nConstants that identify the position of an overlay on the screen."
  },
  {
    "title": "reduce(into:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851202-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary.\n\nSee Also\nTransforming a Sequence\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncThrowingMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, VerificationResult<Transaction>) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure."
  },
  {
    "title": "init(appIdentifier:position:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appconfiguration/3566714-init",
    "html": "Parameters\nappIdentifier\n\nThe iTunes identifier of the recommended app.\n\nposition\n\nThe position of the overlay on the screen.\n\nSee Also\nCreating an App Configuration\nvar appIdentifier: String\nThe iTunes identifier of the recommended app.\nvar position: SKOverlay.Position\nThe position of the overlay on the screen.\nenum SKOverlay.Position\nConstants that identify the position of an overlay on the screen."
  },
  {
    "title": "paymentMode",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/3749559-paymentmode",
    "html": "See Also\nGetting price information\nlet displayPrice: String\nThe localized string representation of the discounted price of the subscription offer.\nlet price: Decimal\nThe decimal representation of the discounted price of the subscription offer.\nstruct Product.SubscriptionOffer.PaymentMode\nThe payment modes for subscription offers."
  },
  {
    "title": "Product.SubscriptionOffer.PaymentMode",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/paymentmode",
    "html": "Overview\n\nA payment mode describes how a subscription offer charges its discounted price — whether it charges one time, charges multiple times, or charges nothing because it’s a free trial.\n\nTopics\nGetting the payment modes\nstatic let freeTrial: Product.SubscriptionOffer.PaymentMode\nA payment mode of a product discount that indicates a free trial offer.\nstatic let payAsYouGo: Product.SubscriptionOffer.PaymentMode\nA payment mode of a product discount that indicates the discount applies over a single billing period or multiple billing periods.\nstatic let payUpFront: Product.SubscriptionOffer.PaymentMode\nA payment mode of a product discount that indicates the system applies the discount up front.\nGetting a localized description\nvar localizedDescription: String\nThe localized text that describes the payment mode.\nAccessing the raw value\nlet rawValue: String\nThe raw string value that represents a payment mode for a subscription offer.\ntypealias Product.SubscriptionOffer.PaymentMode.RawValue\nA type that represents the raw value of a payment mode for a subscription offer.\nCreating a payment mode\ninit(rawValue: String)\nCreates a subscription offer payment mode instance from a raw value.\nComparing and hashing payment modes\nstatic func != (Product.SubscriptionOffer.PaymentMode, Product.SubscriptionOffer.PaymentMode) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSee Also\nGetting price information\nlet displayPrice: String\nThe localized string representation of the discounted price of the subscription offer.\nlet price: Decimal\nThe decimal representation of the discounted price of the subscription offer.\nlet paymentMode: Product.SubscriptionOffer.PaymentMode\nThe offer's payment mode."
  },
  {
    "title": "periodCount",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/3749561-periodcount",
    "html": "Discussion\n\nIf the payment mode is payAsYouGo, the period count represents the number of periods the subscription renews at the discounted price.\n\nThe period count is 1 for offers with payment modes freeTrial and payUpFront.\n\nSee Also\nGetting the subscription duration\nlet period: Product.SubscriptionPeriod\nThe subscription period for the subscription offer."
  },
  {
    "title": "reduce(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851200-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n\nSee Also\nTransforming a Sequence\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncThrowingMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(into: Result, (inout Result, VerificationResult<Transaction>) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "Product.SubscriptionOffer.OfferType",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/offertype",
    "html": "Topics\nGetting the Offer Types\nstatic let introductory: Product.SubscriptionOffer.OfferType\nAn introductory offer for a subscription.\nstatic let promotional: Product.SubscriptionOffer.OfferType\nA promotional offer.\nGetting a Localized Description\nvar localizedDescription: String\nCreating an Offer Type\ninit(rawValue: String)\nA raw value representing a subscription offer type.\ntypealias Product.SubscriptionOffer.OfferType.RawValue\nlet rawValue: String\nA string representing the raw value of the subscription offer type.\nComparing and Hashing Offer Types\nstatic func != (Product.SubscriptionOffer.OfferType, Product.SubscriptionOffer.OfferType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSee Also\nGetting the subscription offer type\nlet type: Product.SubscriptionOffer.OfferType\nThe type of subscription offer, either introductory or promotional."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/3749558-id",
    "html": "Discussion\n\nThis value is nil if the subscription offer is an introductory offer.\n\nPass id to promotionalOffer(offerID:keyID:nonce:signature:timestamp:) to apply this promotion to a purchase, in purchase(options:)."
  },
  {
    "title": "purchaseDate",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749710-purchasedate",
    "html": "See Also\nGetting purchase and expiration dates\nlet expirationDate: Date?\nThe date the subscription expires or renews."
  },
  {
    "title": "init(id:prefersPromotionalIcon:icon:placeholderIcon:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202220-init",
    "html": "Parameters\nproductID\n\nThe product identifier to load from the App Store.\n\nprefersPromotionalIcon\n\nA Boolean value that indicates whether to use the promotional image from the App Store, if it’s available. If this value is true and a promotional image for the product is available, the view displays it instead of the view you provide in the icon parameter.\n\nicon\n\nA closure that returns the image the view displays when the system successfully finishes loading the product from the App Store.\n\nplaceholderIcon\n\nA closure that returns the image that the view uses while the system loads the product from the App Store.\n\nDiscussion\n\nThe product view displays the custom placeholderIcon until the system finishes loading the product. After the product loads, the system uses the view you provide in the icon parameter by default. If prefersPromotionalIcon is true and the product has a promotional image, the view displays the promotional image as its image instead of the view that icon provides.\n\nThe following code example shows how to create a product view using the icon and a custom placeholderIcon:\n\nProductView(id: \"com.example.product\") {\n    Image(systemName: \"star.fill\")\n        .foregroundStyle(.yellow)\n} placeholderIcon: {\n    Image(systemName: \"star.fill\")\n        .foregroundStyle(.gray)\n}\n\n\nTip\n\nTo gain more control over the image that decorates this view, use the init(id:icon:placeholderIcon:) initializer. It receives a ProductIconPhase, which enables you to supply an image for each phase of the image-loading process.\n\nSee Also\nCreating product views that load products\ninit(id: Product.ID, prefersPromotionalIcon: Bool)\nCreates a view to load and merchandise an individual product from the App Store.\ninit(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon)\nCreates a view to load an individual product from the App Store and merchandise it using a custom icon.\ninit(id: Product.ID, icon: (ProductIconPhase) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load an individual product from the App Store, and merchandise it using its promotional image and a custom placeholder icon."
  },
  {
    "title": "environment",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3963920-environment",
    "html": "See Also\nGetting the environment and storefront\nlet storefront: Storefront\nThe App Store storefront associated with the transaction."
  },
  {
    "title": "storefront",
    "url": "https://developer.apple.com/documentation/storekit/transaction/4193541-storefront",
    "html": "See Also\nGetting the environment and storefront\nlet environment: AppStore.Environment\nThe server environment that generates and signs the transaction."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749696-id",
    "html": "Discussion\n\nEvery transaction such as an in-app purchase, restore, or subscription renewal has a unique transaction identifier.\n\nRelationships\nFrom Protocol\nIdentifiable\nSee Also\nIdentifying a transaction\ntypealias Transaction.ID\nA type representing the transaction identifier.\nlet webOrderLineItemID: String?\nA unique ID that identifies subscription purchase events across devices, including subscription renewals.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Transaction conforms to AnyObject."
  },
  {
    "title": "originalID",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749703-originalid",
    "html": "Discussion\n\nThe original transaction identifier, originalID, is identical to id except when the user restores a purchase or renews a transaction. You can use this value to:\n\nIdentify one or more renewals for the same subscription.\n\nDifferentiate a purchase transaction from a restore or a renewal transaction. For restore and renewal transactions, the original transaction identifier, originalID, and transaction identifier, id, differ.\n\nMatch a transaction in the app with a transaction you receive on your server in an App Store Server Notifications event.\n\nSee Also\nGetting the original transaction identifier\nlet originalPurchaseDate: Date\nThe date of purchase for the original transaction."
  },
  {
    "title": "originalPurchaseDate",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749704-originalpurchasedate",
    "html": "See Also\nGetting the original transaction identifier\nlet originalID: UInt64\nThe original transaction identifier of a purchase."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851188-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nTransforming a Sequence\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, VerificationResult<Transaction>) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, VerificationResult<Transaction>) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "drop(while:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851175-drop",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is.\n\nSee Also\nExcluding Transactions\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Transaction.Transactions>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((VerificationResult<Transaction>) -> Bool) -> AsyncFilterSequence<Transaction.Transactions>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "prefix(_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions/3851196-prefix",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence.\n\nSee Also\nSelecting Transactions\nfunc prefix(while: (VerificationResult<Transaction>) -> Bool) -> AsyncPrefixWhileSequence<Transaction.Transactions>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "LargeProductViewStyle",
    "url": "https://developer.apple.com/documentation/storekit/largeproductviewstyle",
    "html": "Topics\nGetting the large product view style\nstatic var large: LargeProductViewStyle\nCreating the style\nfunc makeBody(configuration: LargeProductViewStyle.Configuration) -> View\ntypealias LargeProductViewStyle.Body\ninit()\nRelationships\nConforms To\nProductViewStyle\nSee Also\nSupporting types\nstruct AutomaticProductViewStyle\nstruct CompactProductViewStyle\nA style for a product view that’s suitable for layouts with less available space, or for displaying more items in a small amount of space.\nstruct RegularProductViewStyle\nA style for a product view that uses a standard, platform-appropriate layout."
  },
  {
    "title": "AutomaticProductViewStyle",
    "url": "https://developer.apple.com/documentation/storekit/automaticproductviewstyle",
    "html": "Topics\nGetting the automatic product view styles\nstatic var automatic: AutomaticProductViewStyle\nCreating automatic product view styles\nfunc makeBody(configuration: AutomaticProductViewStyle.Configuration) -> View\ntypealias AutomaticProductViewStyle.Body\ninit()\nRelationships\nConforms To\nProductViewStyle\nSee Also\nSupporting types\nstruct CompactProductViewStyle\nA style for a product view that’s suitable for layouts with less available space, or for displaying more items in a small amount of space.\nstruct RegularProductViewStyle\nA style for a product view that uses a standard, platform-appropriate layout.\nstruct LargeProductViewStyle\nA style for a product view that’s suitable for layouts where the in-app purchase content is prominent."
  },
  {
    "title": "compact",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyle/4202526-compact",
    "html": "See Also\nGetting built-in product view styles\nstatic var automatic: AutomaticProductViewStyle\nAvailable when Self is AutomaticProductViewStyle.\nstatic var large: LargeProductViewStyle\nA product view style suitable for layouts where the in-app purchase content is prominent.\nAvailable when Self is LargeProductViewStyle.\nstatic var regular: RegularProductViewStyle\nA product view style that uses a standard, platform-appropriate layout.\nAvailable when Self is RegularProductViewStyle."
  },
  {
    "title": "RegularProductViewStyle",
    "url": "https://developer.apple.com/documentation/storekit/regularproductviewstyle",
    "html": "Topics\nGetting the regular product view style\nstatic var regular: RegularProductViewStyle\nCreating the style\nfunc makeBody(configuration: RegularProductViewStyle.Configuration) -> View\ntypealias RegularProductViewStyle.Body\ninit()\nRelationships\nConforms To\nProductViewStyle\nSee Also\nSupporting types\nstruct AutomaticProductViewStyle\nstruct CompactProductViewStyle\nA style for a product view that’s suitable for layouts with less available space, or for displaying more items in a small amount of space.\nstruct LargeProductViewStyle\nA style for a product view that’s suitable for layouts where the in-app purchase content is prominent."
  },
  {
    "title": "Product.SubscriptionOffer.Signature",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/signature",
    "html": "Topics\nInitializers\ninit(keyID: String, nonce: UUID, timestamp: Int, signature: Data)\nInstance Properties\nvar hashValue: Int\nvar keyID: String\nvar nonce: UUID\nvar signature: Data\nvar timestamp: Int\nInstance Methods\nfunc hash(into: inout Hasher)\nOperator Functions\nstatic func != (Product.SubscriptionOffer.Signature, Product.SubscriptionOffer.Signature) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionOffer.Signature, Product.SubscriptionOffer.Signature) -> Bool\nRelationships\nConforms To\nHashable\nSendable"
  },
  {
    "title": "purchase()",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyleconfiguration/4203100-purchase",
    "html": "Discussion\n\nUse this method instead of calling purchase(options:)directly on the product."
  },
  {
    "title": "icon",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyleconfiguration/4203098-icon",
    "html": "See Also\nGetting a product view's icon\nstruct ProductViewStyleConfiguration.Icon\nA type-erased icon of an in-app purchase product."
  },
  {
    "title": "errorDescription",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror/3916882-errordescription",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nError Descriptions\nvar localizedDescription: String\nA localized error description.\nvar failureReason: String?\nA localized message describing the reason for the failure.\nvar helpAnchor: String?\nA message providing “help” text if the user requests help by pressing an alert panel help anchor button.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "offerID",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo/3822290-offerid",
    "html": "Discussion\n\nThis value is nil if there isn’t an offer, or if the offer type is introductory.\n\nIf the offer type is promotional, this value contains the promotional offer identifier you set up in App Store Connect. For more information about promotional offers, see Set up promotional offers for auto-renewable subscriptions.\n\nIf the offer type is code, this value contains the reference name of the offer code you set up in App Store Connect. For more information about offer codes, see Set up offer codes.\n\nSee Also\nGetting subscription offers\nlet offerType: Transaction.OfferType?\nThe subscription offer type for the next subscription period."
  },
  {
    "title": "failureReason",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror/3916883-failurereason",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nError Descriptions\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar localizedDescription: String\nA localized error description.\nvar helpAnchor: String?\nA message providing “help” text if the user requests help by pressing an alert panel help anchor button.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "Transaction.RefundRequestError.failed",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror/failed",
    "html": "Discussion\n\nA refund request submission can fail for many reasons, such as having an invalid transaction identifier, or if the App Store can’t process the request for some other reason.\n\nSee Also\nError Enumeration\ncase duplicateRequest\nThe App Store has already received a refund request for this in-app purchase."
  },
  {
    "title": "localizedDescription",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror/3749665-localizeddescription",
    "html": "See Also\nError Descriptions\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA localized message describing the reason for the failure.\nvar helpAnchor: String?\nA message providing “help” text if the user requests help by pressing an alert panel help anchor button.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "hasCurrentEntitlement",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyleconfiguration/4203097-hascurrententitlement",
    "html": "Discussion\n\nUse the hasCurrentEntitlement property to determine whether a purchase may succeed, for a porduct that people can purchase only once. For example, if hasCurrentEntitlement is false, you may choose not to display a purchase button for the product, because the person has already purchased it.\n\nImportant\n\nDon’t use this value to determine whether to enable access to the product; check the in-app purchase transaction information instead (Transaction).\n\nSee Also\nGetting a product's information\nvar product: Product?\nThe in-app purchase product to merchandise.\nlet state: Product.TaskState\nThe product task state that indicates the product’s loading phase."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/3791961",
    "html": "See Also\nComparing and hashing subscription offers\nstatic func != (Product.SubscriptionOffer, Product.SubscriptionOffer) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/3791962-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing subscription offers\nstatic func != (Product.SubscriptionOffer, Product.SubscriptionOffer) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionOffer, Product.SubscriptionOffer) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer/3791963-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing subscription offers\nstatic func != (Product.SubscriptionOffer, Product.SubscriptionOffer) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionOffer, Product.SubscriptionOffer) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "production",
    "url": "https://developer.apple.com/documentation/storekit/appstore/environment/3963897-production",
    "html": "See Also\nGetting the environment value\nstatic let sandbox: AppStore.Environment\nA value that indicates the sandbox server environment.\nstatic let xcode: AppStore.Environment\nA value that indicates the StoreKit Testing in Xcode environment."
  },
  {
    "title": "restorePurchases",
    "url": "https://developer.apple.com/documentation/storekit/storebuttonkind/4203111-restorepurchases",
    "html": "See Also\nGetting button types for store views\nstatic var cancellation: StoreButtonKind\nA type of button that people use to dismiss the current store presentation."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/coarseconversionvalue/4090682-init",
    "html": "Parameters\nrawValue\n\nA string that is one of low, medium, or high.\n\nDiscussion\n\nYou don't need to call the initializer to use coarse conversion values. When you provide the coarse conversion value to the updatePostbackConversionValue(_:coarseValue:completionHandler:) or updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) methods, use the static constants, low, medium, or high.\n\nSee Also\nProviding coarse conversion values\nstatic let high: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a high coarse conversion value.\nstatic let low: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a low coarse conversion value.\nstatic let medium: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a medium coarse conversion value."
  },
  {
    "title": "StoreView.Body",
    "url": "https://developer.apple.com/documentation/storekit/storeview/body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing store views\nvar body: View\nThe content and behavior of the view."
  },
  {
    "title": "body",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202080-body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing a product view\ntypealias ProductView.Body\nThe type of view that represents the body of the product view."
  },
  {
    "title": "onInAppPurchaseStart(perform:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202322-oninapppurchasestart",
    "html": "Parameters\naction\n\nA closure that defines an action to perform, including the product the person intends to purchase as a parameter.\n\nDiscussion\n\nSet the action parameter to nil to remove any actions that ancestor views may add.\n\nSee Also\nResponding to store events\nfunc inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) -> View\nAdds a function the system calls before it processes a purchase from a product view, which provides a set of purchase options.\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, any Error>) -> ())?) -> View\nAdds an action to perform when a purchase the person initiates from within a product view completes.\nenum EntitlementTaskState\nThe state of an entitlement task."
  },
  {
    "title": "init(ids:icon:placeholderIcon:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203378-init",
    "html": "Parameters\nproductIDs\n\nThe product identifiers to load from the App Store.\n\nicon\n\nA closure that receives a Product and a ProductIconPhase as input. The ProductIconPhase indicates the state of the loading operation of the product’s promotional image. The closure returns the view to display for the given product and phase value.\n\nplaceholderIcon\n\nA closure that returns the view that the store view uses while the products are loading. The store view uses the same placeholder image for all the products.\n\nDiscussion\n\nThe store view shows the custom placeholderIcon until all products finish loading. After the products finish loading, the view asynchronously loads and displays each product’s promotional image.\n\nUse the ProductIconPhase to monitor the current loading state of a product’s promotional image, and provide a view for each phase. Consider returning the view provided in the placeholderIcon closure for during the ProductIconPhase.loading phase. For more information, see ProductIconPhase.\n\nIf a product is unavailable, the store view uses the view that the placeholderIcon closure provides as a fallback.\n\nSee Also\nCreating store views that load products\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool)\nCreates a view to load and merchandise a collection of products from the App Store using product identifiers.\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon: (Product) -> Icon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using a custom image.\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon: (Product) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using an image and a custom placeholder icon."
  },
  {
    "title": "init(products:icon:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203382-init",
    "html": "Parameters\nproducts\n\nThe products to merchandise.\n\nicon\n\nA closure that receives a Product and a ProductIconPhase as input. The ProductIconPhase indicates the state of the loading operation of the product’s promotional image. The closure returns the view to display for the given product and phase value.\n\nDiscussion\n\nThe store view asynchronously loads and displays each product’s promotional image. Use the ProductIconPhase to monitor the current loading phase of the product’s promotional image, and provide an image for each phase. For more information about the loading phases, see ProductIconPhase.\n\nSee Also\nCreating store views with preloaded products\ninit(products: some Collection<Product>, prefersPromotionalIcon: Bool)\nCreates a view to load and merchandise a collection of products from the App Store.\ninit(products: some Collection<Product>, prefersPromotionalIcon: Bool, icon: (Product) -> Icon)\nCreates a view to merchandise a collection of products using a custom icon."
  },
  {
    "title": "init(products:prefersPromotionalIcon:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203383-init",
    "html": "Parameters\nproducts\n\nThe products to merchandise.\n\nprefersPromotionalIcon\n\nA Boolean value that indicates whether to use promotional images from the App Store, if they’re available. If this parameter is false, the system ignores promotional images.\n\nDiscussion\n\nBy default, the store view doesn’t show promotional images. If you set prefersPromotionalIcon to true, the store view uses each product’s promotional image as its icon.\n\nSee Also\nCreating store views with preloaded products\ninit(products: some Collection<Product>, prefersPromotionalIcon: Bool, icon: (Product) -> Icon)\nCreates a view to merchandise a collection of products using a custom icon.\ninit(products: some Collection<Product>, icon: (Product, ProductIconPhase) -> Icon)\nCreates a view to merchandise a collection of products with promotional images."
  },
  {
    "title": "init(ids:prefersPromotionalIcon:icon:placeholderIcon:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203381-init",
    "html": "Parameters\nproductIDs\n\nThe product identifiers to load from the App Store.\n\nprefersPromotionalIcon\n\nA Boolean value that indicates whether to use a promotional image from the App Store, if it’s available. If this parameter is false, the system ignores promotional images.\n\nicon\n\nA closure that returns the image the view displays when the products finish loading from the App Store.\n\nplaceholderIcon\n\nA closure that returns the image that the view uses while the products are loading. The view uses the same placeholder image for all the products.\n\nDiscussion\n\nThe store view shows the custom placeholder icon until all products finish loading. After the view finishes loading the products, it uses the image you provide, by default. If you set prefersPromotionalIcon to true, any products that have an available promotional image use the promotional image instead.\n\nThe following example shows how to create a store view using an icon and a custom placeholder icon:\n\nStoreView(ids: [\n    \"com.example.product1\",\n    \"com.example.product2\"\n]) { product in\n     Image(systemName: \"star.fill\")\n         .foregroundStyle(.yellow)\n } placeholderIcon: {\n      Image(systemName: \"star.fill\")\n         .foregroundStyle(.gray)\n }\n\n\nSee Also\nCreating store views that load products\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool)\nCreates a view to load and merchandise a collection of products from the App Store using product identifiers.\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon: (Product) -> Icon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using a custom image.\ninit(ids: some Collection<String>, icon: (Product, ProductIconPhase) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using their promotional images and a custom placeholder icon."
  },
  {
    "title": "init(products:prefersPromotionalIcon:icon:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203384-init",
    "html": "Parameters\nproducts\n\nThe products to merchandise.\n\nprefersPromotionalIcon\n\nA Boolean value that indicates whether to use promotional images from the App Store, if they’re available. If this parameter is false, the system ignores promotional images.\n\nicon\n\nA closure that returns the image the view displays when the products finish loading from the App Store.\n\nDiscussion\n\nIf you set prefersPromotionalIcon to true, the view uses promotional images for products that have a promotional image available.\n\nThe following code example shows how to create a store view using a custom icon:\n\nStoreView(products: [\n          product1,\n          product2,\n          // Add products as needed.\n ]) { product in\n    Image(systemName: \"star.fill\")\n        .foregroundStyle(.yellow)\n    }  \n\n\nSee Also\nCreating store views with preloaded products\ninit(products: some Collection<Product>, prefersPromotionalIcon: Bool)\nCreates a view to load and merchandise a collection of products from the App Store.\ninit(products: some Collection<Product>, icon: (Product, ProductIconPhase) -> Icon)\nCreates a view to merchandise a collection of products with promotional images."
  },
  {
    "title": "inAppPurchaseOptions(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203376-inapppurchaseoptions",
    "html": "Parameters\noptions\n\nA closure you provide for the system to call before it processes a purchase. The system sends the product the person intends to purchase as a parameter. Return a set of purchase options (Product.PurchaseOption) to add to the purchase.\n\nSee Also\nResponding to store events\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, any Error>) -> ())?) -> View\nAdds an action to perform when a purchase the person initiated from within a product view completes.\nfunc onInAppPurchaseStart(perform: ((Product) -> ())?) -> View\nAdds an action to perform when a user triggers the purchase button on a product within this view.\nenum EntitlementTaskState\nThe state of an entitlement task."
  },
  {
    "title": "downgrade",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionrelationship/4148722-downgrade",
    "html": "See Also\nGetting subscription relationships\nstatic let all: Product.SubscriptionRelationship\nstatic let crossgrade: Product.SubscriptionRelationship\nstatic let current: Product.SubscriptionRelationship\nstatic let upgrade: Product.SubscriptionRelationship"
  },
  {
    "title": "current",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionrelationship/4148721-current",
    "html": "See Also\nGetting subscription relationships\nstatic let all: Product.SubscriptionRelationship\nstatic let crossgrade: Product.SubscriptionRelationship\nstatic let downgrade: Product.SubscriptionRelationship\nstatic let upgrade: Product.SubscriptionRelationship"
  },
  {
    "title": "all",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionrelationship/4148719-all",
    "html": "See Also\nGetting subscription relationships\nstatic let crossgrade: Product.SubscriptionRelationship\nstatic let current: Product.SubscriptionRelationship\nstatic let downgrade: Product.SubscriptionRelationship\nstatic let upgrade: Product.SubscriptionRelationship"
  },
  {
    "title": "Product.TaskState.unavailable",
    "url": "https://developer.apple.com/documentation/storekit/product/taskstate/unavailable",
    "html": "See Also\nTask states\ncase loading\ncase success(Product)\ncase failure(any Error)"
  },
  {
    "title": "Product.TaskState.loading",
    "url": "https://developer.apple.com/documentation/storekit/product/taskstate/loading",
    "html": "See Also\nTask states\ncase success(Product)\ncase unavailable\ncase failure(any Error)"
  },
  {
    "title": "Product.TaskState.success(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/taskstate/success",
    "html": "See Also\nTask states\ncase loading\ncase unavailable\ncase failure(any Error)"
  },
  {
    "title": "init(_:prefersPromotionalIcon:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202215-init",
    "html": "Parameters\nproduct\n\nThe product to merchandise.\n\nprefersPromotionalIcon\n\nA Boolean value that indicates whether to use the promotional image from the App Store, if it’s available. If this value is true and a promotional image for the product is available, the view displays it.\n\nDiscussion\n\nIf the product has a promotional image available, the view displays it. Otherwise, the view doesn’t show an image.\n\nIf you set the prefersPromotionalIcon parameter to false, the view doesn’t show an image even if the product has a promotional image available.\n\nTip\n\nTo gain more control over the image that decorates this view, use the init(_:icon:) initializer. It receives a ProductIconPhase, which enables you to supply an image for each phase of the image-loading process.\n\nSee Also\nCreating product views with preloaded products\ninit(Product, prefersPromotionalIcon: Bool, icon: () -> Icon)\nCreates a view to merchandise an individual product using a custom icon.\ninit(Product, icon: (ProductIconPhase) -> Icon)\nCreates a view to display a product that the system already loaded from the App Store, and merchandise it using its promotional image."
  },
  {
    "title": "Product.PurchaseResult.userCancelled",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseresult/usercancelled",
    "html": "See Also\nGetting the Purchase Results\ncase success(VerificationResult<Transaction>)\nThe purchase succeeded and results in a transaction.\ncase pending\nThe purchase is pending, and requires action from the customer."
  },
  {
    "title": "init(ids:prefersPromotionalIcon:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203379-init",
    "html": "Parameters\nproductIDs\n\nThe product identifiers to load from the App Store.\n\nprefersPromotionalIcon\n\nA Boolean value that indicates whether to use promotional images from the App Store, if they’re available. If this parameter is false, the system ignores promotional images.\n\nSee Also\nCreating store views that load products\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon: (Product) -> Icon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using a custom image.\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon: (Product) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using an image and a custom placeholder icon.\ninit(ids: some Collection<String>, icon: (Product, ProductIconPhase) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using their promotional images and a custom placeholder icon."
  },
  {
    "title": "AutomaticSubscriptionStoreControlStyle",
    "url": "https://developer.apple.com/documentation/storekit/automaticsubscriptionstorecontrolstyle",
    "html": "Topics\nGetting the automatic subscription store control style\nstatic var automatic: AutomaticSubscriptionStoreControlStyle\nA subscription store control style that resolves its appearance automatically, based on the current context.\nCreating the style\nfunc makeBody(configuration: AutomaticSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of an automatic subscription store control style.\ntypealias AutomaticSubscriptionStoreControlStyle.Body\nA type that represents the body of an automatic subscription store control style.\ninit()\nCreates an automatic subscription store control style.\nRelationships\nConforms To\nSubscriptionStoreControlStyle\nSee Also\nSupporting types\nstruct ButtonsSubscriptionStoreControlStyle\nA subscription store control style that displays a subscribe button for each subscription plan.\nstruct PickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a picker control, with a single button to subscribe.\nstruct ProminentPickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a prominent picker control, with a single button to subscribe."
  },
  {
    "title": "prominentPicker",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolstyle/4243446-prominentpicker",
    "html": "Discussion\n\nYou can also use subscriptionStoreControlStyle(_:)with prominentPicker as the parameter to construct this style.\n\nSee Also\nGetting built-in subscription store view styles\nstatic var automatic: AutomaticSubscriptionStoreControlStyle\nA subscription store control style that resolves its appearance automatically, based on the current context.\nAvailable when Self is AutomaticSubscriptionStoreControlStyle.\nstatic var buttons: ButtonsSubscriptionStoreControlStyle\nA subscription store control style that displays a subscribe button for each subscription plan.\nAvailable when Self is ButtonsSubscriptionStoreControlStyle.\nstatic var picker: PickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a picker control, with a single button to subscribe.\nAvailable when Self is PickerSubscriptionStoreControlStyle."
  },
  {
    "title": "picker",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolstyle/4240627-picker",
    "html": "Discussion\n\nYou can also use subscriptionStoreControlStyle(_:)with picker as the parameter to construct this style.\n\nSee Also\nGetting built-in subscription store view styles\nstatic var automatic: AutomaticSubscriptionStoreControlStyle\nA subscription store control style that resolves its appearance automatically, based on the current context.\nAvailable when Self is AutomaticSubscriptionStoreControlStyle.\nstatic var buttons: ButtonsSubscriptionStoreControlStyle\nA subscription store control style that displays a subscribe button for each subscription plan.\nAvailable when Self is ButtonsSubscriptionStoreControlStyle.\nstatic var prominentPicker: ProminentPickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a prominent picker control, with a single button to subscribe.\nAvailable when Self is ProminentPickerSubscriptionStoreControlStyle."
  },
  {
    "title": "buttons",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolstyle/4240625-buttons",
    "html": "Discussion\n\nYou can also use subscriptionStoreControlStyle(_:)with buttons as the parameter to construct this style.\n\nSee Also\nGetting built-in subscription store view styles\nstatic var automatic: AutomaticSubscriptionStoreControlStyle\nA subscription store control style that resolves its appearance automatically, based on the current context.\nAvailable when Self is AutomaticSubscriptionStoreControlStyle.\nstatic var picker: PickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a picker control, with a single button to subscribe.\nAvailable when Self is PickerSubscriptionStoreControlStyle.\nstatic var prominentPicker: ProminentPickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a prominent picker control, with a single button to subscribe.\nAvailable when Self is ProminentPickerSubscriptionStoreControlStyle."
  },
  {
    "title": "PickerSubscriptionStoreControlStyle",
    "url": "https://developer.apple.com/documentation/storekit/pickersubscriptionstorecontrolstyle",
    "html": "Topics\nGetting the picker control style\nstatic var picker: PickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a picker control, with a single button to subscribe.\nCreating the style\nfunc makeBody(configuration: PickerSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of a picker subscription store.\ntypealias PickerSubscriptionStoreControlStyle.Body\nA type that represents the body of a picker subscription store control style.\ninit()\nCreates a picker subscription store control style.\nRelationships\nConforms To\nSubscriptionStoreControlStyle\nSee Also\nSupporting types\nstruct AutomaticSubscriptionStoreControlStyle\nThe default in-app subscription store control style that resolves its appearance based on the view’s context.\nstruct ButtonsSubscriptionStoreControlStyle\nA subscription store control style that displays a subscribe button for each subscription plan.\nstruct ProminentPickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a prominent picker control, with a single button to subscribe."
  },
  {
    "title": "automatic",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolstyle/4240624-automatic",
    "html": "Discussion\n\nYou can also use subscriptionStoreControlStyle(_:)with automatic as the parameter to construct this style.\n\nSee Also\nGetting built-in subscription store view styles\nstatic var buttons: ButtonsSubscriptionStoreControlStyle\nA subscription store control style that displays a subscribe button for each subscription plan.\nAvailable when Self is ButtonsSubscriptionStoreControlStyle.\nstatic var picker: PickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a picker control, with a single button to subscribe.\nAvailable when Self is PickerSubscriptionStoreControlStyle.\nstatic var prominentPicker: ProminentPickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a prominent picker control, with a single button to subscribe.\nAvailable when Self is ProminentPickerSubscriptionStoreControlStyle."
  },
  {
    "title": "makeBody(configuration:)",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyle/4202528-makebody",
    "html": "Required\n\nParameters\nconfiguration\n\nThe properties of a product view style.\n\nSee Also\nCreating custom product views\ntypealias ProductViewStyle.Configuration\nA type that represents the properties of a product view style.\nassociatedtype Body\nA view that represents the body of a product view.\n\nRequired"
  },
  {
    "title": "storeButton(_:for:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203620-storebutton",
    "html": "Parameters\nvisibility\n\nThe preferred visibility (Visibility) of the button.\n\nbuttonKinds\n\nThe type of store button (StoreButtonKind).\n\nSee Also\nConfiguring and styling products\nstruct StoreButtonKind\nA button to display in a store view or subscription store view."
  },
  {
    "title": "Body",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyle/4202523-body",
    "html": "Required\n\nSee Also\nCreating custom product views\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a product view.\n\nRequired\n\ntypealias ProductViewStyle.Configuration\nA type that represents the properties of a product view style."
  },
  {
    "title": "ProductViewStyle.Configuration",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyle/configuration",
    "html": "See Also\nCreating custom product views\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a product view.\n\nRequired\n\nassociatedtype Body\nA view that represents the body of a product view.\n\nRequired"
  },
  {
    "title": "regular",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyle/4202529-regular",
    "html": "See Also\nGetting built-in product view styles\nstatic var automatic: AutomaticProductViewStyle\nAvailable when Self is AutomaticProductViewStyle.\nstatic var compact: CompactProductViewStyle\nAn product view style suitable for layouts where less space is available, or for displaying more items in a small amount of space.\nAvailable when Self is CompactProductViewStyle.\nstatic var large: LargeProductViewStyle\nA product view style suitable for layouts where the in-app purchase content is prominent.\nAvailable when Self is LargeProductViewStyle."
  },
  {
    "title": "large",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyle/4202527-large",
    "html": "See Also\nGetting built-in product view styles\nstatic var automatic: AutomaticProductViewStyle\nAvailable when Self is AutomaticProductViewStyle.\nstatic var compact: CompactProductViewStyle\nAn product view style suitable for layouts where less space is available, or for displaying more items in a small amount of space.\nAvailable when Self is CompactProductViewStyle.\nstatic var regular: RegularProductViewStyle\nA product view style that uses a standard, platform-appropriate layout.\nAvailable when Self is RegularProductViewStyle."
  },
  {
    "title": "CompactProductViewStyle",
    "url": "https://developer.apple.com/documentation/storekit/compactproductviewstyle",
    "html": "Topics\nGetting the compact product view style\nstatic var compact: CompactProductViewStyle\nCreating the style\nfunc makeBody(configuration: CompactProductViewStyle.Configuration) -> View\ntypealias CompactProductViewStyle.Body\ninit()\nRelationships\nConforms To\nProductViewStyle\nSee Also\nSupporting types\nstruct AutomaticProductViewStyle\nstruct RegularProductViewStyle\nA style for a product view that uses a standard, platform-appropriate layout.\nstruct LargeProductViewStyle\nA style for a product view that’s suitable for layouts where the in-app purchase content is prominent."
  },
  {
    "title": "ProductViewStyleConfiguration.Icon",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyleconfiguration/icon",
    "html": "Topics\nImplementing product view style configurations\nvar body: View\ntypealias ProductViewStyleConfiguration.Icon.Body\nInstance Methods\nfunc productDescription(Visibility) -> View\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> View\nfunc subscriptionPromotionalOffer(offer: (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?, signature: (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) -> Product.SubscriptionOffer.Signature) -> View\nRelationships\nConforms To\nView\nSee Also\nGetting a product view's icon\nlet icon: ProductViewStyleConfiguration.Icon\nA decorative view for merchandising the product."
  },
  {
    "title": "init(groupID:visibleRelationships:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4248752-init",
    "html": "Parameters\ngroupID\n\nThe subscription group identifier to load from the App Store.\n\nvisibleRelationships\n\nThe kinds of subscription option relationships the view makes visible when someone is already subscribed to the subscription.\n\nSee Also\nCreating subscription store views with subscription group IDs\ninit(groupID: String, visibleRelationships: Product.SubscriptionRelationship, marketingContent: () -> (Content))\nCreates a view to load all the subscriptions in a subscription group from the App Store and merchandise them with custom marketing content.\nstruct AutomaticSubscriptionStoreMarketingContent\nA view that represents the default marketing content for a subscription store."
  },
  {
    "title": "helpAnchor",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror/3916884-helpanchor",
    "html": "See Also\nError Descriptions\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar localizedDescription: String\nA localized error description.\nvar failureReason: String?\nA localized message describing the reason for the failure.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror/3749659",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nError Comparisons\nstatic func == (Transaction.RefundRequestError, Transaction.RefundRequestError) -> Bool\nvar hashValue: Int\nfunc hash(into: inout Hasher)"
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror/3749663-hash",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nError Comparisons\nstatic func != (Transaction.RefundRequestError, Transaction.RefundRequestError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Transaction.RefundRequestError, Transaction.RefundRequestError) -> Bool\nvar hashValue: Int"
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror/3749660",
    "html": "See Also\nError Comparisons\nstatic func != (Transaction.RefundRequestError, Transaction.RefundRequestError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nfunc hash(into: inout Hasher)"
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror/3749664-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nError Comparisons\nstatic func != (Transaction.RefundRequestError, Transaction.RefundRequestError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Transaction.RefundRequestError, Transaction.RefundRequestError) -> Bool\nfunc hash(into: inout Hasher)"
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/appstore/environment/3963895-hashvalue",
    "html": "See Also\nComparing and hashing the environment value\nstatic func != (AppStore.Environment, AppStore.Environment) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/appstore/environment/3963898-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nGetting the raw value\ntypealias AppStore.Environment.RawValue\nA string type that represents the raw value of an App Store environment."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/appstore/environment/3963892",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing the environment value\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/appstore/environment/3963896-init",
    "html": "Parameters\nrawValue\n\nThe raw value to use for the new instance.\n\nRelationships\nFrom Protocol\nRawRepresentable"
  },
  {
    "title": "sandbox",
    "url": "https://developer.apple.com/documentation/storekit/appstore/environment/3963899-sandbox",
    "html": "See Also\nGetting the environment value\nstatic let production: AppStore.Environment\nA value that indicates the production server environment.\nstatic let xcode: AppStore.Environment\nA value that indicates the StoreKit Testing in Xcode environment."
  },
  {
    "title": "AppStore.Environment.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/appstore/environment/rawvalue",
    "html": "See Also\nGetting the raw value\nlet rawValue: String\nThe underlying string value that describes the environment."
  },
  {
    "title": "xcode",
    "url": "https://developer.apple.com/documentation/storekit/appstore/environment/3963900-xcode",
    "html": "See Also\nGetting the environment value\nstatic let production: AppStore.Environment\nA value that indicates the production server environment.\nstatic let sandbox: AppStore.Environment\nA value that indicates the sandbox server environment."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/appstore/environment/3963894-hash",
    "html": "See Also\nComparing and hashing the environment value\nstatic func != (AppStore.Environment, AppStore.Environment) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3792068-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing verification results\nstatic func != (VerificationResult<SignedType>, VerificationResult<SignedType>) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nAvailable when SignedType conforms to Equatable.\nstatic func == (VerificationResult<SignedType>, VerificationResult<SignedType>) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nAvailable when SignedType conforms to Equatable.\nvar hashValue: Int\nThe hash value.\nAvailable when SignedType conforms to Hashable."
  },
  {
    "title": "inAppPurchaseOptions(_:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202211-inapppurchaseoptions",
    "html": "Parameters\noptions\n\nA closure you provide for the system to call before it processes a purchase. The system sends the product the person intends to purchase as a parameter. Return a set of purchase options (Product.PurchaseOption) to add to the purchase.\n\nDiscussion\n\nWhen you provide purchase options ( Product.PurchaseOption ), the view adds default purchase options to your options. These default purchase options may, in some cases, override your purchase options. For example, the default options sets the quantity to 1, because the product view always displays prices based on a single item.\n\nThe product view uses the purchase options to configure the purchase.\n\nIf you want an in-app purchase to begin without adding purchase options, add an action using onInAppPurchaseStart(perform:) instead.\n\nYou can remove any options that ancestor views may add by providing nil for the option parameter, which results in the purchase having the default set of purchase options.\n\nSee Also\nResponding to store events\nfunc onInAppPurchaseStart(perform: ((Product) -> ())?) -> View\nAdds an action to perform when a person uses the purchase button for a product within the view.\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, any Error>) -> ())?) -> View\nAdds an action to perform when a purchase the person initiates from within a product view completes.\nenum EntitlementTaskState\nThe state of an entitlement task."
  },
  {
    "title": "ProductView.Body",
    "url": "https://developer.apple.com/documentation/storekit/productview/body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing a product view\nvar body: View\nThe content and behavior of the view."
  },
  {
    "title": "onInAppPurchaseCompletion(perform:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202321-oninapppurchasecompletion",
    "html": "Parameters\naction\n\nA closure that defines action to perform, including the product value and the purchase result as parameters.\n\nDiscussion\n\nBy default, updates in Transaction emits transactions from successful in-app store view purchases. If the purchase fails with an error, the system displays an alert. You can revert a view to this behavior by setting the action parameter to nil.\n\nEach purchase performs only one action. Descendant views can override the action by using another onInAppPurchaseCompletion(perform:) modifier.\n\nSee Also\nResponding to store events\nfunc inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) -> View\nAdds a function the system calls before it processes a purchase from a product view, which provides a set of purchase options.\nfunc onInAppPurchaseStart(perform: ((Product) -> ())?) -> View\nAdds an action to perform when a person uses the purchase button for a product within the view.\nenum EntitlementTaskState\nThe state of an entitlement task."
  },
  {
    "title": "SKStoreProductParameterProductIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameterproductidentifier",
    "html": "Discussion\n\nThe value for this key is an instance of NSString.\n\nWhen your app uses an SKStoreProductViewController to render an app page for another app, you can optionally choose to highlight an in-app purchase by displaying it at the top of the store page. Set SKStoreProductParameterProductIdentifier to the identifier of the product you want displayed at the top of the page.\n\nThe product indicated by the identifier must be set up as a promoted product in the App Store, otherwise the identifier is ignored. See Promoting In-App Purchases.\n\nNote\n\nUse the same product identifiers as used in the productIdentifier variable in the SKProduct class.\n\nSee Also\nAffiliate and Analytics Keys\nlet SKStoreProductParameterAdvertisingPartnerToken: String\nThe key representing the advertising partner you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterAffiliateToken: String\nThe key representing the affiliate identifier you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterCampaignToken: String\nThe key representing an App Analytics campaign.\nlet SKStoreProductParameterProviderToken: String\nThe key representing the provider token for the developer that created the app specified by the SKStoreProductParameterITunesItemIdentifier key.\nlet SKStoreProductParameterCustomProductPageIdentifier: String"
  },
  {
    "title": "product",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyleconfiguration/4203099-product",
    "html": "See Also\nGetting a product's information\nlet state: Product.TaskState\nThe product task state that indicates the product’s loading phase.\nlet hasCurrentEntitlement: Bool\nA Boolean value that indicates whether an in-app purchase transaction exists for the product."
  },
  {
    "title": "state",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyleconfiguration/4203101-state",
    "html": "See Also\nGetting a product's information\nvar product: Product?\nThe in-app purchase product to merchandise.\nlet hasCurrentEntitlement: Bool\nA Boolean value that indicates whether an in-app purchase transaction exists for the product."
  },
  {
    "title": "ProductIconPhase",
    "url": "https://developer.apple.com/documentation/storekit/producticonphase",
    "html": "Overview\n\nWhen you create a ProductIconPhase instance with an initializer such as init(ids:icon:placeholderIcon:), you define the appearance of the view’s icon, or image, using a content closure. SwiftUI calls the closure at different stages of the promotional image’s load operation with a phase value that indicates the current state.\n\nUse the phase to decide what to draw. For example, you can draw a placeholder image during the loading phase, a view that indicates an error, a default image, or the loaded promotional image if it exists:\n\nStoreView(products: [\n     product1,\n     product2,\n     // Additional products, as needed.\n ]) { product, phase in\n     switch phase {\n     case .loading: MyPlaceholder()\n     case .failure(let error): MyErrorView(error)\n     case .unavailable: MyDefaultIcon()\n     case .success(let promotedIcon): promotedIcon\n     }\n }\n\n\nYou set up promotional images for in-app purchases in App Store Connect. For more information, see Promote in-app purchases.\n\nTopics\nGetting the promotional image's load phases\ncase loading\nThe promotional image is in the process of loading.\ncase success(Image)\nThe promotional image successfully loaded.\ncase unavailable\nThe promotional image isn’t available for download.\ncase failure(any Error)\nThe promotional image failed to load, with an error.\nGetting the promotional image\nvar promotionalIcon: Image?\nThe promotional image, if the loading task is successful.\nGetting the error\nvar error: (any Error)?\nThe error value that indicates the reason a promotional image failed to load."
  },
  {
    "title": "AutomaticProductPlaceholderIcon",
    "url": "https://developer.apple.com/documentation/storekit/automaticproductplaceholdericon",
    "html": "Overview\n\nYou don’t use this type directly. Instead, create a ProductView or StoreView and provide product identifiers without a custom placeholder icon.\n\nTopics\nImplementing an automatic product placeholder icon\nvar body: View\ntypealias AutomaticProductPlaceholderIcon.Body\nInstance Methods\nfunc productDescription(Visibility) -> View\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> View\nfunc subscriptionPromotionalOffer(offer: (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?, signature: (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) -> Product.SubscriptionOffer.Signature) -> View\nRelationships\nConforms To\nView\nSee Also\nCreating product views with a configuration\ninit(ProductViewStyleConfiguration)\nCreates a view to merchandise an individual product using a configuration for product view style."
  },
  {
    "title": "init(_:icon:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202214-init",
    "html": "Parameters\nproduct\n\nThe product to merchandise.\n\nicon\n\nA closure that receives a ProductIconPhase as an input, which indicates the state of the loading operation of the product’s promoted image, and returns the view to display for the specified phase.\n\nDiscussion\n\nThe product view asynchronously loads and displays the product’s promotional image.\n\nThe ProductIconPhase value indicates whether the promotional image is loading, unavailable, or whether it succeeded or failed to load. Use the ProductIconPhase to monitor current loading phase, and to decide the image to return in the icon closure.\n\nSee Also\nCreating product views with preloaded products\ninit(Product, prefersPromotionalIcon: Bool, icon: () -> Icon)\nCreates a view to merchandise an individual product using a custom icon.\ninit(Product, prefersPromotionalIcon: Bool)\nCreates a view to merchandise an individual product."
  },
  {
    "title": "init(_:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202213-init",
    "html": "Parameters\nconfiguration\n\nA configuration for a product view style.\n\nDiscussion\n\nUse this initializer within the makeBody(configuration:) method of a ProductViewStyle to create an instance of the product view you want to style. This is useful for custom product view styles that modify the current style, rather than implementing a new style.\n\nThe following code example shows how to create and use custom styles by composing standard styles:\n\nstruct SpinnerWhenLoadingStyle: ProductViewStyle {\n    public func makeBody(configuration: Configuration) -> some View {\n        switch configuration.state {\n        case .loading:\n            ProgressView()\n                .progressView(.circular)\n        default:\n            ProductView(configuration)\n        }\n    }\n}\n// Use the following elsewhere in the code.\nProductView(id: \"com.example.product\")\n    .productViewStyle(SpinnerWhenLoadingStyle())\n\n\nSee Also\nCreating product views with a configuration\nstruct AutomaticProductPlaceholderIcon\nA view that represents the default placeholder icon for an in-app store product."
  },
  {
    "title": "init(_:prefersPromotionalIcon:icon:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202216-init",
    "html": "Parameters\nproduct\n\nThe product to merchandise.\n\nprefersPromotionalIcon\n\nA Boolean value that indicates whether to use the promotional image from the App Store, if it’s available. If this value is true and a promotional image for the product is available, the view displays it instead of the view you provide in the icon parameter.\n\nicon\n\nA closure that returns the image to use for decorating the in-app purchase product.\n\nDiscussion\n\nIf prefersPromotionalIcon is true and the product has a promotional image, the view displays the promotional image instead of the view you provide in icon.\n\nThe following example shows how to create a product view using a custom icon:\n\nProductView(product) {\n    Image(systemName: \"star.fill\")\n        .foregroundStyle(.yellow)\n}\n\n\nTip\n\nTo gain more control over the image that decorates this view, use the init(_:icon:) initializer. It receives a ProductIconPhase, which enables you to supply an image for each phase of the image-loading process.\n\nSee Also\nCreating product views with preloaded products\ninit(Product, prefersPromotionalIcon: Bool)\nCreates a view to merchandise an individual product.\ninit(Product, icon: (ProductIconPhase) -> Icon)\nCreates a view to display a product that the system already loaded from the App Store, and merchandise it using its promotional image."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate/3749524-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nAccessing the raw value\ntypealias Product.SubscriptionInfo.RenewalState.RawValue\nA type that represents the raw value of a renewal state."
  },
  {
    "title": "init(id:icon:placeholderIcon:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202217-init",
    "html": "Parameters\nproductID\n\nThe product identifier to load from the App Store.\n\nicon\n\nA closure that receives a ProductIconPhase as an input, which indicates the state of the loading operation of the product’s promotional image, and returns the view to display for the specified phase.\n\nplaceholderIcon\n\nA closure that returns an icon to display until the system finishes loading the product from the App Store.\n\nDiscussion\n\nThe product view shows the placeholderIcon until the system finishes loading the product. After the product finishes loading, the view asynchronously loads and displays the product’s promotional image. Use the ProductIconPhase to monitor the current loading state of the product’s promotional image.\n\nIf the product is unavailable, the view displays the placeholderIcon as a fallback.\n\nThe ProductIconPhase value indicates whether the promotional image is loading, unavailable, or whether it succeeded or failed to load. Use the phase to decide what to draw. While the image’s loading operation is in the ProductIconPhase.loading phase, consider displaying the same view that you provide in the placeholderIcon closure. For more information, see ProductIconPhase.\n\nSee Also\nCreating product views that load products\ninit(id: Product.ID, prefersPromotionalIcon: Bool)\nCreates a view to load and merchandise an individual product from the App Store.\ninit(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon)\nCreates a view to load an individual product from the App Store and merchandise it using a custom icon.\ninit(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load an individual product from the App Store and merchandise it using an image and a custom placeholder icon."
  },
  {
    "title": "Product.SubscriptionInfo.RenewalState.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate/rawvalue",
    "html": "See Also\nAccessing the raw value\nlet rawValue: Int\nThe raw value of a renewal state."
  },
  {
    "title": "init(id:prefersPromotionalIcon:icon:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4248750-init",
    "html": "Parameters\nproductID\n\nThe product identifier to load from the App Store.\n\nprefersPromotionalIcon\n\nA Boolean value that indicates whether to use the promotional image from the App Store, if it’s available. If this value is true and a promotional image for the product is available, the view displays it instead of the view you provide in the icon parameter.\n\nicon\n\nA closure that returns the image the view displays when the system finishes loading the product from the App Store.\n\nDiscussion\n\nThe product view displays a placeholder icon until the system finishes loading the product. After the product loads, the system uses the view you provide in the icon parameter, by default. If prefersPromotionalIcon is true and the product has a promotional image, the view displays the promotional image as its icon instead of the provided view.\n\nTip\n\nTo gain more control over the image that decorates this view, use the init(id:icon:placeholderIcon:) initializer. It receives a ProductIconPhase, which enables you to supply an image for each phase of the image-loading process.\n\nSee Also\nCreating product views that load products\ninit(id: Product.ID, prefersPromotionalIcon: Bool)\nCreates a view to load and merchandise an individual product from the App Store.\ninit(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load an individual product from the App Store and merchandise it using an image and a custom placeholder icon.\ninit(id: Product.ID, icon: (ProductIconPhase) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load an individual product from the App Store, and merchandise it using its promotional image and a custom placeholder icon."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate/3749518-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nSee Also\nComparing and hashing renewal states\nstatic func != (Product.SubscriptionInfo.RenewalState, Product.SubscriptionInfo.RenewalState) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate/3749514",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing renewal states\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate/3749522-init",
    "html": "Parameters\nrawValue\n\nThe raw value of the renewal state to create.\n\nRelationships\nFrom Protocol\nRawRepresentable"
  },
  {
    "title": "init(id:prefersPromotionalIcon:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202218-init",
    "html": "Parameters\nproductID\n\nThe product identifier to load from the App Store.\n\nprefersPromotionalIcon\n\nA Boolean value that indicates whether to use the promotional image from the App Store, if it’s available. If this parameter is false, the system ignores any promotional images.\n\nDiscussion\n\nBy default, the view doesn’t show an icon. If you set the prefersPromotionalIcon parameter to true, the view displays a placeholder icon while loading, and replaces the placeholder with the promotional image for the product.\n\nTip\n\nTo gain more control over the image that decorates this view, use the init(id:icon:placeholderIcon:) initializer. It receives a ProductIconPhase, which enables you to supply an image for each phase of the image-loading process.\n\nSee Also\nCreating product views that load products\ninit(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon)\nCreates a view to load an individual product from the App Store and merchandise it using a custom icon.\ninit(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load an individual product from the App Store and merchandise it using an image and a custom placeholder icon.\ninit(id: Product.ID, icon: (ProductIconPhase) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load an individual product from the App Store, and merchandise it using its promotional image and a custom placeholder icon."
  },
  {
    "title": "revoked",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate/3803202-revoked",
    "html": "See Also\nGetting the renewal state\nstatic let subscribed: Product.SubscriptionInfo.RenewalState\nThe user is currently subscribed.\nstatic let expired: Product.SubscriptionInfo.RenewalState\nThe subscription expired.\nstatic let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState\nThe subscription is in a billing retry period.\nstatic let inGracePeriod: Product.SubscriptionInfo.RenewalState\nThe subscription is in a billing grace period state."
  },
  {
    "title": "SubscriptionStorePolicyKind",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorepolicykind",
    "html": "Overview\n\nTo set the destination of a policy button in a SubscriptionStoreView, use subscriptionStorePolicyDestination(url:for:) or subscriptionStorePolicyDestination(for:destination:).\n\nTopics\nGetting policy types\nstatic var privacyPolicy: SubscriptionStorePolicyKind\nThe privacy policy type.\nstatic var termsOfService: SubscriptionStorePolicyKind\nThe terms of service policy type.\nComparing and hashing policy types\nvar hashValue: Int\nfunc hash(into: inout Hasher)\nstatic func != (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (SubscriptionStorePolicyKind, SubscriptionStorePolicyKind) -> Bool\nRelationships\nConforms To\nHashable\nSee Also\nConfiguring the subscription store policies\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> View\nConfigures a view as the destination for a policy button action in subscription store views.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> View\nConfigures a URL as the destination for a policy button action in subscription store views.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> View\nSets the style for the terms of service and privacy policy buttons within a subscription store view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> View\nSets the primary and secondary style for the terms of service and privacy policy buttons within a subscription store view."
  },
  {
    "title": "SubscriptionStoreView.Body",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing a subscription store view\nvar body: View\nThe content and behavior of the view."
  },
  {
    "title": "inBillingRetryPeriod",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate/3749520-inbillingretryperiod",
    "html": "See Also\nGetting the renewal state\nstatic let subscribed: Product.SubscriptionInfo.RenewalState\nThe user is currently subscribed.\nstatic let expired: Product.SubscriptionInfo.RenewalState\nThe subscription expired.\nstatic let inGracePeriod: Product.SubscriptionInfo.RenewalState\nThe subscription is in a billing grace period state.\nstatic let revoked: Product.SubscriptionInfo.RenewalState\nThe App Store has revoked the user’s access to the subscription group."
  },
  {
    "title": "expired",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate/3749517-expired",
    "html": "See Also\nGetting the renewal state\nstatic let subscribed: Product.SubscriptionInfo.RenewalState\nThe user is currently subscribed.\nstatic let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState\nThe subscription is in a billing retry period.\nstatic let inGracePeriod: Product.SubscriptionInfo.RenewalState\nThe subscription is in a billing grace period state.\nstatic let revoked: Product.SubscriptionInfo.RenewalState\nThe App Store has revoked the user’s access to the subscription group."
  },
  {
    "title": "subscriptionStorePolicyDestination(url:for:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4226649-subscriptionstorepolicydestinati",
    "html": "See Also\nConfiguring the subscription store policies\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> View\nConfigures a view as the destination for a policy button action in subscription store views.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> View\nSets the style for the terms of service and privacy policy buttons within a subscription store view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> View\nSets the primary and secondary style for the terms of service and privacy policy buttons within a subscription store view.\nstruct SubscriptionStorePolicyKind\nThe type of policy, such as the terms of service or privacy policies."
  },
  {
    "title": "StoreButtonKind",
    "url": "https://developer.apple.com/documentation/storekit/storebuttonkind",
    "html": "Overview\n\nUse the storeButton(_:for:) modifier on a view to set the visibility of the buttons.\n\nTopics\nGetting button types for store views\nstatic var cancellation: StoreButtonKind\nA type of button that people use to dismiss the current store presentation.\nstatic var restorePurchases: StoreButtonKind\nA type of button that people use to restore purchases.\nGetting additional button types for subscription store views\nstatic var signIn: StoreButtonKind\nA type of button that people use to sign in.\nstatic var redeemCode: StoreButtonKind\nA type of button that people use to redeem an offer code.\nstatic var policies: StoreButtonKind\nA type of button that people use to display store policies.\nSee Also\nConfiguring and styling products\nfunc storeButton(Visibility, for: StoreButtonKind...) -> View\nSpecifies the visibility of auxilliary buttons that store view and subscription store view instances may use."
  },
  {
    "title": "storeButton(_:for:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4204226-storebutton",
    "html": "Parameters\nvisibility\n\nThe preferred visibility (Visibility) of the button.\n\nbuttonKinds\n\nThe type of store button (StoreButtonKind).\n\nSee Also\nAdding accessory feature buttons\nstruct StoreButtonKind\nA button to display in a store view or subscription store view."
  },
  {
    "title": "SubscriptionStoreButtonLabel",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorebuttonlabel",
    "html": "Topics\nInstance Properties\nvar action: SubscriptionStoreButtonLabel\nvar displayName: SubscriptionStoreButtonLabel\nvar hashValue: Int\nvar multiline: SubscriptionStoreButtonLabel\nvar price: SubscriptionStoreButtonLabel\nvar singleLine: SubscriptionStoreButtonLabel\nType Properties\nstatic var action: SubscriptionStoreButtonLabel\nstatic var automatic: SubscriptionStoreButtonLabel\nstatic var displayName: SubscriptionStoreButtonLabel\nstatic var multiline: SubscriptionStoreButtonLabel\nstatic var price: SubscriptionStoreButtonLabel\nstatic var singleLine: SubscriptionStoreButtonLabel\nComparing and hashing button labels\nfunc hash(into: inout Hasher)\nstatic func != (SubscriptionStoreButtonLabel, SubscriptionStoreButtonLabel) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (SubscriptionStoreButtonLabel, SubscriptionStoreButtonLabel) -> Bool\nRelationships\nConforms To\nHashable\nSee Also\nConfiguring subscription store view controls\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> View\nSets a view to use to decorate individual subscription options within a subscription store view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> View\nSets the background style for picker items of the subscription store view instances within a view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> View\nConfigures the subscription store views within a view to use a specified button label.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> View\nSets the control style for subscription store views within a view."
  },
  {
    "title": "subscriptionStoreButtonLabel(_:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4204233-subscriptionstorebuttonlabel",
    "html": "See Also\nConfiguring subscription store view controls\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> View\nSets a view to use to decorate individual subscription options within a subscription store view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> View\nSets the background style for picker items of the subscription store view instances within a view.\nstruct SubscriptionStoreButtonLabel\nThe label of the subscribe button that a subscription store view uses.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> View\nSets the control style for subscription store views within a view."
  },
  {
    "title": "subscriptionStoreControlStyle(_:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4240635-subscriptionstorecontrolstyle",
    "html": "Discussion\n\nThis view modifier set the style of controls for SubscriptionStoreView instances within a view.\n\nSee Also\nConfiguring subscription store view controls\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> View\nSets a view to use to decorate individual subscription options within a subscription store view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> View\nSets the background style for picker items of the subscription store view instances within a view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> View\nConfigures the subscription store views within a view to use a specified button label.\nstruct SubscriptionStoreButtonLabel\nThe label of the subscribe button that a subscription store view uses."
  },
  {
    "title": "signatureData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868436-signaturedata",
    "html": "See Also\nGetting properties for transactions\nvar jwsRepresentation: String\nThe transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Transaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the transaction belongs to the device.\nAvailable when SignedType is Transaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Transaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS transaction.\nAvailable when SignedType is Transaction.\nvar headerData: Data\nThe header component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar payloadData: Data\nThe payload component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signedData: Data\nThe transaction data covered by the signature.\nAvailable when SignedType is Transaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Transaction."
  },
  {
    "title": "SubscriptionStoreControlStyleConfiguration",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolstyleconfiguration",
    "html": "See Also\nCreating custom subscription store views\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a subscription store control.\n\nRequired\n\ntypealias SubscriptionStoreControlStyle.Configuration\nA type that represents the properties of a subscription store control.\nassociatedtype Body\nA view that represents the body of a subscription store control.\n\nRequired"
  },
  {
    "title": "Body",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolstyle/4240622-body",
    "html": "Required\n\nSee Also\nCreating custom subscription store views\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a subscription store control.\n\nRequired\n\ntypealias SubscriptionStoreControlStyle.Configuration\nA type that represents the properties of a subscription store control.\nstruct SubscriptionStoreControlStyleConfiguration\nThe properties of a subscription store view control."
  },
  {
    "title": "EntitlementTaskState",
    "url": "https://developer.apple.com/documentation/storekit/entitlementtaskstate",
    "html": "Overview\n\nTo get an entitlement task state, use currentEntitlementTask(for:priority:action:) or subscriptionStatusTask(for:priority:action:) on a View.\n\nTopics\nGetting the task state\ncase loading\nThe task is loading the entitlement in the background.\ncase success(Value)\nThe task successfully loaded the entitlement.\ncase failure(any Error)\nThe task failed to load the entitlement, with an error.\nGetting the transaction with the entitlement\nvar transaction: VerificationResult<Transaction>?\nThe transaction value if the task is successful.\nAvailable when Value is VerificationResult<Transaction>?.\nvar value: Value?\nThe entitlement value if the task is successful.\nHelper methods\nfunc flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nfunc flatMap<NewValue>((Value) -> EntitlementTaskState<NewValue>) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nfunc map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nfunc map<NewValue>((Value) -> NewValue) -> EntitlementTaskState<NewValue>\nReturns a new state, mapping the entitlement value if successful.\nSee Also\nResponding to store events\nfunc inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) -> View\nAdds a function the system calls before it processes a purchase from a store view, which provides a set of purchase options.\nfunc onInAppPurchaseStart(perform: ((Product) -> ())?) -> View\nAdds an action to perform when a person uses the purchase button for a product within the view.\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, any Error>) -> ())?) -> View\nAdds an action to perform when a purchase the person initiates from within a product view completes.\nfunc subscriptionStoreSignInAction((() -> ())?) -> View\nAdd an action to perform when a person uses the sign-in button on a subscription store view within the view."
  },
  {
    "title": "subscriptionStoreSignInAction(_:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4204241-subscriptionstoresigninaction",
    "html": "See Also\nResponding to store events\nfunc inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) -> View\nAdds a function the system calls before it processes a purchase from a store view, which provides a set of purchase options.\nfunc onInAppPurchaseStart(perform: ((Product) -> ())?) -> View\nAdds an action to perform when a person uses the purchase button for a product within the view.\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, any Error>) -> ())?) -> View\nAdds an action to perform when a purchase the person initiates from within a product view completes.\nenum EntitlementTaskState\nThe state of an entitlement task."
  },
  {
    "title": "init(ids:prefersPromotionalIcon:icon:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4248751-init",
    "html": "Parameters\nproductIDs\n\nThe product identifiers to load from the App Store.\n\nprefersPromotionalIcon\n\nA Boolean value that indicates whether to use promotional images from the App Store, if they’re available. If this parameter is false, the system ignores promotional images.\n\nicon\n\nA closure that returns the image the view displays when the products finish loading from the App Store.\n\nDiscussion\n\nThe store view shows a placeholder icon until all products finish loading. Then, the view uses the image that you provide in icon, by default. If you set prefersPromotionalIcon to true, the view uses the promotional image instead of the icon for any products that have promotional images available.\n\nSee Also\nCreating store views that load products\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool)\nCreates a view to load and merchandise a collection of products from the App Store using product identifiers.\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon: (Product) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using an image and a custom placeholder icon.\ninit(ids: some Collection<String>, icon: (Product, ProductIconPhase) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using their promotional images and a custom placeholder icon."
  },
  {
    "title": "onInAppPurchaseCompletion(perform:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4204091-oninapppurchasecompletion",
    "html": "See Also\nResponding to store events\nfunc inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) -> View\nAdds a function the system calls before it processes a purchase from a store view, which provides a set of purchase options.\nfunc onInAppPurchaseStart(perform: ((Product) -> ())?) -> View\nAdds an action to perform when a person uses the purchase button for a product within the view.\nfunc subscriptionStoreSignInAction((() -> ())?) -> View\nAdd an action to perform when a person uses the sign-in button on a subscription store view within the view.\nenum EntitlementTaskState\nThe state of an entitlement task."
  },
  {
    "title": "ProminentPickerSubscriptionStoreControlStyle",
    "url": "https://developer.apple.com/documentation/storekit/prominentpickersubscriptionstorecontrolstyle",
    "html": "Topics\nGetting the prominent picker control style\nstatic var prominentPicker: ProminentPickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a prominent picker control, with a single button to subscribe.\nCreating the style\nfunc makeBody(configuration: ProminentPickerSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of a prominent picker subscription store.\ntypealias ProminentPickerSubscriptionStoreControlStyle.Body\nA type that represents the body of a prominent picker subscription store control style.\ninit()\nCreates a prominent picker subscription store control style.\nRelationships\nConforms To\nSubscriptionStoreControlStyle\nSee Also\nSupporting types\nstruct AutomaticSubscriptionStoreControlStyle\nThe default in-app subscription store control style that resolves its appearance based on the view’s context.\nstruct ButtonsSubscriptionStoreControlStyle\nA subscription store control style that displays a subscribe button for each subscription plan.\nstruct PickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a picker control, with a single button to subscribe."
  },
  {
    "title": "ButtonsSubscriptionStoreControlStyle",
    "url": "https://developer.apple.com/documentation/storekit/buttonssubscriptionstorecontrolstyle",
    "html": "Topics\nGetting the button subscription store style\nstatic var buttons: ButtonsSubscriptionStoreControlStyle\nA subscription store control style that displays a subscribe button for each subscription plan.\nCreating the style\nfunc makeBody(configuration: ButtonsSubscriptionStoreControlStyle.Configuration) -> View\nCreates a view that represents the body of a button subscription store.\ntypealias ButtonsSubscriptionStoreControlStyle.Body\nA type that represents the body of a button subscription store control style.\ninit()\nCreates a button subscription store control style.\nRelationships\nConforms To\nSubscriptionStoreControlStyle\nSee Also\nSupporting types\nstruct AutomaticSubscriptionStoreControlStyle\nThe default in-app subscription store control style that resolves its appearance based on the view’s context.\nstruct PickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a picker control, with a single button to subscribe.\nstruct ProminentPickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a prominent picker control, with a single button to subscribe."
  },
  {
    "title": "makeBody(configuration:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolstyle/4240626-makebody",
    "html": "Required\n\nParameters\nconfiguration\n\nThe properties of a subscription store control.\n\nSee Also\nCreating custom subscription store views\ntypealias SubscriptionStoreControlStyle.Configuration\nA type that represents the properties of a subscription store control.\nstruct SubscriptionStoreControlStyleConfiguration\nThe properties of a subscription store view control.\nassociatedtype Body\nA view that represents the body of a subscription store control.\n\nRequired"
  },
  {
    "title": "SubscriptionStoreControlStyle.Configuration",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolstyle/configuration",
    "html": "See Also\nCreating custom subscription store views\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a subscription store control.\n\nRequired\n\nstruct SubscriptionStoreControlStyleConfiguration\nThe properties of a subscription store view control.\nassociatedtype Body\nA view that represents the body of a subscription store control.\n\nRequired"
  },
  {
    "title": "Product.PurchaseResult.pending",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseresult/pending",
    "html": "Discussion\n\nIf a pending purchase succeeds, StoreKit delivers the resulting Transaction in the transaction updates.\n\nSee Also\nGetting the Purchase Results\ncase success(VerificationResult<Transaction>)\nThe purchase succeeded and results in a transaction.\ncase userCancelled\nThe user canceled the purchase."
  },
  {
    "title": "Combining parameters for SKAdNetwork 3 postbacks",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/verifying_an_install-validation_postback/combining_parameters_for_skadnetwork_3_postbacks",
    "html": "Overview\n\nCheck your postback’s version, and use the version-specific instructions to combine the parameters to validate the postback. The order of the parameters depends on the version of the postback you receive.\n\nTo verify the signature, combine the postback parameter values in this order for a version 3 postback:\n\nversion\n\nad-network-id\n\ncampaign-id\n\napp-id\n\ntransaction-id\n\nredownload (Use the strings “true” or “false” to represent the Boolean value of the redownload parameter.)\n\nsource-app-id\n\nfidelity-type\n\ndid-win\n\nInclude source-app-id only if you receive it in the postback. Note that the signature doesn’t include a conversion value, even if it’s present in the postback. Postbacks that win the attribution have a did-win value of true. Postbacks that don't win the attribution have a did-win value of false, and don’t include source-app-id.\n\nThe following example of the UTF-8 string includes source-app-id:\n\nversion + '\\u2063' + ad-network-id + '\\u2063' + campaign-id + '\\u2063' + app-id + '\\u2063' + transaction-id + '\\u2063' + redownload + '\\u2063' + source-app-id + '\\u2063' + fidelity-type + '\\u2063' + did-win\n \n\n\nThe following example of the UTF-8 string doesn’t include source-app-id:\n\nversion + '\\u2063' + ad-network-id + '\\u2063' + campaign-id + '\\u2063' + app-id + '\\u2063' + transaction-id + '\\u2063' + redownload + '\\u2063' + fidelity-type + '\\u2063' + did-win\n\n\n\n\nReceive the winning postback with attribution\n\nThe following JSON example shows a version 3 install-validation postback the device sends to an ad network that wins the attribution. This example contains all possible parameters and a valid signature:\n\n{ \n  \"version\": \"3.0\", \n  \"ad-network-id\": \"example123.skadnetwork\", \n  \"campaign-id\": 42, \n  \"transaction-id\": \"6aafb7a5-0170-41b5-bbe4-fe71dedf1e28\", \n  \"app-id\": 525463029, \n  \"attribution-signature\": \"MEYCIQD5eq3AUlamORiGovqFiHWI4RZT/PrM3VEiXUrsC+M51wIhAPMANZA9c07raZJ64gVaXhB9+9yZj/X6DcNxONdccQij\", \n  \"redownload\": true, \n  \"source-app-id\": 1234567891, \n  \"fidelity-type\": 1, \n  \"conversion-value\": 20,\n  \"did-win\": true\n}\n\n\nReceive a nonwinning postback, without attribution\n\nIn iOS 14.6 and later, ad networks that sign ads with version 3 may receive a postback for their qualifying ad impression that don't win the attribution. Such postbacks have a did-win value of false, and don’t include source-app-id or conversion-value.\n\nThe following example shows a version 3 postback for an ad that doesn't win the attribution. This example contains all the parameters the system includes in a nonwinning postback:\n\n{ \n  \"version\": \"3.0\",\n  \"ad-network-id\": \"example123.skadnetwork\",\n  \"campaign-id\": 42,\n  \"transaction-id\": \"f9ac267a-a889-44ce-b5f7-0166d11461f0\",\n  \"app-id\": 525463029,\n  \"attribution-signature\": \"MEUCIQDDetUtkyc/MiQvVJ5I6HIO1E7l598572Wljot2Onzd4wIgVJLzVcyAV+TXksGNoa0DTMXEPgNPeHCmD4fw1ABXX0g=\",\n  \"redownload\": true,\n  \"fidelity-type\": 1,\n  \"did-win\": false\n}\n\n\nUp to five ad networks may receive a nonwinning postback. A single ad network can receive at most one postback per advertised app, per conversion. For example, if the device registers three qualifying ad impressions from your ad network, you receive only one postback.\n\nIf your ad network wins the attribution, you only receive the winning postback, even if the device registers other qualifying impressions for your ad.\n\nFor more information about ad impressions qualifying for attribution, and receiving winning or nonwinning postbacks, see Receiving ad attributions and postbacks.\n\nSee Also\nSKAdNetworks 3 and earlier postbacks\nCombining parameters for previous SKAdNetwork postback versions\nRecreate the byte array for versions 2.2 or earlier."
  },
  {
    "title": "offerType",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3822313-offertype",
    "html": "Deprecated\n\nUse offer instead.\n\nDiscussion\n\nIf this value is nil, there’s no offer applied.\n\nSee Also\nDeprecated\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var environmentStringRepresentation: String\nA string representation of the server environment.\nDeprecated\nvar offerID: String?\nA string that identifies an offer applied to the current subscription.\nDeprecated\n@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2) var offerPaymentModeStringRepresentation: String?\nThe string representation of the payment mode for a subscription offer.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var reasonStringRepresentation: String\nThe string representation of the transaction reason.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var storefrontCountryCode: String\nThe three-letter code that represents the country or region associated with the App Store storefront of the purchase.\nDeprecated"
  },
  {
    "title": "code",
    "url": "https://developer.apple.com/documentation/storekit/transaction/offertype/3822305-code",
    "html": "Discussion\n\nFor more information about offer codes, see Set up offer codes.\n\nSee Also\nGetting offer types\nstatic let introductory: Transaction.OfferType\nAn introductory offer for an auto-renewable subscription.\nstatic let promotional: Transaction.OfferType\nA promotional offer for an auto-renewable subscription."
  },
  {
    "title": "offerID",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3822312-offerid",
    "html": "Deprecated\n\nUse offer instead.\n\nDiscussion\n\nThis value is nil if there isn’t an offer, or if the offer type is introductory.\n\nIf the offer type is promotional, this value contains the promotional offer identifier you set up in App Store Connect. For more information about promotional offers, see Set up promotional offers for auto-renewable subscriptions.\n\nIf the offer type is code, this value contains the reference name of the offer code you set up in App Store Connect. For more information about offer codes, see Set up offer codes.\n\nSee Also\nDeprecated\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var environmentStringRepresentation: String\nA string representation of the server environment.\nDeprecated\n@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2) var offerPaymentModeStringRepresentation: String?\nThe string representation of the payment mode for a subscription offer.\nDeprecated\nvar offerType: Transaction.OfferType?\nThe subscription offer type for the current subscription period.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var reasonStringRepresentation: String\nThe string representation of the transaction reason.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var storefrontCountryCode: String\nThe three-letter code that represents the country or region associated with the App Store storefront of the purchase.\nDeprecated"
  },
  {
    "title": "onInAppPurchaseStart(perform:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4204092-oninapppurchasestart",
    "html": "Parameters\naction\n\nA closure that defines an action to perform, including the product the person intends to purchase as a parameter.\n\nDiscussion\n\nSet the action parameter to nil to remove any actions that ancestor views may add.\n\nSee Also\nResponding to store events\nfunc inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) -> View\nAdds a function the system calls before it processes a purchase from a store view, which provides a set of purchase options.\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, any Error>) -> ())?) -> View\nAdds an action to perform when a purchase the person initiates from within a product view completes.\nfunc subscriptionStoreSignInAction((() -> ())?) -> View\nAdd an action to perform when a person uses the sign-in button on a subscription store view within the view.\nenum EntitlementTaskState\nThe state of an entitlement task."
  },
  {
    "title": "errorCode",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925697-errorcode",
    "html": "See Also\nGetting Error Properties\nvar code: Code\nThe error code.\nvar userInfo: [String : Any]\nThe user information dictionary associated with the error.\nvar errorUserInfo: [String : Any]\nThe error user information dictionary associated with the error.\nvar localizedDescription: String\nA string containing the localized description of the error."
  },
  {
    "title": "Combining parameters to generate a signature for SKAdNetwork 1",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/generating_the_signature_to_validate_storekit-rendered_ads/combining_parameters_to_generate_a_signature_for_skadnetwork_1",
    "html": "Overview\n\nGenerate a signature using the parameters for version 1.0 if you compile your app with an iOS SDK version from 11.3 through 13.7.\n\nTo generate the signature, first combine the values of Ad network install-validation keys for the version 1.0.\n\nThe parameters required for a version 1.0 signature are:\n\nSKStoreProductParameterAdNetworkIdentifier\n\nYour ad network identifier that you registered with Apple. Shown as ad-network-id in Listing 1.\n\nSKStoreProductParameterAdNetworkCampaignIdentifier\n\nA campaign number you provide. Shown as campaign-id in Listing 1.\n\nSKStoreProductParameterITunesItemIdentifier\n\nThe App Store ID of the product to advertise. Shown as itunes-item-id in Listing 1.\n\nSKStoreProductParameterAdNetworkNonce\n\nA unique UUID value that you provide for each ad impression. You must lowercase the string representation of the nonce in the signature. Shown as nonce in Listing 1.\n\nSKStoreProductParameterAdNetworkTimestamp\n\nA timestamp you generate near the time of the ad impression. Shown as timestamp in Listing 1.\n\nCombine the parameters for version 1.0\n\nCreate the UTF-8 string for version 1.0 if you compile your app with an SDK prior to iOS 14.\n\nImportant\n\nYou must use lowercase for the string representation of the nonce: SKStoreProductParameterAdNetworkNonce.\n\nCombine the values into a UTF-8 string with an invisible separator (‘\\u2063’) between them, in the exact order shown:\n\nListing 1 Parameter values combined, in order, for version 1.0.\nad-network-id + '\\u2063' + campaign-id + '\\u2063' + itunes-item-id + '\\u2063' + nonce + '\\u2063' + timestamp\n\n\n\n\nNext, follow the instructions to sign the combined string, encode the signature, and use the generated signature string as described in Generating the signature to validate StoreKit-rendered ads.\n\nSee Also\nSignatures for SKAdNetwork 1, 2, and 2.2–3\nCombining parameters to generate signatures for SKAdNetwork 2.2 and 3\nGenerate signatures to sign your ad with versions 2.2 and 3.\nCombining parameters to generate a signature for SKAdNetwork 2\nGenerate signatures to sign your ad with version 2."
  },
  {
    "title": "Combining parameters to generate a signature for SKAdNetwork 2",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/generating_the_signature_to_validate_storekit-rendered_ads/combining_parameters_to_generate_a_signature_for_skadnetwork_2",
    "html": "Overview\n\nTo generate the signature, first combine the values of Ad network install-validation keys for the version 2.\n\nImportant\n\nLowercase the string representation of the nonce: SKStoreProductParameterAdNetworkNonce. Failing to do so results in an invalid signature. Only ads with valid signatures can get ad attributions.\n\nStrings for version 2 and earlier don’t include a fidelity-type parameter. For version 2, combine the values into a UTF-8 string with an invisible separator (‘\\u2063’) between them, in the exact order shown:\n\nListing 1 Parameter values combined, in order, for version 2.\nversion + '\\u2063' + ad-network-id + '\\u2063' + campaign-id + '\\u2063' + itunes-item-id + '\\u2063' + nonce + '\\u2063' + source-app-id + '\\u2063' + timestamp\n\n\n\n\nSee Also\nSignatures for SKAdNetwork 1, 2, and 2.2–3\nCombining parameters to generate signatures for SKAdNetwork 2.2 and 3\nGenerate signatures to sign your ad with versions 2.2 and 3.\nCombining parameters to generate a signature for SKAdNetwork 1\nGenerate signatures for apps compiled with earlier SDKs."
  },
  {
    "title": "inAppPurchaseOptions(_:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4203983-inapppurchaseoptions",
    "html": "See Also\nResponding to store events\nfunc onInAppPurchaseStart(perform: ((Product) -> ())?) -> View\nAdds an action to perform when a person uses the purchase button for a product within the view.\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, any Error>) -> ())?) -> View\nAdds an action to perform when a purchase the person initiates from within a product view completes.\nfunc subscriptionStoreSignInAction((() -> ())?) -> View\nAdd an action to perform when a person uses the sign-in button on a subscription store view within the view.\nenum EntitlementTaskState\nThe state of an entitlement task."
  },
  {
    "title": "init(subscriptions:marketingContent:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4240634-init",
    "html": "Parameters\nsubscriptions\n\nA collection of auto-renewable subscription Product instances to merchandise. The auto-renewable subscriptions need to belong to the same subscription group.\n\nmarketingContent\n\nA view that contains marketing content, to display above the store controls.\n\nSee Also\nCreating subscription store views with preloaded subscriptions\ninit(subscriptions: some Collection<Product>)\nCreates a view to display a collection of subscription options and merchandise them with automatic marketing content."
  },
  {
    "title": "init(subscriptions:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4248754-init",
    "html": "Parameters\nsubscriptions\n\nA collection of auto-renewable subscription Product instances to merchandise. The auto-renewable subscriptions need to belong to the same subscription group.\n\nSee Also\nCreating subscription store views with preloaded subscriptions\ninit(subscriptions: some Collection<Product>, marketingContent: () -> (Content))\nCreates a view to display a collection of subscription options and merchandise them with custom marketing content."
  },
  {
    "title": "billingIssue",
    "url": "https://developer.apple.com/documentation/storekit/message/reason/4123328-billingissue",
    "html": "Discussion\n\nIf an auto-renewable subscription fails to renew due to a billing issue, the subscription enters a billing retry state, and the App Store sends a message with the billingIssue reason.\n\nWhen a billing issue is in effect, StoreKit displays a Billing Problem message sheet when your app launches, or when your app asks to display it.\n\nThe sheet informs people of the billing issue, and displays an in-app sheet to enable them to correct the issue without leaving your app. Note that people can also resolve billing issues outside of your app by navigating to the manage payments section in Apple ID settings. For more information, see support.apple.com.\n\nApple attempts to renew the subscription during the billing retry period, up to 60 days. During this period, the App Store sends the billingIssue message in the following intervals:\n\nBilling retry interval\n\n\t\n\nMessage frequency\n\n\n\n\nDays 1–3\n\n\t\n\nEvery 24 hours\n\n\n\n\nDays 4–16\n\n\t\n\nEvery 72 hours\n\n\n\n\nDays 17–30\n\n\t\n\nEvery 96 hours\n\n\n\n\nDays 31–60\n\n\t\n\nEvery 120 hours\n\nThe App Store stops sending further messages when the user resolves the billing issue, cancels the subscription, or when the billing retry period ends. StoreKit ensures that the sheet appears only if the message is applicable when your app calls display(in:) or DisplayMessageAction.\n\nFor more information about the billing retry state, see isInBillingRetry in Product.SubscriptionInfo.RenewalInfo.\n\nTest the message in the sandbox environment\n\nYou can simulate billing issues in the sandbox environment to test how the system presents the billingIssue message in your app, and how your app handles it if you choose to delay or suppress its presentation. For more information, including step-by-step test cases, see Testing failing subscription renewals and in-app purchases.\n\nSee Also\nGetting the message reasons\nstatic let generic: Message.Reason\nA message the App Store sends for a generic reason.\nstatic let priceIncreaseConsent: Message.Reason\nA message the App Store sends when you increase the price of an auto-renewable subscription and the price increase requires the user’s consent."
  },
  {
    "title": "signature",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3954519-signature",
    "html": "Discussion\n\nUse this signature with Apple CryptoKit if you verify the signature on the device.\n\nSee Also\nGetting properties for app transactions\nvar jwsRepresentation: String\nThe app transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is AppTransaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nAvailable when SignedType is AppTransaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is AppTransaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar headerData: Data\nThe header component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar payloadData: Data\nThe payload component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signedData: Data\nThe app transaction data covered by the signature.\nAvailable when SignedType is AppTransaction.\nvar signatureData: Data\nThe signature component of the JWS app transaction.\nAvailable when SignedType is AppTransaction."
  },
  {
    "title": "signedData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868439-signeddata",
    "html": "See Also\nGetting properties for subscription renewal info\nvar jwsRepresentation: String\nThe subscription renewal information signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the subscription renewal info belongs to the device.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedDate: Date\nThe date that the App Store signed the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar headerData: Data\nThe header component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar payloadData: Data\nThe payload component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signatureData: Data\nThe signature component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo."
  },
  {
    "title": "jwsRepresentation",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3954517-jwsrepresentation",
    "html": "Discussion\n\nUse this value to perform your own JWS verification on your server or on the device.\n\nSee Also\nGetting properties for app transactions\nvar deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nAvailable when SignedType is AppTransaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is AppTransaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar headerData: Data\nThe header component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar payloadData: Data\nThe payload component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signedData: Data\nThe app transaction data covered by the signature.\nAvailable when SignedType is AppTransaction.\nvar signatureData: Data\nThe signature component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is AppTransaction."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3792066",
    "html": "See Also\nComparing and hashing verification results\nstatic func != (VerificationResult<SignedType>, VerificationResult<SignedType>) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nAvailable when SignedType conforms to Equatable.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nAvailable when SignedType conforms to Hashable.\nvar hashValue: Int\nThe hash value.\nAvailable when SignedType conforms to Hashable."
  },
  {
    "title": "headerData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3954516-headerdata",
    "html": "See Also\nGetting properties for app transactions\nvar jwsRepresentation: String\nThe app transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is AppTransaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nAvailable when SignedType is AppTransaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is AppTransaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar payloadData: Data\nThe payload component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signedData: Data\nThe app transaction data covered by the signature.\nAvailable when SignedType is AppTransaction.\nvar signatureData: Data\nThe signature component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is AppTransaction."
  },
  {
    "title": "deviceVerificationNonce",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3954515-deviceverificationnonce",
    "html": "Discussion\n\nUse the lowercased nonce when computing the deviceVerification value.\n\nThis value is identical to the deviceVerificationNonce value in AppTransaction.\n\nSee Also\nGetting properties for app transactions\nvar jwsRepresentation: String\nThe app transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is AppTransaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nAvailable when SignedType is AppTransaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar headerData: Data\nThe header component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar payloadData: Data\nThe payload component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signedData: Data\nThe app transaction data covered by the signature.\nAvailable when SignedType is AppTransaction.\nvar signatureData: Data\nThe signature component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is AppTransaction."
  },
  {
    "title": "deviceVerification",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3954514-deviceverification",
    "html": "Discussion\n\nFor more information about using the device verification value, see deviceVerification.\n\nThis value is identical to the deviceVerification value in AppTransaction.\n\nSee Also\nGetting properties for app transactions\nvar jwsRepresentation: String\nThe app transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is AppTransaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is AppTransaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar headerData: Data\nThe header component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar payloadData: Data\nThe payload component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signedData: Data\nThe app transaction data covered by the signature.\nAvailable when SignedType is AppTransaction.\nvar signatureData: Data\nThe signature component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is AppTransaction."
  },
  {
    "title": "signedDate",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3954522-signeddate",
    "html": "Discussion\n\nUse the signedDate to verify whether the certificate used to sign the transaction was valid when the App Store signed the transaction.\n\nSee Also\nGetting properties for app transactions\nvar jwsRepresentation: String\nThe app transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is AppTransaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nAvailable when SignedType is AppTransaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is AppTransaction.\nvar headerData: Data\nThe header component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar payloadData: Data\nThe payload component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signedData: Data\nThe app transaction data covered by the signature.\nAvailable when SignedType is AppTransaction.\nvar signatureData: Data\nThe signature component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is AppTransaction."
  },
  {
    "title": "debugDescription",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3792067-debugdescription",
    "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3792065",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing verification results\nstatic func == (VerificationResult<SignedType>, VerificationResult<SignedType>) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nAvailable when SignedType conforms to Equatable.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nAvailable when SignedType conforms to Hashable.\nvar hashValue: Int\nThe hash value.\nAvailable when SignedType conforms to Hashable."
  },
  {
    "title": "deviceVerificationNonce",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868425-deviceverificationnonce",
    "html": "Discussion\n\nUse the lowercased nonce when computing the deviceVerification value.\n\nThis value is identical to the deviceVerificationNonce value in Transaction.\n\nSee Also\nGetting properties for transactions\nvar jwsRepresentation: String\nThe transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Transaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the transaction belongs to the device.\nAvailable when SignedType is Transaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS transaction.\nAvailable when SignedType is Transaction.\nvar headerData: Data\nThe header component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar payloadData: Data\nThe payload component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signedData: Data\nThe transaction data covered by the signature.\nAvailable when SignedType is Transaction.\nvar signatureData: Data\nThe signature component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Transaction."
  },
  {
    "title": "deviceVerification",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868423-deviceverification",
    "html": "Discussion\n\nFor more information about using the deviceVerification value, see deviceVerification.\n\nThis value is identical to the deviceVerification value in Transaction.\n\nSee Also\nGetting properties for transactions\nvar jwsRepresentation: String\nThe transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Transaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Transaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS transaction.\nAvailable when SignedType is Transaction.\nvar headerData: Data\nThe header component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar payloadData: Data\nThe payload component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signedData: Data\nThe transaction data covered by the signature.\nAvailable when SignedType is Transaction.\nvar signatureData: Data\nThe signature component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Transaction."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate/3749519-hashvalue",
    "html": "See Also\nComparing and hashing renewal states\nstatic func != (Product.SubscriptionInfo.RenewalState, Product.SubscriptionInfo.RenewalState) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "subscriptionStorePolicyDestination(for:destination:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4211638-subscriptionstorepolicydestinati",
    "html": "See Also\nConfiguring the subscription store policies\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> View\nConfigures a URL as the destination for a policy button action in subscription store views.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> View\nSets the style for the terms of service and privacy policy buttons within a subscription store view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> View\nSets the primary and secondary style for the terms of service and privacy policy buttons within a subscription store view.\nstruct SubscriptionStorePolicyKind\nThe type of policy, such as the terms of service or privacy policies."
  },
  {
    "title": "body",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4203852-body",
    "html": "Relationships\nFrom Protocol\nView\nSee Also\nImplementing a subscription store view\ntypealias SubscriptionStoreView.Body\nThe type of view that represents the body of the subscription store view."
  },
  {
    "title": "subscriptionStorePolicyForegroundStyle(_:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4211639-subscriptionstorepolicyforegroun",
    "html": "See Also\nConfiguring the subscription store policies\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> View\nConfigures a view as the destination for a policy button action in subscription store views.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> View\nConfigures a URL as the destination for a policy button action in subscription store views.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> View\nSets the primary and secondary style for the terms of service and privacy policy buttons within a subscription store view.\nstruct SubscriptionStorePolicyKind\nThe type of policy, such as the terms of service or privacy policies."
  },
  {
    "title": "subscriptionStorePolicyForegroundStyle(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4211640-subscriptionstorepolicyforegroun",
    "html": "See Also\nConfiguring the subscription store policies\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> View\nConfigures a view as the destination for a policy button action in subscription store views.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> View\nConfigures a URL as the destination for a policy button action in subscription store views.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> View\nSets the style for the terms of service and privacy policy buttons within a subscription store view.\nstruct SubscriptionStorePolicyKind\nThe type of policy, such as the terms of service or privacy policies."
  },
  {
    "title": "paymentQueue(_:shouldAddStorePayment:for:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver/2877502-paymentqueue",
    "html": "Parameters\nqueue\n\nThe payment queue the app uses to make the payment request.\n\npayment\n\nThe payment request.\n\nproduct\n\nThe in-app purchase product.\n\nReturn Value\n\nReturn true to continue the transaction in your app.\n\nReturn false to defer or cancel the transaction.\n\nIf you return false, you can continue the transaction later by manually adding the SKPayment payment to the SKPaymentQueue queue.\n\nDiscussion\n\nThe system calls this delegate method when the user starts an in-app purchase in the App Store, and the transaction continues in your app. Specifically, if your app is already installed, StoreKit calls this method automatically.\n\nIf your app isn’t installed when the user starts the in-app purchase in the App Store, the user receives a notification when the app installation is complete. StoreKit calls this method when the user taps the notification. Otherwise, if the user opens the app manually, StoreKit calls this method only if they open the app soon after they initiate the purchase.\n\nImportant\n\nTo enable promoted in-app purchases, your app needs to use either PurchaseIntent (starting in iOS 16.4) or paymentQueue(_:shouldAddStorePayment:for:) (starting in iOS 11). Don’t use both at the same time. If necessary, use conditional compilation to identify the OS version the app is running in. For more information, see Running code on a specific platform or OS version.\n\nFor more information, see Promoting in-app purchases.\n\nSee Also\nHandling promoted in-app purchases\nPromoting in-app purchases\nShow promoted in-app purchases on your product page and handle purchases that users initiate on the App Store."
  },
  {
    "title": "payloadData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868431-payloaddata",
    "html": "Discussion\n\nThis value is the same as the jsonRepresentation in Transaction.\n\nSee Also\nGetting properties for transactions\nvar jwsRepresentation: String\nThe transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Transaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the transaction belongs to the device.\nAvailable when SignedType is Transaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Transaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS transaction.\nAvailable when SignedType is Transaction.\nvar headerData: Data\nThe header component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signedData: Data\nThe transaction data covered by the signature.\nAvailable when SignedType is Transaction.\nvar signatureData: Data\nThe signature component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Transaction."
  },
  {
    "title": "jwsRepresentation",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868429-jwsrepresentation",
    "html": "Discussion\n\nUse this value to perform your own JWS verification on your server, or on the device.\n\nSee Also\nGetting properties for transactions\nvar deviceVerification: Data\nThe device verification value to use to verify whether the transaction belongs to the device.\nAvailable when SignedType is Transaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Transaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS transaction.\nAvailable when SignedType is Transaction.\nvar headerData: Data\nThe header component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar payloadData: Data\nThe payload component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signedData: Data\nThe transaction data covered by the signature.\nAvailable when SignedType is Transaction.\nvar signatureData: Data\nThe signature component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Transaction."
  },
  {
    "title": "intents",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/4123376-intents",
    "html": "Discussion\n\nWhen a user selects to purchase a promoted product on the App Store, your app receives a purchase intent. Use the product object to complete your app’s purchase workflow, including finishing the purchase, unlocking the product, and any other workflow specific to your app.\n\nThe following example code receives the purchase intent, and calls a method to complete the purchase workflow:\n\nfunc purchaseProduct(_ product: Product) async {\n    // Complete the purchase workflow.\n    do {\n        try await product.purchase()\n    }\n    catch {\n        <#Handle Error#>\n    }\n    <#Add remaining purchase workflow.#>\n}\n\n\nfor await purchaseIntent in PurchaseIntent.intents {\n    // Complete the purchase workflow.\n    await purchaseProduct(purchaseIntent.product)\n}\n\n\n\n\nSee Also\nGetting purchase intents\nstruct PurchaseIntent.PurchaseIntents\nAn asynchronous sequence of purchase intents for in-app purchases that users initiate on the App Store."
  },
  {
    "title": "all",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/4137248-all",
    "html": "See Also\nMonitoring subscription status changes\nstatic var updates: Product.SubscriptionInfo.Status.Statuses\nThe asynchronous sequence that emits status information when a subscription’s status changes.\nstruct Product.SubscriptionInfo.Status.Statuses\nAn asynchronous sequence that listens for new subscription status information."
  },
  {
    "title": "updates",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/3851115-updates",
    "html": "See Also\nMonitoring subscription status changes\nstatic var all: AsyncStream<(groupID: String, statuses: [Product.SubscriptionInfo.Status])>\nstruct Product.SubscriptionInfo.Status.Statuses\nAn asynchronous sequence that listens for new subscription status information."
  },
  {
    "title": "localizedDescription",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925707-localizeddescription",
    "html": "See Also\nGetting Error Properties\nvar code: Code\nThe error code.\nvar errorCode: Int\nThe integer error code.\nvar userInfo: [String : Any]\nThe user information dictionary associated with the error.\nvar errorUserInfo: [String : Any]\nThe error user information dictionary associated with the error."
  },
  {
    "title": "delegate",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductviewcontroller/1620634-delegate",
    "html": "Discussion\n\nYour application must set the delegate before presenting the store view controller.\n\nSee Also\nSetting a delegate\nprotocol SKStoreProductViewControllerDelegate\nA protocol called when the user dismisses the store screen.\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3792069-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing verification results\nstatic func != (VerificationResult<SignedType>, VerificationResult<SignedType>) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nAvailable when SignedType conforms to Equatable.\nstatic func == (VerificationResult<SignedType>, VerificationResult<SignedType>) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nAvailable when SignedType conforms to Equatable.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nAvailable when SignedType conforms to Hashable."
  },
  {
    "title": "low",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/coarseconversionvalue/4090672-low",
    "html": "Discussion\n\nThis constant has no special meaning. It’s up to the app or ad network to determine its meaning as needed.\n\nSee Also\nProviding coarse conversion values\nstatic let high: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a high coarse conversion value.\nstatic let medium: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a medium coarse conversion value.\ninit(rawValue: String)\nCreates a coarse conversion value from the raw value."
  },
  {
    "title": "quantity(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3749445-quantity",
    "html": "Parameters\nquantity\n\nThe number of items the customer is purchasing.\n\nThe default value is 1. The maximum value is 10.\n\nReturn Value\n\nAn instance of Product.PurchaseOption to use in purchase(options:).\n\nDiscussion\n\nThe quantity applies to consumable in-app purchases and non-renewing subscriptions.\n\nSee Also\nSetting the purchase options\nstatic func appAccountToken(UUID) -> Product.PurchaseOption\nSets a UUID to associate the purchase with an account in your system.\nstatic func onStorefrontChange(shouldContinuePurchase: (Storefront) -> Bool) -> Product.PurchaseOption\nIndicates whether a transaction needs to continue if the App Store storefront changes on the device during the transaction.\nstatic func promotionalOffer(offerID: String, keyID: String, nonce: UUID, signature: Data, timestamp: Int) -> Product.PurchaseOption\nApplies a promotional offer for an auto-renewable subscription."
  },
  {
    "title": "simulatesAskToBuyInSandbox(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3749446-simulatesasktobuyinsandbox",
    "html": "Parameters\nsimulateAskToBuy\n\nSet to true to simulate a child’s account asking permission to make a purchase.\n\nReturn Value\n\nAn instance of Product.PurchaseOption to use in purchase(options:).\n\nDiscussion\n\nFor information about testing Ask to Buy scenarios, see Testing at all stages of development with Xcode and the sandbox.\n\nFor information about purchases made using Ask to Buy, see Approve what kids buy with Ask to Buy."
  },
  {
    "title": "high",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/coarseconversionvalue/4090671-high",
    "html": "Discussion\n\nThis constant has no special meaning. It’s up to the app or ad network to determine its meaning as needed.\n\nSee Also\nProviding coarse conversion values\nstatic let low: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a low coarse conversion value.\nstatic let medium: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a medium coarse conversion value.\ninit(rawValue: String)\nCreates a coarse conversion value from the raw value."
  },
  {
    "title": "Combining parameters for previous SKAdNetwork postback versions",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/verifying_an_install-validation_postback/combining_parameters_for_previous_skadnetwork_postback_versions",
    "html": "Overview\n\nCombine postback parameters to recreate a byte array that you use to verify Apple’s signature. To recreate the byte array, create a UTF-8 string by combining the parameter values in an exact order, with an invisible separator (‘\\u2063’) between them. You must combine the parameters in the exact orders as show in the examples. For more information about the parameters and verifying the signature, and an example using newer versions, see Verifying an install-validation postback.\n\nCombine postback parameters for version 2.2\n\nThe following JSON shows an example of a version 2.2 install-validation postback that contains all possible parameters and a valid signature:\n\n{\n  \"version\" : \"2.2\",\n  \"ad-network-id\" : \"com.example\",\n  \"campaign-id\" : 42,\n  \"transaction-id\" : \"6aafb7a5-0170-41b5-bbe4-fe71dedf1e28\",\n  \"app-id\" : 525463029,\n  \"attribution-signature\" : \"MEYCIQDTuQ1Z4Tpy9D3aEKbxLl5J5iKiTumcqZikuY/AOD2U7QIhAJAaiAv89AoquHXJffcieEQXdWHpcV8ZgbKN0EwV9/sY\",\n  \"redownload\": true,\n  \"source-app-id\": 1234567891,\n  \"fidelity-type\": 1,\n  \"conversion-value\": 20\n}  \n\n\nTo verify the signature, combine version 2.2 postback parameters in this order:\n\nversion\n\nad-network-id\n\ncampaign-id\n\napp-id\n\ntransaction-id\n\nredownload Note: use the strings “true” or “false” to represent the Boolean value of the redownload parameter.\n\nsource-app-id\n\nfidelity-type\n\nInclude source-app-id only if you received it in the postback. Note that the signature never includes a conversion value, even if it’s present in the postback.\n\nThe following is an example of the UTF-8 string for a postback with source-app-id present in the postback:\n\nversion + '\\u2063' + ad-network-id + '\\u2063' + campaign-id + '\\u2063' + app-id + '\\u2063' + transaction-id + '\\u2063' + redownload + '\\u2063' + source-app-id\n+ '\\u2063' + fidelity-type\n \n\n\nThe following is an example of the UTF-8 string for a postback without source-app-id:\n\nversion + '\\u2063' + ad-network-id + '\\u2063' + campaign-id + '\\u2063' + app-id + '\\u2063' + transaction-id + '\\u2063' + redownload + '\\u2063' + fidelity-type\n\n\n\n\nCombine postback parameters for versions 2 and 2.1\n\nVersion 2 and 2.1 postbacks contain the following parameters. Combine their values in this order:\n\nversion\n\nad-network-id\n\ncampaign-id\n\napp-id\n\ntransaction-id\n\nredownload Note: use the strings “true” or “false” to represent the Boolean value of the redownload parameter.\n\nsource-app-id\n\nInclude source-app-id only if you receive it in the postback. Note that the signature never includes a conversion value, even if it’s present in the postback.\n\nThe following is an example of the UTF-8 string for a postback with source-app-id present in the postback:\n\nversion + '\\u2063' + ad-network-id + '\\u2063' + campaign-id + '\\u2063' + app-id + '\\u2063' + transaction-id + '\\u2063' + redownload + '\\u2063' + source-app-id\n \n\n\nThe following is an example of the UTF-8 string for a postback without source-app-id:\n\nversion + '\\u2063' + ad-network-id + '\\u2063' + campaign-id + '\\u2063' + app-id + '\\u2063' + transaction-id + '\\u2063' + redownload\n\n\n\n\nCombine postback parameters for version 1\n\nVersion 1 postbacks contain the following parameters. Combine their values in this order:\n\nad-network-id\n\ncampaign-id\n\napp-id\n\ntransaction-id\n\nThe following is an example of the UTF-8 string for a version 1.0 postback:\n\nad-network-id + '\\u2063' + campaign-id + '\\u2063' + app-id + '\\u2063' + transaction-id \n\n\nSee Also\nSKAdNetworks 3 and earlier postbacks\nCombining parameters for SKAdNetwork 3 postbacks\nRecreate the byte array for version 3 postbacks that win and don’t win attribution."
  },
  {
    "title": "errorUserInfo",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925699-erroruserinfo",
    "html": "See Also\nGetting Error Properties\nvar code: Code\nThe error code.\nvar errorCode: Int\nThe integer error code.\nvar userInfo: [String : Any]\nThe user information dictionary associated with the error.\nvar localizedDescription: String\nA string containing the localized description of the error."
  },
  {
    "title": "Testing introductory offers",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/testing_introductory_offers",
    "html": "Overview\n\nTo test introductory offers, verify that users see the same subscription and introductory offer prices in your app as they do in the App Store. As part of your test, make sure your app presents introductory offers only to users that are eligible for them.\n\nTo test introductory offers:\n\nConfigure test accounts, as described in Create a sandbox tester account. Create a variety of accounts that are eligible or ineligible for offers.\n\nInitiate in-app purchases from within the app for each test user.\n\nVerify that the user experience and pricing information dynamically represent the accurate price of your subscription.\n\nIntroductory offers are only offered once, but when testing your app, you can reset the status of the test account to allow you to redeem an introductory offer more than once. To reset offer eligibility for the sandbox account:\n\nOn the test iOS device, open Settings > Apple ID > Media & Purchases (or iTunes & App Store for iOS 13 and earlier). Under the Sandbox Account section, tap your highlighted Sandbox Apple ID then tap Manage to open the sandbox Subscription Management page.\n\nTap the expired subscription you want to reactivate. The subscription products that appear are those you configured in App Store Connect under the same subscription group.\n\nIf the test account used an introductory offer, then the system diplays a Reset Eligibility button that lets you reset and redeem another introductory offer.\n\nSee Also\nIntroductory offers\nImplementing introductory offers in your app\nOffer introductory pricing for auto-renewable subscriptions to eligible users.\nclass SKProductDiscount\nThe details of an introductory offer or a promotional offer for an auto-renewable subscription."
  },
  {
    "title": "code",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925696-code",
    "html": "See Also\nGetting Error Properties\nvar errorCode: Int\nThe integer error code.\nvar userInfo: [String : Any]\nThe user information dictionary associated with the error.\nvar errorUserInfo: [String : Any]\nThe error user information dictionary associated with the error.\nvar localizedDescription: String\nA string containing the localized description of the error."
  },
  {
    "title": "Testing complete transactions",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_complete_transactions",
    "html": "Overview\n\nLocate where your app calls the finishTransaction(_:) method, and verify that your app completes all work related to the transaction before calling the method. For example, if the purchase includes downloadable content, verify your app downloaded the content to your test device as described in Persisting a purchase. Verify that you call finishTransaction(_:) for every transaction, whether it succeeded or failed. For more information, see Finishing a transaction.\n\nSee Also\nTransaction observer\nTesting transaction observer code\nVerify that your app activates its payment transaction observer by using breakpoints.\nTesting a successful transaction\nConfirm that your app can make a successful transaction in the sandbox environment by inspecting the transaction."
  },
  {
    "title": "Product.PromotionInfo.Visibility",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/visibility",
    "html": "Overview\n\nUse the visibility states to set the visibility of a promoted in-app purchase. Call update() to save your changes.\n\nThe visibility states have the following effects on the user’s device:\n\nProduct.PromotionInfo.Visibility.visible makes the promoted in-app purchase visible in the App Store.\n\nProduct.PromotionInfo.Visibility.hidden hides the promoted in-app purchase in the App Store.\n\nProduct.PromotionInfo.Visibility.appStoreConnectDefault let’s you control the visibility using settings in App Store Connect. For more information, see Promote in-app purchases.\n\nTopics\nGetting visibility states\ncase appStoreConnectDefault\nA visibility value for a promoted in-app purchase that uses the visibility setting from App Store Connect.\ncase hidden\nA visibility value that hides a promoted in-app purchase on the App Store on a user’s device.\ncase visible\nA visibility value that makes a promoted in-app purchase visible on the App Store on a user’s device.\nCreating visibility states\ninit?(rawValue: Int)\nCreates a visibility state.\ntypealias Product.PromotionInfo.Visibility.RawValue\nA type that represents the raw value of the visibility state of a promoted in-app purchase.\nvar rawValue: Int\nThe raw value that represents the visiblity state of a promoted in-app purchase.\nComparing and hashing visibility\nstatic func != (Product.PromotionInfo.Visibility, Product.PromotionInfo.Visibility) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nSee Also\nManaging promotion visibility\nvar visibility: Product.PromotionInfo.Visibility\nA value that indicates whether the promoted in-app purchase is visible or hidden on the user’s device.\nstatic func updateProductVisibility(Product.PromotionInfo.Visibility, for: Product.ID)\nUpdates a value that indicates whether a promoted in-app purchase appears in the App Store on the user's device."
  },
  {
    "title": "updateProductVisibility(_:for:)",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/4115023-updateproductvisibility",
    "html": "Parameters\nvisibility\n\nA visibility value of Product.PromotionInfo.Visibility that determines whether a promoted in-app purchase appears in the App Store on the user's device.\n\nproductID\n\nThe product identifier of the promoted in-app purchase.\n\nDiscussion\n\nCall this method to change the visibility setting for a promoted in-app purchase. Changes take effect after you call this method.\n\nThe following code example updates a promoted product's visibility after the user purchases it. The purchased product is hidden to avoid showing it again on the device.\n\n// Update visibility to hide a promoted product after the user purchases it.\nlet purchasedProductIdentifier = \"com.example.ExampleApp.product1\"\n\n\ndo {\n  try await Product.PromotionInfo.updateProductVisibility(.hidden, for: purchasedProductIdentifier)\n}\ncatch {\n  <#Handle Error#>\n}\n\n\nSee Also\nManaging promotion visibility\nvar visibility: Product.PromotionInfo.Visibility\nA value that indicates whether the promoted in-app purchase is visible or hidden on the user’s device.\nenum Product.PromotionInfo.Visibility\nThe visibility states for product promotion information."
  },
  {
    "title": "SKAdNetwork 4 release notes",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/skadnetwork_release_notes/skadnetwork_4_release_notes",
    "html": "Overview\n\nUse “4.0” as the version number when signing ads for this version.\n\nYou’re eligible to receive a version 4 postback if all participants meet the following conditions:\n\nThe ad network generates an ad signature for version 4.\n\nFor ads that appear in an app, the app is built with iOS 16.1 SDK or later. For web ads, the ad appears in Safari 16.1 or later.\n\nThe advertised app is App Store-signed and is running on a device with iOS 16.1 or later.\n\nAdvertised apps built with iOS 16.1 SDK or later can register up to three conversions that result in postbacks for the winning ad impression. Apps built with earlier SDKs can register only one conversion, resulting in one winning postback.\n\nNew features\n\nMultiple postbacks. SKAdNetwork now supports multiple conversions in three conversion windows. When you call the new methods updatePostbackConversionValue(_:coarseValue:completionHandler:) and updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:), the app can update conversion values in three separate conversion windows. The app may send up to three postbacks for the winning ad attribution.\n\nYou can lock a conversion during a conversion window to receive the postback sooner by calling updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) and setting the lock to true. Otherwise, the system sends postbacks after the conversion window closes. For more information about postback timing, see Receiving ad attributions and postbacks. For more information about multiple postbacks, see Receiving postbacks in multiple conversion windows.\n\nCoarse conversion values. The conversion value that you send can include both a fine-grained value and a coarse-grained value. For information about coarse conversion values, see SKAdNetwork.CoarseConversionValue. You provide the fine and coarse conversion values in the new methods updatePostbackConversionValue(_:coarseValue:completionHandler:) and updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:).\n\nHierarchical source identifiers. Ad networks can now provide hierarchical source identifiers when they sign an ad, which replaces and expands on campaign identifiers. The source identifer is a four-digit integer, which you indicate in sourceIdentifier for view-through ads and in SKStoreProductParameterAdNetworkSourceIdentifier for StoreKit-rendered ads. Winning postbacks contain two, three, or four digits of the source identifier, depending on the ad impression’s privacy threshold tier.\n\nAttributed ads on the web. SKAdNetwork for Web Ads supports attributed ads that you initiate on Safari web pages.\n\nSee Also\nSKAdNetwork versions\nSKAdNetwork 3 release notes\nA version of SKAdNetwork available in iOS 14.6 and later.\nSKAdNetwork 2.2 release notes\nA version of SKAdNetwork available in iOS 14.5 and later.\nSKAdNetwork 2.1 release notes\nA version of SKAdNetwork available in iOS 14 and later.\nSKAdNetwork 2 release notes\nA version of SKAdNetwork available in iOS 14 and later.\nSKAdNetwork 1 release notes\nA version of SKAdNetwork available in iOS 11.3 and later."
  },
  {
    "title": "updateProductOrder(byID:)",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/4115022-updateproductorder",
    "html": "Parameters\norder\n\nA collection of product identifiers (Product.ID) in the order that you want the promoted in-app purchases to appear, from first to last. Use an empty list to cancel previous changes.\n\nDiscussion\n\nCall this static method to override the default order of promoted in-app purchases on the current device. You provide the product identifiers of the promoted in-app purchases to set their order.\n\nTo hide a promoted in-app purchase so it doesn't display in the App Store for the user, don't include its product identifier when calling this method. You may want to do this, for example, if the user has already purchased the product, or if it isn't relevant to them for some other reason.\n\nTo set the order using Product.PromotionInfo objects instead of product identifiers, see updateAll(_:).\n\nCancel overrides\n\nTo cancel the order and visibility changes you make, send an empty collection in the order parameter. All in-app purchases then display in the default order.\n\n// Cancel overrides by using an empty collection.\ndo {\n    try await Product.PromotionInfo.updateProductOrder(byID: [])\n}\ncatch {\n    <#Handle error.#>\n}\n"
  },
  {
    "title": "Combining parameters to generate signatures for SKAdNetwork 2.2 and 3",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/generating_the_signature_to_validate_storekit-rendered_ads/combining_parameters_to_generate_signatures_for_skadnetwork_2_2_and_3",
    "html": "Overview\n\nTo generate the signature, combine the required values of Ad network install-validation keys for version 2, and include a fidelity-type value of 1 for StoreKit-rendered ads.\n\nImportant\n\nLowercase the string representation of the nonce: SKStoreProductParameterAdNetworkNonce. Failing to do so results in an invalid signature. Only ads with valid signatures can get ad attributions.\n\nFor versions 2.2 and 3, combine the values into a UTF-8 string with an invisible separator (‘\\u2063’) between them, in the exact order the code below shows:\n\n//Parameter values combined, in order, for version 2.2 and 3.\nversion + '\\u2063' + ad-network-id + '\\u2063' + campaign-id + '\\u2063' + itunes-item-id + '\\u2063' + nonce + '\\u2063' + source-app-id + '\\u2063' + fidelity-type + '\\u2063' + timestamp\n\n\n\n\nSee Also\nSignatures for SKAdNetwork 1, 2, and 2.2–3\nCombining parameters to generate a signature for SKAdNetwork 2\nGenerate signatures to sign your ad with version 2.\nCombining parameters to generate a signature for SKAdNetwork 1\nGenerate signatures for apps compiled with earlier SDKs."
  },
  {
    "title": "update()",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/4115020-update",
    "html": "Discussion\n\nIf you change the visibility value by setting it directly, call update() to save your changes to the App Store server. Changes take effect after you call update() or updateAll(_:).\n\nSee Also\nUpdating order and visibility\nstatic func updateAll(some Collection<Product.PromotionInfo>)\nSets the order and visibility of all the promoted products and saves your changes."
  },
  {
    "title": "updateAll(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/4115021-updateall",
    "html": "Parameters\npromotions\n\nA collection of Product.PromotionInfo objects that you list in the order they are to appear in the App Store on the user’s device. Use an empty collection to cancel previous changes.\n\nDiscussion\n\nCall this static method to set the order of promoted in-app purchases for the user. Calling this method overrides any previous order and visibility that you set for this user.\n\nTo remove a promoted in-app purchase so it doesn’t display for a user, there are two options:\n\nDon’t include it in the promotions collection.\n\nChange its visibility value to Product.PromotionInfo.Visibility.hidden.\n\nTo set the order of promoted in-app purchases using product identifiers instead of Product.PromotionInfo objects, see updateProductOrder(byID:).\n\nCancel overrides\n\nTo cancel the order and visibility changes you make, send an empty collection in promotions. All in-app purchases then display in the default order.\n\nSee Also\nUpdating order and visibility\nfunc update()\nSaves your changes to the promoted product’s visibility."
  },
  {
    "title": "init(groupID:visibleRelationships:marketingContent:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4240630-init",
    "html": "Parameters\ngroupID\n\nThe subscription group identifier to load from the App Store.\n\nvisibleRelationships\n\nThe kinds of subscription option relationships the view makes visible when someone is already subscribed to the subscription.\n\nmarketingContent\n\nThe view that contains marketing content, to display above the store controls.\n\nSee Also\nCreating subscription store views with subscription group IDs\ninit(groupID: String, visibleRelationships: Product.SubscriptionRelationship)\nCreates a view to load all subscriptions in a subscription group from the App Store and merchandise them with automatic marketing content.\nstruct AutomaticSubscriptionStoreMarketingContent\nA view that represents the default marketing content for a subscription store."
  },
  {
    "title": "AutomaticSubscriptionStoreMarketingContent",
    "url": "https://developer.apple.com/documentation/storekit/automaticsubscriptionstoremarketingcontent",
    "html": "Overview\n\nYou don’t use this type directly. Instead, create a SubscriptionStoreView using an initializer that doesn’t include a marketingContent parameter for providing custom marketing content.\n\nTopics\nImplementing automatic marketing content\nvar body: View\nThe content and behavior of the view.\ntypealias AutomaticSubscriptionStoreMarketingContent.Body\nA type that represents the body of automatic subscription store marketing content.\nInstance Methods\nfunc productDescription(Visibility) -> View\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> View\nfunc subscriptionPromotionalOffer(offer: (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?, signature: (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) -> Product.SubscriptionOffer.Signature) -> View\nRelationships\nConforms To\nView\nSee Also\nCreating subscription store views with subscription group IDs\ninit(groupID: String, visibleRelationships: Product.SubscriptionRelationship)\nCreates a view to load all subscriptions in a subscription group from the App Store and merchandise them with automatic marketing content.\ninit(groupID: String, visibleRelationships: Product.SubscriptionRelationship, marketingContent: () -> (Content))\nCreates a view to load all the subscriptions in a subscription group from the App Store and merchandise them with custom marketing content."
  },
  {
    "title": "presentCodeRedemptionSheet()",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/3566726-presentcoderedemptionsheet",
    "html": "Discussion\n\nThe presentCodeRedemptionSheet() function displays a system sheet where customers can enter and redeem subscription offer codes. If you generate subscription offer codes in App Store Connect, call this function to enable users to redeem the offer.\n\nNote\n\nFor apps with more than one scene, and on iOS 16 or later and iPadOS 16 or later, use offerCodeRedemption(isPresented:onCompletion:) or presentOfferCodeRedeemSheet(in:) instead.\n\nWhen your app calls presentCodeRedemptionSheet(), the system determines where to display the screen. Use presentCodeRedemptionSheet() to support devices running iOS 14 through iOS 15, and iPadOS 14 through iPadOS 15.\n\nFor information on implementing subscription offer codes, see Implementing offer codes in your app.\n\nImportant\n\nSet up subscription offer codes in App Store Connect before calling this API. Customers can only redeem these offers in your app through the redemption sheet; don’t use a custom UI. For information on configuring and generating subscription offer codes, see Set up offer codes.\n\nThis method applies to subscription offer codes only; it doesn’t apply to promo codes for apps or in-app purchases. For more information on promo codes, see Request and manage promo codes.\n\nThis function doesn’t affect Mac apps built with Mac Catalyst."
  },
  {
    "title": "init(productIDs:marketingContent:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4240632-init",
    "html": "Parameters\nproductIDs\n\nThe product identifiers to load from the App Store.\n\nmarketingContent\n\nThe view that contains marketing content, to display above the store controls.\n\nSee Also\nCreating subscription store views with product IDs\ninit(productIDs: some Collection<String>)\nCreates a view to load a collection of subscriptions and merchandise them with automatic marketing content."
  },
  {
    "title": "init(productIDs:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4248753-init",
    "html": "Parameters\nproductIDs\n\nThe product identifiers to load from the App Store.\n\nSee Also\nCreating subscription store views with product IDs\ninit(productIDs: some Collection<String>, marketingContent: () -> (Content))\nCreates a view to load a collection of subscriptions from the App Store and merchandise them with custom marketing content."
  },
  {
    "title": "payloadData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3954518-payloaddata",
    "html": "Discussion\n\nThis value is the same as the jsonRepresentation in AppTransaction.\n\nSee Also\nGetting properties for app transactions\nvar jwsRepresentation: String\nThe app transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is AppTransaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nAvailable when SignedType is AppTransaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is AppTransaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar headerData: Data\nThe header component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signedData: Data\nThe app transaction data covered by the signature.\nAvailable when SignedType is AppTransaction.\nvar signatureData: Data\nThe signature component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is AppTransaction."
  },
  {
    "title": "generic",
    "url": "https://developer.apple.com/documentation/storekit/message/reason/3963908-generic",
    "html": "See Also\nGetting the message reasons\nstatic let billingIssue: Message.Reason\nA message the App Store sends that informs people of a billing problem and enables them to update billing information.\nstatic let priceIncreaseConsent: Message.Reason\nA message the App Store sends when you increase the price of an auto-renewable subscription and the price increase requires the user’s consent."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/reason/3963906",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing message reasons\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/storekit/message/reason/3963911-init",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating a message reason\ntypealias Message.Reason.RawValue\nA type representing the raw value of a message reason.\nlet rawValue: Int\nThe raw value of a message reason."
  },
  {
    "title": "Message.Reason.RawValue",
    "url": "https://developer.apple.com/documentation/storekit/message/reason/rawvalue",
    "html": "See Also\nCreating a message reason\ninit(rawValue: Int)\nCreates a message reason using the raw value.\nlet rawValue: Int\nThe raw value of a message reason."
  },
  {
    "title": "priceIncreaseConsent",
    "url": "https://developer.apple.com/documentation/storekit/message/reason/3963913-priceincreaseconsent",
    "html": "Discussion\n\nFor more information about managing prices, see Managing Prices and Manage pricing for auto-renewable subscriptions.\n\nSee Also\nGetting the message reasons\nstatic let billingIssue: Message.Reason\nA message the App Store sends that informs people of a billing problem and enables them to update billing information.\nstatic let generic: Message.Reason\nA message the App Store sends for a generic reason."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/storekit/message/reason/3963914-rawvalue",
    "html": "Relationships\nFrom Protocol\nRawRepresentable\nSee Also\nCreating a message reason\ninit(rawValue: Int)\nCreates a message reason using the raw value.\ntypealias Message.Reason.RawValue\nA type representing the raw value of a message reason."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/message/reason/3963909-hash",
    "html": "See Also\nComparing and hashing message reasons\nstatic func != (Message.Reason, Message.Reason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/message/reason/3963910-hashvalue",
    "html": "See Also\nComparing and hashing message reasons\nstatic func != (Message.Reason, Message.Reason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "Product.PromotionInfo.Visibility.appStoreConnectDefault",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/visibility/appstoreconnectdefault",
    "html": "Discussion\n\nWhen a promoted in-app purchase has a visibility value of Product.PromotionInfo.Visibility.appStoreConnectDefault, the in-app purchase is:\n\nVisible if the setting in App Store Connect makes it visible\n\nHidden if the setting in App Store Connect makes it hidden\n\nUse this value to control the visibility for promoted in-app purchases in App Store Connect, globally, for all users. For example, if you have a product to promote on a holiday, start by manually setting it as hidden using App Store Connect. On the holiday, change the setting to make the promotion visible. If the promotion visibility in the app is the default (Product.PromotionInfo.Visibility.appStoreConnectDefault), it becomes visible for all users automatically.\n\nFor more information about the visibility settings in App Store Connect, see Promote in-app purchases.\n\nSee Also\nGetting visibility states\ncase hidden\nA visibility value that hides a promoted in-app purchase on the App Store on a user’s device.\ncase visible\nA visibility value that makes a promoted in-app purchase visible on the App Store on a user’s device."
  },
  {
    "title": "signatureData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3954520-signaturedata",
    "html": "See Also\nGetting properties for app transactions\nvar jwsRepresentation: String\nThe app transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is AppTransaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nAvailable when SignedType is AppTransaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is AppTransaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar headerData: Data\nThe header component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar payloadData: Data\nThe payload component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signedData: Data\nThe app transaction data covered by the signature.\nAvailable when SignedType is AppTransaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is AppTransaction."
  },
  {
    "title": "signedData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3954521-signeddata",
    "html": "See Also\nGetting properties for app transactions\nvar jwsRepresentation: String\nThe app transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is AppTransaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nAvailable when SignedType is AppTransaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is AppTransaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar headerData: Data\nThe header component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar payloadData: Data\nThe payload component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signatureData: Data\nThe signature component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is AppTransaction."
  },
  {
    "title": "signatureData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868437-signaturedata",
    "html": "See Also\nGetting properties for subscription renewal info\nvar jwsRepresentation: String\nThe subscription renewal information signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the subscription renewal info belongs to the device.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedDate: Date\nThe date that the App Store signed the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar headerData: Data\nThe header component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar payloadData: Data\nThe payload component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedData: Data\nThe subscription renewal info data covered by the signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo."
  },
  {
    "title": "signature",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868435-signature",
    "html": "Discussion\n\nUse this signature with Apple CryptoKit if you verify the signature on the device.\n\nSee Also\nGetting properties for subscription renewal info\nvar jwsRepresentation: String\nThe subscription renewal information signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the subscription renewal info belongs to the device.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedDate: Date\nThe date that the App Store signed the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar headerData: Data\nThe header component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar payloadData: Data\nThe payload component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedData: Data\nThe subscription renewal info data covered by the signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signatureData: Data\nThe signature component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo."
  },
  {
    "title": "headerData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868428-headerdata",
    "html": "See Also\nGetting properties for subscription renewal info\nvar jwsRepresentation: String\nThe subscription renewal information signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the subscription renewal info belongs to the device.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedDate: Date\nThe date that the App Store signed the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar payloadData: Data\nThe payload component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedData: Data\nThe subscription renewal info data covered by the signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signatureData: Data\nThe signature component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo."
  },
  {
    "title": "deviceVerification",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868424-deviceverification",
    "html": "Discussion\n\nFor more information about using the device verification value, see deviceVerification.\n\nThis value is identical to the deviceVerification value in Product.SubscriptionInfo.RenewalInfo.\n\nSee Also\nGetting properties for subscription renewal info\nvar jwsRepresentation: String\nThe subscription renewal information signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedDate: Date\nThe date that the App Store signed the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar headerData: Data\nThe header component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar payloadData: Data\nThe payload component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedData: Data\nThe subscription renewal info data covered by the signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signatureData: Data\nThe signature component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo."
  },
  {
    "title": "payloadData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868432-payloaddata",
    "html": "Discussion\n\nThis value is the same as the jsonRepresentation in Product.SubscriptionInfo.RenewalInfo.\n\nSee Also\nGetting properties for subscription renewal info\nvar jwsRepresentation: String\nThe subscription renewal information signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the subscription renewal info belongs to the device.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedDate: Date\nThe date that the App Store signed the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar headerData: Data\nThe header component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedData: Data\nThe subscription renewal info data covered by the signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signatureData: Data\nThe signature component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo."
  },
  {
    "title": "deviceVerificationNonce",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868426-deviceverificationnonce",
    "html": "Discussion\n\nUse the lowercased nonce when computing the deviceVerification value.\n\nThis value is identical to the deviceVerificationNonce value in Product.SubscriptionInfo.RenewalInfo.\n\nSee Also\nGetting properties for subscription renewal info\nvar jwsRepresentation: String\nThe subscription renewal information signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the subscription renewal info belongs to the device.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedDate: Date\nThe date that the App Store signed the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar headerData: Data\nThe header component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar payloadData: Data\nThe payload component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedData: Data\nThe subscription renewal info data covered by the signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signatureData: Data\nThe signature component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo."
  },
  {
    "title": "jwsRepresentation",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868430-jwsrepresentation",
    "html": "Discussion\n\nUse this value to perform your own JWS verification on your server, or on the device.\n\nSee Also\nGetting properties for subscription renewal info\nvar deviceVerification: Data\nThe device verification value to use to verify whether the subscription renewal info belongs to the device.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedDate: Date\nThe date that the App Store signed the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar headerData: Data\nThe header component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar payloadData: Data\nThe payload component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedData: Data\nThe subscription renewal info data covered by the signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signatureData: Data\nThe signature component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo."
  },
  {
    "title": "signedData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868438-signeddata",
    "html": "See Also\nGetting properties for transactions\nvar jwsRepresentation: String\nThe transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Transaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the transaction belongs to the device.\nAvailable when SignedType is Transaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Transaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS transaction.\nAvailable when SignedType is Transaction.\nvar headerData: Data\nThe header component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar payloadData: Data\nThe payload component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signatureData: Data\nThe signature component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Transaction."
  },
  {
    "title": "signedDate",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868440-signeddate",
    "html": "Discussion\n\nUse the signedDate to verify whether the certificate used to sign the transaction was valid when the App Store signed the transaction.\n\nSee Also\nGetting properties for transactions\nvar jwsRepresentation: String\nThe transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Transaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the transaction belongs to the device.\nAvailable when SignedType is Transaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Transaction.\nvar headerData: Data\nThe header component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar payloadData: Data\nThe payload component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signedData: Data\nThe transaction data covered by the signature.\nAvailable when SignedType is Transaction.\nvar signatureData: Data\nThe signature component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Transaction."
  },
  {
    "title": "signedDate",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868441-signeddate",
    "html": "Discussion\n\nUse the signedDate to verify whether the certificate used to sign the transaction was valid when the App Store signed the transaction.\n\nSee Also\nGetting properties for subscription renewal info\nvar jwsRepresentation: String\nThe subscription renewal information signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the subscription renewal info belongs to the device.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar headerData: Data\nThe header component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar payloadData: Data\nThe payload component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedData: Data\nThe subscription renewal info data covered by the signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signatureData: Data\nThe signature component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo."
  },
  {
    "title": "signature",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868434-signature",
    "html": "Discussion\n\nUse this signature with Apple CryptoKit if you verify the signature on the device.\n\nSee Also\nGetting properties for transactions\nvar jwsRepresentation: String\nThe transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Transaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the transaction belongs to the device.\nAvailable when SignedType is Transaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Transaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS transaction.\nAvailable when SignedType is Transaction.\nvar headerData: Data\nThe header component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar payloadData: Data\nThe payload component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signedData: Data\nThe transaction data covered by the signature.\nAvailable when SignedType is Transaction.\nvar signatureData: Data\nThe signature component of the JWS transaction.\nAvailable when SignedType is Transaction."
  },
  {
    "title": "revocationReason",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3803222-revocationreason",
    "html": "See Also\nGetting revocation status\nlet revocationDate: Date?\nThe date that the App Store refunded the transaction or revoked it from Family Sharing.\nstruct Transaction.RevocationReason\nReasons that describe why the App Store may refund a transaction or revoke it from Family Sharing.\ntypealias Transaction.RevocationReason.RawValue\nThe type that represents the raw value of a transaction revocation reason."
  },
  {
    "title": "Testing resubscribing from the subscriptions page",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_resubscribing_from_the_subscriptions_page",
    "html": "Overview\n\nCustomers can manage their active subscriptions, as well as their expired subscriptions for up to a year after expiry, on the Subscriptions page in iOS, tvOS, iPadOS, and macOS. From this page, customers can upgrade, downgrade, cancel, or change the type of their subscriptions.\n\nIn this test scenario, the customer resubscribes to an expired subscription from the Subscriptions page in the App Store.\n\nSet up testing\n\nThis test case requires one or more subscriptions configured in App Store Connect and an expired subscription for your Sandbox Apple ID. If you don’t already have an expired subscription, purchase an auto-renewable subscription and let it expire.\n\nBegin testing\n\nTo test resubscribing from the Subscriptions page:\n\nOn the test iOS device, open Settings > App Store.\n\nIn the Sandbox Account section, tap your highlighted Sandbox Apple ID, and tap Manage.\n\nOn devices running iOS 16 or later, tap Subscriptions on the Account Settings sheet.\n\nIn the sandbox Subscriptions page, select the expired subscription you want to reactivate. The subscription products that appear are those you configured in App Store Connect under the same subscription group.\n\nSelect a subscription product to resubscribe to.\n\nTo complete the purchase, authenticate the payment sheet that appears.\n\nOpen your app.\n\nIn Xcode, verify that your SKPaymentTransactionObserver gets a callback on paymentQueue(_:updatedTransactions:) with a transaction in the SKPaymentTransactionState.purchased state.\n\nCheck that your app retrieves and verifies the app receipt. Verify that the successful transaction is in the receipt.\n\nCheck that your app makes the in-app purchase available and updates the subscriber’s status.\n\nIn Xcode, check that your app calls finishTransaction(_:). For more information, see Finishing a transaction.\n\nConclude testing\n\nThis test case requires no cleanup. For auto-renewable subscriptions, you can perform the test again when the subscription expires.\n\nSee Also\nSubscriptions\nTesting an auto-renewable subscription\nVerify that your app handles a subscription lapse properly using the accelerated time rates within the sandbox environment.\nTesting disabling auto-renew\nVerify that your app receives subscription updates when a user cancels a subscription by verifying the receipt or receiving a notification."
  },
  {
    "title": "revocationDate",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3803221-revocationdate",
    "html": "See Also\nGetting revocation status\nlet revocationReason: Transaction.RevocationReason?\nThe reason that the App Store refunded the transaction or revoked it from Family Sharing.\nstruct Transaction.RevocationReason\nReasons that describe why the App Store may refund a transaction or revoke it from Family Sharing.\ntypealias Transaction.RevocationReason.RawValue\nThe type that represents the raw value of a transaction revocation reason."
  },
  {
    "title": "Handling errors",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/handling_errors",
    "html": "Overview\n\nA StoreKit request may fail for one of many possible reasons, including invalid product information, invalid payment details, problems with your App Store Connect account, or networking issues. When an error occurs, check the error code to find out what went wrong.\n\nDetermine the cause of the error\n\nWhen handling errors, such as with the request(_:didFailWithError:) delegate method, it’s important to use the domain and code of the resulting error to determine the underlying cause of failure.\n\nStoreKit uses SKErrorDomain for errors related to payments, store products, and cloud services, as described in SKError.Code. For additional information on troubleshooting StoreKit framework issues, see the In-App Purchase FAQ.\n\nErrors related to networking use NSURLErrorDomain. The following table describes some of the most common networking errors that may occur when using StoreKit:\n\nError code\n\n\t\n\nDescription\n\n\n\n\nNSURLErrorTimedOut (-1001)\n\n\t\n\nThe connection timed out.\n\n\n\n\nNSURLErrorCannotFindHost (-1003)\n\n\t\n\nThe connection failed because it can't find the host.\n\n\n\n\nNSURLErrorCannotConnectToHost (-1004)\n\n\t\n\nThe connection failed because it can't connect to the host.\n\n\n\n\nNSURLErrorNetworkConnectionLost (-1005)\n\n\t\n\nThe connection failed because it lost the network connection.\n\n\n\n\nNSURLErrorNotConnectedToInternet (-1009)\n\n\t\n\nThe connection failed because the device isn't connected to the internet.\n\n\n\n\nNSURLErrorUserCancelledAuthentication (-1012)\n\n\t\n\nThe connection failed because the user canceled required authentication.\n\n\n\n\nNSURLErrorSecureConnectionFailed (-1200)\n\n\t\n\nThe secure connection failed for an unknown reason.\n\nSee Also\nErrors\nenum SKError.Code\nError codes for StoreKit errors.\nstruct SKError\nStoreKit error descriptions, codes, and domains.\nlet SKErrorDomain: String\nThe error domain name for StoreKit errors."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/3791927",
    "html": "See Also\nComparing and hashing status\nstatic func != (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/3791953-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing status\nstatic func != (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "headerData",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868427-headerdata",
    "html": "See Also\nGetting properties for transactions\nvar jwsRepresentation: String\nThe transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Transaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the transaction belongs to the device.\nAvailable when SignedType is Transaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Transaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS transaction.\nAvailable when SignedType is Transaction.\nvar payloadData: Data\nThe payload component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signedData: Data\nThe transaction data covered by the signature.\nAvailable when SignedType is Transaction.\nvar signatureData: Data\nThe signature component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Transaction."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/3791954-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing status\nstatic func != (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "PurchaseIntent.PurchaseIntents",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/purchaseintents",
    "html": "Topics\nIterating over purchase intents\nfunc makeAsyncIterator() -> PurchaseIntent.PurchaseIntents.AsyncIterator\nCreates the iterator that produces elements of the asynchronous sequence.\nstruct PurchaseIntent.PurchaseIntents.AsyncIterator\nAn iterator that produces elements of the asynchronous purchase intents sequence.\ntypealias PurchaseIntent.PurchaseIntents.Element\nA type that represents a purchase intents element.\nFiltering and matching purchase intents\nfunc allSatisfy((PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(PurchaseIntent) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (PurchaseIntent) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc filter((PurchaseIntent) -> Bool) -> AsyncFilterSequence<PurchaseIntent.PurchaseIntents>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (PurchaseIntent, PurchaseIntent) -> Bool) -> PurchaseIntent?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nTransforming purchase intents\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((PurchaseIntent) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<PurchaseIntent.PurchaseIntents, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((PurchaseIntent) -> SegmentOfResult) -> AsyncFlatMapSequence<PurchaseIntent.PurchaseIntents, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((PurchaseIntent) -> Transformed) -> AsyncThrowingMapSequence<PurchaseIntent.PurchaseIntents, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (PurchaseIntent) -> Bool) -> AsyncPrefixWhileSequence<PurchaseIntent.PurchaseIntents>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, PurchaseIntent) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, PurchaseIntent) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.\nExcluding purchase intents\nfunc drop(while: (PurchaseIntent) -> Bool) -> AsyncDropWhileSequence<PurchaseIntent.PurchaseIntents>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<PurchaseIntent.PurchaseIntents>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nRelationships\nConforms To\nAsyncSequence\nSee Also\nGetting purchase intents\nstatic var intents: PurchaseIntent.PurchaseIntents\nThe asynchronous sequence that emits a purchase intent when the user selects a promoted in-app purchase on the App Store."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/4123331",
    "html": "See Also\nComparing purchase intents\nstatic func != (PurchaseIntent, PurchaseIntent) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/4123330",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing purchase intents\nstatic func == (PurchaseIntent, PurchaseIntent) -> Bool\nReturns a Boolean value that indicates whether two values are equal."
  },
  {
    "title": "Product.SubscriptionInfo.Status.Statuses",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/statuses",
    "html": "Topics\nIterating over the status\nfunc makeAsyncIterator() -> Product.SubscriptionInfo.Status.Statuses.AsyncIterator\nCreates the iterator that produces elements of the asynchronous sequence.\nstruct Product.SubscriptionInfo.Status.Statuses.AsyncIterator\nAn iterator that produces elements of the asynchronous sequence.\ntypealias Product.SubscriptionInfo.Status.Statuses.AsyncIterator.Element\nThe type of element the iterator produces.\ntypealias Product.SubscriptionInfo.Status.Statuses.Element\nThe type of element the iterator traverses.\nFiltering and matching elements\nfunc allSatisfy((Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (Product.SubscriptionInfo.Status) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc filter((Product.SubscriptionInfo.Status) -> Bool) -> AsyncFilterSequence<Product.SubscriptionInfo.Status.Statuses>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc max(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool) -> Product.SubscriptionInfo.Status?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nTransforming elements\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Product.SubscriptionInfo.Status) -> ElementOfResult?) -> AsyncCompactMapSequence<Product.SubscriptionInfo.Status.Statuses, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Product.SubscriptionInfo.Status) -> SegmentOfResult) -> AsyncFlatMapSequence<Product.SubscriptionInfo.Status.Statuses, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncThrowingMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Product.SubscriptionInfo.Status) -> Transformed) -> AsyncMapSequence<Product.SubscriptionInfo.Status.Statuses, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncPrefixWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Product.SubscriptionInfo.Status) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Product.SubscriptionInfo.Status) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.\nExcluding elements\nfunc drop(while: (Product.SubscriptionInfo.Status) -> Bool) -> AsyncDropWhileSequence<Product.SubscriptionInfo.Status.Statuses>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Product.SubscriptionInfo.Status.Statuses>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nRelationships\nConforms To\nAsyncSequence\nSee Also\nMonitoring subscription status changes\nstatic var updates: Product.SubscriptionInfo.Status.Statuses\nThe asynchronous sequence that emits status information when a subscription’s status changes.\nstatic var all: AsyncStream<(groupID: String, statuses: [Product.SubscriptionInfo.Status])>"
  },
  {
    "title": "product",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/4123377-product",
    "html": "Discussion\n\nTo enable users to complete the purchase they start on the App Store, call purchase(options:) on this product instance.\n\nSee Also\nIdentifying the product\nvar id: Product.ID\nThe product identifier of the promoted in-app purchase that the user selects to purchase on the App Store."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent/4123375-id",
    "html": "See Also\nIdentifying the product\nlet product: Product\nThe product information of the promoted in-app purchase the user selects to purchase on the App Store."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/3868415-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nError Comparisons\nstatic func != (VerificationResult<SignedType>.VerificationError, VerificationResult<SignedType>.VerificationError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (VerificationResult<SignedType>.VerificationError, VerificationResult<SignedType>.VerificationError) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954494-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc reduce<Result>(Result, (Result, Message) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "Handling refund notifications",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/handling_refund_notifications",
    "html": "Overview\n\nThe App Store server sends near real-time notifications when customers receive refunds for in-app purchases. If you offer content across multiple platforms, for example gems or coins for games, and you update player account balances on your server, receiving refund notifications is important. Respond to refund notifications by interpreting and handling the refund information, and informing customers in the app of any actions you take as a result of the refund.\n\nTo enable notifications, see Enabling App Store Server Notifications and App Store Server Notifications.\n\nReceive notifications of customer refunds for one-time purchases\n\nCustomers request refunds in several ways, such as:\n\nContacting Apple Customer Support and asking for a refund\n\nLogging in and using Apple’s self-service tool, reportaproblem.apple.com, to request a refund\n\nAsking their payment method issuer for a refund\n\nWhen the App Store processes a refund, the App Store server sends a REFUND notification to your server, at the URL you configure. Your server must respond to the post with a 200 response code. The REFUND notification applies to consumable, non-consumable, and non-renewing subscriptions only. To detect refunds for auto-renewable subscriptions, see Detect a Refund.\n\nInterpret and handle the refund notification\n\nYour server is responsible for parsing and interpreting all notifications from the App Store server. For the REFUND notification, identify the specific transaction, product ID, and relevant dates from the response:\n\nFind the most recent transaction for the product_id in the unified_receipt.latest_receipt_info by checking the purchase_date to select the most recent transaction.\n\nThe date when App Store issued the refund is in the cancellation_date_ms field for the transaction.\n\nFor more information about the response, see App Store Server Notifications.\n\nYou’re responsible to store, monitor, and take appropriate action for each refunded transaction when you receive a REFUND notification. For example, you might build your own in-game currency-rebalancing logic that handles refunded transactions by linking a notification to a player account or session.\n\nInform customers by presenting contextual messaging in the app for any actions you take as a result of the refund.\n\nIdentify refund abuse\n\nReduce refund abuse and identify repeated refunded purchases by mapping REFUND notifications to the player accounts on your server. Monitor and analyze your data to identify suspicious refund activity.\n\nIf you offer content across multiple platforms, keep the balances for user accounts up to date on your server. Use App Store Server Notifications to get near real-time status updates for the transactions that affect your customers.\n\nSee Also\nRefunds\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds."
  },
  {
    "title": "payloadValue",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868433-payloadvalue",
    "html": "Discussion\n\nThis property represents the value of a payload in a JSON Web Signature (JWS) value that passed StoreKit verification.\n\nThis property throws an error if the JWS value containing the payload doesn’t pass StoreKit’s verification and is therefore unverified. To access the payload of an unverified JWS value, get the associated value of the verification result, or use the unsafePayloadValue property.\n\nSee Also\nGetting the verification results\ncase verified(SignedType)\nThe associated value passed StoreKit automatic verification checks.\ncase unverified(SignedType, VerificationResult<SignedType>.VerificationError)\nThe associated value failed StoreKit automatic verification checks.\nvar unsafePayloadValue: SignedType\nThe associated value of the verification result that StoreKit doesn’t confirm as verified.\nenum VerificationResult.VerificationError\nError cases for StoreKit JWS verification."
  },
  {
    "title": "unsafePayloadValue",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/3868442-unsafepayloadvalue",
    "html": "Discussion\n\nThis property represents the value of a payload in a JSON Web Signature (JWS) value that’s not confirmed to have passed StoreKit verification.\n\nUse the unsafePayloadValue for debugging purposes or other situations where the integrity of the data is unimportant. This property ignores any verification errors. To get a payload that passed verification, or to check for verification errors, use the payloadValue property instead.\n\nImportant\n\nDon’t trust the integrity of the values you receive from the unsafePayloadValue property. This property contains data regardless of the verification result, and contains data even if StoreKit’s verification fails.\n\nTo determine if the JWS value fails verification, perform a verification on the jwsRepresentation property for subscription renewal information, the jwsRepresentation property for transactions, or the jwsRepresentation property for app transactions.\n\nSee Also\nGetting the verification results\ncase verified(SignedType)\nThe associated value passed StoreKit automatic verification checks.\ncase unverified(SignedType, VerificationResult<SignedType>.VerificationError)\nThe associated value failed StoreKit automatic verification checks.\nvar payloadValue: SignedType\nThe verified value of the signed type that StoreKit confirms as verified.\nenum VerificationResult.VerificationError\nError cases for StoreKit JWS verification."
  },
  {
    "title": "localizedDescription",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/3868420-localizeddescription",
    "html": "See Also\nError Description\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA localized message describing the reason for the failure.\nvar helpAnchor: String?\nA message providing “help” text if the user requests help by pressing an alert panel help anchor button.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "VerificationResult.VerificationError.revokedCertificate",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/revokedcertificate",
    "html": "Discussion\n\nIn some cases, this error may resolve if you try again later.\n\nSee Also\nError Codes\ncase invalidCertificateChain\nAn error indicating that the certificate chain is invalid.\ncase invalidDeviceVerification\nAn error that indicates the signed value wasn’t generated for the current device.\ncase invalidEncoding\nAn error that indicates the signature, certificate chain, or other part of value uses invalid encoding.\ncase invalidSignature\nAn error that indicates that the signature didn’t match the header and payload.\ncase missingRequiredProperties\nAn error that indicates the header or payload are missing information that’s required to verify the signature."
  },
  {
    "title": "SKStoreProductParameterCustomProductPageIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparametercustomproductpageidentifier",
    "html": "See Also\nAffiliate and Analytics Keys\nlet SKStoreProductParameterProductIdentifier: String\nThe key representing the product identifier for the promoted product you want the store to display at the top of the page.\nlet SKStoreProductParameterAdvertisingPartnerToken: String\nThe key representing the advertising partner you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterAffiliateToken: String\nThe key representing the affiliate identifier you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterCampaignToken: String\nThe key representing an App Analytics campaign.\nlet SKStoreProductParameterProviderToken: String\nThe key representing the provider token for the developer that created the app specified by the SKStoreProductParameterITunesItemIdentifier key."
  },
  {
    "title": "SKStoreProductParameterAffiliateToken",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameteraffiliatetoken",
    "html": "Discussion\n\nThe value for this key is an instance of NSString.\n\nYou receive an affiliate identifier when you sign up for the Affiliate Program. The affiliate associated with this view controller is paid a commission for any items purchased using the controller.\n\nLearn more about the Affiliate Program at https://apple.com/itunes/affiliates.\n\nSee Also\nAffiliate and Analytics Keys\nlet SKStoreProductParameterProductIdentifier: String\nThe key representing the product identifier for the promoted product you want the store to display at the top of the page.\nlet SKStoreProductParameterAdvertisingPartnerToken: String\nThe key representing the advertising partner you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterCampaignToken: String\nThe key representing an App Analytics campaign.\nlet SKStoreProductParameterProviderToken: String\nThe key representing the provider token for the developer that created the app specified by the SKStoreProductParameterITunesItemIdentifier key.\nlet SKStoreProductParameterCustomProductPageIdentifier: String"
  },
  {
    "title": "SKStoreProductParameterAdvertisingPartnerToken",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameteradvertisingpartnertoken",
    "html": "Discussion\n\nThe value for this key is an instance of NSString.\n\nSee Also\nAffiliate and Analytics Keys\nlet SKStoreProductParameterProductIdentifier: String\nThe key representing the product identifier for the promoted product you want the store to display at the top of the page.\nlet SKStoreProductParameterAffiliateToken: String\nThe key representing the affiliate identifier you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterCampaignToken: String\nThe key representing an App Analytics campaign.\nlet SKStoreProductParameterProviderToken: String\nThe key representing the provider token for the developer that created the app specified by the SKStoreProductParameterITunesItemIdentifier key.\nlet SKStoreProductParameterCustomProductPageIdentifier: String"
  },
  {
    "title": "Product Dictionary Keys",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductviewcontroller/product_dictionary_keys",
    "html": "Overview\n\nThese dictionary keys are used in the parameter for the loadProduct(withParameters:completionBlock:) method.\n\nThe SKStoreProductParameterITunesItemIdentifier key represents the product to display, and is always required. Other keys provide optional affiliate or promoted product information.\n\nLearn more about the Affiliate Program at https://apple.com/itunes/affiliates.\n\nTopics\nRequired Key\nlet SKStoreProductParameterITunesItemIdentifier: String\nThe key representing the iTunes identifier for the item you want the store to display when the view controller is presented.\nAffiliate and Analytics Keys\nlet SKStoreProductParameterProductIdentifier: String\nThe key representing the product identifier for the promoted product you want the store to display at the top of the page.\nlet SKStoreProductParameterAdvertisingPartnerToken: String\nThe key representing the advertising partner you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterAffiliateToken: String\nThe key representing the affiliate identifier you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterCampaignToken: String\nThe key representing an App Analytics campaign.\nlet SKStoreProductParameterProviderToken: String\nThe key representing the provider token for the developer that created the app specified by the SKStoreProductParameterITunesItemIdentifier key.\nlet SKStoreProductParameterCustomProductPageIdentifier: String\nSee Also\nLoading a new product screen\nOffering media for sale in your app\nAllow users to purchase media in the App Store from within your app.\nfunc loadProduct(withParameters: [String : Any], completionBlock: ((Bool, (any Error)?) -> Void)?)\nLoads a new product screen to display.\nfunc loadProduct(withParameters: [String : Any], impression: SKAdImpression, completionBlock: ((Bool, (any Error)?) -> Void)?)"
  },
  {
    "title": "loadProduct(withParameters:impression:completionBlock:)",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductviewcontroller/3951378-loadproduct",
    "html": "Discussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc loadProduct(withParameters parameters: [String : Any], impression: SKAdImpression) async throws -> Bool\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nSee Also\nLoading a new product screen\nOffering media for sale in your app\nAllow users to purchase media in the App Store from within your app.\nfunc loadProduct(withParameters: [String : Any], completionBlock: ((Bool, (any Error)?) -> Void)?)\nLoads a new product screen to display.\nProduct Dictionary Keys\nKeys for identifying products and the tokens for affiliates and campaigns."
  },
  {
    "title": "userInfo",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925711-userinfo",
    "html": "See Also\nGetting Error Properties\nvar code: Code\nThe error code.\nvar errorCode: Int\nThe integer error code.\nvar errorUserInfo: [String : Any]\nThe error user information dictionary associated with the error.\nvar localizedDescription: String\nA string containing the localized description of the error."
  },
  {
    "title": "medium",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/coarseconversionvalue/4090673-medium",
    "html": "Discussion\n\nThis constant has no special meaning. It’s up to the app or ad network to determine its meaning as needed.\n\nSee Also\nProviding coarse conversion values\nstatic let high: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a high coarse conversion value.\nstatic let low: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a low coarse conversion value.\ninit(rawValue: String)\nCreates a coarse conversion value from the raw value."
  },
  {
    "title": "promotionalOffer(offerID:keyID:nonce:signature:timestamp:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3749444-promotionaloffer",
    "html": "Parameters\nofferID\n\nThe subscription-offer identifier, id.\n\nkeyID\n\nThe key ID of the subscription key.\n\nnonce\n\nThe anti-replay value used in the signature. Use lowercase.\n\nsignature\n\nThe cryptographic signature of the offer parameters, which you generate on your server.\n\ntimestamp\n\nThe UNIX time, in milliseconds, when you generate the signature.\n\nReturn Value\n\nAn instance of Product.PurchaseOption to use in purchase(options:).\n\nDiscussion\n\nFor information about keyID, nonce, signature, and timestamp, see Generating a signature for promotional offers. If you’re providing an appAccountToken(_:) in the purchase options, you must include that value when you generate the signature. Use lowercase for the UUID string representations of the app account token and the nonce in the signature.\n\nYou can offer a discounted or free period of service for auto-renewable subscriptions on iOS, iPadOS, macOS, and tvOS using promotional offers. Before you can provide promotional offers in your app, you must set up the offers in your App Store Connect account. To configure your offer, see Set up promotional offers for auto-renewable subscriptions.\n\nSee Also\nSetting the purchase options\nstatic func appAccountToken(UUID) -> Product.PurchaseOption\nSets a UUID to associate the purchase with an account in your system.\nstatic func onStorefrontChange(shouldContinuePurchase: (Storefront) -> Bool) -> Product.PurchaseOption\nIndicates whether a transaction needs to continue if the App Store storefront changes on the device during the transaction.\nstatic func quantity(Int) -> Product.PurchaseOption\nIndicates the quantity of items the customer is purchasing."
  },
  {
    "title": "appAccountToken(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption/3749440-appaccounttoken",
    "html": "Parameters\ntoken\n\nA UUID you provide to associate with the purchase.\n\nReturn Value\n\nAn instance of Product.PurchaseOption to use in purchase(options:).\n\nDiscussion\n\nWhen you set the app account token in the purchase options, the App Store returns the same app account token value in the resulting transaction, in appAccountToken.\n\nSee Also\nSetting the purchase options\nstatic func onStorefrontChange(shouldContinuePurchase: (Storefront) -> Bool) -> Product.PurchaseOption\nIndicates whether a transaction needs to continue if the App Store storefront changes on the device during the transaction.\nstatic func promotionalOffer(offerID: String, keyID: String, nonce: UUID, signature: Data, timestamp: Int) -> Product.PurchaseOption\nApplies a promotional offer for an auto-renewable subscription.\nstatic func quantity(Int) -> Product.PurchaseOption\nIndicates the quantity of items the customer is purchasing."
  },
  {
    "title": "Product.PromotionInfo.Visibility.hidden",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/visibility/hidden",
    "html": "Discussion\n\nA promoted in-app purchase with this visibility setting isn’t visible on the App Store on a user’s device.\n\nSee Also\nGetting visibility states\ncase appStoreConnectDefault\nA visibility value for a promoted in-app purchase that uses the visibility setting from App Store Connect.\ncase visible\nA visibility value that makes a promoted in-app purchase visible on the App Store on a user’s device."
  },
  {
    "title": "SKAdNetwork 2.1 release notes",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/skadnetwork_release_notes/skadnetwork_2_1_release_notes",
    "html": "Overview\n\nUse “2.1” as the version number when signing ads for this version.\n\nAd networks are eligible to receive a version 2.1 postback if all three of the following conditions are met:\n\nThe source app generates a signature for version 2.1.\n\nThe source app is built with the iOS 14 SDK or later.\n\nThe advertised app is App Store-signed and running on a device with iOS 14 or later.\n\nNew features\n\nNew features include:\n\nSKAdNetwork now signs install-validation postbacks using Apple’s NIST P-256 public key. For more information, see Verifying an install-validation postback.\n\nSee Also\nSKAdNetwork versions\nSKAdNetwork 4 release notes\nA version of SKAdNetwork available in iOS 16.1 and later.\nSKAdNetwork 3 release notes\nA version of SKAdNetwork available in iOS 14.6 and later.\nSKAdNetwork 2.2 release notes\nA version of SKAdNetwork available in iOS 14.5 and later.\nSKAdNetwork 2 release notes\nA version of SKAdNetwork available in iOS 14 and later.\nSKAdNetwork 1 release notes\nA version of SKAdNetwork available in iOS 11.3 and later."
  },
  {
    "title": "SKAdNetwork 2 release notes",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/skadnetwork_release_notes/skadnetwork_2_release_notes",
    "html": "Overview\n\nUse “2.0” as the version number when signing ads for this version.\n\nAd networks are eligible to receive a version 2.0 postback if all three of the following conditions are met:\n\nThe source app generates a signature for version 2.0.\n\nThe source app is built with the iOS 14 SDK or later.\n\nThe advertised app is App Store-signed and running on a device with iOS 14 or later.\n\nWhen verifying an install-validation postback for version 2.0, use the following Apple P-192 public key:\n\nMEkwEwYHKoZIzj0CAQYIKoZIzj0DAQEDMgAEMyHD625uvsmGq4C43cQ9BnfN2xslVT5V1nOmAMP6qaRRUll3PB1JYmgSm+62sosG\n\n\nFor more information, see Verifying an install-validation postback.\n\nNew features\n\nNew features include:\n\nThe advertised app can now provide conversion values. For more information, see updateConversionValue(_:).\n\nThe install-validation postback now contains additional parameters, including the version number, conversion value, source app ID, and redownload value. For more information, see Verifying an install-validation postback.\n\nSee Also\nSKAdNetwork versions\nSKAdNetwork 4 release notes\nA version of SKAdNetwork available in iOS 16.1 and later.\nSKAdNetwork 3 release notes\nA version of SKAdNetwork available in iOS 14.6 and later.\nSKAdNetwork 2.2 release notes\nA version of SKAdNetwork available in iOS 14.5 and later.\nSKAdNetwork 2.1 release notes\nA version of SKAdNetwork available in iOS 14 and later.\nSKAdNetwork 1 release notes\nA version of SKAdNetwork available in iOS 11.3 and later."
  },
  {
    "title": "SKAdNetwork 1 release notes",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/skadnetwork_release_notes/skadnetwork_1_release_notes",
    "html": "Overview\n\nYou’re eligible to receive a version 1.0 postback when any of these conditions are met:\n\nThe source app uses iOS 13.7 SDK or earlier.\n\nThe advertised app is App Store-signed and running on a device with iOS 14 or earlier.\n\nThe original install-validation postback doesn’t include a version number. For more information, see Combining parameters for previous SKAdNetwork postback versions.\n\nWhen verifying an install-validation postback for version 1.0, use the following Apple P-192 public key:\n\nMEkwEwYHKoZIzj0CAQYIKoZIzj0DAQEDMgAEMyHD625uvsmGq4C43cQ9BnfN2xslVT5V1nOmAMP6qaRRUll3PB1JYmgSm+62sosG\n\n\nFor more information, see Verifying an install-validation postback.\n\nNew features\n\nThis is the original version of SKAdNetwork.\n\nSee Also\nSKAdNetwork versions\nSKAdNetwork 4 release notes\nA version of SKAdNetwork available in iOS 16.1 and later.\nSKAdNetwork 3 release notes\nA version of SKAdNetwork available in iOS 14.6 and later.\nSKAdNetwork 2.2 release notes\nA version of SKAdNetwork available in iOS 14.5 and later.\nSKAdNetwork 2.1 release notes\nA version of SKAdNetwork available in iOS 14 and later.\nSKAdNetwork 2 release notes\nA version of SKAdNetwork available in iOS 14 and later."
  },
  {
    "title": "SKAdNetwork 2.2 release notes",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/skadnetwork_release_notes/skadnetwork_2_2_release_notes",
    "html": "Overview\n\nUse “2.2” as the version number when signing ads for this version.\n\nAd networks are eligible to receive a version 2.2 postback if all three of the following conditions are met:\n\nThe source app generates a signature for version 2.2.\n\nThe source app is built with iOS 14.5 SDK or later.\n\nThe advertised app is App Store-signed and running on a device with iOS 14.5 or later.\n\nNew features\n\nNew features include:\n\nYou can now create view-through ads using the new APIs SKAdImpression , startImpression(_:completionHandler:), and endImpression(_:completionHandler:).\n\nYou can now indicate whether an ad is a view-through ad or a StoreKit-rendered ad by using the new fidelity-type parameter. The fidelity-type value is 0 for view-through ads, and 1 for StoreKit-rendered ads. You include this parameter when you sign an ad, and receive it in the postback.\n\nFor more information about view-through ads and fidelity-type, see Signing and providing ads and Generating the signature to validate view-through ads. For more information about the postback, see Verifying an install-validation postback.\n\nSee Also\nSKAdNetwork versions\nSKAdNetwork 4 release notes\nA version of SKAdNetwork available in iOS 16.1 and later.\nSKAdNetwork 3 release notes\nA version of SKAdNetwork available in iOS 14.6 and later.\nSKAdNetwork 2.1 release notes\nA version of SKAdNetwork available in iOS 14 and later.\nSKAdNetwork 2 release notes\nA version of SKAdNetwork available in iOS 14 and later.\nSKAdNetwork 1 release notes\nA version of SKAdNetwork available in iOS 11.3 and later."
  },
  {
    "title": "visibility",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/4115024-visibility",
    "html": "Discussion\n\nTo override the visibility of a promoted in-app purchase, set the visibility value and then call update() to save the change. You can also call updateProductVisibility(_:for:) to set the visibility.\n\nThe default value is Product.PromotionInfo.Visibility.appStoreConnectDefault.\n\nSee Also\nManaging promotion visibility\nenum Product.PromotionInfo.Visibility\nThe visibility states for product promotion information.\nstatic func updateProductVisibility(Product.PromotionInfo.Visibility, for: Product.ID)\nUpdates a value that indicates whether a promoted in-app purchase appears in the App Store on the user's device."
  },
  {
    "title": "currentOrder",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/4115018-currentorder",
    "html": "Discussion\n\nThis asynchronous array returns a list of Product.PromotionInfo objects in the custom order they appear in on the device.\n\nNote\n\nThis list is empty if you don’t override the order, and the App Store displays the products in their default order.\n\nFor information about setting the default order using App Store Connect, see Promote in-app purchases."
  },
  {
    "title": "SKAdNetwork 3 release notes",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/skadnetwork_release_notes/skadnetwork_3_release_notes",
    "html": "Overview\n\nUse “3.0” as the version number when signing ads for this version.\n\nYou’re eligible to receive a version 3.0 postback if all three of the following conditions are met:\n\nThe source app generates a signature for version 3.0.\n\nThe source app is built with iOS 14.6 SDK or later.\n\nThe advertised app is App Store-signed and is running on a device with iOS 14.6 or later.\n\nNew features\n\nNew features include:\n\nDevices can now send install-validation postbacks to multiple ad networks that sign their ads using version 3.0. One ad network receives a postback with a did-win parameter value of true for the ad impression that wins the ad attribution. Up to five other ad networks receive a postback with a did-win parameter value of false if their ad impressions qualified for, but didn’t win, the attribution.\n\nFor more information about signing ads with version 3.0, see Signing and providing ads. For more information about your ad’s eligibility to receive an attribution or a non-winning postback, see Receiving ad attributions and postbacks. For details about the postback, see Verifying an install-validation postback.\n\nSee Also\nSKAdNetwork versions\nSKAdNetwork 4 release notes\nA version of SKAdNetwork available in iOS 16.1 and later.\nSKAdNetwork 2.2 release notes\nA version of SKAdNetwork available in iOS 14.5 and later.\nSKAdNetwork 2.1 release notes\nA version of SKAdNetwork available in iOS 14 and later.\nSKAdNetwork 2 release notes\nA version of SKAdNetwork available in iOS 14 and later.\nSKAdNetwork 1 release notes\nA version of SKAdNetwork available in iOS 11.3 and later."
  },
  {
    "title": "Unlocking purchased content",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/unlocking_purchased_content",
    "html": "Overview\n\nAfter a purchase is complete, it’s your responsibility to make sure that you programmatically make the content available to the user.\n\nIdentify the purchased content\n\nFor an in-app purchase product that enables app functionality, such as a premium subscription, set a Boolean value to enable the code path and update your user interface as needed. Consult your app's persistent transaction record to determine the functionality to unlock. Your app needs to update this Boolean value whenever the user completes a purchase and at app launch. For information on making a persistent record, see Persisting a purchase.\n\nFor example, using the app receipt, your code might look like the following:\n\nguard let receiptURL = Bundle.main.appStoreReceiptURL else { customError() }\ndo {\n    let receiptData = try Data(contentsOf: receiptURL)\n    // Custom method to work with receipts.\n    let rocketCarEnabled = receipt(receiptData, includesProductID: \"com.example.rocketCar\")\n    } catch {\n        print(error)\n    }\n\n\nOr, using the user defaults system.\n\nlet defaults = UserDefaults.standard\nlet rocketCarEnabled = defaults.bool(forKey: \"enable_rocket_car\")\n\n\nAfter you define the Boolean variable that represents the in-app purchase content, use the purchase information to enable the appropriate code paths in your app.\n\nif (rocketCarEnabled) {\n    // Use the rocket car.\n} else {\n    // Use the regular car.\n}\n\n\nDeliver associated content\n\nYour app needs to deliver any content associated with the purchased product to the user. For example, purchasing instruments in a music app requires delivering the sound files needed to let the user play those instruments. You can embed that content in your app bundle or download it as necessary. Each approach has its advantages and disadvantages.\n\nEmbed smaller files (up to a few megabytes) in your app, especially if you expect most users to buy that product. You can make the content in your app bundle available immediately after the user purchases it. However, to add or update content in your app bundle, you need to submit an updated version of your app.\n\nDownload larger files only when needed. Separating content from your app bundle keeps your app’s initial download small. For example, a game can include the first level in its app bundle and let users download additional levels as they purchase them. Assuming your app fetches its list of product identifiers from your server and the information isn’t hard-coded in the app bundle, you don’t need to resubmit your app to add or update content that your app downloads.\n\nNote\n\nYou can’t patch your app binary or download executable code. Your app needs to contain all executable code necessary to support all of its functionality when you submit it. If a new product requires code changes, submit an updated version of your app.\n\nLoad local content\n\nLoad local content using the NSBundle class as you load other resources from your app bundle.\n\nguard let url = Bundle.main.url(forResource: \"rocketCar\", withExtension: \"plist\") else { fatalError() }\nloadVehicle(at: url)\n\n\nDownload content from your own server\n\nAs with all interactions between your app and your server, the details and process of downloading content from your own server are your responsibility. The communication consists of, at a minimum, the following steps:\n\nYour app sends the receipt to your server and requests the content.\n\nYour server validates the receipt to establish that the user purchased the content, as described in Validating receipts with the App Store.\n\nAssuming the receipt is valid, your server responds to your app with the content.\n\nEnsure that your app handles errors gracefully. For example, if the device runs out of disk space during a download, give the user the option to discard the partial download or to resume the download later when space becomes available.\n\nConsider the security implications of how you host your content and how your app communicates with your server. For more information, see Security Overview.\n\nDownload content using on-demand resources\n\nYou can use On-Demand Resources (ODR) for flexibility in downloading data in your app. ODR is an Apple-hosted service you use to store in-app purchase data that your app downloads after you verify the user’s purchase using the app receipt. ODR doesn’t require a call to restore transactions and authenticate the user to download content hosted on Apple’s server.\n\nDownload hosted content from Apple’s server\n\nImportant\n\nSKDownload and its related functionality are deprecated. The following information is for apps that already host content on Apple’s servers and use SKDownload.\n\nApps can use Apple-hosted content for downloaded files. You create an Apple-hosted content bundle using the In-App Purchase Content target in Xcode and submit it to App Store Connect. Apple’s servers store your app’s content using the same infrastructure that supports other large-scale operations, such as the App Store. Apple-hosted content automatically downloads in the background even if your app isn’t running.\n\nIf you need to support older versions of iOS or share your server infrastructure across multiple platforms, you may choose to host your own content using your own server infrastructure.\n\nWhen the user purchases a product that has associated Apple-hosted content, the transaction that passes to your transaction queue observer also includes an instance of SKDownload that lets you download the associated content.\n\nTo download the content, add the download objects from the transaction’s downloads property to the transaction queue by calling the start(_:) method of SKPaymentQueue. If the value of the downloads property is nil, there’s no Apple-hosted content for that transaction. Unlike downloading apps, downloading content doesn’t automatically require a Wi-Fi connection for content larger than a certain size. Avoid using cellular networks to download large files without an explicit action from the user.\n\nImplement the paymentQueue(_:updatedDownloads:) method on the transaction queue observer to respond to changes in a download’s state, such as by updating progress in your UI. If a download fails, use the information in its error property to present the error to the user.\n\nEnsure that your app handles errors gracefully. For example, if the device runs out of disk space during a download, give the user the option to discard the partial download or to resume the download later when space becomes available.\n\nWhile the content is downloading, update your user interface using the values of the progress and timeRemaining properties. You can use the pause(_:), resume(_:), and cancel(_:) methods of SKPaymentQueue from your UI to let the user control in-progress downloads. Use the downloadState property to determine whether the download completes. Don’t use the progress or timeRemaining property of the download object to check its status; these properties are for updating your UI.\n\nNote\n\nDownload all Apple-hosted content before finishing the transaction. After a transaction is complete, its download objects become unusable.\n\nIn iOS, your app can manage the downloaded files. The StoreKit framework saves these files for you in the Caches directory with the backup flag unset. After the download completes, your app is responsible for moving these files to the appropriate location. For content that can be deleted if the device runs out of disk space (and downloaded again later by your app), keep the files in the Caches directory. Otherwise, move the files to the Documents folder and set the flag to exclude them from user backups.\n\n// This is the URL for downloaded content.\nguard var url = download.contentURL else { fatalError() }\n\n\nvar resourceValues = URLResourceValues()\nresourceValues.isExcludedFromBackup = true\n\n\ndo {\n    try url.setResourceValues(resourceValues)\n} catch {\n    print(error)\n}\n\n\nIn macOS, the system manages the downloaded files; your app can’t move or delete them directly. To locate the content after downloading it, use the contentURL property of the download object. To locate the file on subsequent launches, use the contentURL(forProductID:) class method of SKDownload. To delete a file, use the deleteContent(forProductID:) class method. For information about reading the app receipt, see Validating receipts with the App Store.\n\nSee Also\nContent delivery\nPersisting a purchase\nKeep a persistent record of a purchase to continue making the product available as needed.\nFinishing a transaction\nFinish the transaction to complete the purchase process.\nclass SKDownload\nDownloadable content associated with a product.\nDeprecated"
  },
  {
    "title": "errorDescription",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror/3916876-errordescription",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nError Descriptions\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar failureReason: String?\nA message describing the reason for the failure.\nvar helpAnchor: String?\nA localized message that provides additional information if the user requests help.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "recoverySuggestion",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror/3916879-recoverysuggestion",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nError Descriptions\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA message describing the reason for the failure.\nvar helpAnchor: String?\nA localized message that provides additional information if the user requests help."
  },
  {
    "title": "finishTransaction(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue/1506003-finishtransaction",
    "html": "Parameters\ntransaction\n\nThe transaction to finish.\n\nDiscussion\n\nTransactions on the payment queue are persistent until they are completed. StoreKit calls your observer’s paymentQueue(_:updatedTransactions:) method every time your app launches or resumes from background to tell you about transactions in the queue. After you've finished processing a transaction in your app, always call the finishTransaction(_:) method to finish the transaction and remove it from the queue.\n\nCall finishTransaction(_:) only after the app has finished all work it performs to complete the transaction. The transaction's state determines which steps you might take:\n\nFor a failed transaction (SKPaymentTransactionState.failed), update your user interface, track information in analytics, and perform other similar tasks.\n\nFor a successful transaction (SKPaymentTransactionState.purchased or SKPaymentTransactionState.restored), perform all necessary actions to unlock the functionality the user has purchased before finishing the transaction. For example, if you are downloading content, finish the transaction only after the downloads are complete.\n\nIf you validate receipts, validate them before completing the transaction, and take one of the paths described above.\n\nIn rare circumstances, this call might fail, and you'll receive updates for that transaction again. For this reason, you should record information in your app about the transactions it has processed and which steps the app has already completed. That way, you don't repeat steps that shouldn't be performed multiple times. For example, if you are processing a consumable transaction, you only want to add the consumable benefit once.\n\nIf you call finishTransaction(_:) on a transaction that is in the SKPaymentTransactionState.purchasing state, StoreKit raises an exception.\n\nSee Also\nManaging Transactions\nvar delegate: (any SKPaymentQueueDelegate)?\nA delegate that provides information needed to complete transactions.\nvar transactions: [SKPaymentTransaction]\nReturns an array of pending transactions.\nfunc add(SKPayment)\nAdds a payment request to the queue.\nRelated Documentation\nfunc paymentQueue(SKPaymentQueue, updatedTransactions: [SKPaymentTransaction])\nTells an observer that one or more transactions have been updated."
  },
  {
    "title": "Testing a successful transaction",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_a_successful_transaction",
    "html": "Overview\n\nSet a breakpoint in your implementation of the transaction queue observer’s paymentQueue(_:updatedTransactions:) method. Then sign in to the App Store with a Sandbox Apple ID, and make a purchase in your app. Inspect the transaction to verify that its status is SKPaymentTransactionState.purchased.\n\nSet a breakpoint at the point in your code where your app stores the purchase, and confirm that your code saves the data in response to a successful purchase. Inspect the user default or iCloud key-value store, to verify that your code correctly records the information. For more information on saving data in response to a successful purchase, see Persisting a purchase.\n\nSee Also\nTransaction observer\nTesting transaction observer code\nVerify that your app activates its payment transaction observer by using breakpoints.\nTesting complete transactions\nVerify that your app completes transactions properly by confirming that any downloadable purchases are present on your test device."
  },
  {
    "title": "StoreKitError.unknown",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror/unknown",
    "html": "See Also\nStoreKit Error Codes\ncase networkError(URLError)\nA network error occurred.\ncase systemError(any Error)\nA system error occurred.\ncase userCancelled\nThe user canceled.\ncase notAvailableInStorefront\nThe function isn’t available on devices configured for this storefront.\ncase notEntitled\nThe app doesn’t have the appropriate entitlements to use the functionality."
  },
  {
    "title": "Testing Family Sharing",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_family_sharing",
    "html": "Overview\n\nFamily Sharing lets people share access to auto-renewable subscriptions or non-consumables that have Family Sharing enabled with up to five family members. You can use Sandbox Test Families to test whether your app works with Family Sharing as expected.\n\nNote\n\nChanges that you make to product metadata in App Store Connect can take up to one hour to appear in the sandbox environment.\n\nTo test Family Sharing in your app:\n\nEnsure your in-app purchases are set up to support Family Sharing. For more information, see Turn on Family Sharing for in-app purchases.\n\nCreate two or more Sandbox Apple IDs to add to a Sandbox Test Family, or use existing accounts. A family group can have up to six members. For more information, see Create Sandbox Apple IDs.\n\nCreate the Sandbox Test Family in App Store Connect. For more information, see Create a Sandbox Test Family.\n\nTo make testing easier, have a separate device to use for each test family member. You can also use a single device and sign in using each family member’s Sandbox Apple ID in turn.\n\nManage sharing for the Sandbox Test Family\n\nYou can set the sharing status for each member of the Sandbox Test Family individually, as follows:\n\nSharing indicates the family member shares their in-app purchases with the Sandbox Test Family, and gets access to in-app purchases shared by family members.\n\nNot Sharing indicates the family member isn’t sharing, and doesn’t get access to family-shared purchases. Changing the setting to Not Sharing revokes any family-shared purchases they have access to. In the test environment, turning off sharing is the equivalent of a family member leaving the group.\n\nModify the sharing status on the Family Sharing page in iOS by following these steps:\n\nOpen Settings and select App Store.\n\nSelect the Sandbox Apple ID.\n\nOn the popup sheet, select Manage.\n\nOn the Account Settings page, select Family Sharing.\n\nSelect a family member.\n\nSelect Stop Sharing Purchases or Start Sharing Purchases, as appropriate.\n\nYou can also change these settings in App Store Connect. For more information, see Manage a Sandbox Test Family.\n\nTest sharing an in-app purchase in a family group\n\nThe two main test cases for Family Sharing are a family member gaining and losing access to family-shared purchases. You can simulate these situations as follows.\n\nTo test family members gaining access to a shared purchase:\n\nStart with a Sandbox Test Family where members are sharing.\n\nIn your app, purchase a shareable product.\n\nOpen your app on a device signed in with the Sandbox Apple ID of another test family member.\n\nVerify that your app receives a transaction for the shared purchase and unlocks the content for the family member. Note that the transaction has a familyShared ownership type.\n\nWhen sharing auto-renewable subscriptions, if you have App Store Server Notifications V2 enabled in the sandbox environment, your server receives a notification for each test family member that has sharing enabled. For more information, see the SUBSCRIBED notificationType.\n\nTest revoked access to shared in-app purchases\n\nTo test a family member losing access to shared purchases:\n\nStart with a Sandbox Test Family with two or more members, and at least one shared purchase.\n\nIn Account Settings > Family Sharing, select a test family member that is receiving access to a shared in-app purchase.\n\nSelect Stop Sharing Purchases, and Stop Sharing to confirm.\n\nThe test family member loses accesses to shared purchases. Open your app using their Sandbox Apple ID and confirm that your app receives an updated transaction that includes a revocationDate and revocationReason.\n\nIf you have App Store Server Notifications V2 enabled in the sandbox environment, your server receives a REVOKE notificationType for the test family member that has sharing disabled.\n\nNote that you can also change the sharing status using App Store Connect instead of Account Settings in iOS."
  },
  {
    "title": "Testing disabling auto-renew",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_disabling_auto-renew",
    "html": "Overview\n\nCustomers can manage their active subscriptions, as well as their expired subscriptions for up to a year after expiry, in the Subscriptions page on iOS, tvOS, iPadOS, and macOS. In this test scenario, the customer cancels a subscription, which disables auto-renew.\n\nTo set up for this test, purchase an auto-renewable subscription for the Sandbox Apple ID account.\n\nBegin testing\n\nTo test disabling auto-renew:\n\nOn the test iOS device, open Settings > App Store.\n\nIn the Sandbox Account section, tap your highlighted Sandbox Apple ID, and tap Manage.\n\nIn the sandbox Subscriptions page, select the subscription product that you want to cancel.\n\nTap the Cancel Subscription button.\n\nVerify the change in the subscription status using either of these two methods:\n\nIf you’ve configured App Store Connect settings to receive App Store server notifications, your server receives the notification_type DID_CHANGE_RENEWAL_STATUS each time the subscription’s auto-renew status changes. For more information, see Enabling App Store Server Notifications.\n\nVerify the receipt by calling verifyReceipt with the latest receipt. Check that the auto_renew_status property of the responseBody.Pending_renewal_info object changes to 0. The auto_renew_status_change_date_ms property of responseBody contains the timestamp of the change.\n\nTest reenabling the subscription renewal\n\nAfter disabling auto-renew, reenable the subscription on the same Manage Subscriptions page by tapping the subscription and confirming payment.\n\nVerify the change in the subscription status using either of these two methods:\n\nIf you’ve configured App Store Connect settings to receive App Store server notifications, your server receives the notification_type DID_CHANGE_RENEWAL_STATUS each time the subscription’s auto-renew status changes. For more information, see Enabling App Store Server Notifications.\n\nVerify the receipt by calling verifyReceipt with the latest receipt. Check that the auto_renew_status property of the responseBody.Pending_renewal_info object changes to 1. The auto_renew_status_change_date_ms property of responseBody contains the timestamp of the change.\n\nSee Also\nSubscriptions\nTesting an auto-renewable subscription\nVerify that your app handles a subscription lapse properly using the accelerated time rates within the sandbox environment.\nTesting resubscribing from the subscriptions page\nVerify that your app can reactivate an expired subscription by receiving a transaction callback or inspecting an updated receipt."
  },
  {
    "title": "Testing failing subscription renewals and in-app purchases",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_failing_subscription_renewals_and_in-app_purchases",
    "html": "Overview\n\nPayments can fail unexpectedly at any stage of the billing cycle, such as when a payment card expires. Test your app’s user experience to ensure it handles these unexpected events, and provides appropriate levels of service when billing issues occur.\n\nIn sandbox testing, you can simulate billing issues that cause in-app purchases to fail, and auto-renewable subscriptions not to renew. You can also enable Billing Grace Period for the sandbox environment. Use these sandbox features to test how your app handles auto-renewable subscriptions with billing issues that do or don’t recover.\n\nThe sandbox environment sends App Store Server Notifications as you perform tests. For more information, see Enabling App Store Server Notifications.\n\nThe sandbox environment renews auto-renewable subscriptions up to 12 times. For more information about renewal rates in the sandbox environment, see Edit subscription renewal speed.\n\nFor more information about subscription state changes when billing issues occur, see Reducing Involuntary Subscriber Churn. For information about how apps determine access to subscription content, see Handling Subscriptions Billing.\n\nConfigure the sandbox environment to simulate billing issues\n\nFollow these steps on a test device running iOS 16 or iPadOS 16, or later:\n\nSign in to the App Store using a Sandbox Apple ID.\n\nChoose Settings > App Store > Sandbox Account > Manage > Account Settings.\n\nDisable the Allow Purchases & Renewals setting.\n\nDisabling this setting causes in-app purchases to fail, and auto-renewable subscriptions to not renew in the sandbox environment.\n\nNote\n\nThis setting applies to all devices that the Sandbox Apple ID signs in to, and to all active auto-renewable subscriptions belonging to that account.\n\nThis setting stays in a disabled state until you reenable it. Reenable it to simulate a customer resolving a billing issue.\n\nEnable Billing Grace Period in the sandbox environment\n\nTo enable Billing Grace Period in the sandbox environment, log in to App Store Connect, and do the following:\n\nFrom My Apps, select your app.\n\nIn the sidebar under Features, click Subscriptions.\n\nIn the Billing Grace Period section, click Set Up Billing Grace Period.\n\nSelect a duration from the drop-down menu.\n\nSelect whether to apply the grace period to all renewals or to only paid-to-paid renewals. For more information about the configurable settings, see Enable Billing Grace Period for auto-renewable subscriptions.\n\nSelect Only Sandbox Environment to enable Billing Grace Period for testing only.\n\nClick Next.\n\nClick Confirm.\n\nTo test billing issues for subscriptions with Billing Grace Period, first, purchase an auto-renewable subscription, and then configure the setting to simulate billing issues (as described above in Configure the sandbox environment to simulate billing issues).\n\nTest subscriptions that enter a billing retry state\n\nAuto-renewable subscriptions expire and enter a billing retry state when a subscription fails to auto-renew.\n\nThis test case assumes that Billing Grace Period is in a disabled state for the sandbox enviroment. To test subscriptions entering a billing retry state:\n\nSuccessfully purchase an auto-renewable subscription in your app.\n\nSet the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues.\n\nWait for the subscription period to renew. The renewal fails, and it enters a billing retry state.\n\nCheck that your app recognizes the state. Subscriptions in a billing retry state that aren't in a billing grace period are not entitled to service. StoreKit provides the isInBillingRetry value in the Product.SubscriptionInfo.RenewalState object.\n\nTest subscriptions that enter a billing grace period\n\nAuto-renewable subscriptions enter a billing grace period when both of the following occur:\n\nBilling Grace Period is enabled for your app\n\nThe subscription fails to auto-renew\n\nTo test subscriptions entering a billing grace period:\n\nFollow the steps as described above in Enable Billing Grace Period in the sandbox environment.\n\nSuccessfully purchase an auto-renewable subscription in your app.\n\nSet the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues.\n\nWait for the subscription period to renew. The subscription enters the billing grace period.\n\nCheck that your app recognizes the state and provides service for the subscription during the billing grace period. StoreKit provides the grace period expiration date in the gracePeriodExpirationDate property of the Product.SubscriptionInfo.RenewalInfo object.\n\nWait for the billing grace period to expire. The subscription remains in the billing retry state.\n\nCheck that your app recognizes the billing retry state. Subscriptions aren’t entitled to service after the billing grace period expires.\n\nNote\n\nAuto-renewable subscriptions in a billing grace period state are entitled to service.\n\nTest billing problem messaging after a subscription enters a billing retry state\n\nAuto-renewable subscriptions expire and enter a billing retry state when a subscription fails to auto-renew. The system displays a Billing Problem message when your app launches, unless your app chooses to delay the billingIssue message. Use these steps to trigger the message and test how your app responds to the message in various views. For more information about managing these system messages, see Message.\n\nTo test when the system presents the Billing Problem sheet after subscriptions enter the billing retry state:\n\nSuccessfully purchase an auto-renewable subscription in your app.\n\nSet the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues.\n\nWait for the subscription period to renew. The renewal fails, and enters a billing retry state.\n\nThe App Store sends the billingIssue message. Launch the app or bring it to the foreground.\n\nIf your app doesn't implement messages, the system presents the Billing Problem sheet.\n\nIf your app implements messages and delays the message, perform the steps your app requires for it to call display(in:). As long as the billing issue is still active, the system presents the Billing Problem sheet. If you resolve the billing issue before the app calls display(in:), the system doesn't present the sheet.\n\nYou may perform this test with or without Billing Grace Period enabled.\n\nTest subscriptions that recover from billing issues\n\nA subscription is recovered when a billing retry succeeds. It exits a billing retry or billing grace period state, and is active again.\n\nTo test recovered auto-renewable subscriptions, follow these steps:\n\nStart with a subscription in the billing retry state, as described above in Test subscriptions that enter a billing retry state.\n\nChoose Settings > App Store > Sandbox Account > Manage > Account Settings, and enable the Allow Purchases & Renewals setting, which causes the next subscription renewal attempt to succeed.\n\nCheck that your app recognizes the active subscription state, which is entitled to service.\n\nRepeat the test starting with a subscription in the billing grace period, as described above in Test subscriptions that enter a billing grace period.\n\nThe subscription billing cycle for a subscription that recovers from a billing retry state starts on the recovery date. The billing cycle for a subscription that recovers during a billing grace period doesn't change.\n\nTest subscriptions that don't recover from billing issues\n\nSubscriptions exit a billing retry state when any of the following happens:\n\nThe billing retry period expires without recovering the subscription.\n\nThe customer cancels the subscription.\n\nThe subscription is recovered because billing succeeds.\n\nTo test subscriptions that expire and don't recover, follow these steps:\n\nStart with a subscription in a billing retry state, as described above in Test subscriptions that enter a billing retry state.\n\nWait for the billing retry period to expire — don’t enable the Allow Purchases & Renewals setting.\n\nCheck that your app recognizes the subscription state. The subscription is inactive and not entitled to service.\n\nTo test a subscription that a customer cancels, follow these steps:\n\nStart with a subscription in a billing grace period, as described above in Test subscriptions that enter a billing grace period.\n\nCancel the subscription by managing subscriptions in Settings, or by using your app’s implementation of showManageSubscriptions(in:). For more information about managing subscriptions in Settings, see If you want to cancel a subscription from Apple.\n\nThe system immediately cancels the subscription.\n\nCheck that your app recognizes the subscription state. The subscription is inactive and not entitled to service.\n\nRepeat the test starting with a subscription in the billing retry state, as described above in Test subscriptions that enter a billing retry state.\n\nTest a failed in-app purchase\n\nTo test a failed purchase attempt, follow these steps:\n\nSet the environment to simulate billing issues, as described above in Configure the sandbox environment to simulate billing issues.\n\nIn your app, attempt to buy an in-app purchase product. The system displays an error message for the sandbox environment that shows the purchase failed.\n\nTo continue testing billing issues, select OK. Alternatively, to simulate a user resolving a billing issue, select Settings to return to Account Settings, where you can enable Allow Purchases & Renewals.\n\nSee Also\nPayment transactions\nTesting purchases made outside your app\nVerify that your app receives and handles transactions that occur outside of your app, such as subscription purchases, renewals, and offer and promo code redemptions.\nTesting an interrupted purchase\nVerify that your app handles an interrupted purchase by inspecting and invoking payment transactions.\nTesting a payment request\nVerify that requests for payment function properly in the sandbox environment by inspecting the calls to the payment transaction observer."
  },
  {
    "title": "Testing invalid product identifier handling",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_invalid_product_identifier_handling",
    "html": "Overview\n\nIntentionally include an invalid identifier in your app’s list of product identifiers. Then do one of the following:\n\nIn a production build, verify that the app displays the rest of its store UI and that users can purchase the valid products.\n\nIn a development build, verify that the app brings the issue to your attention.\n\nCheck the console log and verify that you can correctly identify the invalid product identifier. Make sure you remove it after testing.\n\nFor more information on fetching product identifiers, see Loading in-app product identifiers.\n\nSee Also\nProduct identifiers and requests\nTesting fetching product identifiers\nVerify that your app receives the correct product identifiers by inspecting or replicating your app’s process for retrieving the identifiers.\nTesting a product request\nVerify that requests for products function properly in the sandbox environment by inspecting the App Store response."
  },
  {
    "title": "Storefront.ID",
    "url": "https://developer.apple.com/documentation/storekit/storefront/id",
    "html": "See Also\nIdentifying the storefront\nstatic var current: Storefront?\nThe current App Store storefront for product purchases.\nlet countryCode: String\nThe three-letter code that represents the country or region associated with the App Store storefront.\nlet id: String\nAn Apple-defined value that uniquely identifies an App Store storefront.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Storefront conforms to AnyObject."
  },
  {
    "title": "Testing a payment request",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_a_payment_request",
    "html": "Overview\n\nCreate an instance of SKPayment using a valid product identifier that you’ve already tested, as described in Testing fetching product identifiers. Set a breakpoint and inspect the payment request. Add the payment request to the transaction queue, and set a breakpoint to confirm that the system calls your observer’s paymentQueue(_:updatedTransactions:) method.\n\nThough you can finish the transaction immediately without providing the content of the purchase during testing, failing to finish the transaction can cause problems. Unfinished transactions remain in the queue indefinitely, which could interfere with later testing. Complete the transaction as described in Finishing a transaction at the end of each test.\n\nSee Also\nPayment transactions\nTesting purchases made outside your app\nVerify that your app receives and handles transactions that occur outside of your app, such as subscription purchases, renewals, and offer and promo code redemptions.\nTesting an interrupted purchase\nVerify that your app handles an interrupted purchase by inspecting and invoking payment transactions.\nTesting failing subscription renewals and in-app purchases\nVerify that your app handles failed subscription renewals that are in the billing retry or billing grace period states, as well as failed in-app purchases."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/storekit/storefront/3792003-id",
    "html": "Discussion\n\nNote\n\nThis documentation comment was inherited from Identifiable.\n\nSee Also\nIdentifying the storefront\nstatic var current: Storefront?\nThe current App Store storefront for product purchases.\nlet countryCode: String\nThe three-letter code that represents the country or region associated with the App Store storefront.\nlet id: String\nAn Apple-defined value that uniquely identifies an App Store storefront.\ntypealias Storefront.ID\nThe type that represents a storefront identifier."
  },
  {
    "title": "Testing a product request",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_a_product_request",
    "html": "Overview\n\nAfter setting a breakpoint in your code, use the list of product identifiers that you tested in Testing fetching product identifiers to create and submit an instance of SKProductsRequest. Then inspect the lists of valid and invalid product identifiers. If there are invalid product identifiers, review your products in App Store Connect and correct your JSON file or property list.\n\nNote\n\nChanges that you make to product metadata in App Store Connect can take up to one hour to appear in the sandbox environment.\n\nSee Testing invalid product identifier handling for more information.\n\nSee Also\nProduct identifiers and requests\nTesting fetching product identifiers\nVerify that your app receives the correct product identifiers by inspecting or replicating your app’s process for retrieving the identifiers.\nTesting invalid product identifier handling\nVerify that your app correctly handles invalid product identifiers."
  },
  {
    "title": "Testing fetching product identifiers",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_fetching_product_identifiers",
    "html": "Overview\n\nIf you embed your product identifiers in your app, set a breakpoint in your code after the code loads the identifiers. Verify that the instance of NSArray contains your expected list of product identifiers.\n\nNote\n\nChanges that you make to product metadata in App Store Connect can take up to one hour to appear in the sandbox environment.\n\nIf your app fetches your product identifiers from a server, manually fetch the JSON file using a web browser such as Safari, or a command-line utility such as curl. Verify that the data your server returns contains the expected list of product identifiers and that your server correctly implements standard HTTP caching mechanisms.\n\nFor more information on fetching product identifiers, see Loading in-app product identifiers.\n\nSee Also\nProduct identifiers and requests\nTesting invalid product identifier handling\nVerify that your app correctly handles invalid product identifiers.\nTesting a product request\nVerify that requests for products function properly in the sandbox environment by inspecting the App Store response."
  },
  {
    "title": "Testing an interrupted purchase",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_an_interrupted_purchase",
    "html": "Overview\n\nAn interrupted purchase is a transaction that requires the user to perform some action outside of your app before completing their transaction. For example, the user may need to update their payment method or accept new terms and conditions before continuing with their transaction.\n\nIn sandbox testing, you can simulate an interrupted purchase by turning on the interrupted purchase feature in App Store Connect for a tester Sandbox Apple ID. This interrupts all purchase attempts by that Sandbox Apple ID until you agree to the updated terms and conditions on the iOS device, or until you turn off the feature in App Store Connect. To learn how to set up interrupted purchase testing, see Enable interrupted purchases for a Sandbox Apple ID.\n\nSet up testing\n\nTo enable interrupted purchases for the Sandbox Apple ID, log in to App Store Connect, and do the following:\n\nFrom Users and Access, open the Users and Access Panel in the sidebar, under the Sandbox header, select Testers. On the right, you can view your Sandbox Apple IDs.\n\nSelect a Sandbox Apple ID to use for testing interrupted purchases. If it’s already enabled, you’ll see a checkmark under the Interrupted Purchases column.\n\nIn the dialog that appears, select Interrupt Purchases for This Tester.\n\nBegin testing\n\nAfter setting up interrupted purchase testing in App Store Connect, use the following steps to test your app:\n\nOn the test device, sign in with the Sandbox Apple ID that has interrupted purchases enabled.\n\nIn your app, select Buy or Subscribe to make an in-app purchase.\n\nObserve that the system displays a payment sheet.\n\nIn Xcode, verify that the payment queue receives a new transaction in the state SKPaymentTransactionState.purchasing.\n\nOn the device, authenticate the payment sheet.\n\nIn Xcode, observe that the payment fails. The payment queue receives an updated transaction in the state SKPaymentTransactionState.failed.\n\nCheck that your code calls finishTransaction(_:) to remove it from the queue.\n\nOn the device, observe that the system displays Terms & Conditions, interrupting the purchase (because you configured the sandbox environment to do so).\n\nOn the device, tap to agree to the Terms & Conditions.\n\nIn Xcode, verify that the payment queue receives a new transaction in the SKPaymentTransactionState.purchased state for the same productIdentifier and in the same quantity as the failed transaction.\n\nIn Xcode, validate the receipt. Check that your app provides the service or the product, and calls finishTransaction(_:).\n\nOn the device, the user should observe a successful purchase.\n\nConclude testing\n\nThe Sandbox Apple ID continues to experience interrupted purchases until you disable it in App Store Connect, or until the user agrees to the terms and conditions on the device. To disable interrupted purchases in App Store Connect, deselect Interrupt Purchases for This Tester. For more information, see Enable interrupted purchases for a Sandbox Apple ID.\n\nSee Also\nPayment transactions\nTesting purchases made outside your app\nVerify that your app receives and handles transactions that occur outside of your app, such as subscription purchases, renewals, and offer and promo code redemptions.\nTesting failing subscription renewals and in-app purchases\nVerify that your app handles failed subscription renewals that are in the billing retry or billing grace period states, as well as failed in-app purchases.\nTesting a payment request\nVerify that requests for payment function properly in the sandbox environment by inspecting the calls to the payment transaction observer."
  },
  {
    "title": "Enabling App Store Server Notifications",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/enabling_app_store_server_notifications",
    "html": "Overview\n\nApp Store Server Notifications is a server-to-server service that sends real-time notifications for in-app purchase events, and notifications for unreported external purchase tokens. To enable notifications, set up an HTTPS URL on your server, and configure settings in App Store Connect.\n\nFor information about parsing and interpreting notifications, see Receiving App Store Server Notifications.\n\nSet up your server and App Store Connect settings\n\nTo receive server notifications from the App Store, your server must support the Transport Layer Security (TLS) 1.2 protocol or later.\n\nTo enable App Store Server Notifications, follow these steps:\n\nDetermine the HTTPS URL on your server to receive notifications for the production environment.\n\nOptionally, determine the HTTPS URL on your server to receive notifications for the sandbox environment for testing notifications. You may use the same URL for both the production and the sandbox environments.\n\nApp Store Connect gives you the choice of receiving version 2 or version 1 notifications for each environment. To choose version 2, set up your endpoint as App Store Server Notifications V2.\n\nConfigure your URL in App Store Connect. For more information, see Enter a URL for App Store Server Notifications.\n\nImportant\n\nIf you specify a port in your URL, the port must be either 443 or greater than or equal to 1024. For example, the URL https://example.com:1234/notifications specifies the port 1234.\n\nConfigure your server to respond with HTTP status codes to indicate whether the App Store server notification POST is successful. For more information, see Responding to App Store Server Notifications.\n\nFor new implementations, use App Store Server Notifications V2. To transition from using version 1 notifications to version 2, test version 2 notifications in the sandbox environment before you update your production environment to version 2.\n\nFor information about changes to App Store Server Notifications, see App Store Server Notifications changelog.\n\nConfigure an allow list\n\nIf your server requires IP addresses to be on an allow list, add the IP address subnet 17.0.0.0/8 to allow your server to receive notifications from the App Store server. This subnet applies to both the sandbox and the production environments.\n\nTest your server setup\n\nTo determine whether your server is receiving notifications, call the Request a Test Notification endpoint in the App Store Server API. This endpoint asks the App Store server to send a notification with the notificationType TEST. Use the testNotificationToken you receive to call the Get Test Notification Status endpoint to learn how your server responds to the test notification.\n\nThe App Store server sends the TEST notification in the version 2 notification format. However, it sends it to your server regardless of whether you configure a version 1 or version 2 notification URL in App Store Connect.\n\nSee Also\nEssentials\nHandling Subscriptions Billing\nBuild logic around the date and time constraints of subscription products, while planning for all scenarios where you control access to content.\nOffering a Subscription Across Multiple Apps\nSupport a single auto-renewable subscription across multiple apps.\nReducing Involuntary Subscriber Churn\nPrevent unintentional loss of subscribers due to billing issues."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/storekit/storefront/3792002-id",
    "html": "Relationships\nFrom Protocol\nIdentifiable\nSee Also\nIdentifying the storefront\nstatic var current: Storefront?\nThe current App Store storefront for product purchases.\nlet countryCode: String\nThe three-letter code that represents the country or region associated with the App Store storefront.\ntypealias Storefront.ID\nThe type that represents a storefront identifier.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Storefront conforms to AnyObject."
  },
  {
    "title": "SKErrorDomain",
    "url": "https://developer.apple.com/documentation/storekit/skerrordomain",
    "html": "See Also\nErrors\nHandling errors\nDetermine the underlying cause of errors that result from StoreKit requests.\nenum SKError.Code\nError codes for StoreKit errors.\nstruct SKError\nStoreKit error descriptions, codes, and domains."
  },
  {
    "title": "SKError",
    "url": "https://developer.apple.com/documentation/storekit/skerror",
    "html": "Topics\nError properties\nvar errorCode: Int\nThe error code that this instance represents.\nvar errorUserInfo: [String : Any]\nAn info dictionary for providing additional details about an error.\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar code: Code\nvar userInfo: [String : Any]\nError codes\nenum SKError.Code\nError codes for StoreKit errors.\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays.\nError domain\nstatic var errorDomain: String\nGets the error domain that identifies an error as a StoreKit error.\nlet SKErrorDomain: String\nThe error domain name for StoreKit errors.\nError code comparisons and hash\nstatic func != (SKError, SKError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (SKError, SKError) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nInitialize\ninit(Code, userInfo: [String : Any])\nSee Also\nErrors\nHandling errors\nDetermine the underlying cause of errors that result from StoreKit requests.\nenum SKError.Code\nError codes for StoreKit errors.\nlet SKErrorDomain: String\nThe error domain name for StoreKit errors."
  },
  {
    "title": "SKError.Code",
    "url": "https://developer.apple.com/documentation/storekit/skerror/code",
    "html": "Topics\nEnumeration Cases\ncase unknown\nError code indicating that an unknown or unexpected error occurred.\ncase clientInvalid\nError code indicating that the client is not allowed to perform the attempted action.\ncase paymentCancelled\nError code indicating that the user canceled a payment request.\ncase paymentInvalid\nError code indicating that one of the payment parameters wasn’t recognized by the App Store.\ncase paymentNotAllowed\nError code indicating that the user is not allowed to authorize payments.\ncase storeProductNotAvailable\nError code indicating that the requested product is not available in the store.\ncase cloudServicePermissionDenied\nError code indicating that the user has not allowed access to Cloud service information.\ncase cloudServiceNetworkConnectionFailed\nError code indicating that the device could not connect to the network.\ncase cloudServiceRevoked\nError code indicating that the user has revoked permission to use this cloud service.\ncase privacyAcknowledgementRequired\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\ncase unauthorizedRequestData\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\ncase invalidOfferIdentifier\nError code indicating that the offer identifier is invalid.\ncase invalidOfferPrice\nError code indicating that the price you specified in App Store Connect is no longer valid.\ncase invalidSignature\nError code indicating that the signature in a payment discount isn’t valid.\ncase missingOfferParams\nError code indicating that parameters are missing in a payment discount.\ncase ineligibleForOffer\nAn error code that indicates the user is ineligible for the subscription offer.\ncase overlayCancelled\nAn error code that indicates the cancellation of an overlay.\ncase overlayInvalidConfiguration\nAn error code that indicates the overlay’s configuration is invalid.\ncase overlayPresentedInBackgroundScene\ncase overlayTimeout\ncase unsupportedPlatform\nAn error code that indicates the current platform doesn’t support overlays.\nRelationships\nConforms To\nSendable\nSee Also\nError codes\nstatic var unknown: SKError.Code\nError code indicating that an unknown or unexpected error occurred.\nstatic var clientInvalid: SKError.Code\nError code indicating that the client is not allowed to perform the attempted action.\nstatic var paymentCancelled: SKError.Code\nError code indicating that the user canceled a payment request.\nstatic var paymentInvalid: SKError.Code\nError code indicating that one of the payment parameters was not recognized by the App Store.\nstatic var paymentNotAllowed: SKError.Code\nError code indicating that the user is not allowed to authorize payments.\nstatic var storeProductNotAvailable: SKError.Code\nError code indicating that the requested product is not available in the store.\nstatic var cloudServicePermissionDenied: SKError.Code\nError code indicating that the user has not allowed access to Cloud service information.\nstatic var cloudServiceNetworkConnectionFailed: SKError.Code\nError code indicating that the device could not connect to the network.\nstatic var cloudServiceRevoked: SKError.Code\nError code indicating that the user has revoked permission to use this cloud service.\nstatic var privacyAcknowledgementRequired: SKError.Code\nError code indicating that the user has not yet acknowledged Apple’s privacy policy for Apple Music.\nstatic var unauthorizedRequestData: SKError.Code\nError code indicating that the app is attempting to use a property for which it does not have the required entitlement.\nstatic var invalidOfferIdentifier: SKError.Code\nError code indicating that the offer identifier cannot be found or is not active.\nstatic var invalidOfferPrice: SKError.Code\nError code indicating that the price you specified in App Store Connect is no longer valid.\nstatic var invalidSignature: SKError.Code\nError code indicating that the signature in a payment discount is not valid.\nstatic var missingOfferParams: SKError.Code\nError code indicating that parameters are missing in a payment discount.\nstatic var ineligibleForOffer: SKError.Code\nAn error code that indicates the user is ineligible for the subscription offer.\nstatic var overlayCancelled: SKError.Code\nAn error code that indicates the cancellation of an overlay.\nstatic var overlayInvalidConfiguration: SKError.Code\nAn error code that indicates the overlay’s configuration is invalid.\nstatic var overlayPresentedInBackgroundScene: SKError.Code\nstatic var overlayTimeout: SKError.Code\nAn error code that indicates the timing out of an overlay.\nstatic var unsupportedPlatform: SKError.Code\nAn error code that indicates the current platform doesn’t support overlays."
  },
  {
    "title": "Testing in-app purchases in Xcode",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/testing_in-app_purchases_in_xcode",
    "html": "Overview\n\nTesting your StoreKit implementation in Xcode ensures that your app behaves correctly when your users perform various tasks associated with subscriptions and in-app purchase transactions. Be sure to test a variety of in-app purchase scenarios, such as receipt validation, promotional offers, interrupted purchases, introductory offers, subscription renewals, and purchase restoration.\n\nPerform basic setup\n\nBefore you begin StoreKit testing in Xcode, complete the steps in Setting up StoreKit Testing in Xcode, including creating a StoreKit configuration file, enabling StoreKit testing in Xcode, and preparing to validate receipts in the test environment. The test scenarios in this article require this basic setup.\n\nSelect the relevant test scenarios to build a test plan for your app. Each test scenario provides additional setup steps, if necessary, along with instructions about how to minimally reset the environment to repeat the test.\n\nValidate a receipt in the test environment\n\nValidating receipts is an integral part of handling and testing in-app purchases. As you test in-app purchases, StoreKit in Xcode generates receipts that are valid only in the test environment. Your app can validate the receipts locally using a certificate that Xcode provides.\n\nImportant\n\nYou can’t validate receipts from the test environment with verifyReceipt because the App Store doesn’t sign these receipts, and the verification fails.\n\nThe test environment’s certificate is a root certificate. There’s no certificate chain to validate when you verify the receipt signature. The following code example retrieves the local receipt:\n\n// Get the receipt if it's available.\nif let appStoreReceiptURL = Bundle.main.appStoreReceiptURL,\n    FileManager.default.fileExists(atPath: appStoreReceiptURL.path) {\n    do {\n        let receiptData = try Data(contentsOf: appStoreReceiptURL, options: .alwaysMapped)\n        let receiptString = receiptData.base64EncodedString(options: [])\n        // Add code to read receiptData.\n    }\n    catch { \n        print(\"Couldn't read receipt data: \" + error.localizedDescription) }\n}\n\n\nFor more information, see Validating receipts on the device.\n\nTest a promotional offer\n\nFor this test scenario, let’s assume the app determines that customers are eligible for the promotional offer when the subscription expires. Use the test environment to speed up the time rate so the subscription expires. Then, you’re ready to test the offer eligibility logic in your app.\n\nAdditional setup steps for this test scenario are:\n\nAdd a subscription offer to your StoreKit configuration file.\n\nIn the app, purchase a subscription within the same subscription group to be eligible for a promotional offer.\n\nEnsure your test user is eligible for the offer according to your app’s requirements, then purchase the subscription with the offer. Test users can redeem subscription offers if:\n\nThey have an existing or expired subscription, including free, discount, or discounted with a subscription offers.\n\nThey qualify for the offer according to criteria that you define.\n\nSee Implementing promotional offers in your app for more information.\n\nIn Xcode, select the StoreKit configuration file in the Project navigator, and then choose Editor > Subscription Renewal Rate > Monthly Renewal Every 30 Seconds.\n\nWait until the subscription expires.\n\nReset the Subscription Renewal rate to Monthly Renewal Every 30 Minutes.\n\nIn the app, select the option to buy the subscription with the offer.\n\nIn your code, verify that the payment request includes the discount, paymentDiscount.\n\nObserve that the system displays the payment sheet with the promotional offer.\n\nIn your code, verify that paymentQueue(_:updatedTransactions:) receives the transaction in the SKPaymentTransactionState.purchasing state.\n\nIn the app, tap Confirm on the payment sheet.\n\nIn your code, verify that paymentQueue(_:updatedTransactions:) receives the transaction in the SKPaymentTransactionState.purchased state.\n\nTo test the same promotional offer purchase again, delete the transaction. In Xcode, choose Debug > StoreKit > Manage Transactions. Select the transaction for the promotional offer purchase, and click Delete.\n\nTest an interrupted purchase\n\nAn interrupted purchase is a transaction that requires the user to perform some action outside your app before the transaction can complete successfully. For example, the user may need to update a payment method or approve new terms and conditions. In Xcode, you can simulate a purchase interruption and its resolution to test how your code handles this scenario end-to-end. You can test this scenario for all in-app purchase product types.\n\nIn the Xcode Project navigator, select the StoreKit configuration file. Choose Editor > Enable Interrupted Purchases. Run the app in the simulator or on a device.\n\nIn the app, buy an in-app purchase.\n\nObserve that the system displays the payment sheet in the app.\n\nIn your code, verify that your SKPaymentTransactionObserver gets a callback on paymentQueue(_:updatedTransactions:) with a transaction in the SKPaymentTransactionState.purchasing state.\n\nIn the app, tap Confirm on the payment sheet.\n\nIn your code, observe that the payment fails (because you enabled interrupted purchases in the test environment). The payment queue receives a transaction in the SKPaymentTransactionState.failed state.\n\nCheck that your code calls finishTransaction(_:) to remove it from the queue.\n\nIn Xcode, choose Debug > StoreKit > Manage Transactions.\n\nSelect the transaction and click Resolve. The test environment resumes a successful purchase.\n\nIn your code, verify that the payment queue receives a transaction in the SKPaymentTransactionState.purchased state for the same productIdentifier in the same quantity as the failed transaction.\n\nIn your code, validate the receipt.\n\nCheck that your app provides the service or product, and then calls finishTransaction(_:).\n\nTo perform the test again for non-consumable products and subscriptions, delete the transaction to run the test again. To delete the transaction, choose Debug > StoreKit > Manage Transactions. Select the transaction and click Delete.\n\nFor consumable in-app purchases, you can test again without additional setup. To reset the test environment to its default behavior, select the StoreKit configuration file in Xcode, then choose Editor > Disable Interrupted Purchases.\n\nTest an introductory offer\n\nCustomers are eligible to redeem an introductory offer one time. Configure an introductory offer for a subscription in your StoreKit configuration file. For more information, see Implementing introductory offers in your app.\n\nEnsure that your app is eligible for an introductory offer by verifying there’s no subscription purchase for the product ID that includes the offer. Either verify the receipt in your code or check the transactions in Xcode by choosing Debug > StoreKit > Manage Transactions.\n\nIn the app, buy the subscription that has an introductory offer.\n\nObserve that the system displays the payment sheet with the introductory offer in the app.\n\nIn your code, verify your SKPaymentTransactionObserver receives a callback on paymentQueue(_:updatedTransactions:) with the transaction in the SKPaymentTransactionState.purchasing state.\n\nIn the app, tap Confirm on the payment sheet.\n\nIn your code, verify your SKPaymentTransactionObserver receives a callback on paymentQueue(_:updatedTransactions:) with the transaction in the SKPaymentTransactionState.purchased state.\n\nIn your code, validate the receipt.\n\nCheck that your app provides the service or product, and then calls finishTransaction(_:).\n\nTo retry the same test scenario, delete the transaction that contains the introductory offer purchase. In Xcode, choose Debug > StoreKit > Manage Transactions. Select the transaction and click Delete. This resets the eligibility for the test user.\n\nTest restoring purchases without existing purchases\n\nAll apps need to provide a way for customers to restore purchases, such as by providing a Restore Purchases button. Test how your app handles this request when the customer has no existing purchases. For more information, see Restoring purchased products.\n\nInclude at least one non-consumable product, auto-renewable subscription, or non-renewable subscription in the StoreKit configuration file. To simulate a user account with no in-app purchases, delete all the transactions before starting the test. In Xcode, choose Debug > StoreKit > Manage Transactions, select all the transactions, and click Delete.\n\nIn the app, select the option your app provides to restore purchases.\n\nIn your code, verify that it calls restoreCompletedTransactions() or restoreCompletedTransactions(withApplicationUsername:).\n\nIn your code, verify that StoreKit notifies your observer that the restore is complete by calling paymentQueueRestoreCompletedTransactionsFinished(_:). Note that StoreKit doesn’t notify the queue of any restored transactions.\n\nYou can repeat this test scenario without additional steps.\n\nTest presenting the App Store sheet for managing subscriptions\n\nYour app can present an App Store sheet that customers can use to manage their subscriptions.\n\nAdditional setup steps for this test scenario are:\n\nInclude two auto-renewable subscriptions that belong to the same subscription group in the StoreKit configuration file.\n\nSubscribe the sandbox user to the subscription with the lowest level of service in that subscription group.\n\nIn the app, implement a Manage Subscriptions button that invokes the showManageSubscriptions(in:) or manageSubscriptionsSheet(isPresented:) method.\n\nSee showManageSubscriptions(in:) and manageSubscriptionsSheet(isPresented:) for more information.\n\nIn the app, tap the Manage Subscriptions button.\n\nObserve that the system displays the App Store sheet for managing subscriptions.\n\nVerify that the test user is a subscriber of the lower-grade subscription.\n\nUpgrade the test user to the higher-grade subscription in that group.\n\nVerify that the user is a subscriber of the higher-grade subscription.\n\nCancel the subscription and confirm it in the Confirm Cancellation dialog.\n\nVerify that the user is no longer a subscriber of any subscription.\n\nYou can repeat this test scenario without additional steps.\n\nTest an offer code\n\nYour app can present a sheet to redeem preconfigured subscription offer codes.\n\nAdditional setup steps for this test scenario are:\n\nInclude one auto-renewable subscription in the StoreKit configuration file.\n\nConfigure an offer code for the above subscription in your StoreKit configuration file under the Offer Codes heading.\n\nIn the app, implement a Redeem Offer Code button that invokes the presentCodeRedemptionSheet() method.\n\nSee presentCodeRedemptionSheet() for more information.\n\nIn the app, tap the Redeem Offer Code button.\n\nObserve that the system displays the Redeem Offer Code sheet.\n\nSelect the offer code that you configured and redeem it.\n\nObserve that the system displays the payment sheet with the applied offer.\n\nIn the app, tap Confirm on the payment sheet.\n\nIn your code, verify your SKPaymentTransactionObserver receives a callback on paymentQueue(_:updatedTransactions:) with the transaction in the SKPaymentTransactionState.purchased state.\n\nCheck that your app provides the service or product, and then calls finishTransaction(_:).\n\nTo retry the same test scenario, delete the transaction that contains the offer code purchase. In Xcode, choose Debug > StoreKit > Manage Transactions. Select the transaction and click Delete.\n\nTest billing retry and grace period for auto-renewable subscriptions\n\nWhen billing for a subscription renewal fails, such as due to an expired card, the App Store retries billing and attempts to recover the subscription. You can enable a billing grace period for your app in App Store Connect so your subscribers can continue accessing paid content while the App Store retries billing. For more information about the billing grace period, see Reducing Involuntary Subscriber Churn.\n\nTest these scenarios in Xcode to ensure your app detects subscriptions that are in billing retry or billing grace period states. In your code, look at the renewalInfo for the subscription to inspect its Product.SubscriptionInfo.RenewalState. For subscriptions in a billing grace period state, ensure your app continues to provide uninterrupted subscription features.\n\nAdditional setup steps for this scenario are:\n\nChoose Editor > Enable Billing Grace Period. This step simulates enabling the billing grace period for your app in App Store Connect. To test billing retry without a billing grace period, leave this setting disabled.\n\nChoose Editor > Enable Billing Retry on Renewal. This step causes all subscription renewals to go into a billing retry state.\n\nSelect your StoreKit configuration file in the Project navigator.\n\nCreate an auto-renewable subscription in-app purchase in your StoreKit configuration file.\n\nPurchase the auto-renewable subscription in your app.\n\nAdjust the time rate of subscription renewals in the testing environment by choosing Editor > Subscription Renewal Rate, and select an option. For more information about the time rates available in the testing environment, see timeRate.\n\nTest your app’s handling of a billing grace period:\n\nIn the testing environment, wait for the subscription period to elapse. The subscription goes into a billing retry state and a billing grace period.\n\nRun your app, then choose Debug > StoreKit > Manage Transactions.\n\nFind and select the subscription transaction.\n\nVerify the subscription transaction is in the billing grace period state.\n\nTest your app to verify that it supports the billing grace period by continuing to provide uninterrupted access to the features the subscription provides.\n\nTest your app’s handling of a billing grace period expiration:\n\nIn the testing environment, wait until the billing grace period elapses for the subscription.\n\nRun your app, then choose Debug > StoreKit > Manage Transactions.\n\nFind and select the subscription transaction.\n\nVerify the subscription transaction is in the billing retry state, and is no longer in the billing grace period state.\n\nTest your app to verify that it works consistently with a subscription expiration.\n\nTest resolving a billing issue for billing retry, either with a billing grace period or without:\n\nIn the testing environment, wait for the subscription period to elapse. Verify your app works consistently with a subscription expiration if you’re not testing a billing grace period.\n\nRun your app, then choose Debug > StoreKit > Manage Transactions.\n\nFind and select the subscription transaction.\n\nVerify the subscription transaction is in either the billing grace period state or the billing retry state.\n\nClick the Resolve Issues button to resolve the billing issue.\n\nTest your app to verify that it provides access to the subscription features as you expect.\n\nTest price increase consent\n\nWhen you increase the price of an auto-renewable subscription by an amount that requires user consent, the App Store gives the user an opportunity to consent to the price increase by presenting a sheet in your app. Your app may defer presentation of the sheet to prevent it from appearing at an inconvenient time in the user interface. Users may also consent to a price increase outside your app. Test these scenarios in Xcode to verify that your app handles deferring or displaying the sheet.\n\nAdditional setup steps for this scenario are:\n\nCreate an auto-renewable subscription purchase in your StoreKit configuration file.\n\nPurchase the subscription in your app.\n\nOptionally, increase the price for your subscription in your StoreKit configuration file. You can still test this scenario without increasing the price.\n\nTest for the deferred price increase consent sheet presentation:\n\nNavigate to a place in your app where you defer presentation of the price increase consent sheet.\n\nRun your app, then choose Debug > StoreKit > Manage Transactions.\n\nFind and select the subscription transaction.\n\nClick Request Price Increase Consent.\n\nVerify that the price increase consent sheet doesn’t display in your app.\n\nNavigate away from the view where you defer presentation.\n\nVerify that the price increase consent sheet displays in your app.\n\nOn the price increase consent sheet in the app, select the Agree to New Price button to test a user consenting to the price increase, or select Close to test the user not giving consent for the price increase.\n\nTest for the price increase consent sheet presentation:\n\nNavigate to a place in your app where you don’t defer presenting the price increase consent sheet.\n\nIn the StoreKit transaction manager, select the subscription purchase, then click Request Price Increase Consent.\n\nVerify that the price increase consent sheet displays in your app.\n\nOn the price increase consent sheet in the app, select the Agree to New Price button to test a user consenting to the price increase, or select Close to test the user not giving consent for the price increase.\n\nFor information about testing price increase consent in an automated test suite, see requestPriceIncreaseConsentForTransaction(identifier:), consentToPriceIncreaseForTransaction(identifier:), and declinePriceIncreaseForTransaction(identifier:).\n\nSee Also\nTesting in-app purchases\nTesting at all stages of development with Xcode and the sandbox\nVerify your implementation of in-app purchases by testing your code throughout its development.\nSetting up StoreKit Testing in Xcode\nPrepare your test environment to test in-app purchases with data you configure locally.\nTesting in-app purchases with sandbox\nTest your implementation of in-app purchases using real product information and server-to-server transactions in the sandbox environment."
  },
  {
    "title": "SKError.Code.unknown",
    "url": "https://developer.apple.com/documentation/storekit/skerror/code/unknown",
    "html": "Discussion\n\nFor more information about the underlying cause of the error, see the localizedDescription property of the error object.\n\nRetrying may resolve this error in some instances."
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954475-contains",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n\nSee Also\nFinding messages\nfunc allSatisfy((Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(where: (Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Message) -> Bool) -> Message?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Message, Message) -> Bool) -> Message?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Message, Message) -> Bool) -> Message?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/4115007",
    "html": "See Also\nComparing promotion info\nstatic func != (Product.PromotionInfo, Product.PromotionInfo) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo/4115006",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing promotion info\nstatic func == (Product.PromotionInfo, Product.PromotionInfo) -> Bool\nReturns a Boolean value that indicates whether two values are equal."
  },
  {
    "title": "SKANError.Code.invalidAdvertisedAppId",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/invalidadvertisedappid",
    "html": "Discussion\n\nAd networks provide an advertised app identifier when signing an ad impression. If you’re providing a StoreKit-rendered ad, check that the value you set for SKStoreProductParameterITunesItemIdentifier in loadProduct(withParameters:completionBlock:) is a valid app identifer. If you’re providing a view-through ad, check the value of advertisedAppStoreItemIdentifier.\n\nSee Also\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase impressionTooShort\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unknown\nAn unknown error occurred.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "SKANError.Code.invalidCampaignId",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/invalidcampaignid",
    "html": "Discussion\n\nCheck that the campaign identifier is a valid value. For more information, see SKStoreProductParameterAdNetworkCampaignIdentifier for StoreKit-rendered ads, and adCampaignIdentifier for view-through ads.\n\nSee Also\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase impressionTooShort\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unknown\nAn unknown error occurred.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "SKANError.Code.invalidSourceAppId",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/invalidsourceappid",
    "html": "Discussion\n\nCheck that the value you provide for SKStoreProductParameterAdNetworkSourceAppStoreIdentifier or sourceAppStoreItemIdentifier is correct and matches the App Store ID of the app that’s displaying the ad.\n\nSee Also\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase impressionTooShort\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unknown\nAn unknown error occurred.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "Product.SubscriptionInfo.RenewalInfo",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalinfo",
    "html": "Overview\n\nThe Product.SubscriptionInfo.RenewalInfo provides information about the next subscription renewal period.\n\nTopics\nGetting the environment\nlet environment: AppStore.Environment\nThe server environment that signs the renewal information for an auto-renewable subscription.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var environmentStringRepresentation: String\nThe string representation of the server environment that signs the renewal information for an auto-renewable subscription.\nDeprecated\nGetting the transaction ID\nlet originalTransactionID: UInt64\nThe transaction identifier of the original purchase.\nGetting the product ID\nlet currentProductID: String\nThe subscription product ID that the customer is subscribed to.\nGetting subscription offers\nlet offerID: String?\nA string that identifies an offer applied to the next subscription period.\nlet offerType: Transaction.OfferType?\nThe subscription offer type for the next subscription period.\nGetting subscription start date\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var recentSubscriptionStartDate: Date\nThe earliest start date of a subscription in a series of auto-renewable subscription purchases that ignores all lapses of paid service shorter than 60 days.\nGetting the renewal or expiration state\nlet state: Product.SubscriptionInfo.RenewalState\nThe renewal state of the auto-renewable subscription.\nlet autoRenewPreference: String?\nThe product ID of the auto-renewable subscription that will automatically renew.\nlet willAutoRenew: Bool\nA Boolean value that indicates whether the subscription will automatically renew in the next period.\nlet expirationReason: Product.SubscriptionInfo.RenewalInfo.ExpirationReason?\nThe reason the auto-renewable subscription expired.\nstruct Product.SubscriptionInfo.RenewalInfo.ExpirationReason\nThe reasons for auto-renewable subscription expirations.\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var renewalDate: Date?\nThe UNIX time, in milliseconds, that the most recent auto-renewable subscription purchase expires.\nGetting billing status\nlet isInBillingRetry: Bool\nA Boolean value that indicates whether an auto-renewable subscription is in the billing retry period.\nlet gracePeriodExpirationDate: Date?\nThe date the billing grace period expires for the auto-renewable subscription.\nGetting the price increase status\nManaging Price Increases for Auto-Renewable Subscriptions\nIdentify the price increase status for auto-renewable subscriptions, in your app and on your server.\nlet priceIncreaseStatus: Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus\nThe status that indicates whether the auto-renewable subscription is subject to a price increase.\nenum Product.SubscriptionInfo.RenewalInfo.PriceIncreaseStatus\nStatus values that indicate whether an auto-renewable subscription is subject to a price increase.\nVerifying subscription renewal information\nlet deviceVerification: Data\nThe device verification value to use to verify whether the renewal information belongs to the device.\nlet deviceVerificationNonce: UUID\nThe UUID to use to compute the device verification value.\nlet signedDate: Date\nThe date that the App Store signed the JWS renewal information.\nGetting subscription renewal info in JSON format\nvar jsonRepresentation: Data\nThe raw JSON representation of the subscription renewal information.\nGetting a debug description\nvar debugDescription: String\nA string representation of the renewal info, suitable for debugging.\nComparing and hashing renewal information\nstatic func != (Product.SubscriptionInfo.RenewalInfo, Product.SubscriptionInfo.RenewalInfo) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo.RenewalInfo, Product.SubscriptionInfo.RenewalInfo) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nCustomDebugStringConvertible\nHashable\nSee Also\nGetting subscription status information\nlet state: Product.SubscriptionInfo.RenewalState\nThe renewal state of the auto-renewable subscription.\nlet renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>\nThe signed renewal information for the auto-renewable subscription.\nlet transaction: VerificationResult<Transaction>\nThe latest transaction for the subscription group.\nstruct Product.SubscriptionInfo.RenewalState\nThe renewal states of auto-renewable subscriptions."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/3791926",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing status\nstatic func == (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "state",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/3749528-state",
    "html": "See Also\nGetting subscription status information\nlet renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>\nThe signed renewal information for the auto-renewable subscription.\nlet transaction: VerificationResult<Transaction>\nThe latest transaction for the subscription group.\nstruct Product.SubscriptionInfo.RenewalInfo\nThe renewal information for an auto-renewable subscription.\nstruct Product.SubscriptionInfo.RenewalState\nThe renewal states of auto-renewable subscriptions."
  },
  {
    "title": "transaction",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/3822295-transaction",
    "html": "See Also\nGetting subscription status information\nlet state: Product.SubscriptionInfo.RenewalState\nThe renewal state of the auto-renewable subscription.\nlet renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>\nThe signed renewal information for the auto-renewable subscription.\nstruct Product.SubscriptionInfo.RenewalInfo\nThe renewal information for an auto-renewable subscription.\nstruct Product.SubscriptionInfo.RenewalState\nThe renewal states of auto-renewable subscriptions."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/3868414-hash",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nError Comparisons\nstatic func != (VerificationResult<SignedType>.VerificationError, VerificationResult<SignedType>.VerificationError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (VerificationResult<SignedType>.VerificationError, VerificationResult<SignedType>.VerificationError) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "VerificationResult.VerificationError.missingRequiredProperties",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/missingrequiredproperties",
    "html": "See Also\nError Codes\ncase invalidCertificateChain\nAn error indicating that the certificate chain is invalid.\ncase invalidDeviceVerification\nAn error that indicates the signed value wasn’t generated for the current device.\ncase invalidEncoding\nAn error that indicates the signature, certificate chain, or other part of value uses invalid encoding.\ncase invalidSignature\nAn error that indicates that the signature didn’t match the header and payload.\ncase revokedCertificate\nAn error that indicates the certificate chain includes a revoked certificate."
  },
  {
    "title": "VerificationResult.VerificationError.invalidCertificateChain",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/invalidcertificatechain",
    "html": "Discussion\n\nThis error may occur if one or more certificates in the certiificate chain are expired or from an untrusted source.\n\nSee Also\nError Codes\ncase invalidDeviceVerification\nAn error that indicates the signed value wasn’t generated for the current device.\ncase invalidEncoding\nAn error that indicates the signature, certificate chain, or other part of value uses invalid encoding.\ncase invalidSignature\nAn error that indicates that the signature didn’t match the header and payload.\ncase missingRequiredProperties\nAn error that indicates the header or payload are missing information that’s required to verify the signature.\ncase revokedCertificate\nAn error that indicates the certificate chain includes a revoked certificate."
  },
  {
    "title": "VerificationResult.VerificationError.invalidEncoding",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/invalidencoding",
    "html": "See Also\nError Codes\ncase invalidCertificateChain\nAn error indicating that the certificate chain is invalid.\ncase invalidDeviceVerification\nAn error that indicates the signed value wasn’t generated for the current device.\ncase invalidSignature\nAn error that indicates that the signature didn’t match the header and payload.\ncase missingRequiredProperties\nAn error that indicates the header or payload are missing information that’s required to verify the signature.\ncase revokedCertificate\nAn error that indicates the certificate chain includes a revoked certificate."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/3868412",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nError Comparisons\nstatic func == (VerificationResult<SignedType>.VerificationError, VerificationResult<SignedType>.VerificationError) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "helpAnchor",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/3921254-helpanchor",
    "html": "See Also\nError Description\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA localized message describing the reason for the failure.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "errorDescription",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/3921252-errordescription",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nError Description\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar failureReason: String?\nA localized message describing the reason for the failure.\nvar helpAnchor: String?\nA message providing “help” text if the user requests help by pressing an alert panel help anchor button.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/3868413",
    "html": "See Also\nError Comparisons\nstatic func != (VerificationResult<SignedType>.VerificationError, VerificationResult<SignedType>.VerificationError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "VerificationResult.VerificationError.invalidSignature",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/invalidsignature",
    "html": "See Also\nError Codes\ncase invalidCertificateChain\nAn error indicating that the certificate chain is invalid.\ncase invalidDeviceVerification\nAn error that indicates the signed value wasn’t generated for the current device.\ncase invalidEncoding\nAn error that indicates the signature, certificate chain, or other part of value uses invalid encoding.\ncase missingRequiredProperties\nAn error that indicates the header or payload are missing information that’s required to verify the signature.\ncase revokedCertificate\nAn error that indicates the certificate chain includes a revoked certificate."
  },
  {
    "title": "recoverySuggestion",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/3921255-recoverysuggestion",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nError Description\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA localized message describing the reason for the failure.\nvar helpAnchor: String?\nA message providing “help” text if the user requests help by pressing an alert panel help anchor button."
  },
  {
    "title": "failureReason",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/3921253-failurereason",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nError Description\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar helpAnchor: String?\nA message providing “help” text if the user requests help by pressing an alert panel help anchor button.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "VerificationResult.VerificationError.invalidDeviceVerification",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror/invaliddeviceverification",
    "html": "See Also\nError Codes\ncase invalidCertificateChain\nAn error indicating that the certificate chain is invalid.\ncase invalidEncoding\nAn error that indicates the signature, certificate chain, or other part of value uses invalid encoding.\ncase invalidSignature\nAn error that indicates that the signature didn’t match the header and payload.\ncase missingRequiredProperties\nAn error that indicates the header or payload are missing information that’s required to verify the signature.\ncase revokedCertificate\nAn error that indicates the certificate chain includes a revoked certificate."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954489-flatmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncThrowingMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc reduce<Result>(Result, (Result, Message) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "reduce(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954504-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncThrowingMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "SKDownload",
    "url": "https://developer.apple.com/documentation/storekit/skdownload",
    "html": "Overview\n\nWhen you create a product in App Store Connect, you can associate one or more pieces of downloadable content with it. At runtime, when a product is purchased by a user, your app uses SKDownload objects to download the content from the App Store.\n\nYour app never directly creates a SKDownload object. Instead, after a payment is processed, your app reads the transaction object’s downloads property to retrieve an array of SKDownload objects associated with the transaction.\n\nTo download the content, you queue a download object on the payment queue and wait for the content to be downloaded. After a download completes, read the download object’s contentURL property to get a URL to the downloaded content. Your app must process the downloaded file before completing the transaction. For example, it might copy the file into a directory whose contents are persistent. When all downloads are complete, you finish the transaction. After the transaction is finished, the download objects cannot be queued to the payment queue and any URLs to the downloaded content are invalid.\n\nTopics\nGetting Content Information\nvar expectedContentLength: Int64\nThe length of the downloadable content, in bytes.\nvar contentIdentifier: String\nA string that uniquely identifies the downloadable content.\nvar contentVersion: String\nA string that identifies which version of the content is available for download.\nvar transaction: SKPaymentTransaction\nThe transaction associated with the downloadable file.\nvar contentLength: Int64\nThe length of the downloadable content, in bytes.\nGetting State Information\nvar state: SKDownloadState\nThe current state of the download object.\nvar progress: Float\nA value that indicates how much of the file has been downloaded.\nvar timeRemaining: TimeInterval\nAn estimated time, in seconds, to finish downloading the content.\nvar SKDownloadTimeRemainingUnknown: TimeInterval\nIndicates that the system cannot determine how much time is needed to finish downloading the content.\nenum SKDownloadState\nThe states that a download operation can be in.\nvar downloadState: SKDownloadState\nThe current state of the download object.\nAccessing a Completed Download\nvar error: (any Error)?\nThe error that prevented the content from being downloaded.\nvar contentURL: URL?\nThe local location of the downloaded file.\nManaging Downloaded Content\nclass func contentURL(forProductID: String) -> URL?\nReturns the local location for the previously downloaded flie.\nclass func deleteContent(forProductID: String)\nDeletes the previously downloaded file.\nRelationships\nInherits From\nNSObject\nSee Also\nContent delivery\nUnlocking purchased content\nDeliver content to the user after validating the purchase.\nPersisting a purchase\nKeep a persistent record of a purchase to continue making the product available as needed.\nFinishing a transaction\nFinish the transaction to complete the purchase process."
  },
  {
    "title": "Finishing a transaction",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/finishing_a_transaction",
    "html": "Overview\n\nFinishing a transaction tells StoreKit that your app completed its workflow to make a purchase complete. Unfinished transactions remain in the queue until they’re finished, so be sure to add the transaction queue observer every time your app launches, to enable your app to finish the transactions. Your app needs to finish each transaction, whether it succeeds or fails.\n\nDo all of the following before you finish a transaction:\n\nPersist the purchase.\n\nDeliver, download, or unlock the purchased content.\n\nUpdate your app’s UI so the user can access the product.\n\nTo finish the transaction, call the finishTransaction(_:) method on the payment queue.\n\nlet transaction: SKPaymentTransaction = <# The current transaction #>\nSKPaymentQueue.default().finishTransaction(transaction)\n\n\nAfter you finish a transaction, don’t take any actions on it or do any work to deliver the product. If any work remains, your app isn’t ready to finish the transaction.\n\nImportant\n\nDon’t call the finishTransaction(_:) method before the transaction is actually complete and attempt to use some other mechanism in your app to track the transaction as unfinished. StoreKit doesn’t function that way, and doing that prevents your app from downloading Apple-hosted content and can lead to other issues.\n\nSee Also\nContent delivery\nUnlocking purchased content\nDeliver content to the user after validating the purchase.\nPersisting a purchase\nKeep a persistent record of a purchase to continue making the product available as needed.\nclass SKDownload\nDownloadable content associated with a product.\nDeprecated"
  },
  {
    "title": "SKReceiptRefreshRequest",
    "url": "https://developer.apple.com/documentation/storekit/skreceiptrefreshrequest",
    "html": "Overview\n\nNote\n\nThe receipt isn’t necessary if you use AppTransaction to validate the app download, or Transaction to validate in-app purchases. Only use the receipt if your app uses the Original API for in-app purchase, or needs the receipt to validate the app download because it can’t use AppTransaction.\n\nUse this API to request a new app receipt from the App Store if the receipt is invalid or missing from its expected location, appStoreReceiptURL. To request the receipt using the SKReceiptRefreshRequest object, you initialize it, attach a delegate, and then call the request’s start() method.\n\nImportant\n\nThe receipt refresh request displays a system prompt that asks users to authenticate with their App Store credentials. For a better user experience, initiate the request after an explicit user action, like tapping or clicking a button.\n\nWhen the request completes successfully, your delegate receives an SKReceiptRefreshRequest object in its requestDidFinish(_:) method. Locate the app receipt using the appStoreReceiptURL property. For information about validating the receipt, see Choosing a receipt validation technique.\n\nIf the request fails and calls your delegate’s request(_:didFailWithError:) method, your app needs to release the request and not attempt to call it a second time. Requests can fail when a user doesn’t authenticate or chooses to cancel the request. Without a validated receipt, assume the user doesn’t have access to premium content.\n\nIn the sandbox environment, you can initialize a receipt with any combination of properties for testing when you call init(receiptProperties:).\n\nUse alternative techniques\n\nThere are times when using SKReceiptRefreshRequest isn’t necessary, so avoid doing so, such as in the following scenarios:\n\nIf the receipt is valid, but may be missing transactions, use restoreCompletedTransactions() instead. For example, the receipt may be missing a transaction if a person purchases a new subscription on another device.\n\nIn the sandbox environment, before the tester completes their first in-app purchase. Receipts are initially absent in the sandbox environment for iOS and iPadOS apps. For more information, see appStoreReceiptURL.\n\nTopics\nInitializing Receipt Refresh Requests\ninit(receiptProperties: [String : Any]?)\nCreates a receipt refresh request with optional properties.\nReceipt Properties and Keys\nvar receiptProperties: [String : Any]?\nThe properties of the receipt.\nlet SKReceiptPropertyIsExpired: String\nA key with a value that indicates whether the receipt is in an expired state.\nlet SKReceiptPropertyIsRevoked: String\nA key with a value that indicates whether the receipt is in a revoked state.\nlet SKReceiptPropertyIsVolumePurchase: String\nA key with a value that indicates whether the receipt is a Volume Purchase Plan receipt.\nRelationships\nInherits From\nSKRequest\nSee Also\nProviding access to previously purchased products\nRestoring purchased products\nGive users functionality that restores their purchases in your app to maintain access to purchased content.\nclass SKRequest\nAn abstract class that represents a request to the App Store.\nclass SKPaymentTransaction\nAn object in the payment queue.\nfunc SKTerminateForInvalidReceipt()\nTerminates an app if the license to use the app has expired."
  },
  {
    "title": "Validating receipts with the App Store",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/validating_receipts_with_the_app_store",
    "html": "Overview\n\nImportant\n\nThe verifyReceipt endpoint is deprecated. To validate receipts on your server, follow the steps in Validating receipts on the device on your server. To validate in-app purchases on your server without using receipts, call the App Store Server API to get Apple-signed transaction and subscription information for your customers, or verify the AppTransaction and Transaction signed data that your app obtains. You can also get the same signed transaction and subscription information from the App Store Server Notifications V2.\n\nAn App Store receipt is a binary encrypted file signed with an Apple certificate. To read the contents of the encrypted file, you need to pass it through the verifyReceipt endpoint. The endpoint’s response includes a readable JSON body. Communication with the App Store is structured as JSON dictionaries, as defined in RFC 4627. Binary data is Base64-encoded, as defined in RFC 4648. Validate receipts with the App Store through a secure server. For information on establishing a secure network connection with the App Store, see Preventing Insecure Network Connections.\n\nWarning\n\nDon’t call the App Store server verifyReceipt endpoint from your app. You can’t build a trusted connection between a user’s device and the App Store directly because you don’t control either end of that connection, which makes it susceptible to a machine-in-the-middle attack.\n\nFetch the receipt data\n\nThe app receipt is always present in the production environment on devices running macOS, iOS, and iPadOS. The app receipt is also always present in TestFlight on devices running macOS. In the sandbox environment and in StoreKit Testing in Xcode, the app receipt is present only after the tester makes the first in-app purchase. If the app calls SKReceiptRefreshRequest or restoreCompletedTransactions(), the app receipt is present only if the app has at least one in-app purchase.\n\nTo retrieve the receipt data from the app on the device, use the appStoreReceiptURL method of Bundle to locate the app’s receipt, and encode the data in Base64. Send this Base64-encoded data to your server.\n\n// Get the receipt if it's available.\nif let appStoreReceiptURL = Bundle.main.appStoreReceiptURL,\n    FileManager.default.fileExists(atPath: appStoreReceiptURL.path) {\n\n\n    do {\n        let receiptData = try Data(contentsOf: appStoreReceiptURL, options: .alwaysMapped)\n        print(receiptData)\n\n\n        let receiptString = receiptData.base64EncodedString(options: [])\n\n\n        // Read receiptData.\n    }\n    catch { print(\"Couldn't read receipt data with error: \" + error.localizedDescription) }\n}\n\n\nSend the receipt data to the App Store\n\nOn your server, create a JSON object with the receipt-data, password, and exclude-old-transactions keys detailed in requestBody.\n\nSubmit this JSON object as the payload of an HTTP POST request. Use the test environment URL https://sandbox.itunes.apple.com/verifyReceipt when testing your app in the sandbox and while your app is in review. Use the production URL https://buy.itunes.apple.com/verifyReceipt when your app is live in the App Store. For more information, see verifyReceipt.\n\nImportant\n\nVerify your receipt first with the production URL; then verify with the sandbox URL if you receive a 21007 status code. This approach ensures you don’t have to switch between URLs while your app is in testing, in review by App Review, or live in the App Store.\n\nParse the response\n\nThe App Store’s response payload is a JSON object that contains the keys and values detailed in responseBody.\n\nThe in_app array contains the non-consumable, non-renewing subscription, and auto-renewable subscription items that the user previously purchased. Check the values in the response for these in-app purchase types to verify transactions as needed.\n\nFor auto-renewable subscription items, parse the response to get information about the currently active subscription period. When you validate the receipt for a subscription, latest_receipt contains the latest encoded receipt, which is the same as the value for receipt-data in the request, and latest_receipt_info contains all the transactions for the subscription, including the initial purchase and subsequent renewals, but not including any restores.\n\nYou can use these values to check whether an auto-renewable subscription has expired. Use these values along with the expiration_intent subscription field to get the reason for expiration.\n\nSee Also\nPurchase validation\nChoosing a receipt validation technique\nSelect the type of receipt validation, on the device or on your server, that works for your app.\nvar appStoreReceiptURL: URL?\nThe file URL for the bundle’s App Store receipt.\nclass SKReceiptRefreshRequest\nA request to the App Store to get the app receipt, which represents the user’s transactions with your app.\nRelated Documentation\nApp Store Receipts\nValidate app and in-app purchase receipts with the App Store."
  },
  {
    "title": "Choosing a receipt validation technique",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/choosing_a_receipt_validation_technique",
    "html": "Overview\n\nNote\n\nThe receipt isn’t necessary if you use AppTransaction to validate the app download, or Transaction to validate in-app purchases. Only use the receipt if your app uses the Original API for in-app purchase, or needs the receipt to validate the app download because it can’t use AppTransaction.\n\nAn App Store receipt provides a record of the sale of an app and any purchases the person makes within the app. You can authenticate purchased content by adding receipt validation code to your app or server. Receipt validation requires an understanding of secure coding techniques to employ a solution that’s secure and unique to your app.\n\nChoose a validation technique\n\nThere are two ways to verify a receipt’s authenticity:\n\nLocally, on the device. Validating receipts locally requires code that reads and validates a binary file that Apple encodes and signs as a PKCS #7 container. For more information, see Validating receipts on the device.\n\nOn your server with the App Store. Validating receipts with the App Store requires secure connections between your app and your server, and between your server and the App Store. For more information, see Validating receipts with the App Store.\n\nCompare the approaches and determine the method that best fits your app and your infrastructure. You can also choose to implement both approaches. For managing auto-renewable subscriptions, see the following table for the key advantages that server-side receipt validation provides over on-device receipt validation:\n\nCapability\n\n\t\n\nOn-device validation\n\n\t\n\nServer-side validation\n\n\n\n\nValidates authenticity of receipt\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nIncludes subscription renewal transactions\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nIncludes additional subscription information\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nResistant to device clock change\n\n\t\n\nNo\n\n\t\n\nYes\n\nReceipts contain non-consumable in-app purchases, auto-renewable subscriptions, and non-renewing subscriptions indefinitely. Consumable in-app purchases remain in the receipt until you call finishTransaction(_:). You may choose to maintain and manage records of consumable in-app purchases on your server.\n\nGet the latest receipt\n\nThe App Store updates receipts immediately after completed purchases. When you call verifyReceipt from your server, the App Store returns the latest transaction information, regardless of the contents of the receipt you send in the request.\n\nOn the device, the system updates the receipt immediately when it has an internet connection, and any of the following occur:\n\nThe customer completes an in-app purchase.\n\nThe app launches its transaction observer (SKPaymentTransactionObserver) and has unfinished transactions or subscription renewals.\n\nThe app calls restoreCompletedTransactions() or restoreCompletedTransactions(withApplicationUsername:) to restore transactions.\n\nThe app sends a request to SKReceiptRefreshRequest to get a receipt if the receipt is invalid or missing.\n\nTransactions can also occur at times when the app isn’t running. When necessary, call restoreCompletedTransactions() to ensure the receipt you’re working with is up-to-date. For example, if a customer purchases an auto-renewable subscription on another device, call this method to get those transactions and update the receipt.\n\nTo ensure that your app receives all transactions, add the transaction observer, add(_:), at app launch time. For more information, see Setting up the transaction observer for the payment queue.\n\nRelated Sessions from WWDC 2018\n\nSession 705: Engineering Subscriptions\n\nSee Also\nPurchase validation\nValidating receipts with the App Store\nVerify transactions with the App Store on a secure server.\nvar appStoreReceiptURL: URL?\nThe file URL for the bundle’s App Store receipt.\nclass SKReceiptRefreshRequest\nA request to the App Store to get the app receipt, which represents the user’s transactions with your app."
  },
  {
    "title": "Persisting a purchase",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/persisting_a_purchase",
    "html": "Overview\n\nAfter making a product available, your app needs to make a persistent record of the purchase. Your app uses that persistent record to continue making the product available on launch and to restore purchases. Your app’s persistence strategy depends on the type of products you sell:\n\nFor non-consumable products and auto-renewable subscriptions, use the app receipt as your persistent record. If the app receipt isn’t available, use the user defaults system or iCloud to keep a persistent record.\n\nFor non-renewing subscriptions, use iCloud or your own server to keep a persistent record.\n\nFor consumable products, your app updates its internal state to reflect the purchase. Ensure that the updated state is part of an object that supports state preservation (in iOS) or that you manually preserve the state across app launches (in iOS or macOS).\n\nWhen using the user defaults system or iCloud, your app can store a value, such as a number or Boolean value, or a copy of the transaction receipt. In macOS, users can edit the user defaults system using the defaults command. Storing a receipt requires more application logic, but protects the persistent record from tampering.\n\nNote\n\nWhen persisting with iCloud, your app’s persistent record syncs across devices, but your app is responsible for downloading any associated content on other devices.\n\nPersist purchases using the app receipt\n\nThe app receipt contains a record of the user’s purchases, cryptographically signed by Apple. For more information, see Choosing a receipt validation technique.\n\nThe system adds information about consumable products to the receipt when the user purchases them, and it remains in the receipt until you finish the transaction. After you finish the transaction, the system removes this information the next time it updates the receipt, such as the next time the user makes a purchase.\n\nThe system adds information about all other kinds of purchases to the receipt when the user purchases the products, and it remains in the receipt indefinitely.\n\nPersist a value in user defaults or iCloud\n\nTo store information in user defaults or iCloud, set the value for a key.\n\n#if USE_ICLOUD_STORAGE\nlet storage = NSUbiquitousKeyValueStore.default\n#else\nlet storage = UserDefaults.standard\n#endif\n\n\nstorage.set(true, forKey: \"enable_rocket_car\")\nstorage.set(highestUnlockedLevel, forKey: \"highest_unlocked_level\")\n\n\n\n\nPersist purchases using your own server\n\nSend a copy of the receipt to your server, along with credentials or an identifier, so you can keep track of which receipts belong to a particular user. For example, let users identify themselves to your server with a user name and password. Don’t use the identifierForVendor property of UIDevice. Different devices have different values for this property, so you can’t use it to identify and restore purchases that the same user makes on a different device.\n\nSee Also\nContent delivery\nUnlocking purchased content\nDeliver content to the user after validating the purchase.\nFinishing a transaction\nFinish the transaction to complete the purchase process.\nclass SKDownload\nDownloadable content associated with a product.\nDeprecated"
  },
  {
    "title": "Processing a transaction",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/processing_a_transaction",
    "html": "Overview\n\nImplementing an in-app purchase flow consists of three stages. In the first stage, your app retrieves product information. Then your app requests payment when the user selects a product in your app’s store. Finally, your app delivers the product.\n\nThe App Store calls the transaction queue observer after it processes the payment request. Your app then records information about the purchase for future launches, downloads the purchased content, and marks the transaction as finished.\n\nMonitor transactions in the queue\n\nThe transaction queue plays a central role in letting your app communicate with the App Store through the StoreKit framework. You add work to the queue that the App Store needs to act on, such as a payment request for processing. When the transaction’s state changes, such as when a payment request succeeds, StoreKit calls the app’s transaction queue observer. You decide which class acts as the observer. In very small apps, you might handle all the StoreKit logic in the app delegate, including observing the transaction queue. In most apps, however, you create a separate class that handles this observer logic, along with the rest of your app’s store logic. The observer needs to conform to the SKPaymentTransactionObserver protocol.\n\nBy adding an observer, your app doesn’t need to constantly poll the status of its active transactions. Your app uses the transaction queue for payment requests, to download Apple-hosted content, and to determine when subscriptions renew.\n\nIt’s important to register a transaction queue observer as soon as your app launches, as the code shows below. For more guidance, see Setting up the transaction observer for the payment queue.\n\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n    /* ... */\n    SKPaymentQueue.default().add(observer)\n    return true\n}\n\n\nMake sure that the observer is ready to handle a transaction at any time, not only after you add a transaction to the queue. For example, if a user buys something in your app just before entering a tunnel, your app may not be able to deliver the purchased content if there isn't a network connection. The next time your app launches, StoreKit calls your transaction queue observer again so your app can handle the transaction and deliver the purchased content. Similarly, if your app fails to mark a transaction as finished, StoreKit calls the observer every time your app launches until the transaction finishes.\n\nImplement the paymentQueue(_:updatedTransactions:) method on your transaction queue observer. StoreKit calls this method when the status of a transaction changes, such as when a payment request has been processed. The transaction status tells you what action your app needs to perform, as described in the table below:\n\nStatus\n\n\t\n\nAction to take in your app\n\n\n\n\nSKPaymentTransactionState.purchasing\n\n\t\n\nUpdate your UI to reflect the in-progress status, and wait for StoreKit to call the method again.\n\n\n\n\nSKPaymentTransactionState.deferred\n\n\t\n\nUpdate your UI to reflect the deferred status, and wait for StoreKit to call the method again.\n\n\n\n\nSKPaymentTransactionState.failed\n\n\t\n\nUse the value of the error property to present a message to the user. For a list of error constants, see SKErrorDomain.\n\n\n\n\nSKPaymentTransactionState.purchased\n\n\t\n\nProvide the purchased functionality, typically by unlocking features or delivering content.\n\n\n\n\nSKPaymentTransactionState.restored\n\n\t\n\nRestore the previously purchased functionality.\n\nTransactions in the queue can change state in any order. Your app needs to be ready to work on any active transaction at any time. Act on every transaction according to its transaction state, as in this example:\n\nfunc paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {\n     for transaction in transactions {\n     switch transaction.transactionState {\n          // Call the appropriate custom method for the transaction state.\n     case .purchasing: showTransactionAsInProgress(transaction, deferred: false)\n     case .deferred: showTransactionAsInProgress(transaction, deferred: true)\n     case .failed: failedTransaction(transaction)\n          case .purchased: completeTransaction(transaction)\n     case .restored: restoreTransaction(transaction)\n          // For debugging purposes.\n     @unknown default: print(\"Unexpected transaction state \\(transaction.transactionState)\")\n    }\n     }\n}\n\n\nUpdate the app's UI to reflect transaction changes\n\nTo keep your user interface up to date while waiting, the transaction queue observer can implement optional methods from the SKPaymentTransactionObserver protocol as follows:\n\nStoreKit calls the paymentQueue(_:removedTransactions:) method when it removes transactions from the queue. In your implementation of this method, remove the corresponding items from your app’s UI.\n\nStoreKit calls the paymentQueueRestoreCompletedTransactionsFinished(_:) or paymentQueue(_:restoreCompletedTransactionsFailedWithError:) methods when it finishes restoring transactions, depending on whether there is an error. In your implementation of these methods, update your app’s UI to reflect the success or failure.\n\nFor successfully processed transactions, validate the receipt associated with the transaction to verify the items the user purchased, and unlock content accordingly. For more information on validating receipts serverside, see Validating receipts with the App Store.\n\nSee Also\nPurchases\nRequesting a payment from the App Store\nSubmit a payment request to the App Store when a user selects a product to buy.\nclass SKPayment\nA request to the App Store to process payment for additional functionality that your app offers.\nclass SKMutablePayment\nA mutable request to the App Store to process payment for additional functionality that your app offers.\nclass SKPaymentTransaction\nAn object in the payment queue."
  },
  {
    "title": "SKPayment",
    "url": "https://developer.apple.com/documentation/storekit/skpayment",
    "html": "Overview\n\nA payment object identifies a product and the quantity of those items the user would like to purchase.\n\nTopics\nCreating Payments\ninit(product: SKProduct)\nReturns a new payment for the specified product.\nGetting Payment Details\nvar productIdentifier: String\nA string used to identify a product that can be purchased from within your app.\nvar quantity: Int\nThe number of items the user wants to purchase.\nvar requestData: Data?\nReserved for future use.\nvar applicationUsername: String?\nA string that associates the transaction with a user account on your service.\nSimulating Purchases for Testing\nvar simulatesAskToBuyInSandbox: Bool\nA Boolean value that produces an \"ask to buy\" flow for this payment in the sandbox.\nGetting Discount Details\nvar paymentDiscount: SKPaymentDiscount?\nThe details of the discount offer to apply to the payment.\nclass SKPaymentDiscount\nThe signed discount to apply to a payment.\nRelationships\nInherits From\nNSObject\nConforms To\nNSCopying\nNSMutableCopying\nSee Also\nPurchases\nRequesting a payment from the App Store\nSubmit a payment request to the App Store when a user selects a product to buy.\nProcessing a transaction\nRegister a transaction queue observer to get and handle transaction updates from the App Store.\nclass SKMutablePayment\nA mutable request to the App Store to process payment for additional functionality that your app offers.\nclass SKPaymentTransaction\nAn object in the payment queue."
  },
  {
    "title": "SKMutablePayment",
    "url": "https://developer.apple.com/documentation/storekit/skmutablepayment",
    "html": "Overview\n\nA mutable payment object identifies a product and the quantity of that item the user would like to purchase.\n\nWhen a mutable payment is added to the payment queue, the payment queue copies the contents into an immutable request before queueing the request. Your app can safely change the contents of the mutable payment object.\n\nTopics\nGetting and Setting Attributes\nvar productIdentifier: String\nA string that identifies a product that can be purchased from within your app.\nvar quantity: Int\nThe number of items the user wants to purchase.\nvar requestData: Data?\nReserved for future use.\nvar applicationUsername: String?\nA string that associates the transaction with a user account on your service.\nSimulating Buy for Testing\nvar simulatesAskToBuyInSandbox: Bool\nA Boolean value that produces an “ask to buy” flow for this payment in the sandbox.\nGetting and Setting Discount Details\nvar paymentDiscount: SKPaymentDiscount?\nThe details of the discount offer to apply to the payment.\nRelationships\nInherits From\nSKPayment\nSee Also\nPurchases\nRequesting a payment from the App Store\nSubmit a payment request to the App Store when a user selects a product to buy.\nProcessing a transaction\nRegister a transaction queue observer to get and handle transaction updates from the App Store.\nclass SKPayment\nA request to the App Store to process payment for additional functionality that your app offers.\nclass SKPaymentTransaction\nAn object in the payment queue."
  },
  {
    "title": "SKPaymentTransaction",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransaction",
    "html": "Overview\n\nA payment transaction is created whenever a payment is added to the payment queue. The system delivers transactions to your app when the App Store finishes processing the payment. Completed transactions provide a receipt and transaction identifier that your app can use to save a permanent record of the processed payment.\n\nTopics\nGetting Transaction Information\nvar payment: SKPayment\nThe payment for the transaction.\nvar transactionIdentifier: String?\nA string that uniquely identifies a successful payment transaction.\nvar transactionDate: Date?\nThe date the transaction was added to the App Store’s payment queue.\nvar original: SKPaymentTransaction?\nThe transaction that was restored by the App Store.\nvar error: (any Error)?\nAn object describing the error that occurred while processing the transaction.\nvar transactionReceipt: Data?\nA signed receipt that records all information about a successful payment transaction.\nGetting Downloads\nvar downloads: [SKDownload]\nAn array of download objects representing the downloadable content associated with the transaction.\nDeprecated\nGetting Transaction State\nvar transactionState: SKPaymentTransactionState\nThe current state of the transaction.\nenum SKPaymentTransactionState\nValues representing the state of a transaction.\nRelationships\nInherits From\nNSObject\nConforms To\nSendable\nSee Also\nPurchases\nRequesting a payment from the App Store\nSubmit a payment request to the App Store when a user selects a product to buy.\nProcessing a transaction\nRegister a transaction queue observer to get and handle transaction updates from the App Store.\nclass SKPayment\nA request to the App Store to process payment for additional functionality that your app offers.\nclass SKMutablePayment\nA mutable request to the App Store to process payment for additional functionality that your app offers."
  },
  {
    "title": "SKProductsRequest",
    "url": "https://developer.apple.com/documentation/storekit/skproductsrequest",
    "html": "Overview\n\nYour app uses an SKProductsRequest object to present localized prices and other information to the user without having to maintain that list of product information itself.\n\nTo use an SKProductsRequest object, you initialize it with a list of product identifier strings, attach a delegate, and then call the request’s start() method. When the request completes, your delegate receives an SKProductsResponse object.\n\nNote\n\nBe sure to keep a strong reference to the request object; otherwise, the system might deallocate the request before it can complete.\n\nTopics\nInitializing a Products Request\ninit(productIdentifiers: Set<String>)\nInitializes the request with the set of product identifiers.\nSetting the Delegate\nvar delegate: (any SKProductsRequestDelegate)?\nThe delegate that receives the response of the app's products request.\nprotocol SKProductsRequestDelegate\nA set of methods the delegate implements so it receives the product information your app requests.\nRelationships\nInherits From\nSKRequest\nSee Also\nProduct information\nLoading in-app product identifiers\nLoad the unique identifiers for your in-app products to retrieve product information from the App Store.\nFetching product information from the App Store\nRetrieve up-to-date information about the products for sale in your app to display to your customers.\nclass SKProductsResponse\nAn App Store response to a request for information about a list of products.\nclass SKProduct\nInformation about a registered product in App Store Connect."
  },
  {
    "title": "Fetching product information from the App Store",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/fetching_product_information_from_the_app_store",
    "html": "Overview\n\nTo ensure your customers see only products that are available for them to purchase, query the App Store before displaying your app’s store UI. Compare the App Store’s list of product identifiers to your local product identifiers. To retrieve a list of your app’s product identifiers, see Loading in-app product identifiers.\n\nRequest product information\n\nTo query the App Store, create an SKProductsRequest and initialize it with a list of your product identifiers. Keep a strong reference to the request object; otherwise, the system might deallocate the request before it can complete.\n\nThe products request retrieves information about valid products, along with a list of invalid product identifiers, and then calls its delegate to process the result. The delegate needs to implement the SKProductsRequestDelegate protocol to handle the response from the App Store. Here’s a simple implementation of both pieces of code:\n\n// Keep a strong reference to the product request.\nvar request: SKProductsRequest!\n\n\nfunc validate(productIdentifiers: [String]) {\n     let productIdentifiers = Set(productIdentifiers)\n\n\n     request = SKProductsRequest(productIdentifiers: productIdentifiers)\n     request.delegate = self \n     request.start()\n}\n\n\nvar products = [SKProduct]()\n// Create the SKProductsRequestDelegate protocol method \n// to receive the array of products.\nfunc productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) {\n    if !response.products.isEmpty {\n       products = response.products\n       // Implement your custom method here.\n       displayStore(products)\n    }\n\n\n    for invalidIdentifier in response.invalidProductIdentifiers {\n       // Handle any invalid product identifiers as appropriate.\n    }\n}\n\n\nKeep a reference to the array of SKProduct objects that the delegate receives. Use these same product objects to create a payment request when a user purchases a product.\n\nIf the list of products you sell in your app is subject to change, such as when you add or remove a product from sale, consider creating a custom class that encapsulates a reference to the product object along with other information, such as pictures or descriptions that you fetch from your server. For more information on payment requests, see Requesting a payment from the App Store.\n\nTroubleshoot invalid product IDs\n\nInvalid product identifiers in the App Store response to your products request usually indicate an error in your app’s list of product identifiers. Invalid product identifiers may also indicate an incorrectly configured product in App Store Connect. Actionable UI and insightful logging can help you resolve this type of issue, as follows:\n\nIn production builds, display your app’s store UI and omit the invalid product.\n\nIn development builds, display an error to call attention to the issue.\n\nIn both production and development builds, use NSLog to write a message to the console to record the invalid identifier.\n\nIf your app fetches the list from your server, you can define a logging mechanism to let your app send the list of invalid identifiers back to your server.\n\nVerify that you have a signed Paid Applications Agreement for your developer account. For more information about this agreement, see Sign and update agreements.\n\nFor more information about troubleshooting invalid product identifiers, see invalidProductIdentifiers.\n\nSee Also\nProduct information\nLoading in-app product identifiers\nLoad the unique identifiers for your in-app products to retrieve product information from the App Store.\nclass SKProductsRequest\nAn object that can retrieve localized information from the App Store about a specified list of products.\nclass SKProductsResponse\nAn App Store response to a request for information about a list of products.\nclass SKProduct\nInformation about a registered product in App Store Connect."
  },
  {
    "title": "Loading in-app product identifiers",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/loading_in-app_product_identifiers",
    "html": "Overview\n\nImplementing an in-app purchase flow consists of three stages. In the first stage, your app retrieves product information. Then your app requests payment when the user selects a product in your app’s store. Finally, your app delivers the product.\n\nTo begin the purchase process, your app needs the product identifiers so it can retrieve information about the products from the App Store and present its store UI to the user. Every product you sell in your app has a unique product identifier. You provide this value in App Store Connect when you create a new in-app purchase product (see Create in-app purchases for more information). Your app uses these product identifiers to fetch information about products available for sale in the App Store, such as pricing, and to submit payment requests when users purchase those products.\n\nThere are several strategies for storing a list of product identifiers in your app, such as embedding them in the app bundle or storing them on your server. You can then retrieve the product identifiers by reading them locally in the app bundle or fetching them from your server. Choose the method that best serves your app’s needs.\n\nNote\n\nThere’s no runtime mechanism to fetch a list of the configured products in App Store Connect for a particular app. You’re responsible for managing your app’s list of products and providing that information to your app.\n\nRetrieve product IDs from the app bundle\n\nEmbed the product identifiers in your app bundle if:\n\nYour app has a fixed list of in-app purchase products. For example, apps with an in-app purchase to remove ads or unlock functionality can embed the product identifier list in the app bundle.\n\nYou expect users to update the app to see new in-app purchase products.\n\nThe app or product doesn’t require a server.\n\nInclude a property list file in your app bundle containing an array of product identifiers, such as the following:\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<array>\n    <string>com.example.level1</string>\n    <string>com.example.level2</string>\n    <string>com.example.rocket_car</string>\n</array>\n</plist>\n\n\nTo get product identifiers from the property list, locate the file in the app bundle and read it.\n\nguard let url = Bundle.main.url(forResource: \"product_ids\", withExtension: \"plist\") else { fatalError(\"Unable to resolve url for in the bundle.\") }\ndo {\n    let data = try Data(contentsOf: url)\n    let productIdentifiers = try PropertyListSerialization.propertyList(from: data, options: .mutableContainersAndLeaves, format: nil) as? [String]\n} catch let error as NSError {\n    print(\"\\(error.localizedDescription)\")\n}\n\n\nRetrieve product IDs from your server\n\nStore the product identifiers on your server if:\n\nYou update the list of in-app products frequently, without updating your app. For example, games that support additional levels or characters can fetch the product identifiers list from your server.\n\nThe products consist of delivered content.\n\nYour app or product requires a server.\n\nHost a JSON file on your server with the product identifiers. For example, the following JSON file contains three product IDs:\n\n[\n    \"com.example.level1\",\n    \"com.example.level2\",\n    \"com.example.rocket_car\"\n]\n\n\nTo get product identifiers from your server, fetch and read the JSON file.\n\nfunc fetchProductIdentifiers(from url: URL) {\n    DispatchQueue.global(qos: .default).async {\n        do {\n            let jsonData = try Data(contentsOf: url)\n            let identifiers = try JSONSerialization.jsonObject(with: jsonData, options: []) as? [String]\n\n\n            guard let productIdentifiers = identifiers else {fatalError(\"Identifiers are not of type String.\")}\n\n\n            DispatchQueue.main.async {\n                self.delegate?.display(products: productIdentifiers) \n            }\n\n\n        } catch let error as NSError {\n            print(\"\\(error.localizedDescription)\")\n        }\n    }\n}\n\n\nConsider versioning the JSON file so future versions of your app can change its structure without breaking older versions of your app. For example, you might name the file that uses the old structure products_v1.json and the file that uses a new structure products_v2.json. This is especially useful if your JSON file is more complex than the simple array in the example.\n\nTo ensure that your app remains responsive, use a background thread to download the JSON file and extract the list of product identifiers. To minimize the data that transfers, use standard HTTP caching mechanisms, such as the Last-Modified and If-Modified-Since headers.\n\nAfter loading all in-app product identifiers, pass them into the product information request to the App Store. For details on obtaining product information, see Fetching product information from the App Store.\n\nSee Also\nProduct information\nFetching product information from the App Store\nRetrieve up-to-date information about the products for sale in your app to display to your customers.\nclass SKProductsRequest\nAn object that can retrieve localized information from the App Store about a specified list of products.\nclass SKProductsResponse\nAn App Store response to a request for information about a list of products.\nclass SKProduct\nInformation about a registered product in App Store Connect."
  },
  {
    "title": "SKRequest",
    "url": "https://developer.apple.com/documentation/storekit/skrequest",
    "html": "Overview\n\nTo make a request, initialize a subclass of SKRequest—such as SKProductsRequest or SKReceiptRefreshRequest—set the delegate property, and call the start() method.\n\nTopics\nControlling the Request\nfunc start()\nSends the request to the Apple App Store.\nfunc cancel()\nCancels a previously started request.\nAccessing the Delegate\nvar delegate: (any SKRequestDelegate)?\nThe delegate of the request object.\nprotocol SKRequestDelegate\nCommon methods that are implemented by delegates for any subclass of the SKRequest abstract class.\nRelationships\nInherits From\nNSObject\nSee Also\nEssentials\nSetting up the transaction observer for the payment queue\nEnable your app to receive and handle transactions by adding an observer.\nOffering, completing, and restoring in-app purchases\nFetch, display, purchase, validate, and finish transactions in your app.\nclass SKPaymentQueue\nA queue of payment transactions for the App Store to process.\nprotocol SKPaymentTransactionObserver\nA set of methods that process transactions, unlock purchased functionality, and continue promoted in-app purchases.\nprotocol SKPaymentQueueDelegate\nThe protocol that provides information needed to complete transactions."
  },
  {
    "title": "SKPaymentQueueDelegate",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueuedelegate",
    "html": "Overview\n\nThis protocol includes a method that lets your app determine whether to continue a transaction if the customer’s App Store storefront changes.\n\nTopics\nContinuing transactions\nfunc paymentQueue(SKPaymentQueue, shouldContinue: SKPaymentTransaction, in: SKStorefront) -> Bool\nAsks the delegate whether to continue the transaction if the device’s App Store storefront changes during a transaction.\nShowing price consent\nfunc paymentQueueShouldShowPriceConsent(SKPaymentQueue) -> Bool\nAsks the delegate whether to immediately display a price consent sheet.\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nEssentials\nSetting up the transaction observer for the payment queue\nEnable your app to receive and handle transactions by adding an observer.\nOffering, completing, and restoring in-app purchases\nFetch, display, purchase, validate, and finish transactions in your app.\nclass SKPaymentQueue\nA queue of payment transactions for the App Store to process.\nprotocol SKPaymentTransactionObserver\nA set of methods that process transactions, unlock purchased functionality, and continue promoted in-app purchases.\nclass SKRequest\nAn abstract class that represents a request to the App Store."
  },
  {
    "title": "SKPaymentTransactionObserver",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver",
    "html": "Overview\n\nObservers of SKPaymentQueue objects implement the methods of this protocol.\n\nThe system calls an observer when the queue updates or removes transactions. An observer needs to process all successful transactions, unlock the functionality the user purchases, and then finish the transaction by calling the payment queue’s finishTransaction(_:) method.\n\nTopics\nHandling transactions\nfunc paymentQueue(SKPaymentQueue, updatedTransactions: [SKPaymentTransaction])\nTells an observer that one or more transactions have been updated.\n\nRequired\n\nfunc paymentQueue(SKPaymentQueue, removedTransactions: [SKPaymentTransaction])\nTells an observer that one or more transactions have been removed from the queue.\nRestoring transactions\nfunc paymentQueue(SKPaymentQueue, restoreCompletedTransactionsFailedWithError: any Error)\nTells the observer that an error occurred while restoring transactions.\nfunc paymentQueueRestoreCompletedTransactionsFinished(SKPaymentQueue)\nTells the observer that the payment queue has finished sending restored transactions.\nHandling promoted in-app purchases\nPromoting in-app purchases\nShow promoted in-app purchases on your product page and handle purchases that users initiate on the App Store.\nfunc paymentQueue(SKPaymentQueue, shouldAddStorePayment: SKPayment, for: SKProduct) -> Bool\nTells the observer when a user initiates an in-app purchase from the App Store.\nRevoking entitlements\nfunc paymentQueue(SKPaymentQueue, didRevokeEntitlementsForProductIdentifiers: [String])\nTells an observer that the user is no longer entitled to one or more Family Sharing purchases.\nChanging the storefront\nfunc paymentQueueDidChangeStorefront(SKPaymentQueue)\nTells the observer that the storefront for the payment queue has changed.\nHandling download actions\nfunc paymentQueue(SKPaymentQueue, updatedDownloads: [SKDownload])\nTells the observer that the payment queue has updated one or more download objects.\nDeprecated\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nEssentials\nSetting up the transaction observer for the payment queue\nEnable your app to receive and handle transactions by adding an observer.\nOffering, completing, and restoring in-app purchases\nFetch, display, purchase, validate, and finish transactions in your app.\nclass SKPaymentQueue\nA queue of payment transactions for the App Store to process.\nprotocol SKPaymentQueueDelegate\nThe protocol that provides information needed to complete transactions.\nclass SKRequest\nAn abstract class that represents a request to the App Store."
  },
  {
    "title": "failureReason",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror/3916877-failurereason",
    "html": "Relationships\nFrom Protocol\nLocalizedError\nSee Also\nError Descriptions\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar helpAnchor: String?\nA localized message that provides additional information if the user requests help.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "StoreKitError.notAvailableInStorefront",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror/notavailableinstorefront",
    "html": "See Also\nStoreKit Error Codes\ncase networkError(URLError)\nA network error occurred.\ncase systemError(any Error)\nA system error occurred.\ncase userCancelled\nThe user canceled.\ncase notEntitled\nThe app doesn’t have the appropriate entitlements to use the functionality.\ncase unknown\nAn unknown error occurred."
  },
  {
    "title": "StoreKitError.userCancelled",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror/usercancelled",
    "html": "See Also\nStoreKit Error Codes\ncase networkError(URLError)\nA network error occurred.\ncase systemError(any Error)\nA system error occurred.\ncase notAvailableInStorefront\nThe function isn’t available on devices configured for this storefront.\ncase notEntitled\nThe app doesn’t have the appropriate entitlements to use the functionality.\ncase unknown\nAn unknown error occurred."
  },
  {
    "title": "StoreKitError.notEntitled",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror/notentitled",
    "html": "See Also\nStoreKit Error Codes\ncase networkError(URLError)\nA network error occurred.\ncase systemError(any Error)\nA system error occurred.\ncase userCancelled\nThe user canceled.\ncase notAvailableInStorefront\nThe function isn’t available on devices configured for this storefront.\ncase unknown\nAn unknown error occurred."
  },
  {
    "title": "StoreKitError.systemError(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror/systemerror",
    "html": "See Also\nStoreKit Error Codes\ncase networkError(URLError)\nA network error occurred.\ncase userCancelled\nThe user canceled.\ncase notAvailableInStorefront\nThe function isn’t available on devices configured for this storefront.\ncase notEntitled\nThe app doesn’t have the appropriate entitlements to use the functionality.\ncase unknown\nAn unknown error occurred."
  },
  {
    "title": "localizedDescription",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror/3749593-localizeddescription",
    "html": "See Also\nError Descriptions\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA message describing the reason for the failure.\nvar helpAnchor: String?\nA localized message that provides additional information if the user requests help.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "helpAnchor",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror/3916878-helpanchor",
    "html": "See Also\nError Descriptions\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA message describing the reason for the failure.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error."
  },
  {
    "title": "VerificationResult.unverified(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/unverified",
    "html": "Discussion\n\nThe first associated value in this case is the App Store-signed value. The second associated value provides the reason why the verification failed.\n\nSee Also\nGetting the verification results\ncase verified(SignedType)\nThe associated value passed StoreKit automatic verification checks.\nvar payloadValue: SignedType\nThe verified value of the signed type that StoreKit confirms as verified.\nvar unsafePayloadValue: SignedType\nThe associated value of the verification result that StoreKit doesn’t confirm as verified.\nenum VerificationResult.VerificationError\nError cases for StoreKit JWS verification."
  },
  {
    "title": "invalidConversionValue",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925706-invalidconversionvalue",
    "html": "Discussion\n\nApps provide a conversion value when calling updatePostbackConversionValue(_:completionHandler:) or updateConversionValue(_:). Check that the conversion value you provide is within the allowed range.\n\nSee Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "SKCloudServiceSetupOptionsKey",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupoptionskey",
    "html": "Topics\nInitializing\ninit(rawValue: String)\nInitializes a cloud service setup options key based on the provided raw value.\nIndicating Setup Options\nstatic let action: SKCloudServiceSetupOptionsKey\nA key that specifies the action for a setup entry point.\nstruct SKCloudServiceSetupAction\nA string used to specify the type of setup action to offer for a cloud service.\nstatic let iTunesItemIdentifier: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store item that the user is trying to access through the service.\nstatic let affiliateToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate token.\nstatic let campaignToken: SKCloudServiceSetupOptionsKey\nA key that specifies the iTunes Store affiliate campaign token.\nstatic let messageIdentifier: SKCloudServiceSetupOptionsKey\nA key that is used to select the main message presented to the user for this setup view.\nstruct SKCloudServiceSetupMessageIdentifier\nIdentifiers for the available messages the setup view can present to the user.\nRelationships\nConforms To\nEquatable\nHashable\nRawRepresentable\nSendable\nSee Also\nLoading the Setup View\nOffering Apple Music Subscription in Your App\nAllow eligible users to subscribe to Apple Music library.\nfunc load(options: [SKCloudServiceSetupOptionsKey : Any], completionHandler: ((Bool, (any Error)?) -> Void)?)\nLoads the cloud service setup view with the specified options."
  },
  {
    "title": "VerificationResult.verified(_:)",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verified",
    "html": "Discussion\n\nThe associated value in this case is the App Store-signed value.\n\nSee Also\nGetting the verification results\ncase unverified(SignedType, VerificationResult<SignedType>.VerificationError)\nThe associated value failed StoreKit automatic verification checks.\nvar payloadValue: SignedType\nThe verified value of the signed type that StoreKit confirms as verified.\nvar unsafePayloadValue: SignedType\nThe associated value of the verification result that StoreKit doesn’t confirm as verified.\nenum VerificationResult.VerificationError\nError cases for StoreKit JWS verification."
  },
  {
    "title": "Testing an auto-renewable subscription",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_an_auto-renewable_subscription",
    "html": "Overview\n\nAuto-renewable subscriptions behave differently in the sandbox environment and the production environment.\n\nIn the sandbox environment, subscription renewals happen at an accelerated rate, and auto-renewable subscriptions renew up to 12 times after the initial purchase. This enables you to test how your app handles a subscription renewal, a subscription lapse, and a subscription history that includes gaps.\n\nYou can choose a subscription renewal speed for each Sandbox Apple ID account in App Store Connect. For a complete list of subscription durations within the sandbox environment and more information, see Manage Sandbox Apple ID settings.\n\nThe accelerated expiration and renewal rates in the sandbox environment make it possible for subscriptions to expire before the system tries to renew them. When a subscription expires before the system tries to renew it, it results in a short lapse in the subscription period. These lapses are possible in production; verify that your app handles them appropriately.\n\nSee Also\nSubscriptions\nTesting resubscribing from the subscriptions page\nVerify that your app can reactivate an expired subscription by receiving a transaction callback or inspecting an updated receipt.\nTesting disabling auto-renew\nVerify that your app receives subscription updates when a user cancels a subscription by verifying the receipt or receiving a notification."
  },
  {
    "title": "Testing purchases made outside your app",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox/testing_purchases_made_outside_your_app",
    "html": "Overview\n\nWhen your app offers in-app purchases, customers typically buy the products from within your app. However, purchase transactions can also occur on another device or even outside your app. Your app needs to handle these transactions when it launches. Use the Test Transactions feature in Account Settings in iOS to simulate and test such transactions in the sandbox environment.\n\nSimulate a variety of purchase events\n\nSeveral types of events result in a purchase transaction that occurs outside your app, including the following:\n\nRedeeming offer codes\n\nPeople can redeem offer codes on the Redeem Gift Card or Code page in their App Store account settings, by using a redemption URL, and when your app calls presentCodeRedemptionSheet(). For more information, see Set up offer codes.\n\nRedeeming a promo code for an in-app purchase\n\nPeople can redeem a promo codes in the App Store. For more information, see Request and manage promo codes.\n\nRenewing an auto-renewable subscription\n\nApple bills customers when an auto-renewable subscription renews, and the renewal transaction occurs outside your app.\n\nResubscribing from the Apple Subscriptions page\n\nPeople can resubscribe to expired subscriptions from their Account > Subscriptions page in the App Store.\n\nAll of these events result in StoreKit sending a transaction to your app through the updates asynchronous sequence in Transaction. Test your app to be sure it handles the transaction.\n\nSet up and perform a test\n\nTo create a transaction outside your app for the testing environment, first open Account Settings on the iOS device, as follows:\n\nOpen Settings and select App Store.\n\nSelect the Sandbox Apple ID.\n\nSelect Manage on the popup sheet. The Account Settings page appears.\n\nNext, you need the product ID for a product you set up in App Store Connect, and your app’s bundle ID.\n\nNote\n\nChanges that you make to product metadata in App Store Connect can take up to one hour to appear in the sandbox environment.\n\nTo simulate a purchase outside your app, follow these steps:\n\nOn the Account Settings page, select Test Transactions.\n\nEnter your product ID and the bundle ID in the text boxes labeled Product ID and Bundle ID, respectively.\n\nClick Next.\n\nThe system brings up the payment sheet for the sandbox environment, which is labeled with \"App Store [Sandbox]\". Confirm the purchase. Note: The sandbox environment doesn’t process actual payments. Instead, it returns transactions as if payments were processed successfully.\n\nAfter you confirm the purchase, use the following steps to test your app:\n\nOpen your app. The system delivers the new transaction to your app through the updates asynchronous sequence in Transaction.\n\nConfirm that your app receives and processes the transaction to provide access to the purchased product.\n\nConclude or restart a test\n\nYou can repeat the test by purchasing the product again through the Test Transactions feature in Account Settings. To repurchase some products you might first need to clear the transactions for the Sandbox Apple ID, following these steps:\n\nOpen Settings and select App Store.\n\nSelect the Sandbox Apple ID.\n\nSelect Manage on the popup sheet.\n\nOn the Account Settings page, select Clear Purchase History.\n\nRestart your app. The purchase history for the Sandbox Apple ID will be empty and ready for testing. Clearing the purchase history for Sandbox Apple IDs with a high number of purchases may take longer.\n\nSee Also\nPayment transactions\nTesting an interrupted purchase\nVerify that your app handles an interrupted purchase by inspecting and invoking payment transactions.\nTesting failing subscription renewals and in-app purchases\nVerify that your app handles failed subscription renewals that are in the billing retry or billing grace period states, as well as failed in-app purchases.\nTesting a payment request\nVerify that requests for payment function properly in the sandbox environment by inspecting the calls to the payment transaction observer."
  },
  {
    "title": "Storefront.Storefronts",
    "url": "https://developer.apple.com/documentation/storekit/storefront/storefronts",
    "html": "Topics\nCreating an iterator\nfunc makeAsyncIterator() -> Storefront.Storefronts.AsyncIterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Storefront.Storefronts.AsyncIterator\nThe iterator that produces elements of the asynchronous sequence.\nFinding elements\nfunc allSatisfy((Storefront) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(where: (Storefront) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Storefront) -> Bool) -> Storefront?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Storefront, Storefront) -> Bool) -> Storefront?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Storefront, Storefront) -> Bool) -> Storefront?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nSelecting elements\nfunc prefix(Int) -> AsyncPrefixSequence<Storefront.Storefronts>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Storefront) -> Bool) -> AsyncPrefixWhileSequence<Storefront.Storefronts>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nExcluding elements\nfunc drop(while: (Storefront) -> Bool) -> AsyncDropWhileSequence<Storefront.Storefronts>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Storefront.Storefronts>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Storefront) -> Bool) -> AsyncFilterSequence<Storefront.Storefronts>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Storefront) -> ElementOfResult?) -> AsyncCompactMapSequence<Storefront.Storefronts, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Storefront) -> SegmentOfResult) -> AsyncFlatMapSequence<Storefront.Storefronts, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncThrowingMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Storefront) -> Transformed) -> AsyncMapSequence<Storefront.Storefronts, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, Storefront) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Storefront) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.\nRelationships\nConforms To\nAsyncSequence\nSee Also\nListening for storefront changes\nstatic var updates: Storefront.Storefronts\nThe asynchronous sequence that emits storefront information when the system updates the storefront."
  },
  {
    "title": "isFamilyShareable",
    "url": "https://developer.apple.com/documentation/storekit/skproduct/3564805-isfamilyshareable",
    "html": "Discussion\n\nCheck the value of isFamilyShareable to learn whether an in-app purchase is sharable with the family group.\n\n// Determine whether an in-app purchase supports Family Sharing.\nlet myProduct: SKProduct = getProductWithId(id: \"com.example.product_identifier\")\nif myProduct.isFamilyShareable {\n    print(\"Product can be shared with family group.\")\n}\n\n\nWhen displaying in-app purchases in your app, indicate whether the product includes Family Sharing to help customers make a selection that best fits their needs.\n\nConfigure your in-app purchases to allow Family Sharing in App Store Connect. For more information about setting up Family Sharing, see Turn-on Family Sharing for in-app purchases.\n\nSee Also\nGetting Product Attributes\nvar localizedDescription: String\nA description of the product.\nvar localizedTitle: String\nThe name of the product.\nvar contentVersion: String\nA string that identifies the version of the content.\nvar contentLengths: [NSNumber]\nThe total size of the content, in bytes.\nDeprecated"
  },
  {
    "title": "SKProductStorePromotionController",
    "url": "https://developer.apple.com/documentation/storekit/skproductstorepromotioncontroller",
    "html": "Overview\n\nFor information about promoting in-app purchases, see Promoting in-app purchases.\n\nNote\n\nSKProductStorePromotionController and promoted in-app purchases aren’t available to compatible iPad and iPhone apps running in visionOS.\n\nTopics\nManaging promoted product order\nfunc fetchStorePromotionOrder(completionHandler: (([SKProduct], (any Error)?) -> Void)?)\nReads the product order override that determines the promoted product order on this device.\nfunc update(storePromotionOrder: [SKProduct], completionHandler: (((any Error)?) -> Void)?)\nOverrides the promoted product order on this device.\nManaging promoted product visibility\nfunc fetchStorePromotionVisibility(for: SKProduct, completionHandler: ((SKProductStorePromotionVisibility, (any Error)?) -> Void)?)\nReads the visibility setting of a promoted product in the App Store for this device.\nfunc update(storePromotionVisibility: SKProductStorePromotionVisibility, for: SKProduct, completionHandler: (((any Error)?) -> Void)?)\nUpdates the visibility of the product on the App Store, per device.\nenum SKProductStorePromotionVisibility\nThe visibility settings that determine if an in-app purchase is visible on a device.\nGetting the controller\nclass func `default`() -> Self\nReturns the default product store promotion controller.\nRelationships\nInherits From\nNSObject\nSee Also\nPromotions\nPromoting in-app purchases\nShow promoted in-app purchases on your product page and handle purchases that users initiate on the App Store.\nTesting promoted in-app purchases\nTest your in-app purchases before making your app available in the App Store."
  },
  {
    "title": "paymentQueue(_:didRevokeEntitlementsForProductIdentifiers:)",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver/3564804-paymentqueue",
    "html": "Parameters\nqueue\n\nThe payment queue that calls the delegate method.\n\nproductIdentifiers\n\nThe list of product identifiers with revoked entitlements.\n\nDiscussion\n\nThe system calls this delegate method whenever App Store revokes in-app purchases for a family member based on changes in Family Sharing, or when the purchaser gets a refund for an in-app purchase. Implement this method in your payment queue observer to reestablish a user’s access to products. Revoked transactions have the cancellation_date populated in the receipt.\n\nFor products with Family Sharing enabled, the following conditions may trigger this method in the family member’s app:\n\nThe purchaser receives a refund for a non-consumable or an auto-renewable subscription they shared.\n\nThe purchaser leaves the family group in which they were sharing subscriptions or non-consumables.\n\nThe purchaser disables Family Sharing for a non-consumable or stops sharing a subscription.\n\nThe purchaser hides an app, which makes their non-consumable purchase unavailable for sharing.\n\nThe family member leaves the group and no longer gets access to shared purchases.\n\nThe family organizer stops sharing payment in iCloud family settings. This change affects non-consumables.\n\nBy leaving a family group, or disabling sharing in any of the ways listed above, family members are no longer entitled to family-shared purchases. The productIdentifiers parameter contains the revoked product IDs. Your app needs to check the receipt on the device, which the system automatically updates prior to calling this method, and provide the correct level of access for the in-app purchases.\n\nIf you receive App Store Server Notifications, your server receives a notificationType REVOKE for the family member when the conditions listed above occur.\n\nImportant\n\nAlways check the receipt to determine the users’s correct level of access for the product. A user may lose access through Family Sharing, but may have purchased the product directly.\n\nStoreKit also calls this method in the purchaser’s app when the purchaser receives a refund for a non-consumable or an auto-renewable subscription, regardless if the product is shared with the family. If you receive App Store Server Notifications, your server receives a notificationType REFUND for the purchaser.\n\nIf you use server-side receipt validation with the App Store, call your server to reprocess the receipt and update your purchase records."
  },
  {
    "title": "Subscriptions and offers",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers",
    "html": "Topics\nEssentials\nHandling Subscriptions Billing\nBuild logic around the date and time constraints of subscription products, while planning for all scenarios where you control access to content.\nEnabling App Store Server Notifications\nConfigure your server and provide an HTTPS URL to receive notifications about in-app purchase events and unreported external purchase tokens.\nOffering a Subscription Across Multiple Apps\nSupport a single auto-renewable subscription across multiple apps.\nReducing Involuntary Subscriber Churn\nPrevent unintentional loss of subscribers due to billing issues.\nIntroductory offers\nProvide discount pricing for new customers to encourage them to subscribe.\nImplementing introductory offers in your app\nOffer introductory pricing for auto-renewable subscriptions to eligible users.\nTesting introductory offers\nTest your introductory pricing in a variety of user scenarios.\nclass SKProductDiscount\nThe details of an introductory offer or a promotional offer for an auto-renewable subscription.\nPromotional offers\nProvide discount pricing for existing or previously subscribed customers to encourage them to renew.\nSetting up promotional offers\nGenerate a key and configure offers for auto-renewable subscriptions in App Store Connect.\nImplementing promotional offers in your app\nOffer discounted pricing for auto-renewable subscription products to eligible subscribers.\nGenerating a signature for promotional offers\nCreate a signature to validate a promotional offer using your private key.\nGenerating a Promotional Offer Signature on the Server\nGenerate a signature using your private key and lightweight cryptography libraries.\nclass SKPaymentDiscount\nThe signed discount to apply to a payment.\nSubscription offer codes\nProvide offer codes to customers to acquire, retain, and win back subscribers.\nImplementing offer codes in your app\nProvide subscription service for customers who redeem offer codes through the App Store or within your app.\nSubscription service entitlement\nDetermining service entitlement on the server\nIdentify a customer’s entitlement to your service, offers, and messaging by analyzing a validated receipt and the state of their subscription."
  },
  {
    "title": "Supporting Family Sharing in your app",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/supporting_family_sharing_in_your_app",
    "html": "Overview\n\nFamily Sharing allows a user to share access to auto-renewable subscriptions or non-consumables with up to five family members on all of their Apple devices. Enabling Family Sharing for a subscription can make your content or service more appealing to subscribers, and may encourage conversion to a paid subscription, increase user engagement, and improve retention. Developers can choose to turn on Family Sharing for in-app purchases and non-consumables in App Store Connect. Users can also choose whether to share their purchases with family.\n\nWhen users share a purchase through Family Sharing, each family member gets their own unique receipts and transactions. Process the transactions in the same way you already handle purchases — you don’t need any special logic for shared products. However, you do need to implement a new method in your transaction observer, and listen for a new notification type in server notifications. Specifically, to support Family Sharing, you need to:\n\nEnable Family Sharing for your in-app purchases in App Store Connect. For more information, see Turn on Family Sharing for in-app purchases.\n\nDuring runtime, check whether in-app purchases support Family Sharing using either isFamilyShareable in Product or isFamilyShareable in SKProduct. Then inform users when merchandising your subscriptions.\n\nProcess purchased and restored transactions in your app. This is standard processing you already do for any purchases.\n\nImplement paymentQueue(_:didRevokeEntitlementsForProductIdentifiers:) in your transaction observer to handle conditions in which products are no longer shared.\n\nListen for the REVOKE notification_type from App Store Server Notifications on your server.\n\nRelated Sessions from WWDC20\n\nSession 10661: What's new with in-app purchase\n\nEnable Family Sharing for in-app purchases\n\nTo make Family Sharing available for an in-app purchase, developers need to turn on Family Sharing in App Store Connect. After you enable Family Sharing for an in-app purchase, you can’t turn it off. For more information, see Turn on Family Sharing for in-app purchases.\n\nUsers can choose whether to share their purchases with family. As users join or leave family groups and enable or disable sharing, your app needs to update the family’s access to your products. For information about how users manage their Family Sharing choices, see Set Up Family Sharing on iPhone.\n\nProvide access to shared purchases\n\nYour app receives a unique receipt for each family member entitled to a shared purchase, on each of their devices. For subscriptions, your app unlocks access through the normal purchase flow. For non-consumable products, unlocking access may require users to initiate a restored purchase, depending on the Family Sharing settings at the time of purchase.\n\nTo provide access for family members to a subscription or non-consumable, your app needs to handle purchased and restored transactions as usual. Specifically, follow these steps:\n\nSet up a transaction observer at app launch so your app receives transactions that occur outside of your app, such as receiving a Family Sharing purchase. For more information on this best practice, see Setting up the transaction observer for the payment queue.\n\nVerify the receipt. Look for a transaction in the latest receipt info array (responseBody.Latest_receipt_info) with the new Family Sharing purchase.\n\nHandle purchased (SKPaymentTransactionState.purchased) transactions. This is a standard state apps need to handle, and you don’t need anything special for Family Sharing. For shared subscriptions, the transaction always has a purchased state. For shared non-consumable products, the transaction has a purchased state if Family Sharing was enabled for the product at the time of the purchase. For more information about handling transactions, see Processing a transaction.\n\nHandle restored (SKPaymentTransactionState.restored) transactions, which is also a standard state apps need to handle. For shared non-consumable products, your app gets a restored transaction if developers enable Family Sharing after the user purchases the product. To gain access to the shared product, family members use your app’s restore functionality. For more information about restoring, see Restoring purchased products.\n\nUnlock access to the shared subscription or non-consumable product.\n\nCall finishTransaction(_:).\n\nRevoke access if Family Sharing is disabled\n\nWith Family Sharing products, users have access to products only while Family Sharing is enabled. If the purchaser leaves the group, gets a refund, or stops sharing, the expectation is that the family’s access to the product stops immediately.\n\nWhen a condition occurs that disables sharing, StoreKit informs your app by updating the receipt, and then calling the paymentQueue(_:didRevokeEntitlementsForProductIdentifiers:) method of the SKPaymentTransactionObserver protocol. Implement this method on your transaction observer, and do the following:\n\nVerify the receipt. Revoked products appear in the receipt with a cancellation_date field present.\n\nProvide the app with access to all the products to which the user is entitled.\n\nFor more information, including a list of conditions that trigger this call, see paymentQueue(_:didRevokeEntitlementsForProductIdentifiers:).\n\nListen for the revoke notification\n\nIf you set up your server to receive App Store Server Notifications, your server gets a REVOKE notification_type as soon as a shared purchase is no longer shared. This notification serves the same purpose as the paymentQueue(_:didRevokeEntitlementsForProductIdentifiers:)call. Listen for and process this notification by:\n\nChecking the latest receipt (unified_receipt.Latest_receipt_info) in the response body. Revoked products appear in the receipt with a cancellation_date field present.\n\nProviding the app with access to all products to which the user is entitled.\n\nUpdating your records, if you keep server-based records to manage your customers' subscriptions.\n\nIndicate to users when products support Family Sharing\n\nWhen your app displays in-app purchases, indicate in your UI whether users can share the product with family. Call isFamilyShareable to determine at runtime whether the in-app purchase supports Family Sharing. Knowing whether a product is shareable helps users make a selection that best fits their needs.\n\nSee Also\nFamily Sharing\nvar isFamilyShareable: Bool\nA Boolean value that indicates whether the product is available for Family Sharing in App Store Connect.\nfunc paymentQueue(SKPaymentQueue, didRevokeEntitlementsForProductIdentifiers: [String])\nTells an observer that the user is no longer entitled to one or more Family Sharing purchases."
  },
  {
    "title": "SKTerminateForInvalidReceipt()",
    "url": "https://developer.apple.com/documentation/storekit/1620081-skterminateforinvalidreceipt",
    "html": "See Also\nProviding access to previously purchased products\nRestoring purchased products\nGive users functionality that restores their purchases in your app to maintain access to purchased content.\nclass SKReceiptRefreshRequest\nA request to the App Store to get the app receipt, which represents the user’s transactions with your app.\nclass SKRequest\nAn abstract class that represents a request to the App Store.\nclass SKPaymentTransaction\nAn object in the payment queue."
  },
  {
    "title": "current",
    "url": "https://developer.apple.com/documentation/storekit/storefront/3803207-current",
    "html": "Discussion\n\nUse current to determine a customer's current storefront region and offer in-app products suitable for that region. You maintain your own list of product identifiers and the storefronts in which you make them available.\n\nSee Also\nIdentifying the storefront\nlet countryCode: String\nThe three-letter code that represents the country or region associated with the App Store storefront.\nlet id: String\nAn Apple-defined value that uniquely identifies an App Store storefront.\ntypealias Storefront.ID\nThe type that represents a storefront identifier.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Storefront conforms to AnyObject."
  },
  {
    "title": "countryCode",
    "url": "https://developer.apple.com/documentation/storekit/storefront/3792000-countrycode",
    "html": "Discussion\n\nThis property uses the ISO 3166-1 Alpha-3 country code representation.\n\nSee Also\nIdentifying the storefront\nstatic var current: Storefront?\nThe current App Store storefront for product purchases.\nlet id: String\nAn Apple-defined value that uniquely identifies an App Store storefront.\ntypealias Storefront.ID\nThe type that represents a storefront identifier.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Storefront conforms to AnyObject."
  },
  {
    "title": "SKANError.Code.impressionTooShort",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/impressiontooshort",
    "html": "See Also\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unknown\nAn unknown error occurred.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "SKANError.Code.impressionNotFound",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/impressionnotfound",
    "html": "Discussion\n\nThis error may occur if an app calls endImpression(_:completionHandler:) before calling startImpression(_:completionHandler:).\n\nSee Also\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionTooShort\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unknown\nAn unknown error occurred.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "invalidSourceAppId",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3928247-invalidsourceappid",
    "html": "Discussion\n\nCheck that the value you provide for SKStoreProductParameterAdNetworkSourceAppStoreIdentifier or sourceAppStoreItemIdentifier is correct and matches the App Store ID of the app that’s displaying the ad.\n\nSee Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "SKANError.Code.impressionMissingRequiredValue",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/impressionmissingrequiredvalue",
    "html": "Discussion\n\nCheck that your instance of SKAdImpression provides all of the required values.\n\nSee Also\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase impressionTooShort\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unknown\nAn unknown error occurred.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "makeAsyncIterator()",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954491-makeasynciterator",
    "html": "Relationships\nFrom Protocol\nAsyncSequence\nSee Also\nCreating an iterator\nstruct Message.Messages.AsyncIterator\nThe asynchronous iterator that produces elements of the asynchronous sequence.\ntypealias Message.Messages.Element\nThe type of element traversed by the iterator."
  },
  {
    "title": "latestTransaction",
    "url": "https://developer.apple.com/documentation/storekit/product/3803206-latesttransaction",
    "html": "Discussion\n\nThis value is nil if the user has never purchased this product. The following example illustrates requesting the latest transaction for a product to determine whether the user has purchased the product.\n\nguard let resultingTransaction = await product.latestTransaction else {\n    // The user hasn't purchased this product.\n    return\n}\nguard case .verified(let transaction) = resultingTransaction else {\n    // Ignore unverified transactions.\n    return\n}\n// Update your app based on the details from the latest transaction.\n"
  },
  {
    "title": "reduce(into:_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954506-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary.\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncThrowingMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc reduce<Result>(Result, (Result, Message) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure."
  },
  {
    "title": "Restoring purchased products",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/restoring_purchased_products",
    "html": "Overview\n\nUsers sometimes need to restore purchased content, such as when they upgrade to a new phone. Include some mechanism in your app, such as a Restore Purchases button, to let them restore their purchases.\n\nImportant\n\nDon’t automatically restore purchases, especially when your app launches. Restoring purchases prompts for the user’s App Store credentials, which interrupts the flow of your app.\n\nIn most cases, you only need to refresh the app receipt and deliver the products on the receipt. The refreshed receipt contains a record of the user’s purchases in the app, from any device the user’s App Store account is logged into. However, an app might require an alternative approach under the given circumstances:\n\nYou use Apple-hosted content — Restore completed transactions to give your app the transaction objects it uses to download the content.\n\nYou need to support your app on devices where the app receipt isn’t available — Restore completed transactions instead.\n\nYour app uses non-renewing subscriptions — Your app is responsible for the restoration process.\n\nRefreshing a receipt doesn’t create new transactions; it requests the latest copy of the receipt from the App Store. Refresh the receipt only once; refreshing it multiple times in a row has the same result.\n\nRestoring completed transactions creates a new transaction for each previously completed transaction, essentially replaying history for your transaction queue observer. Your app maintains its own state to keep track of why it’s restoring completed transactions and how to handle them. Restoring multiple times creates multiple restored transactions for each completed transaction.\n\nNote\n\nIf the user attempts to purchase a product that they’ve already purchased, the App Store creates a regular transaction instead of a restore transaction, but the user isn’t charged again for the product. Unlock the content for these transactions the same way you do for original transactions.\n\nGive the user an appropriate level of control over the content that’s downloaded again. For example, don’t automatically download three years of daily newspapers or hundreds of megabytes of game levels at the same time.\n\nRefresh the app receipt\n\nCreate a receipt refresh request, set a delegate, and start the request. The request supports optional properties for obtaining receipts in various states, such as expired receipts, during testing. For details, see the init(receiptProperties:) method of SKReceiptRefreshRequest.\n\nlet refresh = SKReceiptRefreshRequest()\nrefresh.delegate = self\nrefresh.start()\n\n\nAfter the app receipt refreshes, examine it and deliver any additional products, as necessary.\n\nRestore completed transactions\n\nYour app starts restoring completed transactions by calling the restoreCompletedTransactions() method of SKPaymentQueue. This call sends a request to the App Store to restore all of your app’s completed transactions. If your app sets a value for the applicationUsername property of its payment requests, use the restoreCompletedTransactions(withApplicationUsername:) method to provide the same information when restoring the transactions.\n\nThe App Store generates a new transaction to restore each previously completed transaction. The restored transaction refers to the original transaction. Instances of SKPaymentTransaction have an original property, and the entries in the receipt have an original_transaction_id field value.\n\nNote\n\nThe date fields have slightly different meanings for restored purchases. For details, see the purchase_date and original_purchase_date fields in the responseBody.Receipt.In_app.\n\nStoreKit calls the transaction queue observer with a status of SKPaymentTransactionState.restored for each restored transaction, as described in Processing a transaction. The action you take depends on your app’s design.\n\nIf your app uses the app receipt and doesn’t have Apple-hosted content, this code isn’t needed because your app doesn’t restore completed transactions. Finish any restored transactions immediately.\n\nIf your app uses the app receipt and has Apple-hosted content, let the user select which products to restore before starting the restoration process. During restoration, download the user-selected content before finishing those transactions, and finish any other transactions immediately.\n\nlet productIDsToRestore: [String]() = <# From the user #>\nlet transaction: SKPaymentTransaction = <# Current transaction #>\n\n\nguard let identifier = transaction.transactionIdentifier else { customError() }\nif productIDsToRestore.contains(identifier) {\n// Re-download the Apple-hosted content\n}\n\n\nSKPaymentQueue.default().finishTransaction(transaction)\n\n\nIf your app doesn’t use the app receipt, it examines all completed transactions as it restores them. It uses a similar code path to the original purchase logic to make the product available and then finishes the transaction. Apps with more than a few products, especially products with associated content, let the user select which products to restore instead of restoring everything. These apps keep track of which completed transactions to process as they restore them, and which transactions to ignore by finishing them immediately without restoring them.\n\nSee Also\nProviding access to previously purchased products\nclass SKReceiptRefreshRequest\nA request to the App Store to get the app receipt, which represents the user’s transactions with your app.\nclass SKRequest\nAn abstract class that represents a request to the App Store.\nclass SKPaymentTransaction\nAn object in the payment queue.\nfunc SKTerminateForInvalidReceipt()\nTerminates an app if the license to use the app has expired."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954487-flatmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncThrowingMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc reduce<Result>(Result, (Result, Message) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954471-compactmap",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncThrowingMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc reduce<Result>(Result, (Result, Message) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "filter(_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954483-filter",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n\nSee Also\nExcluding messages\nfunc drop(while: (Message) -> Bool) -> AsyncDropWhileSequence<Message.Messages>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Message.Messages>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements."
  },
  {
    "title": "dropFirst(_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954481-dropfirst",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nSee Also\nExcluding messages\nfunc drop(while: (Message) -> Bool) -> AsyncDropWhileSequence<Message.Messages>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc filter((Message) -> Bool) -> AsyncFilterSequence<Message.Messages>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "Product.ProductType",
    "url": "https://developer.apple.com/documentation/storekit/product/producttype",
    "html": "Topics\nGetting the Product Type\nstatic let consumable: Product.ProductType\nA consumable in-app purchase.\nstatic let nonConsumable: Product.ProductType\nA non-consumable in-app purchase.\nstatic let nonRenewable: Product.ProductType\nA non-renewing subscription.\nstatic let autoRenewable: Product.ProductType\nAn auto-renewable subscription.\nGetting a Localized Description\nvar localizedDescription: String\nCreating a Product Type\ninit(rawValue: String)\nlet rawValue: String\nThe value for product type as a backing value.\ntypealias Product.ProductType.RawValue\nComparing and Hashing Product Types\nstatic func != (Product.ProductType, Product.ProductType) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSee Also\nGetting product identifiers and type\nlet id: String\nThe unique product identifier.\ntypealias Product.ID\nA type representing a unique product identifier.\nlet type: Product.ProductType\nThe in-app purchase product type.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Product conforms to AnyObject."
  },
  {
    "title": "prefix(_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954500-prefix",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence.\n\nSee Also\nSelecting messages\nfunc prefix(while: (Message) -> Bool) -> AsyncPrefixWhileSequence<Message.Messages>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "first(where:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954485-first",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFinding messages\nfunc allSatisfy((Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(Message) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc max(by: (Message, Message) -> Bool) -> Message?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Message, Message) -> Bool) -> Message?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "contains(where:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954477-contains",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFinding messages\nfunc allSatisfy((Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(Message) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc first(where: (Message) -> Bool) -> Message?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Message, Message) -> Bool) -> Message?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Message, Message) -> Bool) -> Message?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "prefix(while:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954502-prefix",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n\nSee Also\nSelecting messages\nfunc prefix(Int) -> AsyncPrefixSequence<Message.Messages>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence."
  },
  {
    "title": "allSatisfy(_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954469-allsatisfy",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true.\n\nSee Also\nFinding messages\nfunc contains(Message) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Message) -> Bool) -> Message?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Message, Message) -> Bool) -> Message?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Message, Message) -> Bool) -> Message?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "SKStoreProductParameterAdNetworkTimestamp",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameteradnetworktimestamp",
    "html": "Discussion\n\nThe value for this key is an NSNumber. Ad networks generate the timestamp, represented as UNIX time in milliseconds, at the time you’re preparing to serve the ad.\n\nSee Also\nRequired keys\nlet SKStoreProductParameterAdNetworkIdentifier: String\nThe key that represents the advertising network’s unique identifier.\nlet SKStoreProductParameterAdNetworkCampaignIdentifier: String\nThe key that represents the advertising network’s campaign.\nlet SKStoreProductParameterAdNetworkNonce: String\nThe key that represents a random value to use for added security.\nlet SKStoreProductParameterAdNetworkAttributionSignature: String\nThe key that represents the advertising network’s cryptographic signature to use for install validation."
  },
  {
    "title": "SKProduct",
    "url": "https://developer.apple.com/documentation/storekit/skproduct",
    "html": "Overview\n\nSKProduct objects are returned as part of an SKProductsResponse object.\n\nTopics\nGetting the Product Identifier\nvar productIdentifier: String\nThe string that identifies the product to the Apple App Store.\nGetting Product Attributes\nvar localizedDescription: String\nA description of the product.\nvar localizedTitle: String\nThe name of the product.\nvar contentVersion: String\nA string that identifies the version of the content.\nvar isFamilyShareable: Bool\nA Boolean value that indicates whether the product is available for Family Sharing in App Store Connect.\nvar contentLengths: [NSNumber]\nThe total size of the content, in bytes.\nDeprecated\nGetting Pricing Information\nvar price: NSDecimalNumber\nThe cost of the product in the local currency.\nvar priceLocale: Locale\nThe locale used to format the price of the product.\nvar introductoryPrice: SKProductDiscount?\nThe object containing introductory price information for the product.\nvar discounts: [SKProductDiscount]\nAn array of subscription offers available for the auto-renewable subscription.\nclass SKProductDiscount\nThe details of an introductory offer or a promotional offer for an auto-renewable subscription.\nGetting Subscription Information\nvar subscriptionGroupIdentifier: String?\nThe identifier of the subscription group to which the subscription belongs.\nvar subscriptionPeriod: SKProductSubscriptionPeriod?\nThe period details for products that are subscriptions.\nclass SKProductSubscriptionPeriod\nAn object containing the subscription period duration information.\nenum SKProduct.PeriodUnit\nValues representing the duration of an interval, from a day up to a year.\nGetting Downloadable Content Information\nvar isDownloadable: Bool\nA Boolean value that indicates whether the App Store has downloadable content for this product.\nvar downloadContentLengths: [NSNumber]\nThe lengths of the downloadable files available for this product.\nvar downloadContentVersion: String\nA string that identifies which version of the content is available for download.\nvar downloadable: Bool\nA Boolean value that indicates whether the App Store has downloadable content for this product.\nDeprecated\nRelationships\nInherits From\nNSObject\nConforms To\nSendable\nSee Also\nProduct information\nLoading in-app product identifiers\nLoad the unique identifiers for your in-app products to retrieve product information from the App Store.\nFetching product information from the App Store\nRetrieve up-to-date information about the products for sale in your app to display to your customers.\nclass SKProductsRequest\nAn object that can retrieve localized information from the App Store about a specified list of products.\nclass SKProductsResponse\nAn App Store response to a request for information about a list of products."
  },
  {
    "title": "SKProductsResponse",
    "url": "https://developer.apple.com/documentation/storekit/skproductsresponse",
    "html": "Topics\nResponse Information\nvar products: [SKProduct]\nA list of products, one product for each valid product identifier provided in the original request.\nvar invalidProductIdentifiers: [String]\nAn array of product identifier strings that the App Store doesn’t recognize.\nRelationships\nInherits From\nNSObject\nConforms To\nSendable\nSee Also\nProduct information\nLoading in-app product identifiers\nLoad the unique identifiers for your in-app products to retrieve product information from the App Store.\nFetching product information from the App Store\nRetrieve up-to-date information about the products for sale in your app to display to your customers.\nclass SKProductsRequest\nAn object that can retrieve localized information from the App Store about a specified list of products.\nclass SKProduct\nInformation about a registered product in App Store Connect."
  },
  {
    "title": "SKStorefront",
    "url": "https://developer.apple.com/documentation/storekit/skstorefront",
    "html": "Overview\n\nIn-app products you create through App Store Connect are available for sale in every region with an App Store. You can use the storefront information to determine the customer's region, and offer in-app products suitable for that region. StoreKit exposes SKStorefront storefront information as a read-only property in SKPaymentQueue.\n\nYou must maintain your own list of product identifiers and the storefronts in which you want to make them available.\n\nNote\n\nDon't save the storefront information with your user information; storefront information can change at any time. Always get the storefront identifier immediately before you display product information or availability to the user in your app. Storefront information may not be used to develop or enhance a user profile, or track customers for advertising or marketing purposes.\n\nShow Products Based on the Current Storefront\n\nThe following example function shouldShow returns false if your product isn’t suitable for the given storefront. You must create your own list of products available by storefront, referred to as myProducts in Listing 1.\n\nListing 1 Use the storefront value to determine if your app should display a product.\nfunc shouldShow(_ productIdentifier: String, in storefront: SKStorefront) -> Bool {\n    var shouldShow = true\n     \n    // myProducts is a dictionary representing your own metadata for products,\n    // keyed on an SKProduct.productIdentifier.\n    if let myProduct = myProducts[productIdentifier] {\n        shouldShow = myProduct.countryCodes.contains(storefront.countryCode)\n    }\n    return shouldShow\n}\n\n\nListing 2 requests information for products that you wish to display based on the device's storefront. It uses the shouldShow function defined in Listing 1.\n\nListing 2 Request product information for the products to display.\nfunc fetchProductInfo() {\n    var identifiers = Set<String>()\n    if let storefront = SKPaymentQueue.default().storefront {\n        for (identifier, _) in myProducts {\n            if shouldShow(identifier, in: storefront) {\n                identifiers.insert(identifier)\n            }\n        }\n        let request = SKProductsRequest(productIdentifiers: identifiers)\n        request.delegate = self\n        request.start()\n    }\n}\n\n\nListen for Storefront Changes\n\nThe storefront value can change at any time. To listen for changes in this value, implement the paymentQueueDidChangeStorefront(_:) method. Refresh the list of your available products when the storefront changes, as shown in Listing 3. The shouldShow function is defined in Listing 1.\n\nListing 3 Listen for storefront changes in the transaction observer.\nfunc paymentQueueDidChangeStorefront(_ queue: SKPaymentQueue) {\n    if let storefront = queue.storefront {\n        // Refresh the displayed products based on the new storefront.\n        for product in storeProducts {\n            if shouldShow(product.productIdentifier, in: storefront) {\n                // Display this product in your store UI.\n         }\n      }\n   }\n}\n\n\nRespond to Storefront Changes\n\nThe current storefront can change at any time, including during a transaction. Listing 4 determines whether the transaction should continue in the updated storefront. Your delegate's paymentQueue(_:shouldContinue:in:) method must return quickly, before the call times out. The shouldShow function is defined in Listing 1.\n\nListing 4 Determine whether to continue a transaction in an updated storefront.\nSKPaymentQueue.default().delegate = self  // Set your object as the SKPaymentQueue delegate.\n\n\nfunc paymentQueue(_ paymentQueue: SKPaymentQueue,\n                  shouldContinue transaction: SKPaymentTransaction,\n                  in newStorefront: SKStorefront) -> Bool {\n    return shouldShow(transaction.payment.productIdentifier, in: newStorefront)\n}\n\n\nIf the product isn't available in the updated storefront, the transaction fails with the error SKError.Code.storeProductNotAvailable. Handle this error in your paymentQueue(_:updatedTransactions:) method by displaying an alert to let the user know why the app can't complete the transaction, as shown in Listing 5.\n\nListing 5 Display an alert if a product isn't available in an updated storefront.\nfunc paymentQueue(_ queue: SKPaymentQueue,\n                  updatedTransactions transactions: [SKPaymentTransaction]) {\n    for transaction in transactions {\n        if let transactionError = transaction.error as NSError?,\n            transactionError.domain == SKErrorDomain\n            && transactionError.code == SKError.storeProductNotAvailable.rawValue {\n            // Show an alert.\n        }\n    }\n}\n\n\nChange the App Store Country or Region in the Sandbox Environment\n\nWhen you change the App Store Country or Region in App Store Connect for a Sandbox Apple ID, it changes the storefront in your app. Change the region to test in-app purchases for different regions in your app. For more information about changing the App Store Country or Region in App Store Connect, see Test in-app purchases.\n\nImportant\n\nTo successfully activate a storefront after you change the region in App Store Connect, sign out of the Sandbox Apple ID account on the device and sign back in.\n\nTopics\nIdentifying the Storefront\nvar countryCode: String\nThe three-letter code representing the country or region associated with the App Store storefront.\nvar identifier: String\nA value defined by Apple that uniquely identifies an App Store storefront.\nRelationships\nInherits From\nNSObject\nConforms To\nSendable"
  },
  {
    "title": "Requesting a payment from the App Store",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/requesting_a_payment_from_the_app_store",
    "html": "Overview\n\nAfter you present your app’s store UI, users can make purchases from within your app. When the user chooses a product, your app creates and submits a payment request to the App Store.\n\nImplementing an in-app purchase flow consists of three stages. In the first stage, your app retrieves product information. Then your app requests payment when the user selects a product in your app’s store. Finally, your app delivers the products.\n\nCreate a payment request\n\nWhen the user selects a product to buy, create a payment request using the corresponding SKProduct object and set the quantity if needed, as the code below shows. The product object comes from the array of products that your app’s products request returns, as described in Fetching product information from the App Store.\n\n// Use the corresponding SKProduct object that returns in the array from SKProductsRequest.\nlet payment = SKMutablePayment(product: product)\npayment.quantity = 2\n\n\nSubmit a payment request\n\nSubmit your payment request to the App Store by adding it to the payment queue. If you add a payment object to the queue more than once, the system submits it to the App Store multiple times, charging the user and requiring your app to deliver the product each time.\n\nSKPaymentQueue.default().add(payment)\n\n\nFor each payment request your app submits, it receives a corresponding transaction to process. For more information about transactions and the payment queue, see Processing a transaction.\n\nFor auto-renewable subscriptions, you may submit a payment request with a subscription offer for users you determine eligible to receive an offer. For more information, see Implementing promotional offers in your app.\n\nSee Also\nPurchases\nProcessing a transaction\nRegister a transaction queue observer to get and handle transaction updates from the App Store.\nclass SKPayment\nA request to the App Store to process payment for additional functionality that your app offers.\nclass SKMutablePayment\nA mutable request to the App Store to process payment for additional functionality that your app offers.\nclass SKPaymentTransaction\nAn object in the payment queue."
  },
  {
    "title": "init(id:)",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/4143438-init",
    "html": "Parameters\nid\n\nThe in-app binding identifier that your server receives from the Apple server when your server initiates payment method binding.\n\nDiscussion\n\nThis method succeeds if the app is entitled to use this API, the id is valid and unexpired, and the user is eligible. Otherwise, it throws an error. See PaymentMethodBinding.PaymentMethodBindingError and StoreKitError.userCancelled for the error information.\n\nThis method determines if the user is eligible, and requires that they're signed in to the App Store.\n\nImportant\n\nThis method may display a system prompt that asks users to sign in with their Apple ID. Call this method only after an explicit user action, like tapping or clicking a button.\n\nNote that it's possible that the system determines a user isn't eligible after it prompts for authentication."
  },
  {
    "title": "Offering, completing, and restoring in-app purchases",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/offering_completing_and_restoring_in-app_purchases",
    "html": "Overview\n\nUse the In-App Purchase API to give people the ability to purchase virtual goods within your app or directly from the App Store using the StoreKit framework. This sample code project demonstrates how to retrieve, display, and restore in-app purchases. First, you set up your app to register and use a single-transaction queue observer at launch. The transaction queue observer manages all payment transactions and handles all transaction states. Confirm that it’s a shared instance of a custom class that conforms to the SKPaymentTransactionObserver protocol. Then, remove the transaction observer when the system is about to terminate the app. See Setting up the transaction observer for the payment queue for more information.\n\nThis sample code project, which builds the InAppPurchases app, supports the iOS, iPadOS, macOS, and tvOS platforms. After launching, the app queries the App Store about product identifiers in the Products.plist file. The app updates its UI with the App Store’s response, which may include available products for sale, unrecognized product identifiers, or both. The app also displays all available purchased and restored payment transactions.\n\nConfigure the sample code project\n\nBefore you can run and test this sample code project, you need to:\n\nStart with a completed app that supports in-app purchases and has some configured in-app purchases in App Store Connect. For more information, see Overview for configuring in-app purchases.\n\nCreate a Sandbox Apple ID in App Store Connect.\n\nOpen the sample code project in Xcode, select the target that you want to build, click Signing & Capabilities, and change its bundle identifier to one that supports in-app purchases.\n\nChoose the appropriate team from the Team pop-up menu to let Xcode automatically manage your provisioning profile. See Assign a project to a team for details.\n\nOpen the ProductIds.plist file in the sample and update its content with your existing in-app purchases product IDs.\n\nFor iOS and tvOS devices, build and run the InAppPurchases and InAppPurchasestvOS targets, respectively, which the sample uses to build the app. If you have any code-signing issues, see If a code signing error occurs.\n\nFor macOS, before building the InAppPurchasesmacOS target, sign out of the Mac App Store. Build the target, then launch the resulting app from the Finder the first time to obtain a receipt. See Testing in-app purchases with sandbox for details.\n\nUpon launching, the app queries the App Store about the product identifiers in ProductIds.plist. When successful, it displays a list of products available for sale in the App Store. Tap any product in that list to purchase it. When you receive a prompt to authenticate the purchase, use your test user account. If the product request fails, see invalidProductIdentifiers for reasons the App Store may return invalid product identifiers.\n\nDisplay available products for sale with localized pricing\n\nThe sample configures the app so it confirms that the user has authorization to make payments on the device before presenting products for sale.\n\nvar isAuthorizedForPayments: Bool {\n    return SKPaymentQueue.canMakePayments()\n}\n\n\nAfter the app confirms authorization, it sends a products request to the App Store to fetch localized product information. Querying the App Store ensures that the app only presents users with products available for purchase. The app initializes the products request with a list of product identifiers associated with products to sell in its UI. Be sure to keep a strong reference to the products request object; the system may release it before the request completes. See Product ID for more information.\n\nfileprivate func fetchProducts(matchingIdentifiers identifiers: [String]) {\n    // Create a set for the product identifiers.\n    let productIdentifiers = Set(identifiers)\n    \n    // Initialize the product request with the above identifiers.\n    productRequest = SKProductsRequest(productIdentifiers: productIdentifiers)\n    productRequest.delegate = self\n    \n    // Send the request to the App Store.\n    productRequest.start()\n}\n\n\nThe App Store responds to the products request with an SKProductsResponse object. Its products property contains information about all the products that are available for purchase in the App Store. The app uses this property to update its UI. The response’s invalidProductIdentifiers property includes all product identifiers that the App Store doesn’t recognize. See invalidProductIdentifiers for reasons the App Store may return invalid product identifiers.\n\n// Contains products with identifiers that the App Store recognizes. As such, they are available for purchase.\nif !response.products.isEmpty {\n    availableProducts = response.products\n}\n\n\n// invalidProductIdentifiers contains all product identifiers that the App Store doesn’t recognize.\nif !response.invalidProductIdentifiers.isEmpty {\n    invalidProductIdentifiers = response.invalidProductIdentifiers\n}\n\n\nTo display the price of a product in the UI, the app uses the locale and currency that the App Store returns. For instance, consider a user who is logged in to the French App Store and their device uses the United States locale. When attempting to purchase a product, the App Store displays the product’s price in Euros. Converting and showing the product’s price in U.S. dollars to match the device’s locale would be incorrect.\n\nextension SKProduct {\n    /// - returns: The cost of the product formatted in the local currency.\n    var regularPrice: String? {\n        let formatter = NumberFormatter()\n        formatter.numberStyle = .currency\n        formatter.locale = self.priceLocale\n        return formatter.string(from: self.price)\n    }\n}\n\nInteract with the app to purchase products\n\nUsers can tap any product available for sale in the UI to purchase it. The app allows users to restore non-consumable products and auto-renewable subscriptions. The sample implements the Restore button and Settings > Restore all restorable purchases to implement this feature in the iOS and tvOS version of the app, respectively. It implements the Store > Restore menu item to restore purchases in the macOS version of the app. Tapping any purchased item brings up purchase information, such as product identifier, transaction identifier, and transaction date. When the purchase is a restored one, the purchase information also contains its original transaction’s identifier and date.\n\nHandle payment transaction states\n\nWhen a transaction is pending in the payment queue, StoreKit notifies the app’s transaction observer by calling its paymentQueue(_:updatedTransactions:) method. Every transaction has five possible states, including SKPaymentTransactionState.purchasing, SKPaymentTransactionState.purchased, SKPaymentTransactionState.failed, SKPaymentTransactionState.restored, and SKPaymentTransactionState.deferred. For more information, see SKPaymentTransactionState. The observer’s paymentQueue(_:updatedTransactions:) needs to be able to respond to any of these states at any time.\n\nfunc paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {\n    for transaction in transactions {\n        switch transaction.transactionState {\n        case .purchasing: break\n        // Don’t block the UI. Allow the user to continue using the app.\n        case .deferred: print(Messages.deferred)\n        // The purchase was successful.\n        case .purchased: handlePurchased(transaction)\n        // The transaction failed.\n        case .failed: handleFailed(transaction)\n        // There are restored products.\n        case .restored: handleRestored(transaction)\n        @unknown default: fatalError(Messages.unknownPaymentTransaction)\n        }\n    }\n}\n\n\nWhen a transaction fails, the app inspects the error property to determine what happened. The app only displays errors with code that is different from paymentCancelled.\n\n// Don’t send any notifications when the user cancels the purchase.\nif (transaction.error as? SKError)?.code != .paymentCancelled {\n    DispatchQueue.main.async {\n        self.delegate?.storeObserverDidReceiveMessage(message)\n    }\n}\n\n\nWhen the user defers a transaction, apps need to allow them to continue using the UI while waiting for StoreKit to update the transaction.\n\nRestore completed purchases\n\nWhen users purchase non-consumables, auto-renewable subscriptions, or non-renewing subscriptions, they expect them to be available on all their devices indefinitely. The app provides a UI that allows users to restore their past purchases. See Original API for in-app purchase for more information.\n\n@IBAction func restore(_ sender: UIBarButtonItem) {\n    // Calls StoreObserver to restore all restorable purchases.\n    StoreObserver.shared.restore()\n}\n\n\nThe sample uses restoreCompletedTransactions() to restore non-consumables and auto-renewable subscriptions. StoreKit notifies the app’s transaction observer by calling paymentQueue(_:updatedTransactions:) with a transaction state of .restored for each restored transaction. Restoring non-renewing subscriptions isn’t within the scope of this sample code project. For information about restore failures, see restoreCompletedTransactions().\n\nProvide content and finish the transaction\n\nApps need to deliver the content or unlock the purchased functionality after receiving a transaction with a state of .purchased or .restored. These states indicate that the App Store has received a payment for a product from the user.\n\nUnfinished transactions stay in the payment queue. StoreKit calls the app’s persistent observer’s paymentQueue(_:updatedTransactions:) each time upon launching or resuming from the background until the app finishes these transactions. As a result, the App Store may repeatedly prompt users to authenticate their purchases or prevent them from purchasing products from the app.\n\nThe sample calls finishTransaction(_:) on transactions with a state of .failed, .purchased, or .restored to remove them from the queue. Finished transactions aren’t recoverable. Therefore, apps need to provide the purchased content or complete their purchase process before finishing transactions.\n\n// Finish the successful transaction.\nSKPaymentQueue.default().finishTransaction(transaction)\n\nSee Also\nEssentials\nSetting up the transaction observer for the payment queue\nEnable your app to receive and handle transactions by adding an observer.\nclass SKPaymentQueue\nA queue of payment transactions for the App Store to process.\nprotocol SKPaymentTransactionObserver\nA set of methods that process transactions, unlock purchased functionality, and continue promoted in-app purchases.\nprotocol SKPaymentQueueDelegate\nThe protocol that provides information needed to complete transactions.\nclass SKRequest\nAn abstract class that represents a request to the App Store."
  },
  {
    "title": "SKPaymentQueue",
    "url": "https://developer.apple.com/documentation/storekit/skpaymentqueue",
    "html": "Overview\n\nThe payment queue communicates with the App Store and presents a user interface so that the user can authorize payment. The contents of the queue are persistent between launches of your app.\n\nTo process a payment, first add at least one observer object (SKPaymentTransactionObserver) to the queue (see add(_:)). Then, add a payment object (SKPayment) for the item the user wants to purchase. Each time you add a payment object, the queue creates a transaction object (SKPaymentTransaction) to process that payment and enqueues it to be processed. After payment is fulfilled, the queue updates the transaction object and then calls any observer objects to provide them the updated transaction. Your observer should process the transaction and then remove it from the queue.\n\nThe exact mechanism you use to process a processed transaction depends on the design of your app and the product being purchased. Here are a few common examples:\n\nIf the product is a feature already built into your app, your app enables the feature to process the transaction.\n\nIf the product includes downloadable content provided by the App Store, your app retrieves the SKDownload objects from the transaction and ask the payment queue to download them. You provide the actual content files to be served by the App Store to App Store Connect when you create the product information.\n\nIf the product represents downloadable content provided by your own server, your app might open a network connection to your server and download the content from there.\n\nFor more information on designing the payment processing portion of your app, see In-App Purchase Programming Guide.\n\nTopics\nDetermining Whether the User Can Make Payments\nclass func canMakePayments() -> Bool\nA method that indicates whether the person can make purchases.\nDetermining Store Content\nvar storefront: SKStorefront?\nThe App Store storefront of the device.\nGetting the Queue\nclass func `default`() -> Self\nReturns the default payment queue instance.\nAdding, Getting, and Removing Observers\nfunc add(any SKPaymentTransactionObserver)\nAdds an observer to the payment queue.\nvar transactionObservers: [any SKPaymentTransactionObserver]\nAn array of all active payment queue observers.\nfunc remove(any SKPaymentTransactionObserver)\nRemoves an observer from the payment queue.\nManaging Transactions\nvar delegate: (any SKPaymentQueueDelegate)?\nA delegate that provides information needed to complete transactions.\nvar transactions: [SKPaymentTransaction]\nReturns an array of pending transactions.\nfunc add(SKPayment)\nAdds a payment request to the queue.\nfunc finishTransaction(SKPaymentTransaction)\nNotifies the App Store that the app finished processing the transaction.\nRestoring Purchases\nfunc restoreCompletedTransactions()\nAsks the payment queue to restore previously completed purchases.\nfunc restoreCompletedTransactions(withApplicationUsername: String?)\nAsks the payment queue to restore previously completed purchases, providing an opaque identifier for the user’s account.\nShowing Price Consent\nfunc showPriceConsentIfNeeded()\nAsks the system to display the price consent sheet if the user hasn’t yet responded to a subscription price increase.\nRedeeming Codes\nfunc presentCodeRedemptionSheet()\nDisplays a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nDownloading Content\nfunc start([SKDownload])\nAdds a set of downloads to the download list.\nDeprecated\nfunc cancel([SKDownload])\nRemoves a set of downloads from the download list.\nDeprecated\nfunc pause([SKDownload])\nPauses a set of downloads.\nDeprecated\nfunc resume([SKDownload])\nResumes a set of downloads.\nDeprecated\nRelationships\nInherits From\nNSObject\nConforms To\nSendable\nSee Also\nEssentials\nSetting up the transaction observer for the payment queue\nEnable your app to receive and handle transactions by adding an observer.\nOffering, completing, and restoring in-app purchases\nFetch, display, purchase, validate, and finish transactions in your app.\nprotocol SKPaymentTransactionObserver\nA set of methods that process transactions, unlock purchased functionality, and continue promoted in-app purchases.\nprotocol SKPaymentQueueDelegate\nThe protocol that provides information needed to complete transactions.\nclass SKRequest\nAn abstract class that represents a request to the App Store."
  },
  {
    "title": "Setting up the transaction observer for the payment queue",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/setting_up_the_transaction_observer_for_the_payment_queue",
    "html": "Overview\n\nTo process transactions in your app, you need to create and add an observer to the payment queue. The observer object responds to new transactions and synchronizes the queue of pending transactions with the App Store, and the payment queue prompts users to authorize payment. It’s important to add the transaction observer at app launch to ensure you don't miss payment queue notifications that the system may send when the app launches.\n\nCreate an observer\n\nCreate and build a custom observer class to handle changes to the payment queue.\n\nclass StoreObserver: NSObject, SKPaymentTransactionObserver {\n                ....\n    //Initialize the store observer.\n    override init() {\n        super.init()\n        //Other initialization here.\n    }\n\n\n    //Observe transaction updates.\n    func paymentQueue(_ queue: SKPaymentQueue,updatedTransactions transactions: [SKPaymentTransaction]) {\n        //Handle transaction states here.\n    }\n                ....\n}\n\n\nCreate an instance of this observer class to act as the observer of changes to the payment queue.\n\nlet iapObserver = StoreObserver()\n\n\nTip\n\nConsider creating your observer as a shared instance of the class for global reference in any other class. A shared instance also ensures the lifetime of the object, so that the same instance handles callbacks for the SKPaymentTransactionObserver protocol.\n\nAfter you create the transaction observer, you can add it to the payment queue.\n\nAdd an observer\n\nStoreKit attaches your observer to the queue when your app calls.\n\nSKPaymentQueue.default().add(iapObserver)\n\n\nStoreKit can notify your SKPaymentTransactionObserver instance automatically when the content of the payment queue changes upon resuming or while running your app.\n\nImplement the transaction observer.\n\nimport UIKit\nimport StoreKit\n\n\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n                ....\n    // Attach an observer to the payment queue.\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {\n        SKPaymentQueue.default().add(iapObserver)\n        return true\n    }\n\n\n    // The system calls this when the app is about to terminate.\n    func applicationWillTerminate(_ application: UIApplication) {\n        // Remove the observer.\n        SKPaymentQueue.default().remove(iapObserver)\n    }\n                ....\n}\n\n\nIt’s important to add the observer at launch, in application(_:didFinishLaunchingWithOptions:), to ensure that it persists during all launches of your app, receives all payment queue notifications, and continues transactions that may initiate outside the app, such as:\n\nPromoted in-app purchases. For more information, see Promoting in-app purchases.\n\nBackground subscription renewals\n\nInterrupted purchases\n\nThe observer needs to be persistent so the system doesn't deallocate it when it sends the app to the background. Only a persistent observer can receive transactions that may occur while your app is in the background, such as a renewal transaction for an auto-renewable subscription.\n\nSee Also\nEssentials\nOffering, completing, and restoring in-app purchases\nFetch, display, purchase, validate, and finish transactions in your app.\nclass SKPaymentQueue\nA queue of payment transactions for the App Store to process.\nprotocol SKPaymentTransactionObserver\nA set of methods that process transactions, unlock purchased functionality, and continue promoted in-app purchases.\nprotocol SKPaymentQueueDelegate\nThe protocol that provides information needed to complete transactions.\nclass SKRequest\nAn abstract class that represents a request to the App Store.\nRelated Documentation\nfunc add(any SKPaymentTransactionObserver)\nAdds an observer to the payment queue."
  },
  {
    "title": "PaymentMethodBinding.PaymentMethodBindingError",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/paymentmethodbindingerror",
    "html": "Overview\n\nThe methods of PaymentMethodBinding may return these errors, as well as the StoreKitError.userCancelled error.\n\nTopics\nGetting error codes\ncase failed\nThe initialization or binding operation failed.\ncase invalidPinningID\nThe in-app binding identifier is invalid or expired.\ncase notEligible\nThe user isn’t eligible.\nGetting error descriptions\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA string that describes the reason for the failure.\nvar helpAnchor: String?\nA localized message that provides additional information if the user requests help.\nvar localizedDescription: String\nA localized message that describes the error.\nvar recoverySuggestion: String?\nA message that contains a suggestion for recovering from the error.\nComparing and hashing errors\nstatic func != (PaymentMethodBinding.PaymentMethodBindingError, PaymentMethodBinding.PaymentMethodBindingError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (PaymentMethodBinding.PaymentMethodBindingError, PaymentMethodBinding.PaymentMethodBindingError) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nLocalizedError"
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/4143421",
    "html": "See Also\nComparing and hashing bindings\nstatic func != (PaymentMethodBinding, PaymentMethodBinding) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/4143420",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing bindings\nstatic func == (PaymentMethodBinding, PaymentMethodBinding) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/4143437-id",
    "html": "Discussion\n\nNote\n\nThis documentation comment was inherited from Identifiable.\n\nSee Also\nCreating and identifying bindings\nlet id: String\nThe in-app binding identifier.\ntypealias PaymentMethodBinding.ID\nA type that represents the identifier of a payment account binding."
  },
  {
    "title": "bind()",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/4143433-bind",
    "html": "Discussion\n\nImportant\n\nThis method displays a system prompt that asks users to authenticate with their Apple ID. Call this method only after an explicit user action, like tapping or clicking a button.\n\nThis method displays an Apple sheet that asks the user to confirm whether to add the payment method associated with the in-app binding ID (id). If the user confirms adding the payment method, it becomes the user’s primary payment method for media purchases and subscriptions from Apple.\n\nThe binding succeeds if this method doesn’t throw an error.\n\nThis method throws an error in any of the following conditions:\n\nThe user cancels the sheet and doesn’t confirm the payment method update.\n\nThe in-app binding ID (id) is invalid or expired.\n\nThe user isn’t eligible.\n\nThe app isn’t entitled to use this API.\n\nFor more information about the errors, see PaymentMethodBinding.PaymentMethodBindingError and StoreKitError.userCancelled."
  },
  {
    "title": "PaymentMethodBinding.ID",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/id",
    "html": "See Also\nCreating and identifying bindings\nlet id: String\nThe in-app binding identifier.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when PaymentMethodBinding conforms to AnyObject."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/4143435-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing bindings\nstatic func != (PaymentMethodBinding, PaymentMethodBinding) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (PaymentMethodBinding, PaymentMethodBinding) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/4143434-hash",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing bindings\nstatic func != (PaymentMethodBinding, PaymentMethodBinding) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (PaymentMethodBinding, PaymentMethodBinding) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding/4143436-id",
    "html": "Discussion\n\nThis identifier is the in-app binding identifier that your server receives from the Apple server when your server initiates payment method binding.\n\nRelationships\nFrom Protocol\nIdentifiable\nSee Also\nCreating and identifying bindings\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when PaymentMethodBinding conforms to AnyObject.\ntypealias PaymentMethodBinding.ID\nA type that represents the identifier of a payment account binding."
  },
  {
    "title": "Product.CollectionTaskState",
    "url": "https://developer.apple.com/documentation/storekit/product/collectiontaskstate",
    "html": "Topics\nCollection task states\ncase loading\ncase success([Product], unavailable: [Product.ID])\ncase failure(any Error)\nRelationships\nConforms To\nSendable\nSee Also\nLoading products\nenum Product.TaskState"
  },
  {
    "title": "SKStoreProductParameterAdNetworkCampaignIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameteradnetworkcampaignidentifier",
    "html": "Discussion\n\nThe value for this key is an NSNumber. Ad networks determine their own campaign identifiers, which must be an integer >=1 and <=100.\n\nUse SKStoreProductParameterAdNetworkSourceIdentifier instead of this value to generate version 4 and later signatures.\n\nSee Also\nRequired keys\nlet SKStoreProductParameterAdNetworkIdentifier: String\nThe key that represents the advertising network’s unique identifier.\nlet SKStoreProductParameterAdNetworkTimestamp: String\nThe key that represents the UNIX time, in milliseconds, of the ad impression.\nlet SKStoreProductParameterAdNetworkNonce: String\nThe key that represents a random value to use for added security.\nlet SKStoreProductParameterAdNetworkAttributionSignature: String\nThe key that represents the advertising network’s cryptographic signature to use for install validation."
  },
  {
    "title": "Message.Messages.Element",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/element",
    "html": "See Also\nCreating an iterator\nfunc makeAsyncIterator() -> Message.Messages.AsyncIterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Message.Messages.AsyncIterator\nThe asynchronous iterator that produces elements of the asynchronous sequence."
  },
  {
    "title": "Message.Messages.AsyncIterator",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/asynciterator",
    "html": "Topics\nGetting the Next Element\nfunc next() -> Message.Messages.Element?\ntypealias Message.Messages.AsyncIterator.Element\nRelationships\nFrom Protocol\nAsyncSequence\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> Message.Messages.AsyncIterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\ntypealias Message.Messages.Element\nThe type of element traversed by the iterator."
  },
  {
    "title": "musicCatalogSubscriptionEligible",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecapability/2609457-musiccatalogsubscriptioneligible",
    "html": "See Also\nIdentifying Cloud Service Capabilities\nstatic var musicCatalogPlayback: SKCloudServiceCapability\nThe device allows playback of Apple Music catalog tracks.\nstatic var addToCloudMusicLibrary: SKCloudServiceCapability\nThe device allows tracks to be added to the user’s music library."
  },
  {
    "title": "musicCatalogPlayback",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecapability/1620625-musiccatalogplayback",
    "html": "See Also\nIdentifying Cloud Service Capabilities\nstatic var musicCatalogSubscriptionEligible: SKCloudServiceCapability\nThe device allows subscription to the Apple Music catalog.\nstatic var addToCloudMusicLibrary: SKCloudServiceCapability\nThe device allows tracks to be added to the user’s music library."
  },
  {
    "title": "invalidCampaignId",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925705-invalidcampaignid",
    "html": "Discussion\n\nCheck that the campaign identifier is a valid value. For more information, see SKStoreProductParameterAdNetworkCampaignIdentifier for StoreKit-rendered ads, and adCampaignIdentifier for view-through ads.\n\nSee Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "impressionNotFound",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925703-impressionnotfound",
    "html": "Discussion\n\nThis error may occur if an app calls endImpression(_:completionHandler:) before calling startImpression(_:completionHandler:).\n\nSee Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "setAdditionalValue(_:forKey:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appclipconfiguration/3571385-setadditionalvalue",
    "html": "Parameters\nvalue\n\nThe value to associate with the key.\n\nkey\n\nThe string that identifies an additional value.\n\nDiscussion\n\nSet additional values to verify and associate an app installation with an ad campaign. For more information, see SKAdNetwork.\n\nSee Also\nVerifying Advertising Campaigns\nvar campaignToken: String?\nA token you use to represent an ad campaign and measure its effectiveness.\nvar providerToken: String?\nA token that represents the provider of an app promotion campaign, and that you use to measure the campaign’s effectiveness.\nfunc additionalValue(forKey: String) -> Any?\nReturns the object associated with the key."
  },
  {
    "title": "SKOverlay.TransitionContext",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/transitioncontext",
    "html": "Overview\n\nFor more information on animating UI changes while the system presents or dismisses an overlay, see storeOverlayWillStartPresentation(_:transitionContext:) and storeOverlayWillStartDismissal(_:transitionContext:).\n\nTopics\nAdding an Animation\nfunc addAnimation(() -> Void)\nAdds a closure you can use to animate view properties.\nvar startFrame: CGRect\nThe size and location of the overlay before the transition.\nvar endFrame: CGRect\nThe size and location of the overlay at the end of the transition.\nRelationships\nInherits From\nNSObject\nSee Also\nResponding to the Overlay’s Appearance and Disappearance\nfunc storeOverlayWillStartPresentation(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform presents an overlay.\nfunc storeOverlayDidFinishPresentation(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform finished presenting an overlay.\nfunc storeOverlayWillStartDismissal(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform dismisses an overlay.\nfunc storeOverlayDidFinishDismissal(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that platform finished dismissing an overlay."
  },
  {
    "title": "position",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appclipconfiguration/3571384-position",
    "html": "See Also\nCreating an App Clip Configuration\ninit(position: SKOverlay.Position)\nCreates an object that represents the attributes of an overlay you use to recommend an App Clip’s corresponding app.\nenum SKOverlay.Position\nConstants that identify the position of an overlay on the screen."
  },
  {
    "title": "init(position:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appclipconfiguration/3571383-init",
    "html": "Parameters\nposition\n\nThe position of the overlay on the screen.\n\nSee Also\nCreating an App Clip Configuration\nvar position: SKOverlay.Position\nThe position of the overlay on the screen.\nenum SKOverlay.Position\nConstants that identify the position of an overlay on the screen."
  },
  {
    "title": "adNetworkIdMissing",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925695-adnetworkidmissing",
    "html": "Discussion\n\nThe value you specify for your ad network identifier in your ad impresion must match the value in the Info.plist. An app that participates in ad campaigns by displaying ads must include the ad network identifiers in its Info.plist. For more information, see Configuring a source app.\n\nSee Also\nGetting Error Codes\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "invalidAdvertisedAppId",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3928246-invalidadvertisedappid",
    "html": "Discussion\n\nAd networks provide an advertised app identifier when signing an ad impression. If you’re providing a StoreKit-rendered ad, check that the value you set for SKStoreProductParameterITunesItemIdentifier in loadProduct(withParameters:completionBlock:) is a valid app identifer. If you’re providing a view-through ad, check the value of advertisedAppStoreItemIdentifier.\n\nSee Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "impressionMissingRequiredValue",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925702-impressionmissingrequiredvalue",
    "html": "Discussion\n\nCheck that your instance of SKAdImpression provides all of the required values.\n\nSee Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "campaignToken",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appclipconfiguration/3571382-campaigntoken",
    "html": "Discussion\n\nA campaign token is a 40-byte string that represents an ad campaign. By setting the campaignToken, you can measure the effectiveness of an Apple Services Performance Partners Program link or an App Store Connect Analytics campaign.\n\nFor more information, see Apple Services Performance Partners Program and App Store Connect.\n\nSee Also\nVerifying Advertising Campaigns\nvar providerToken: String?\nA token that represents the provider of an app promotion campaign, and that you use to measure the campaign’s effectiveness.\nfunc setAdditionalValue(Any?, forKey: String)\nSets an additional value for a key, such as a value for measuring the effectiveness of an ad campaign.\nfunc additionalValue(forKey: String) -> Any?\nReturns the object associated with the key."
  },
  {
    "title": "storeOverlayDidFailToLoad(_:error:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlaydelegate/3566705-storeoverlaydidfailtoload",
    "html": "Parameters\noverlay\n\nAn overlay object that failed to load.\n\nerror\n\nAn indication of why the overlay failed to load.\n\nDiscussion\n\nCommon cases for a failure when loading an overlay are:\n\nUsing invalid iTunes identifiers.\n\nTrying to present an overlay for media that’s not an app.\n\nTrying to present an overlay from an app extension or the simulator."
  },
  {
    "title": "deviceVerificationID",
    "url": "https://developer.apple.com/documentation/storekit/appstore/3803197-deviceverificationid",
    "html": "Discussion\n\nUse this property to verify whether an App Store-signed JSON Web Signature (JWS) is valid for the current device. The JWS may be one of the following:\n\nA jwsRepresentation representing a signed transaction\n\nA jwsRepresentation representing a signed subscription renewal information\n\nA jwsRepresentation representing a signed app transaction.\n\nTo verify that the JWS is valid for the current device, follow these steps:\n\nAppend the lowercased UUID string representation of this property, deviceVerificationID, after the lowercased UUID string representation of the device verification nonce. For a transaction, the nonce is deviceVerificationNonce. For subscription renewal information, the nonce is deviceVerificationNonce. For an app transaction, the nonce is deviceVerificationNonce.\n\nCompute the SHA-384 hash of the appended UUID strings.\n\nVerify that the SHA-384 digest is equal to the device verification property. For a transaction, the device verification property is deviceVerification. For subscription renewal information, the device verification property is deviceVerification. For an app transaction, the device verifcation property is deviceVerification."
  },
  {
    "title": "SKANError.Code.invalidConversionValue",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/invalidconversionvalue",
    "html": "Discussion\n\nApps provide a conversion value when calling updatePostbackConversionValue(_:completionHandler:) or updateConversionValue(_:). Check that the conversion value you provide is within the allowed range.\n\nSee Also\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase impressionTooShort\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unknown\nAn unknown error occurred.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "SubscriptionStoreControlBackground",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolbackground",
    "html": "Topics\nBackground types\nstatic var automatic: SubscriptionStoreControlBackground\nstatic var gradientMaterial: SubscriptionStoreControlBackground\nstatic var gradientMaterialOnScroll: SubscriptionStoreControlBackground\nSee Also\nStyling subscription store views\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> View\nSets the background style for picker items of the subscription store view instances within a view.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> View\nSets the control style for subscription store views within a view.\nprotocol SubscriptionStoreControlStyle\nA type that specifies the appearance and interaction of controls in the subscription store view instances within the view hierarchy.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> View\nSets a view to use to decorate individual subscription options within a subscription store view."
  },
  {
    "title": "Product.PurchaseError",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseerror",
    "html": "Overview\n\nThe purchase(options:) function may throw a purchase error.\n\nTopics\nGetting Purchase Error Codes\ncase invalidOfferIdentifier\nThe promotional offer identifier provided in the purchase options is invalid.\ncase productUnavailable\nThe product isn’t available.\ncase purchaseNotAllowed\nThe user isn’t allowed to make purchases.\ncase ineligibleForOffer\nThe user isn't eligible for the offer.\ncase invalidOfferPrice\nThe price of the offer isn't valid.\ncase invalidOfferSignature\nThe offer signature isn't valid.\ncase invalidQuantity\nThe quantity to purchase is invalid.\ncase missingOfferParameters\nThe offer parameters are missing.\nGetting Error Properties\nvar localizedDescription: String\nvar errorDescription: String?\nvar failureReason: String?\nvar helpAnchor: String?\nvar recoverySuggestion: String?\nComparing Errors\nstatic func != (Product.PurchaseError, Product.PurchaseError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.PurchaseError, Product.PurchaseError) -> Bool\nvar hashValue: Int\nfunc hash(into: inout Hasher)\nRelationships\nConforms To\nError\nLocalizedError\nSee Also\nPurchasing a product\nfunc purchase(options: Set<Product.PurchaseOption>) -> Product.PurchaseResult\nInitiates a purchase for the product with the App Store and displays the confirmation sheet.\nfunc purchase(confirmIn: some UIScene, options: Set<Product.PurchaseOption>) -> Product.PurchaseResult\nInitiates a purchase for the product with the App Store and displays the confirmation sheet.\nstruct Product.PurchaseOption\nOptional settings for a product purchase.\nenum Product.PurchaseResult\nThe result of a purchase."
  },
  {
    "title": "subscriptionPeriodFormatStyle",
    "url": "https://developer.apple.com/documentation/storekit/product/4044348-subscriptionperiodformatstyle",
    "html": "Discussion\n\nUse this format style to format text that describes a subscription period, including its length and unit, such as “1 week”, “2 months”, and so on.\n\nSee Also\nDisplaying a product description and price\nlet displayName: String\nThe localized display name of the product, if it exists.\nlet description: String\nThe localized description of the product.\nlet displayPrice: String\nThe localized string representation of the product price, suitable for display.\nlet price: Decimal\nThe decimal representation of the cost of the product, in local currency.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency\nThe format style for the numbers in the price of the product.\nvar subscriptionPeriodUnitFormatStyle: Product.SubscriptionPeriod.Unit.FormatStyle\nThe format style for subscription period units, such as week, month, or year."
  },
  {
    "title": "subscriptionPeriodUnitFormatStyle",
    "url": "https://developer.apple.com/documentation/storekit/product/4044349-subscriptionperiodunitformatstyl",
    "html": "See Also\nDisplaying a product description and price\nlet displayName: String\nThe localized display name of the product, if it exists.\nlet description: String\nThe localized description of the product.\nlet displayPrice: String\nThe localized string representation of the product price, suitable for display.\nlet price: Decimal\nThe decimal representation of the cost of the product, in local currency.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency\nThe format style for the numbers in the price of the product.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var subscriptionPeriodFormatStyle: Date.ComponentsFormatStyle\nThe format style for the date components related to a subscription’s duration."
  },
  {
    "title": "Promoting in-app purchases",
    "url": "https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver/promoting_in-app_purchases",
    "html": "Overview\n\nStarting in iOS 11, you can promote in-app purchases on the App Store.\n\nNote\n\nTo support promoted in-app purchases in apps with a minimum version of iOS 16.4 and later, use PurchaseIntent. For more information, see Supporting promoted in-app purchases in your app.\n\nPromoted in-app purchases appear on your product page, can appear in search results, and can appear as featured items on an appropriate tab on the App Store. Users can start an in-app purchase on the App Store and then transition to your app to continue the transaction. If your app isn’t installed, they receive a prompt to download it.\n\nPromoting in-app purchases requires two steps:\n\nIn App Store Connect, set up promotions by uploading promotional images. Use the App Store Promotions feature in App Store Connect to manage their order and visibility. For more information about the setup, see Promote in-app purchases.\n\nIn your app, implement the delegate method paymentQueue(_:shouldAddStorePayment:for:) from the SKPaymentTransactionObserver protocol to handle the purchase.\n\nImportant\n\nTo enable promoted in-app purchases, your app needs to use either PurchaseIntent (starting in iOS 16.4) or paymentQueue(_:shouldAddStorePayment:for:) (starting in iOS 11). Don’t use both at the same time. If necessary, use conditional compilation to identify the OS version the app is running in. For more information, see Running code on a specific platform or OS version.\n\nTo customize the list of promoted in-app purchases for users, you can override their default order and visibility using SKProductStorePromotionController. Use overrides to show promotions that are relevant to the user. Overrides are specific to a device, and take effect after the user launches the app at least once. Using SKProductStorePromotionController is optional and isn’t required for your in-app purchases to appear on the App Store.\n\nFor marketing guidance on this feature, see Promoting Your In-App Purchases.\n\nNote\n\nPromoted in-app purchases aren’t available to compatible iPad or iPhone apps running in visionOS.\n\nComplete the purchase in the app\n\nWhen a user selects an in-app product to purchase on the App Store, StoreKit automatically opens your app and sends the transaction information to the delegate in the SKPaymentTransactionObserver protocol. Your app needs to complete the purchase transaction and any related actions that are specific to it.\n\nIn the delegate method, return true to continue the transaction, or false to defer or cancel it.\n\nIf your app isn’t installed when the user selects to purchase the in-app product, the App Store automatically downloads the app or prompts the user to purchase it. If the installed version of your app is an older version that doesn’t support in-app purchase promotions, the App Store prompts the user to upgrade the app.\n\nContinue the transaction\n\nTo continue an in-app purchase transaction, implement the delegate method in the SKPaymentTransactionObserver protocol and return true. StoreKit then displays the payment sheet, and the user can complete the transaction.\n\n//Continuing a transaction from the App Store.\n\n\n//MARK: - SKPaymentTransactionObserver\n\n\nfunc paymentQueue(_ queue: SKPaymentQueue, shouldAddStorePayment payment: SKPayment,\n        for product: SKProduct) -> Bool {\n    // Check to see if you can complete the transaction.\n    // Return true if you can.\n    return true\n}\n\n\nDefer or cancel the transaction\n\nIf your app needs to defer or cancel a transaction, return false. For example, you may need to defer a transaction if the user is in the middle of onboarding, and continue it after they complete the onboarding. Or, you may need to cancel a transaction if the user has already unlocked the product they’re trying to buy.\n\nTo defer a transaction:\n\nSave the payment to use when the app is ready. The payment already contains information about the product. Don’t create a new SKPayment with the same product.\n\nReturn false.\n\nAfter the user finishes the onboarding or other actions that require a deferral, send the saved payment to the payment queue as you do with a typical in-app purchase.\n\nTo cancel a transaction:\n\nReturn false.\n\nProvide feedback to the user. Although this step is optional, if you don’t provide feedback, the app’s lack of action after the user selects to purchase an in-app product in the App Store may seem like a bug.\n\n//Handling a transaction from the App Store.\n\n\n//MARK: - SKPaymentTransactionObserver\n\n\nfunc paymentQueue(_ queue: SKPaymentQueue, shouldAddStorePayment payment: SKPayment,\n        for product: SKProduct) -> Bool {\n\n\n    // Add code here to check if your app needs to defer the transaction.\n    let shouldDeferPayment = ...\n    // If you need to defer until onboarding is complete, save the payment and return false.\n    if shouldDeferPayment {\n        self.savedPayment = payment\n        return false\n    }\n\n\n    // Add code here to check if your app needs to cancel the transaction.\n    let shouldCancelPayment = ...\n    // If you need to cancel the transaction, then return false:\n    if shouldCancelPayment {\n        return false\n    }\n}\n\n\n// If you cancel the transaction, provide feedback to the user.\n\n\n// Continuing a previously deferred payment.\nSKPaymentQueue.default().add(savedPayment)\n\n\nGet visibility settings\n\nTo get the visibility settings for a promoted product, call fetchStorePromotionVisibility(for:completionHandler:), providing the product information.\n\n// Reading visibility override of a promoted in-app purchase.\n\n\n// Fetch product info for \"Hidden Beaches pack.\"\n\n\nlet storePromotionController = SKProductStorePromotionController.default()\nstorePromotionController.fetchStorePromotionVisibility(forProduct: hiddenBeaches,\n    completionHandler: { visibility: SKProductSTorePromotionVisiblity, error: Error?) in\n        // visibility == .default\n})\n\n\nOverride visibility settings\n\nFor each device, you can decide whether to make in-app purchases visible or hidden. For example, you may want to hide products the customer already purchased, and show only the products they can buy.\n\nFor example, to hide the Pro Subscription product after a user purchases it, fetch the product information and update the store promotion controller with the .hide setting, as the following code example shows. The Pro Subscription promoted in-app purchase no longer appears in the App Store on the device.\n\n// Hide the promoted product Pro Subscription after the user purchases it.\n\n\nlet storePromotionController = SKProductStorePromotionController.default()\nstorePromotionController.update(storePromotionVisibility: .hide, for: proSubscription,\n    completionHandler: { (error: Error?) in\n        // Completion.\n    })\n\n\nOverride the order of promoted products\n\nYou can customize the promoted in-app purchases on each device by overriding their default order. Use overrides to show promotions that are relevant to the user. For example, you can override the order to promote an in-app purchase that unlocks a level in your game when a user reaches the preceding level.\n\nTo override the promotion order, add the product information to an array in the order they are to appear. Pass the array to the update(storePromotionOrder:completionHandler:) method. The App Store displays the products in the array, followed by the remaining promoted products, which appear in the same relative order that you set in App Store Connect.\n\n// Overriding the order of promoted in-app purchases.\n\n\n// Fetch product information for three products: Pro Subscription, Fishing Hot Spots, and Hidden Beaches.\nlet storePromotionController = SKProductStorePromotionController.default()\n\n\n// Update the order.\nlet newProductsOrder = [hiddenBeaches, proSubscription, fishingHotSpots]\nstorePromotionController.updateStorePromotionOrder(newProductsOrder,\n    completionHandler: { (error: Error?) in\n        // Complete.\n    })\n\n\nCancel order overrides\n\nTo remove overrides and use the default promotion order, send an empty product array to the update(storePromotionOrder:completionHandler:) method. The App Store then displays the promoted in-app purchase products in the default order that you set in App Store Connect.\n\nFetch order overrides\n\nTo get the product promotion order for the device, call fetchStorePromotionOrder(completionHandler:). This method returns an array of products that have an overridden order. If you get an empty array, there aren’t any overrides and the products are in the default order.\n\n// Getting the order override of promoted in-app purchases.\n\n\nlet storePromotionController = SKProductStorePromotionController.default()\nstorePromotionController.fetchStorePromotionOrder(completionHandler: {\n    (products: [SKProduct], error: Error?) in\n        // products == [hiddenBeaches, proSubscription, fishingHotSpots]\n    })\n\n\nSee Also\nPromotions\nTesting promoted in-app purchases\nTest your in-app purchases before making your app available in the App Store.\nclass SKProductStorePromotionController\nA product promotion controller for customizing the order and visibility of in-app purchases per device."
  },
  {
    "title": "StoreKitError.networkError(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror/networkerror",
    "html": "See Also\nStoreKit Error Codes\ncase systemError(any Error)\nA system error occurred.\ncase userCancelled\nThe user canceled.\ncase notAvailableInStorefront\nThe function isn’t available on devices configured for this storefront.\ncase notEntitled\nThe app doesn’t have the appropriate entitlements to use the functionality.\ncase unknown\nAn unknown error occurred."
  },
  {
    "title": "subscribed",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate/3749525-subscribed",
    "html": "Discussion\n\nAn auto-renewable subscription in this state is entitled to service.\n\nSee Also\nGetting the renewal state\nstatic let expired: Product.SubscriptionInfo.RenewalState\nThe subscription expired.\nstatic let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState\nThe subscription is in a billing retry period.\nstatic let inGracePeriod: Product.SubscriptionInfo.RenewalState\nThe subscription is in a billing grace period state.\nstatic let revoked: Product.SubscriptionInfo.RenewalState\nThe App Store has revoked the user’s access to the subscription group."
  },
  {
    "title": "updates",
    "url": "https://developer.apple.com/documentation/storekit/storefront/3851159-updates",
    "html": "Discussion\n\nThe storefront value can change at any time. Use updates to listen for changes in this value. Respond to storefront changes by refreshing the list of your available products.\n\nSee Also\nListening for storefront changes\nstruct Storefront.Storefronts\nAn asynchronous sequence that listens for changes to the storefront."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchase/noticeresult/3925682",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing results\nstatic func == (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchase/noticeresult/3925683",
    "html": "See Also\nComparing and hashing results\nstatic func != (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchase/noticeresult/3925687-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing results\nstatic func != (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchase/noticeresult/3925686-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing results\nstatic func != (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "ExternalPurchase.NoticeResult.cancelled",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchase/noticeresult/cancelled",
    "html": "Discussion\n\nIf your app’s call to presentNoticeSheet() results in this value, you must not show external purchases.\n\nSee Also\nGetting notice sheet results\ncase continuedWithExternalPurchaseToken(token: String)\nDescribes when people chose to continue to view external purchases, and provides the external purchase token."
  },
  {
    "title": "addToCloudMusicLibrary",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecapability/1620629-addtocloudmusiclibrary",
    "html": "See Also\nIdentifying Cloud Service Capabilities\nstatic var musicCatalogPlayback: SKCloudServiceCapability\nThe device allows playback of Apple Music catalog tracks.\nstatic var musicCatalogSubscriptionEligible: SKCloudServiceCapability\nThe device allows subscription to the Apple Music catalog."
  },
  {
    "title": "priceFormatStyle",
    "url": "https://developer.apple.com/documentation/storekit/product/4044347-priceformatstyle",
    "html": "Discussion\n\nThe priceFormatStyle value is a localized number suitable for display.\n\nTo display the price directly, rather than making calculations, use the displayPrice string instead.\n\nSee Also\nDisplaying a product description and price\nlet displayName: String\nThe localized display name of the product, if it exists.\nlet description: String\nThe localized description of the product.\nlet displayPrice: String\nThe localized string representation of the product price, suitable for display.\nlet price: Decimal\nThe decimal representation of the cost of the product, in local currency.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var subscriptionPeriodFormatStyle: Date.ComponentsFormatStyle\nThe format style for the date components related to a subscription’s duration.\nvar subscriptionPeriodUnitFormatStyle: Product.SubscriptionPeriod.Unit.FormatStyle\nThe format style for subscription period units, such as week, month, or year."
  },
  {
    "title": "subscriptionStoreControlIcon(icon:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4204235-subscriptionstorecontrolicon",
    "html": "Parameters\nicon\n\nA closure that takes a Product and Product.SubscriptionInfo and returns a view.\n\nDiscussion\n\nYou can adjust this view to provide a different appearance for each subscription option.\n\nSee Also\nConfiguring subscription store view controls\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> View\nSets the background style for picker items of the subscription store view instances within a view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> View\nConfigures the subscription store views within a view to use a specified button label.\nstruct SubscriptionStoreButtonLabel\nThe label of the subscribe button that a subscription store view uses.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> View\nSets the control style for subscription store views within a view."
  },
  {
    "title": "displayName",
    "url": "https://developer.apple.com/documentation/storekit/product/3749579-displayname",
    "html": "Discussion\n\nThe storefront of the device determines the language of the display name, not the preferred language set on the device. For more information, see Storefront.\n\nNote\n\nWhen you create a new product in App Store Connect or in a StoreKit configuration file, you can test it before you add a product localization. The displayName value is an empty string until you add a localization. For more information on localizations, see Add and remove localizations.\n\nSee Also\nDisplaying a product description and price\nlet description: String\nThe localized description of the product.\nlet displayPrice: String\nThe localized string representation of the product price, suitable for display.\nlet price: Decimal\nThe decimal representation of the cost of the product, in local currency.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency\nThe format style for the numbers in the price of the product.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var subscriptionPeriodFormatStyle: Date.ComponentsFormatStyle\nThe format style for the date components related to a subscription’s duration.\nvar subscriptionPeriodUnitFormatStyle: Product.SubscriptionPeriod.Unit.FormatStyle\nThe format style for subscription period units, such as week, month, or year."
  },
  {
    "title": "ExternalPurchase.NoticeResult",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchase/noticeresult",
    "html": "Overview\n\nThese values return when your app calls presentNoticeSheet().\n\nTopics\nGetting notice sheet results\ncase cancelled\nDescribes when people chose to cancel and not view external purchases.\ncase continuedWithExternalPurchaseToken(token: String)\nDescribes when people chose to continue to view external purchases, and provides the external purchase token.\nComparing and hashing results\nstatic func != (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (ExternalPurchase.NoticeResult, ExternalPurchase.NoticeResult) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nSendable\nSee Also\nOffering an external purchase\nstatic var canPresent: Bool\nA Boolean value that indicates whether the app can successfully present the notice sheet to inform people about external purchases.\nstatic func presentNoticeSheet() -> ExternalPurchase.NoticeResult\nPresents a notice sheet from Apple that informs people before showing external purchases and determines whether your app can present external purchases.\nproperty list key SKExternalPurchase\nA string array of country codes that indicates your app supports external purchases."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954492-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncThrowingMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc reduce<Result>(Result, (Result, Message) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954473-compactmap",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n\nSee Also\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncThrowingMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc reduce<Result>(Result, (Result, Message) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "max(by:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954496-max",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n\nSee Also\nFinding messages\nfunc allSatisfy((Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(Message) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Message) -> Bool) -> Message?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (Message, Message) -> Bool) -> Message?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "min(by:)",
    "url": "https://developer.apple.com/documentation/storekit/message/messages/3954498-min",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n\nSee Also\nFinding messages\nfunc allSatisfy((Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(Message) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Message) -> Bool) -> Message?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Message, Message) -> Bool) -> Message?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "SKStoreProductParameterAdNetworkAttributionSignature",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameteradnetworkattributionsignature",
    "html": "Discussion\n\nThe value for this key is an NSString. The ad network creates the cryptographic signature, used to sign ads. For instructions on generating this value, see Generating the signature to validate StoreKit-rendered ads.\n\nSee Also\nRequired keys\nlet SKStoreProductParameterAdNetworkIdentifier: String\nThe key that represents the advertising network’s unique identifier.\nlet SKStoreProductParameterAdNetworkCampaignIdentifier: String\nThe key that represents the advertising network’s campaign.\nlet SKStoreProductParameterAdNetworkTimestamp: String\nThe key that represents the UNIX time, in milliseconds, of the ad impression.\nlet SKStoreProductParameterAdNetworkNonce: String\nThe key that represents a random value to use for added security."
  },
  {
    "title": "init(_:userInfo:)",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925704-init",
    "html": "Parameters\ncode\n\nThe error code.\n\nuserInfo\n\nThe dictionary of additional information to pass with the error."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925701-hashvalue",
    "html": "See Also\nComparing and Hashing Errors\nstatic func != (SKANError, SKANError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (SKANError, SKANError) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "SKStoreProductParameterAdNetworkNonce",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameteradnetworknonce",
    "html": "Discussion\n\nThe value for this key is an NSUUID. Ad networks generate a random value for this key at the time of the ad impression.\n\nImportant\n\nWhen you generate the signature value (SKStoreProductParameterAdNetworkAttributionSignature), you must sign the nonce as an all-lowercase UUID string representation.\n\nSee Also\nRequired keys\nlet SKStoreProductParameterAdNetworkIdentifier: String\nThe key that represents the advertising network’s unique identifier.\nlet SKStoreProductParameterAdNetworkCampaignIdentifier: String\nThe key that represents the advertising network’s campaign.\nlet SKStoreProductParameterAdNetworkTimestamp: String\nThe key that represents the UNIX time, in milliseconds, of the ad impression.\nlet SKStoreProductParameterAdNetworkAttributionSignature: String\nThe key that represents the advertising network’s cryptographic signature to use for install validation."
  },
  {
    "title": "Product.SubscriptionInfo.RenewalState",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate",
    "html": "Overview\n\nA subscription's renewal state indicates whether an auto-renewable subscription is entitled to service. Subscriptions in the subscribed and inGracePeriod states are entitled to service.\n\nSubscriptions in the expired, inBillingRetryPeriod, and revoked states aren't entitled to service if the user doesn't have other Product.SubscriptionInfo.Status items that give them entitlement to service for that subscription. For example, a user may have a status in the expired state for a subscription that they purchased individually, and another status in the subscribed state for the same subscription, which they get through Family Sharing. In that case, the user has an entitlement to service for that subscription.\n\nFor more information about Family Sharing, see Supporting Family Sharing in your app. For more information about entitlements, see currentEntitlements.\n\nTopics\nGetting the renewal state\nstatic let subscribed: Product.SubscriptionInfo.RenewalState\nThe user is currently subscribed.\nstatic let expired: Product.SubscriptionInfo.RenewalState\nThe subscription expired.\nstatic let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState\nThe subscription is in a billing retry period.\nstatic let inGracePeriod: Product.SubscriptionInfo.RenewalState\nThe subscription is in a billing grace period state.\nstatic let revoked: Product.SubscriptionInfo.RenewalState\nThe App Store has revoked the user’s access to the subscription group.\nGetting a localized description\nvar localizedDescription: String\nA string containing the localized description of the renewal state.\nCreating a renewal state\ninit(rawValue: Int)\nCreates a new instance with the specified raw value.\nComparing and hashing renewal states\nstatic func != (Product.SubscriptionInfo.RenewalState, Product.SubscriptionInfo.RenewalState) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nAccessing the raw value\nlet rawValue: Int\nThe raw value of a renewal state.\ntypealias Product.SubscriptionInfo.RenewalState.RawValue\nA type that represents the raw value of a renewal state.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSee Also\nGetting subscription status information\nlet state: Product.SubscriptionInfo.RenewalState\nThe renewal state of the auto-renewable subscription.\nlet renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>\nThe signed renewal information for the auto-renewable subscription.\nlet transaction: VerificationResult<Transaction>\nThe latest transaction for the subscription group.\nstruct Product.SubscriptionInfo.RenewalInfo\nThe renewal information for an auto-renewable subscription."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/storekit/product/3749584-id",
    "html": "Discussion\n\nNote\n\nThis documentation comment was inherited from Identifiable.\n\nSee Also\nGetting product identifiers and type\nlet id: String\nThe unique product identifier.\ntypealias Product.ID\nA type representing a unique product identifier.\nlet type: Product.ProductType\nThe in-app purchase product type.\nstruct Product.ProductType\nThe types of in-app purchases."
  },
  {
    "title": "type",
    "url": "https://developer.apple.com/documentation/storekit/product/3749591-type",
    "html": "See Also\nGetting product identifiers and type\nlet id: String\nThe unique product identifier.\ntypealias Product.ID\nA type representing a unique product identifier.\nstruct Product.ProductType\nThe types of in-app purchases.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Product conforms to AnyObject."
  },
  {
    "title": "Product.ID",
    "url": "https://developer.apple.com/documentation/storekit/product/id",
    "html": "See Also\nGetting product identifiers and type\nlet id: String\nThe unique product identifier.\nlet type: Product.ProductType\nThe in-app purchase product type.\nstruct Product.ProductType\nThe types of in-app purchases.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Product conforms to AnyObject."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/storekit/product/3749583-id",
    "html": "Relationships\nFrom Protocol\nIdentifiable\nSee Also\nGetting product identifiers and type\ntypealias Product.ID\nA type representing a unique product identifier.\nlet type: Product.ProductType\nThe in-app purchase product type.\nstruct Product.ProductType\nThe types of in-app purchases.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Product conforms to AnyObject."
  },
  {
    "title": "SKStoreProductParameterAdNetworkSourceAppStoreIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameteradnetworksourceappstoreidentifier",
    "html": "Discussion\n\nThe value for this key is an NSNumber. Provide the App Store item identifier of the app that’s displaying the ad.\n\nDuring testing, if you’re using a development-signed build to display the ads and not an app from App Store, use 0 as the item identifier.\n\nSee Also\nRequired keys for SKAdNetwork 2 and later\nlet SKStoreProductParameterAdNetworkVersion: String\nThe key that represents the version of the ad network API."
  },
  {
    "title": "Product.SubscriptionPeriod",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionperiod",
    "html": "Overview\n\nUse the value and the unit together to determine the subscription period. For example, if the unit is Product.SubscriptionPeriod.Unit.month, and the value is 3, the subscription period is three months.\n\nTopics\nGetting the subscription period\nlet value: Int\nThe number of period units.\nlet unit: Product.SubscriptionPeriod.Unit\nThe increment of time for the subscription period.\nenum Product.SubscriptionPeriod.Unit\nUnits of time that describe subscription periods.\nGetting the period date range\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) func dateRange(referenceDate: Date) -> Range<Date>\nThe calculated date range of a subscription period, starting at the reference date.\nFormatting the subscription period\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) func formatted<S>(S, referenceDate: Date) -> S.FormatOutput\nFormats the subscription period using a format style that takes a date range as an input.\nfunc formatted<S>(S, referenceDate: Date) -> S.FormatOutput\nFormats the subscription period using a format style that takes a duration as an input.\nGetting a debug description\nvar debugDescription: String\nA string representation of the subscription period, suitable for debugging.\nComparing and hashing subscription periods\nstatic func != (Product.SubscriptionPeriod, Product.SubscriptionPeriod) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionPeriod, Product.SubscriptionPeriod) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nCustomDebugStringConvertible\nHashable\nSee Also\nGetting subscription information\nlet subscription: Product.SubscriptionInfo?\nThe subscription information for an auto-renewable subscripton.\nstruct Product.SubscriptionInfo\nInformation about an auto-renewable subscription, such as its status, period, subscription group, and subscription offer details.\nstruct Product.SubscriptionOffer\nInformation about a subscription offer that you configure in App Store Connect.\nstruct Product.SubscriptionInfo.Status\nThe renewal status information for an auto-renewable subscription."
  },
  {
    "title": "SKStoreProductParameterAdNetworkVersion",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameteradnetworkversion",
    "html": "Discussion\n\nThe value for this key is an NSString. Set this key to version number \"4.0\", \"3.0\", \"2.2\", “2.1\", or \"2.0\". Use the highest available version whenever possible. For version availability, see SKAdNetwork release notes.\n\nAd networks use this key and the other Ad network install-validation keys when signing ads. For more information, see Generating the signature to validate StoreKit-rendered ads.\n\nSee Also\nRequired keys for SKAdNetwork 2 and later\nlet SKStoreProductParameterAdNetworkSourceAppStoreIdentifier: String\nThe key that represents the App Store ID of the app that displays the ad."
  },
  {
    "title": "isFamilyShareable",
    "url": "https://developer.apple.com/documentation/storekit/product/3749585-isfamilyshareable",
    "html": "Discussion\n\nCheck the value of isFamilyShareable to learn whether an in-app purchase is sharable with the family group.\n\nWhen displaying in-app purchases in your app, indicate whether the product includes Family Sharing to help customers make a selection that best fits their needs.\n\nConfigure your in-app purchases to allow Family Sharing in App Store Connect. For more information about setting up Family Sharing, see Turn-on Family Sharing for in-app purchases."
  },
  {
    "title": "updateConversionValue(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/3566697-updateconversionvalue",
    "html": "Deprecated\n\nUse updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) instead.\n\nParameters\nconversionValue\n\nAn unsigned 6-bit value (>=0 and <=63). The app or the ad network determines the meaning of the value. The default value is 0.\n\nDiscussion\n\nApps that ad networks advertise call updateConversionValue(_:) or registerAppForAdNetworkAttribution() when the app first launches, to register the attribution.\n\nImportant\n\nProvide a valid conversion value within the range of >=0 and <=63 when calling updateConversionValue(_:) to register the attribution. Invalid conversion values cause the method to fail, and the conversion to fail to register.\n\nApps may call updateConversionValue(_:) again within a rolling 24-hour period to update the conversion value. Calling this method serves two purposes:\n\nIt registers the attribution by generating an install notification — the cryptographically signed data that confirms that a user installed and launched this app as a result of an ad.\n\nIt enables the app to provide and update a conversion value.\n\nConversion values are a 6-bit value that the ad network or the app defines. The app decides when to update the value, which it can do any number of times before a rolling 24-hour timer expires. The 24-hour timer restarts each time the app calls this method with a valid conversion value greater than the previous value. When the timer expires, the conversion value is final and subsequent calls to updateConversionValue(_:) have no effect.\n\nThe device sends the install notification postback to the ad network’s URL within 0-24 hours after the timer expires. The postback only contains the final conversion value if sending the data meets Apple’s privacy threshold. Only postbacks with an ad attribution can contain a conversion value; non-winning postbacks don't include a conversion value. For more information, see Receiving ad attributions and postbacks.\n\nAd networks must verify the postback after receiving it. See Verifying an install-validation postback for more information.\n\nSee Also\nDeprecated\nclass func registerAppForAdNetworkAttribution()\nVerifies the first launch of an app installed as a result of an ad.\nDeprecated"
  },
  {
    "title": "status(for:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3822297-status",
    "html": "Parameters\ngroupID\n\nThe subscription group identifier of the subscription to get status for.\n\nReturn Value\n\nAn array of Product.SubscriptionInfo.Status. This array is empty if the customer has never subscribed to a product in this subscription group.\n\nDiscussion\n\nTo get the subscription group identifier of a subscription, see subscriptionGroupID in Product.SubscriptionInfo, or subscriptionGroupID in Transaction. You originally create subscription group identifiers when you set up in-app purchases in App Store Connect. For more information, see Offer auto-renewable subscriptions.\n\nUsers can only buy one auto-renewable subscription within a group at a time. However, the returned array may contain multiple status values if your subscription supports Family Sharing, and the person has access to other subscriptions in the group through Family Sharing. For more information about Family Sharing, see Enable Family Sharing for your subscriptions.\n\nSee Also\nDetermining the subscription status\nvar status: [Product.SubscriptionInfo.Status]\nAn array that contains status information for a subscription group, including renewal and transaction information.\nstruct Product.SubscriptionInfo.Status\nThe renewal status information for an auto-renewable subscription."
  },
  {
    "title": "SKStoreProductParameterAdNetworkSourceIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameteradnetworksourceidentifier",
    "html": "Discussion\n\nThis key is available for ad impressions that use SKAdNetwork 4 and later. The SKStoreProductParameterAdNetworkSourceIdentifier, also known as the hierarchical source identifier, replaces and extends the campaign identifier value, SKStoreProductParameterAdNetworkCampaignIdentifier.\n\nAd networks and developers define the meaning of the hierarchical source identifier. This string represents an integer of up to four digits. You can encode information about your advertisement in each set of digits; you may receive two, three, or all four digits of the sourceIdentifier in the first winning postback, depending on the ad impression’s postback data tier. For more information about the value you may get in the postback, see Receiving postbacks in multiple conversion windows."
  },
  {
    "title": "SKStoreProductViewControllerDelegate",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductviewcontrollerdelegate",
    "html": "Overview\n\nTypically, this protocol is implemented by the view controller in your application that originally displayed the store screen.\n\nTopics\nResponding to a Dismiss Action\nfunc productViewControllerDidFinish(SKStoreProductViewController)\nCalled when the user dismisses the store screen.\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nSetting a delegate\nvar delegate: (any SKStoreProductViewControllerDelegate)?\nThe store view controller’s delegate."
  },
  {
    "title": "subscriptionPeriod",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3749536-subscriptionperiod",
    "html": "See Also\nGetting the subscription period\nstruct Product.SubscriptionPeriod\nValues that represent the duration of time between subscription renewals."
  },
  {
    "title": "customProductPageIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appclipconfiguration/3791474-customproductpageidentifier",
    "html": "Discussion\n\nThe identifier, referred to as the product variant identifier, identifies specific variant product pages from App Store Connect for your app."
  },
  {
    "title": "additionalValue(forKey:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appclipconfiguration/3571381-additionalvalue",
    "html": "Parameters\nkey\n\nThe string that identifies an additional value.\n\nReturn Value\n\nThe associated value of the key.\n\nDiscussion\n\nAdditional values are values you use to verify and associate an app installation with an ad campaign. For more information, see SKAdNetwork.\n\nSee Also\nVerifying Advertising Campaigns\nvar campaignToken: String?\nA token you use to represent an ad campaign and measure its effectiveness.\nvar providerToken: String?\nA token that represents the provider of an app promotion campaign, and that you use to measure the campaign’s effectiveness.\nfunc setAdditionalValue(Any?, forKey: String)\nSets an additional value for a key, such as a value for measuring the effectiveness of an ad campaign."
  },
  {
    "title": "providerToken",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appclipconfiguration/3612098-providertoken",
    "html": "Discussion\n\nWhen you set a provider token, you must also set the campaignToken.\n\nWhen promoting your own apps, set your own provider token using providerToken. This allows you to track a promotion’s effectiveness independently from any affiliate campaign that shares the same campaign token.\n\nWhen promoting apps by other developers, set providerToken using their provider token. This allows those developers to track the effectiveness of your App Store Connect Analytics campaign.\n\nSee Also\nVerifying Advertising Campaigns\nvar campaignToken: String?\nA token you use to represent an ad campaign and measure its effectiveness.\nfunc setAdditionalValue(Any?, forKey: String)\nSets an additional value for a key, such as a value for measuring the effectiveness of an ad campaign.\nfunc additionalValue(forKey: String) -> Any?\nReturns the object associated with the key."
  },
  {
    "title": "SKOverlay.Position",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/position",
    "html": "Topics\nDescribing the Overlay’s Position\ncase bottom\nSpecifies that the overlay is at the bottom of the screen.\ncase bottomRaised\nSpecifies that the overlay is at a raised position at the bottom of the screen.\nRelationships\nConforms To\nSendable\nSee Also\nCreating an App Configuration\ninit(appIdentifier: String, position: SKOverlay.Position)\nCreates an object that represents the attributes of an overlay you use to recommend another app on the App Store.\nvar appIdentifier: String\nThe iTunes identifier of the recommended app.\nvar position: SKOverlay.Position\nThe position of the overlay on the screen."
  },
  {
    "title": "impressionTooShort",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3963919-impressiontooshort",
    "html": "See Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "Offering Apple Music Subscription in Your App",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupviewcontroller/offering_apple_music_subscription_in_your_app",
    "html": "Overview\n\nWith an Apple Music membership, users can play songs from the entire Apple Music catalog or access their iCloud music library across all their devices. You can offer users the option to sign up for an Apple Music subscription directly from your app by following these steps:\n\nRequest Apple Music Library access from the user.\n\nDetermine if the user is eligible for an Apple Music subscription.\n\nPresent the sign-up subscription offer if the user is eligible.\n\nRequest Apple Music Library Access\n\nThe user must grant permission before your app can access Apple Music library. See Requesting Access to Apple Music Library for details. Use authorizationStatus() to determine your app’s authorization status. If the authorization status is SKCloudServiceAuthorizationStatus.authorized, your app can check if the user is eligible for an Apple Music subscription offer.\n\nSKCloudServiceController.authorizationStatus() == .authorized\n\n\nImportant\n\nWhen the Music app is absent on the user’s device, load(options:completionHandler:) fails to load.\n\nDetermine if the User is Eligible for an Apple Music Subscription\n\nAfter getting Apple Music access from the user, call requestCapabilities(completionHandler:) on an instance of SKCloudServiceController to query the user’s capabilities. Then, inspect the capabilities parameter of this method to determine eligibility. See Determining a User’s Apple Music Capabilities for details. A user has an active subscription to Apple Music when capabilities contains musicCatalogPlayback. A user is eligible for the offer when capabilities doesn’t include musicCatalogPlayback but contains musicCatalogSubscriptionEligible.\n\nlet controller = SKCloudServiceController()\ncontroller.requestCapabilities { (capabilities: SKCloudServiceCapability, error: Error?) in\n    guard error == nil else { return }\n\n\n    if capabilities.contains(.musicCatalogSubscriptionEligible) && !capabilities.contains(.musicCatalogPlayback) {\n        // Allows subscription to the Apple Music catalog.\n    }\n}\n\n\nPresent the Offer to Subscribe for Apple Music\n\nFor users who are eligible for an Apple Music subscription, use the following steps to allow users to sign up for it.\n\nFirst, create a dictionary with an action key to subscribe:\n\nlet options: [SKCloudServiceSetupOptionsKey: Any] = [.action: SKCloudServiceSetupAction.subscribe]\n\n\nIf you have an iTunes Store affiliate account, you can add the affiliateToken key to the dictionary to earn commision if the user subscribes:\n\nlet affiliateToken = \"Your_Affiliate_Token\"\nlet options: [SKCloudServiceSetupOptionsKey: Any] = [.action: SKCloudServiceSetupAction.subscribe, .affiliateToken: affiliateToken]\n\n\nBy default, the setup view is configured with the messageIdentifier key set to join. Add messageIdentifier to the dictionary and set it to addMusic, connect, or playMusic if you wish to change the default message that your app shows to the user:\n\nlet options: [SKCloudServiceSetupOptionsKey: Any] = [.action: SKCloudServiceSetupAction.subscribe, .messageIdentifier: SKCloudServiceSetupMessageIdentifier.addMusic]\n\n\nNext, create an SKCloudServiceSetupViewController object and set the view controller class as its delegate:\n\nlet controller = SKCloudServiceSetupViewController()\ncontroller.delegate = self\n\n\nThen, pass the dictionary to the load(options:completionHandler:) method of the SKCloudServiceSetupViewController object. Finally, present the SKCloudServiceSetupViewController object modally from your app:\n\ncontroller.load(options: options) { [weak self] (result: Bool, error: Error?) in\n   guard error == nil else { return }\n   \n    if result {\n        self?.present(controller, animated: true, completion: nil)\n    }\n}\n\n\nSee Also\nLoading the Setup View\nfunc load(options: [SKCloudServiceSetupOptionsKey : Any], completionHandler: ((Bool, (any Error)?) -> Void)?)\nLoads the cloud service setup view with the specified options.\nstruct SKCloudServiceSetupOptionsKey\nKeys used to specify the types of setup options for a cloud service."
  },
  {
    "title": "storeOverlayWillStartPresentation(_:transitionContext:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlaydelegate/3566709-storeoverlaywillstartpresentatio",
    "html": "Parameters\noverlay\n\nAn overlay object that’s about to appear.\n\ntransitionContext\n\nA context you can use to animate changes to UI components as the overlay appears.\n\nDiscussion\n\nUse the transitionContext parameter to animate updates to the UI on the main thread. For example, make a UIImageView disappear by animating the change of its opacity to 0% as shown in the following code:\n\nfunc storeOverlayWillStartPresentation(_ overlay: SKOverlay, transitionContext: SKOverlay.TransitionContext) {\n    transitionContext.addAnimation { [self] in\n        self.imageView.layer.opacity = 0\n    }\n}\n\n\nSee Also\nResponding to the Overlay’s Appearance and Disappearance\nfunc storeOverlayDidFinishPresentation(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform finished presenting an overlay.\nfunc storeOverlayWillStartDismissal(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform dismisses an overlay.\nfunc storeOverlayDidFinishDismissal(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that platform finished dismissing an overlay.\nclass SKOverlay.TransitionContext\nA context object you can use to animate UI changes while the platform presents or dismisses an overlay."
  },
  {
    "title": "storeOverlayDidFinishPresentation(_:transitionContext:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlaydelegate/3566707-storeoverlaydidfinishpresentatio",
    "html": "Parameters\noverlay\n\nThe overlay object that appears.\n\ntransitionContext\n\nA context you can use to animate changes to UI components after the overlay appears.\n\nSee Also\nResponding to the Overlay’s Appearance and Disappearance\nfunc storeOverlayWillStartPresentation(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform presents an overlay.\nfunc storeOverlayWillStartDismissal(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform dismisses an overlay.\nfunc storeOverlayDidFinishDismissal(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that platform finished dismissing an overlay.\nclass SKOverlay.TransitionContext\nA context object you can use to animate UI changes while the platform presents or dismisses an overlay."
  },
  {
    "title": "storeOverlayWillStartDismissal(_:transitionContext:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlaydelegate/3566708-storeoverlaywillstartdismissal",
    "html": "Parameters\noverlay\n\nAn overlay object that’s about to disappear.\n\ntransitionContext\n\nThe context you can use to animate changes to UI components when the overlay disappears.\n\nDiscussion\n\nUse the transitionContext parameter to animate updates to the UI on the main thread. For example, make a UIImageView appear by animating the change of its opacity to 100%, as shown in the following code:\n\nfunc storeOverlayWillStartDismissal(_ overlay: SKOverlay, transitionContext: SKOverlay.TransitionContext) {\n    transitionContext.addAnimation { [self] in\n        self.imageView.layer.opacity = 1\n    }\n}\n\nSee Also\nResponding to the Overlay’s Appearance and Disappearance\nfunc storeOverlayWillStartPresentation(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform presents an overlay.\nfunc storeOverlayDidFinishPresentation(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform finished presenting an overlay.\nfunc storeOverlayDidFinishDismissal(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that platform finished dismissing an overlay.\nclass SKOverlay.TransitionContext\nA context object you can use to animate UI changes while the platform presents or dismisses an overlay."
  },
  {
    "title": "load(options:completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupviewcontroller/2609450-load",
    "html": "Parameters\noptions\n\nA key that identifies the type of setup the user needs to do. See SKCloudServiceSetupOptionsKey for possible values.\n\ncompletionHandler\n\nA block that is called when the setup view has loaded. The block takes the following parameters:\n\nresult\n\nA Boolean value that indicates whether the view controller has loaded the view and can be presented.\n\nerror\n\nAn error value that indicates the reason for failure. Possible values are SKError.Code.unknown, SKError.Code.cloudServicePermissionDenied, and SKError.Code.cloudServiceNetworkConnectionFailed.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc load(options: [SKCloudServiceSetupOptionsKey : Any] = [:]) async throws -> Bool\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nSee Also\nLoading the Setup View\nOffering Apple Music Subscription in Your App\nAllow eligible users to subscribe to Apple Music library.\nstruct SKCloudServiceSetupOptionsKey\nKeys used to specify the types of setup options for a cloud service."
  },
  {
    "title": "storeOverlayDidFinishDismissal(_:transitionContext:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlaydelegate/3566706-storeoverlaydidfinishdismissal",
    "html": "Parameters\noverlay\n\nAn app banner object that disappeared.\n\ntransitionContext\n\nThe context you can use to animate changes to UI components when the overlay disappears.\n\nSee Also\nResponding to the Overlay’s Appearance and Disappearance\nfunc storeOverlayWillStartPresentation(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform presents an overlay.\nfunc storeOverlayDidFinishPresentation(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform finished presenting an overlay.\nfunc storeOverlayWillStartDismissal(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform dismisses an overlay.\nclass SKOverlay.TransitionContext\nA context object you can use to animate UI changes while the platform presents or dismisses an overlay."
  },
  {
    "title": "delegate",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupviewcontroller/2609451-delegate",
    "html": "Discussion\n\nYou can identify a delegate to get informed when the cloud service setup view controller is dismissed.\n\nSee Also\nSetting a Delegate\nprotocol SKCloudServiceSetupViewControllerDelegate\nA protocol that defines the methods a cloud service setup view controller can use to get the status of the view, including when it is dismissed."
  },
  {
    "title": "SKCloudServiceSetupViewControllerDelegate",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupviewcontrollerdelegate",
    "html": "Topics\nReceiving Notification of Dismissal\nfunc cloudServiceSetupViewControllerDidDismiss(SKCloudServiceSetupViewController)\nTells the delegate that the cloud service setup view controller was dismissed.\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nSetting a Delegate\nvar delegate: (any SKCloudServiceSetupViewControllerDelegate)?\nThe cloud service view controller's delegate."
  },
  {
    "title": "unsupported",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925710-unsupported",
    "html": "Discussion\n\nFor information about supported features by version number, see SKAdNetwork release notes. For example, to provide view-through ads, use SKAdNetwork version 2.2 or later.\n\nSee Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "unknown",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925709-unknown",
    "html": "Discussion\n\nIf this error appears, continue processing the ad; an ad impression may succeed despite this error.\n\nSee Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "mismatchedSourceAppId",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925708-mismatchedsourceappid",
    "html": "Discussion\n\nCheck that the sourceAppStoreItemIdentifier you provide in the SKAdImpression object matches the app identifier of the app displaying the ad.\n\nSee Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "invalidVersion",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3928248-invalidversion",
    "html": "Discussion\n\nAd networks provide an SKAdNetwork version number when preparing an ad impression, in SKStoreProductParameterAdNetworkVersion or version. Check that the version number is valid and that you follow the version-specific instructions to generate a signature. For more information about versions, see SKAdNetwork release notes.\n\nSee Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation."
  },
  {
    "title": "SKANError.Code.adNetworkIdMissing",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/adnetworkidmissing",
    "html": "Discussion\n\nThe value you specify for your ad network identifier in your ad impresion must match the value in the Info.plist. An app that participates in ad campaigns by displaying ads must include the ad network identifiers in its Info.plist. For more information, see Configuring a source app.\n\nSee Also\nError Codes\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase impressionTooShort\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unknown\nAn unknown error occurred.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3792005",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing transactions\nstatic func == (Transaction, Transaction) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "Transaction.RefundRequestStatus",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequeststatus",
    "html": "Overview\n\nThe following methods throw the refund request status: beginRefundRequest(in:), beginRefundRequest(for:in:), beginRefundRequest(in:), and beginRefundRequest(for:in:).\n\nThe refund request status reflects the status of the request, not the status of the refund itself.\n\nTopics\nGetting Refund Request Status\ncase userCancelled\nThe user canceled submission of their refund request.\ncase success\nThe App Store has received the refund request.\nComparing and Hashing Refund Request Status\nstatic func != (Transaction.RefundRequestStatus, Transaction.RefundRequestStatus) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Transaction.RefundRequestStatus, Transaction.RefundRequestStatus) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nSee Also\nRequesting refunds\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds.\nfunc beginRefundRequest(in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a window scene.\nfunc beginRefundRequest(in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a view controller.\nstatic func beginRefundRequest(for: UInt64, in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a window scene.\nstatic func beginRefundRequest(for: UInt64, in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a view controller.\nenum Transaction.RefundRequestError\nThe error codes for refund requests."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925694",
    "html": "See Also\nComparing and Hashing Errors\nstatic func != (SKANError, SKANError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "showManageSubscriptions(in:subscriptionGroupID:)",
    "url": "https://developer.apple.com/documentation/storekit/appstore/4193482-showmanagesubscriptions",
    "html": "Parameters\nscene\n\nThe UIWindowScene that the system displays the sheet on.\n\nsubscriptionGroupID\n\nThe subscription group identifier that the subscription belongs to.\n\nSee Also\nManaging subscriptions\nstatic func showManageSubscriptions(in: UIWindowScene)\nPresents the App Store sheet for managing subscriptions."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925693",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and Hashing Errors\nstatic func == (SKANError, SKANError) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "SKANError.Code.invalidVersion",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/invalidversion",
    "html": "Discussion\n\nAd networks provide an SKAdNetwork version number when preparing an ad impression, in SKStoreProductParameterAdNetworkVersion or version. Check that the version number is valid and that you follow the version-specific instructions to generate a signature. For more information about versions, see SKAdNetwork release notes.\n\nSee Also\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase impressionTooShort\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unknown\nAn unknown error occurred.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "SKANError.Code.unsupported",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/unsupported",
    "html": "Discussion\n\nFor information about supported features by version number, see SKAdNetwork release notes. For example, to provide view-through ads, use SKAdNetwork version 2.2 or later.\n\nSee Also\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase impressionTooShort\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unknown\nAn unknown error occurred."
  },
  {
    "title": "init(sourceAppStoreItemIdentifier:advertisedAppStoreItemIdentifier:adNetworkIdentifier:adCampaignIdentifier:adImpressionIdentifier:timestamp:signature:version:)",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3951376-init",
    "html": "See Also\nCreating a signature\nvar version: String\nThe version of the SKAdNetwork API.\nvar adNetworkIdentifier: String\nA string that represents the advertising network’s unique identifier.\nvar sourceIdentifier: NSNumber\nA four-digit integer that ad networks define to represent the ad campaign.\nvar adCampaignIdentifier: NSNumber\nA number that represents the advertising network’s campaign.\nvar advertisedAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that the ad impression advertises.\nvar adImpressionIdentifier: String\nA random value to use for added security.\nvar sourceAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that displays the ad.\nvar timestamp: NSNumber\nA number that represents the UNIX time, in milliseconds, of the ad impression."
  },
  {
    "title": "SKANError.Code.unknown",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/unknown",
    "html": "Discussion\n\nIf this error appears, continue processing the ad; an ad impression may succeed despite this error.\n\nSee Also\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase impressionTooShort\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "SKANError.Code.mismatchedSourceAppId",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code/mismatchedsourceappid",
    "html": "Discussion\n\nCheck that the sourceAppStoreItemIdentifier you provide in the SKAdImpression object matches the app identifier of the app displaying the ad.\n\nSee Also\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase impressionTooShort\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase unknown\nAn unknown error occurred.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "appVersionID",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954438-appversionid",
    "html": "Discussion\n\nThe App Store assigns this value. In the sandbox and xcode environments, this value is nil.\n\nSee Also\nGetting app and version info\nlet bundleID: String\nThe bundle identifier that the app transaction applies to.\nlet appVersion: String\nThe app version that the app transaction applies to.\nlet originalAppVersion: String\nThe app version that the user originally purchased from the App Store.\nlet appID: UInt64?\nThe unique identifier the App Store uses to identify the app."
  },
  {
    "title": "callAsFunction()",
    "url": "https://developer.apple.com/documentation/storekit/requestreviewaction/3954513-callasfunction",
    "html": "Discussion\n\nDon’t call this method directly. SwiftUI calls it when you call the RequestReviewAction instance that you get from the requestReview environment value.\n\nFor information about how Swift uses the callAsFunction()method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language."
  },
  {
    "title": "Product.PurchaseOption",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseoption",
    "html": "Overview\n\nAssociate purchase options with an in-app purchase when you call the purchase(options:) or purchase(confirmIn:options:) methods. Use the testing-specific options with StoreKit Test or in the sandbox testing environment.\n\nPurchase options enable you to provide additional information for the purchase, including an app account token, promotional offer, and quantity, and indicate how the transaction behaves if the storefront changes.\n\nNote that purchases fail if a purchase option is invalid, and can result in the purchase method throwing a StoreKitError or Product.PurchaseError.\n\nUse purchase options during testing\n\nIn the sandbox testing environment, use simulatesAskToBuyInSandbox(_:) to test Ask To Buy scenarios.\n\nIn the Xcode testing environment with StoreKit Test, use the following testing-specific purchase options when you call buyProduct(identifier:options:):\n\nUse codeOffer(referenceName:) and promotionalOffer(id:) to simulate customers redeeming the offers.\n\nUse purchaseDate(_:renewalBehavior:) to control the transaction date and subscription renewal behavior.\n\nTopics\nSetting the purchase options\nstatic func appAccountToken(UUID) -> Product.PurchaseOption\nSets a UUID to associate the purchase with an account in your system.\nstatic func onStorefrontChange(shouldContinuePurchase: (Storefront) -> Bool) -> Product.PurchaseOption\nIndicates whether a transaction needs to continue if the App Store storefront changes on the device during the transaction.\nstatic func promotionalOffer(offerID: String, keyID: String, nonce: UUID, signature: Data, timestamp: Int) -> Product.PurchaseOption\nApplies a promotional offer for an auto-renewable subscription.\nstatic func quantity(Int) -> Product.PurchaseOption\nIndicates the quantity of items the customer is purchasing.\nSetting options for StoreKit Testing in Xcode\nstatic func purchaseDate(Date, renewalBehavior: Product.PurchaseOption.SubscriptionRenewalBehavior) -> Product.PurchaseOption\nSets the purchase date for the transaction in the testing environment, and indicates the renewal behavior for an auto-renewable subscription.\nenum Product.PurchaseOption.SubscriptionRenewalBehavior\nRenewal options for auto-renewable subscriptions that you purchase in the testing environment.\nstatic func codeOffer(referenceName: String) -> Product.PurchaseOption\nSets an offer code for the transaction in the testing environment.\nstatic func promotionalOffer(id: String) -> Product.PurchaseOption\nSets a promotional offer for the transaction in the testing environment.\nSetting options for sandbox testing\nstatic func simulatesAskToBuyInSandbox(Bool) -> Product.PurchaseOption\nSimulates an Ask to Buy scenario when testing your app in the sandbox environment.\nSetting custom purchase options\nstatic func custom(key: String, value: Data) -> Product.PurchaseOption\nAdds data for a custom key to a purchase.\nstatic func custom(key: String, value: String) -> Product.PurchaseOption\nAdds a string for a custom key to a purchase.\nstatic func custom(key: String, value: Bool) -> Product.PurchaseOption\nAdds a Boolean value for a custom key to a purchase.\nstatic func custom(key: String, value: Double) -> Product.PurchaseOption\nAdds a number for a custom key to a purchase.\nComparing and hashing purchase options\nstatic func != (Product.PurchaseOption, Product.PurchaseOption) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.PurchaseOption, Product.PurchaseOption) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nGetting a debug description\nvar debugDescription: String\nA debug description of the purchase option.\nType Methods\nstatic func promotionalOffer(offerID: String, signature: Product.SubscriptionOffer.Signature) -> Product.PurchaseOption\nRelationships\nConforms To\nCustomDebugStringConvertible\nHashable\nSee Also\nPurchasing a product\nfunc purchase(options: Set<Product.PurchaseOption>) -> Product.PurchaseResult\nInitiates a purchase for the product with the App Store and displays the confirmation sheet.\nfunc purchase(confirmIn: some UIScene, options: Set<Product.PurchaseOption>) -> Product.PurchaseResult\nInitiates a purchase for the product with the App Store and displays the confirmation sheet.\nenum Product.PurchaseResult\nThe result of a purchase.\nenum Product.PurchaseError\nError information for product purchase errors."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/message/3954509-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing messages\nstatic func != (Message, Message) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Message, Message) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "Transaction properties",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transaction_properties",
    "html": "Topics\nGetting the environment and storefront\nlet environment: AppStore.Environment\nThe server environment that generates and signs the transaction.\nlet storefront: Storefront\nThe App Store storefront associated with the transaction.\nGetting the original transaction identifier\nlet originalID: UInt64\nThe original transaction identifier of a purchase.\nlet originalPurchaseDate: Date\nThe date of purchase for the original transaction.\nIdentifying a transaction\nlet id: UInt64\nThe unique identifier for the transaction.\ntypealias Transaction.ID\nA type representing the transaction identifier.\nlet webOrderLineItemID: String?\nA unique ID that identifies subscription purchase events across devices, including subscription renewals.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Transaction conforms to AnyObject.\nIdentifying the app and product\nlet appBundleID: String\nThe bundle identifier for the app.\nlet productID: String\nThe product identifier of the in-app purchase.\nlet productType: Product.ProductType\nThe type of the in-app purchase.\nlet subscriptionGroupID: String?\nThe identifier of the subscription group that the subscription belongs to.\nGetting purchase and expiration dates\nlet purchaseDate: Date\nThe date that the App Store charged the user’s account for a purchased or restored product, or for a subscription purchase or renewal after a lapse.\nlet expirationDate: Date?\nThe date the subscription expires or renews.\nGetting purchase details\nlet isUpgraded: Bool\nA Boolean that indicates whether the user upgraded to another subscription.\nlet ownershipType: Transaction.OwnershipType\nA value that indicates whether the transaction was purchased by the user, or is made available to them through Family Sharing.\ntypealias Transaction.OwnershipType.RawValue\nThe type that represents the raw value of a transaction’s ownership type.\nstruct Transaction.OwnershipType\nThe types the system uses to describe whether the user purchased the product or it’s available to them through Family Sharing.\nlet purchasedQuantity: Int\nThe number of consumable products purchased.\nGetting subscription status\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var subscriptionStatus: Product.SubscriptionInfo.Status?\nAn array that contains status information for a subscription group, including renewal and transaction information.\nGetting transaction reason\nlet reason: Transaction.Reason\nThe cause of the purchase transaction, whether it’s a customer’s purchase or an auto-renewable subscription renewal that the system initiates.\nstruct Transaction.Reason\nA cause of a purchase transaction, indicating whether it’s a customer’s purchase or an auto-renewable subscription renewal that the system initiates.\nIdentifying subscription offers\nlet offer: Transaction.Offer?\nThe subscription offer that applies to the transaction, including its offer type, payment mode, and ID.\nstruct Transaction.Offer\nThe subscription offers that apply to a transaction.\nGetting revocation status\nlet revocationDate: Date?\nThe date that the App Store refunded the transaction or revoked it from Family Sharing.\nlet revocationReason: Transaction.RevocationReason?\nThe reason that the App Store refunded the transaction or revoked it from Family Sharing.\nstruct Transaction.RevocationReason\nReasons that describe why the App Store may refund a transaction or revoke it from Family Sharing.\ntypealias Transaction.RevocationReason.RawValue\nThe type that represents the raw value of a transaction revocation reason.\nCorrelating transactions with accounts\nlet appAccountToken: UUID?\nA UUID that associates the transaction with a user on your own service.\nDeprecated\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var environmentStringRepresentation: String\nA string representation of the server environment.\nDeprecated\nvar offerID: String?\nA string that identifies an offer applied to the current subscription.\nDeprecated\n@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2) var offerPaymentModeStringRepresentation: String?\nThe string representation of the payment mode for a subscription offer.\nDeprecated\nvar offerType: Transaction.OfferType?\nThe subscription offer type for the current subscription period.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var reasonStringRepresentation: String\nThe string representation of the transaction reason.\nDeprecated\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, macCatalyst 17.0) var storefrontCountryCode: String\nThe three-letter code that represents the country or region associated with the App Store storefront of the purchase.\nDeprecated"
  },
  {
    "title": "latest(for:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3792063-latest",
    "html": "Parameters\nproductID\n\nThe product identifier that the function uses to look up the latest transaction.\n\nReturn Value\n\nA VerificationResult with a single Transaction, or nil if the user hasn't purchased the product.\n\nDiscussion\n\nCall this function for any type of in-app purchase. The following example illustrates requesting the latest transaction to determine if the user purchased the product indicated by the string productIdentifier.\n\nguard let verificationResult = await Transaction.latest(for: productIdentifier) else {    \n    // The user hasn't purchased this product.\n    return\n}\n\n\nswitch verificationResult {\ncase .verified(let transaction):\n    // Check the transaction and give the user access to purchased \n    // content as appropriate.\n    ...\ncase .unverified(let transaction, let verificationError):\n    // Handle unverified transactions based \n    // on your business model.\n    ...\n}\n\n\nSee Also\nGetting transaction history\nstatic var all: Transaction.Transactions\nA sequence that emits all the transactions for the user for your app.\nstatic var unfinished: Transaction.Transactions\nA sequence that emits unfinished transactions for the user."
  },
  {
    "title": "currentEntitlement(for:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3792058-currententitlement",
    "html": "Parameters\nproductID\n\nIn-app purchase product identifier.\n\nReturn Value\n\nA VerificationResult or nil if the user has no current in-app purchases.\n\nSee Also\nGetting current entitlements\nstatic var currentEntitlements: Transaction.Transactions\nA sequence of the latest transactions that entitle a user to in-app purchases and subscriptions."
  },
  {
    "title": "all",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3851203-all",
    "html": "Discussion\n\nThis sequence returns the user’s transaction history current to the moment you access it. The sequence emits a finite number of transactions. If the App Store processes additional transactions for the user while you’re accessing this sequence, they appear in the transaction listener updates.\n\nThe transaction history includes consumable in-app purchases that the app hasn’t finished by calling finish(). It doesn’t include finished consumable products or finished non-renewing subscriptions, repurchased non-consumable products or subscriptions, or restored purchases.\n\nSee Also\nGetting transaction history\nstatic func latest(for: String) -> VerificationResult<Transaction>?\nGets the user’s latest transaction for an in-app purchase.\nstatic var unfinished: Transaction.Transactions\nA sequence that emits unfinished transactions for the user."
  },
  {
    "title": "requestAuthorization(_:)",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecontroller/1620609-requestauthorization",
    "html": "Parameters\nhandler\n\nA block that is called when authorization is granted or denied by the user.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nclass func requestAuthorization() async -> SKCloudServiceAuthorizationStatus\n\n\nFor example:\n\nlet authorization = await SKCloudServiceController.requestAuthorization()\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nYou can use this method to ask the user for permission to play Apple Music tracks or to add tracks to the music library.\n\nSee Also\nGetting Authorization to Access the Music Library\nRequesting Access to Apple Music Library\nPrompt the user to authorize access to Apple Music library.\nclass func authorizationStatus() -> SKCloudServiceAuthorizationStatus\nReturns the type of authorization the user has set for accessing the music library on the device.\nenum SKCloudServiceAuthorizationStatus\nConstants that indicate the type of authorization the user has set for accessing the music library."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/3925700-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nSee Also\nComparing and Hashing Errors\nstatic func != (SKANError, SKANError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (SKANError, SKANError) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "open()",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchaselink/3925691-open",
    "html": "Discussion\n\nCall this asynchronous method to have the system attempt to open the external purchase link, as shown below:\n\ntry await ExternalPurchaseLink.open()\n\n\nTo use this method, follow these steps:\n\nCall canOpen to determine whether to display a button or other user-interface controls that enable you to call open(). If it returns true, your app can display the user-interface controls to enable deliberate user interaction.\n\nIn response to deliberate user interaction, such as tapping a button, call open(). The system displays the continuation sheet that enables the user to choose whether to continue to view your app’s external purchase URL. This asynchronous method returns before the system presents the continuation sheet, and throws an error if canOpen is false.\n\nIf the person chooses to continue, this method opens the current storefront’s destination URL that you configure in the SKExternalPurchaseLink property list key and appends an external purchase token and the app's bundleID to the URL. For example, StoreKit opens the following URL on the default browser if your destination URL is https://site.example.com:\n\nhttps://site.example.com?externalPurchaseToken=ewoJImFwcEFwcGxlSWQiOjEyMzQ1Njc4OTAsCgkiYnVuZGxlSWQiOiJjb20uZXhhbXBsZSIsCgkidG9rZW5DcmVhdGlvbkRhdGUiOjE3MDYxNjk2MDAwMDAsCgkiZXh0ZXJuYWxQdXJjaGFzZUlkIjoiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwIgp9&bundleId=com.example\n\n\n\n\nImportant\n\nRecord and use the token to report the customer’s external purchases to Apple. For more information, see External Purchase Server API.\n\nHandle errors\n\nThis method throws a StoreKitError if any of the following are true:\n\nYour app doesn’t have the com.apple.developer.storekit.external-purchase-link entitlement.\n\nYou haven’t configured external purchases for the current App Store storefront in SKExternalPurchaseLink.\n\nThe current App Store storefront doesn’t support external purchases.\n\nThe person is ineligible to make external purchases.\n\nA network or system error occurs.\n\nFor more information about App Store storefronts, see Storefront.\n\nSee Also\nOffering an external purchase link\nstatic var canOpen: Bool\nA Boolean value that indicates whether the app can successfully open the configured external purchase link in the current App Store storefront.\nproperty list key SKExternalPurchaseLink\nA dictionary that contains URLs to websites where people using your app can make external purchases, for supported regions."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/3954452",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing messages\nstatic func == (Message, Message) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "Transaction.Transactions",
    "url": "https://developer.apple.com/documentation/storekit/transaction/transactions",
    "html": "Overview\n\nYou don’t create a Transaction.Transactions sequence directly. Use methods such as all, updates, or currentEntitlements to get transactions.\n\nTopics\nCreating an Iterator\nfunc makeAsyncIterator() -> Transaction.Transactions.AsyncIterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Transaction.Transactions.AsyncIterator\nThe asynchronous iterator that produces elements of the asynchronous sequence.\ntypealias Transaction.Transactions.Element\nThe type of element traversed by the iterator.\nFinding Transactions\nfunc allSatisfy((VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(VerificationResult<Transaction>) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (VerificationResult<Transaction>) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (VerificationResult<Transaction>, VerificationResult<Transaction>) -> Bool) -> VerificationResult<Transaction>?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nSelecting Transactions\nfunc prefix(Int) -> AsyncPrefixSequence<Transaction.Transactions>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (VerificationResult<Transaction>) -> Bool) -> AsyncPrefixWhileSequence<Transaction.Transactions>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nExcluding Transactions\nfunc drop(while: (VerificationResult<Transaction>) -> Bool) -> AsyncDropWhileSequence<Transaction.Transactions>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Transaction.Transactions>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((VerificationResult<Transaction>) -> Bool) -> AsyncFilterSequence<Transaction.Transactions>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nTransforming a Sequence\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((VerificationResult<Transaction>) -> ElementOfResult?) -> AsyncCompactMapSequence<Transaction.Transactions, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((VerificationResult<Transaction>) -> SegmentOfResult) -> AsyncFlatMapSequence<Transaction.Transactions, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncThrowingMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((VerificationResult<Transaction>) -> Transformed) -> AsyncMapSequence<Transaction.Transactions, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc reduce<Result>(Result, (Result, VerificationResult<Transaction>) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, VerificationResult<Transaction>) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.\nRelationships\nConforms To\nAsyncSequence\nSee Also\nMonitoring transaction-related changes\nstatic var updates: Transaction.Transactions\nThe asynchronous sequence that emits a transaction when the system creates or updates transactions that occur outside of the app or on other devices."
  },
  {
    "title": "delegate",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/3566700-delegate",
    "html": "See Also\nSetting a delegate\nprotocol SKOverlayDelegate\nMethods for responding to the overlay’s appearance, dismissal, or failure to load."
  },
  {
    "title": "reason",
    "url": "https://developer.apple.com/documentation/storekit/message/3963916-reason",
    "html": "See Also\nGetting messages and message reasons\nstatic var messages: Message.Messages\nThe asynchronous sequence that sends a message when the App Store creates it.\nstruct Message.Messages\nAn asynchronous sequence of messages from the App Store.\nstruct Message.Reason\nReasons for the App Store messages."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/message/3954453",
    "html": "See Also\nComparing and hashing messages\nstatic func != (Message, Message) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "SKOverlay.AppConfiguration",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appconfiguration",
    "html": "Topics\nCreating an App Configuration\ninit(appIdentifier: String, position: SKOverlay.Position)\nCreates an object that represents the attributes of an overlay you use to recommend another app on the App Store.\nvar appIdentifier: String\nThe iTunes identifier of the recommended app.\nvar position: SKOverlay.Position\nThe position of the overlay on the screen.\nenum SKOverlay.Position\nConstants that identify the position of an overlay on the screen.\nDismissing the Overlay\nvar userDismissible: Bool\nA Boolean value that indicates whether the user can dismiss the overlay.\nVerifying Advertising Campaigns\nvar campaignToken: String?\nA token you use to represent an ad campaign and measure its effectiveness.\nvar providerToken: String?\nA token that represents the provider of an app promotion campaign, and that you use to measure the campaign’s effectiveness.\nfunc setAdditionalValue(Any?, forKey: String)\nSets an additional value for a key; for example, a value for measuring the effectiveness of an ad campaign.\nfunc additionalValue(forKey: String) -> Any?\nReturns the object associated with the key.\nPromoting the Latest App Version\nvar latestReleaseID: String?\nThe release ID of the latest version of your app as displayed in App Store Connect.\nAdvertising Another App\nvar customProductPageIdentifier: String?\nAn optional identifier for an app’s custom product page.\nSetting an Ad Impression\nfunc setAdImpression(SKAdImpression)\nInstance Properties\nvar appImpression: AppImpression?\nRelationships\nInherits From\nSKOverlay.Configuration\nSee Also\nCreating an overlay\ninit(configuration: SKOverlay.Configuration)\nCreates an overlay you use to recommend another app on the App Store.\nvar configuration: SKOverlay.Configuration\nAn overlay’s attributes; for example, its position on the screen.\nclass SKOverlay.AppClipConfiguration\nAn object that represents the attributes of an overlay you use to recommend an App Clip’s corresponding full app.\nclass SKOverlay.Configuration\nThe abstract superclass for all classes that represent an overlay’s attributes."
  },
  {
    "title": "requestReview()",
    "url": "https://developer.apple.com/documentation/storekit/skstorereviewcontroller/2851536-requestreview",
    "html": "Deprecated\n\nFor iOS, iPadOS, and apps built with Mac Catalyst, use requestReview(in:) instead.\n\nDiscussion\n\nAlthough you normally call this method when it makes sense in the user experience flow of your app, App Store policy governs the actual display of a rating and review request view. Because this method may not present an alert, it isn’t appropriate to call requestReview() or requestReview(in:) in response to a button tap or other user action.\n\nNote\n\nWhen you call this method while your app is in development mode, a rating and review request view is always displayed so you can test the user interface and experience. However, this method has no effect when you call it in an app that you distribute using TestFlight.\n\nWhen you call this method in your shipping app and the system displays a rating and review request view, the system handles the entire process for you. In addition, you can continue to include a persistent link in the settings or configuration screens of your app that links to your App Store product page. To automatically open a page on which users can write a review in the App Store, append the query parameter action=write-review to your product URL.\n\nSee Also\nIndicating an appropriate time for a review\nclass func requestReview(in: UIWindowScene)\nTells StoreKit to ask the user to rate or review the app, if appropriate, using the specified scene."
  },
  {
    "title": "requestReview(in:)",
    "url": "https://developer.apple.com/documentation/storekit/skstorereviewcontroller/3566727-requestreview",
    "html": "Parameters\nwindowScene\n\nThe window scene that StoreKit uses to present the rating and review request interface.\n\nDiscussion\n\nWhen you call this method in your shipping app and the system displays a rating and review request view, the system handles the entire process for you. Although you normally call this method when it makes sense in the user experience flow of your app, App Store policy governs the actual display of a rating and review request view. When your app calls this API, StoreKit uses the following criteria::\n\nIf the person hasn’t rated or reviewed your app on this device, StoreKit displays the ratings and review request a maximum of three times within a 365-day period.\n\nIf the person has rated or reviewed your app on this device, StoreKit displays the ratings and review request if the app version is new, and if more than 365 days have passed since the person’s previous review.\n\nNote\n\nBecause this method may not present an alert, don’t call requestReview() or requestReview(in:) in response to a button tap or other user action.\n\nIt’s up to your app to decide on the best timing for requesting reviews. For design guidance, see Human Interface Guidelines > Ratings and reviews.\n\nTest review requests\n\nWhen your app calls this method while it’s in development mode, StoreKit always displays the rating and review request view, so you can test the user interface and experience. However, this method has no effect in apps that you distribute for beta testing using TestFlight.\n\nProvide a persistent link to your product page (optional)\n\nYour customers can review your app at any time on the App Store. To make it easier for people to leave reviews, you may include a persistent link to your App Store product page in your app’s settings or configuration screens. Append the query parameter action=write-review to your product page URL to automatically open the App Store page where users can write a review.\n\nSee Also\nIndicating an appropriate time for a review\nclass func requestReview()\nTells StoreKit to ask the user to rate or review your app, if appropriate."
  },
  {
    "title": "SKStoreProductParameterAdNetworkIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameteradnetworkidentifier",
    "html": "Discussion\n\nThe value for this key is an NSString.\n\nAd networks obtain an ad network identifier during registration. Ad networks are responsible for sharing their ad network IDs with participating app developers. Apps that display ads and need to initiate the app install validation process must include the ad network ID in their Info.plist. For more information see Registering an ad network and Configuring Apps.\n\nSee Also\nRequired keys\nlet SKStoreProductParameterAdNetworkCampaignIdentifier: String\nThe key that represents the advertising network’s campaign.\nlet SKStoreProductParameterAdNetworkTimestamp: String\nThe key that represents the UNIX time, in milliseconds, of the ad impression.\nlet SKStoreProductParameterAdNetworkNonce: String\nThe key that represents a random value to use for added security.\nlet SKStoreProductParameterAdNetworkAttributionSignature: String\nThe key that represents the advertising network’s cryptographic signature to use for install validation."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/3749387",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing products\nstatic func == (Product, Product) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "Product.SubscriptionRelationship",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionrelationship",
    "html": "Topics\nGetting subscription relationships\nstatic let all: Product.SubscriptionRelationship\nstatic let crossgrade: Product.SubscriptionRelationship\nstatic let current: Product.SubscriptionRelationship\nstatic let downgrade: Product.SubscriptionRelationship\nstatic let upgrade: Product.SubscriptionRelationship\nCreating a subscription relationship\ninit(rawValue: Int)\nvar rawValue: Int\nUsing type aliases\ntypealias Product.SubscriptionRelationship.ArrayLiteralElement\ntypealias Product.SubscriptionRelationship.Element\ntypealias Product.SubscriptionRelationship.RawValue\nRelationships\nConforms To\nHashable\nOptionSet"
  },
  {
    "title": "Product.TaskState",
    "url": "https://developer.apple.com/documentation/storekit/product/taskstate",
    "html": "Topics\nTask states\ncase loading\ncase success(Product)\ncase unavailable\ncase failure(any Error)\nRelationships\nConforms To\nSendable\nSee Also\nLoading products\nenum Product.CollectionTaskState"
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/3749388",
    "html": "See Also\nComparing and hashing products\nstatic func != (Product, Product) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/3749582-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing products\nstatic func != (Product, Product) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product, Product) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "debugDescription",
    "url": "https://developer.apple.com/documentation/storekit/product/3791970-debugdescription",
    "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/3749581-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing products\nstatic func != (Product, Product) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product, Product) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3791956-hash",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nRelationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing subscription information\nstatic func != (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3791957-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing subscription information\nstatic func != (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3791915",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing subscription information\nstatic func == (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3791916",
    "html": "See Also\nComparing and hashing subscription information\nstatic func != (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "subscriptionGroupID",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3791959-subscriptiongroupid",
    "html": "Discussion\n\nAuto-renewable subscriptions always belong to a subscription group. You create the subscription group identifiers in App Store Connect before you create and add an auto-renewable subscription. For more information about subscription groups, see Offer auto-renewable subscriptions.\n\nSee Also\nIdentifying the subscription group\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var groupDisplayName: String\nThe localized name of the subscription group, suitable for display.\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var groupLevel: Int\nThe rank of the subscription relative to other subscriptions in the same subscription group."
  },
  {
    "title": "groupDisplayName",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/4179047-groupdisplayname",
    "html": "Discussion\n\nYou provide a group display name in App Store Connect when you set up a subscription group. For more information, see Offer auto-renewable subscriptions.\n\nThe SubscriptionStoreView uses this value as part of the automatic marketing content if you don’t provide a marketing content view.\n\nNote\n\nWhen you create a new product in App Store Connect or in a StoreKit configuration file, you can test it before you add a product localization. The groupDisplayName value is an empty string until you add a localization. For more information on localizations, see Add localizations.\n\nSee Also\nIdentifying the subscription group\nlet subscriptionGroupID: String\nThe subscription group identifier for this subscription.\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var groupLevel: Int\nThe rank of the subscription relative to other subscriptions in the same subscription group."
  },
  {
    "title": "isEligibleForIntroOffer(for:)",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3791958-iseligibleforintrooffer",
    "html": "Parameters\ngroupID\n\nThe subscription group identifier to check eligibility for an introductory offer.\n\nReturn Value\n\ntrue if the customer is eligible for an introductory offer on any auto-renewable subscription within the subscription group; false otherwise.\n\nDiscussion\n\nThis value may be true even if you haven’t set up an introductory offer in App Store Connect.\n\nSee Also\nGetting subscription offer details\nvar isEligibleForIntroOffer: Bool\nA Boolean value that indicates whether the customer is eligible for an introductory offer.\nlet introductoryOffer: Product.SubscriptionOffer?\nInformation about the introductory offer available for the auto-renewable subscription.\nlet promotionalOffers: [Product.SubscriptionOffer]\nAn array of promotional offers available for the auto-renewable subscription.\nstruct Product.SubscriptionOffer\nInformation about a subscription offer that you configure in App Store Connect."
  },
  {
    "title": "groupLevel",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/4179048-grouplevel",
    "html": "Discussion\n\nIf you offer multiple auto-renewable subscriptions with different price tiers, you can assign each to a level in App Store Connect. Ranking your subscriptions determines the upgrade, downgrade, and crossgrade paths available.\n\nSubscriptions with the highest level of service within a subscription group have a groupLevel value of 1. Subscriptions with lower levels of service or content have groupLevel values of 2 or greater. For example, when comparing two subscriptions, moving from a subscription with a groupLevel of 2 to a subscription with a groupLevel of 1 represents an upgrade.\n\nFor more information on ranking, see Ranking subscriptions within the group. For information on assigning subscription levels in App Store Connect, see Assign subscription levels.\n\nNote\n\nOn systems earlier than iOS 17, macOS 14, tvOS 17, and watchOS 10, this property returns a sentinel value of 0 when you test your app using StoreKit Testing in Xcode or if there’s an unexpected server error.\n\nSee Also\nIdentifying the subscription group\nlet subscriptionGroupID: String\nThe subscription group identifier for this subscription.\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var groupDisplayName: String\nThe localized name of the subscription group, suitable for display."
  },
  {
    "title": "promotionalOffers",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3749532-promotionaloffers",
    "html": "Discussion\n\nThis array is empty if you haven't set up promotional offers in App Store Connect.\n\nFor more information about promotional offers, see Set up promotional offers for auto-renewable subscriptions.\n\nSee Also\nGetting subscription offer details\nvar isEligibleForIntroOffer: Bool\nA Boolean value that indicates whether the customer is eligible for an introductory offer.\nstatic func isEligibleForIntroOffer(for: String) -> Bool\nReturns a Boolean value that determines the customer's eligibility for an introductory offer within the provided subscription group.\nlet introductoryOffer: Product.SubscriptionOffer?\nInformation about the introductory offer available for the auto-renewable subscription.\nstruct Product.SubscriptionOffer\nInformation about a subscription offer that you configure in App Store Connect."
  },
  {
    "title": "introductoryOffer",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3749529-introductoryoffer",
    "html": "Discussion\n\nThis value is nil if you don't set up an introductory offer in App Store Connect. Use isEligibleForIntroOffer to determine whether the customer is eligible for an introductory offer.\n\nSee Also\nGetting subscription offer details\nvar isEligibleForIntroOffer: Bool\nA Boolean value that indicates whether the customer is eligible for an introductory offer.\nstatic func isEligibleForIntroOffer(for: String) -> Bool\nReturns a Boolean value that determines the customer's eligibility for an introductory offer within the provided subscription group.\nlet promotionalOffers: [Product.SubscriptionOffer]\nAn array of promotional offers available for the auto-renewable subscription.\nstruct Product.SubscriptionOffer\nInformation about a subscription offer that you configure in App Store Connect."
  },
  {
    "title": "Product.SubscriptionOffer",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptionoffer",
    "html": "Overview\n\nSubscription offers represent introductory offers and promotional offers that you set up in App Store Connect.\n\nFor more information about introductory offers and promotional offers, see Set an introductory offer for an auto-renewable subscription and Set up promotional offers for auto-renewable subscriptions.\n\nTopics\nGetting price information\nlet displayPrice: String\nThe localized string representation of the discounted price of the subscription offer.\nlet price: Decimal\nThe decimal representation of the discounted price of the subscription offer.\nlet paymentMode: Product.SubscriptionOffer.PaymentMode\nThe offer's payment mode.\nstruct Product.SubscriptionOffer.PaymentMode\nThe payment modes for subscription offers.\nGetting the subscription duration\nlet period: Product.SubscriptionPeriod\nThe subscription period for the subscription offer.\nlet periodCount: Int\nThe number of periods that the subscription offer renews for.\nGetting the subscription offer type\nlet type: Product.SubscriptionOffer.OfferType\nThe type of subscription offer, either introductory or promotional.\nstruct Product.SubscriptionOffer.OfferType\nThe types of subscription offers.\nGetting the promotional offer identifier\nlet id: String?\nThe promotional offer identifier.\nComparing and hashing subscription offers\nstatic func != (Product.SubscriptionOffer, Product.SubscriptionOffer) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionOffer, Product.SubscriptionOffer) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nStructures\nstruct Product.SubscriptionOffer.Signature\nRelationships\nConforms To\nHashable\nSee Also\nGetting subscription information\nlet subscription: Product.SubscriptionInfo?\nThe subscription information for an auto-renewable subscripton.\nstruct Product.SubscriptionInfo\nInformation about an auto-renewable subscription, such as its status, period, subscription group, and subscription offer details.\nstruct Product.SubscriptionPeriod\nValues that represent the duration of time between subscription renewals.\nstruct Product.SubscriptionInfo.Status\nThe renewal status information for an auto-renewable subscription."
  },
  {
    "title": "isEligibleForIntroOffer",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3803203-iseligibleforintrooffer",
    "html": "Discussion\n\nThis value is true if the customer is eligible for an introductory offer on this auto-renewable subscription, or any auto-renewable subscription in the same subscription group; this value is false otherwise. This value may be true even if you haven’t set up an introductory offer in App Store Connect. The following example illustrates checking the subscription property of a product to determine whether the user is eligible for an introductory offer.\n\nfunc eligibleForIntro(product: Product) async throws -> Bool {\n    guard let renewableSubscription = product.subscription else {\n        // No renewable subscription is available for this product.\n        return false\n    }\n    if await renewableSubscription.isEligibleForIntroOffer {\n        // The product is eligible for an introductory offer.\n        return true\n    }\n    return false\n}\n\n\nSee Also\nGetting subscription offer details\nstatic func isEligibleForIntroOffer(for: String) -> Bool\nReturns a Boolean value that determines the customer's eligibility for an introductory offer within the provided subscription group.\nlet introductoryOffer: Product.SubscriptionOffer?\nInformation about the introductory offer available for the auto-renewable subscription.\nlet promotionalOffers: [Product.SubscriptionOffer]\nAn array of promotional offers available for the auto-renewable subscription.\nstruct Product.SubscriptionOffer\nInformation about a subscription offer that you configure in App Store Connect."
  },
  {
    "title": "renewalInfo",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status/3822294-renewalinfo",
    "html": "See Also\nGetting subscription status information\nlet state: Product.SubscriptionInfo.RenewalState\nThe renewal state of the auto-renewable subscription.\nlet transaction: VerificationResult<Transaction>\nThe latest transaction for the subscription group.\nstruct Product.SubscriptionInfo.RenewalInfo\nThe renewal information for an auto-renewable subscription.\nstruct Product.SubscriptionInfo.RenewalState\nThe renewal states of auto-renewable subscriptions."
  },
  {
    "title": "loadProduct(withParameters:completionBlock:)",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductviewcontroller/1620632-loadproduct",
    "html": "Parameters\nparameters\n\nA dictionary describing the content you want the view controller to display. See Product Dictionary Keys for keys that describe the product. See Ad network install-validation keys for keys that describe an impression in an advertising campaign.\n\nblock\n\nA block to be called when the product information has been loaded from the App Store. The completion block is called on the main thread and receives the following parameters:\n\nresult\n\ntrue if the product information was successfully loaded, otherwise false.\n\nerror\n\nIf an error occurred, this object describes the error. If the product information was successfully loaded, this value is nil.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc loadProduct(withParameters parameters: [String : Any]) async throws -> Bool\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nFor a seamless user experience, load the product information before presenting the SKStoreProductViewController view controller. However, if you load the product information while presenting the view controller, once loaded, the product data replaces the contents of the view controller.\n\nSee Also\nLoading a new product screen\nOffering media for sale in your app\nAllow users to purchase media in the App Store from within your app.\nfunc loadProduct(withParameters: [String : Any], impression: SKAdImpression, completionBlock: ((Bool, (any Error)?) -> Void)?)\nProduct Dictionary Keys\nKeys for identifying products and the tokens for affiliates and campaigns."
  },
  {
    "title": "status",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/3822296-status",
    "html": "Discussion\n\nThis array is empty if the customer was never subscribed to a product in this subscription group.\n\nThe array can have more than one subscription status if your subscription supports Family Sharing. Provide the customer with service for the subscription based on the highest level of service where the state is subscribed.\n\nSee Also\nDetermining the subscription status\nstatic func status(for: String) -> [Product.SubscriptionInfo.Status]\nGets the subscription status for a subscription group identifier.\nstruct Product.SubscriptionInfo.Status\nThe renewal status information for an auto-renewable subscription."
  },
  {
    "title": "subscription",
    "url": "https://developer.apple.com/documentation/storekit/product/3749590-subscription",
    "html": "Discussion\n\nA nil value indicates that this product isn’t an auto-renewable subscription.\n\nFor more information about subscriptions, see Auto-renewable Subscriptions.\n\nSee Also\nGetting subscription information\nstruct Product.SubscriptionInfo\nInformation about an auto-renewable subscription, such as its status, period, subscription group, and subscription offer details.\nstruct Product.SubscriptionPeriod\nValues that represent the duration of time between subscription renewals.\nstruct Product.SubscriptionOffer\nInformation about a subscription offer that you configure in App Store Connect.\nstruct Product.SubscriptionInfo.Status\nThe renewal status information for an auto-renewable subscription."
  },
  {
    "title": "adNetworkIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3727295-adnetworkidentifier",
    "html": "Discussion\n\nSet this property to your ad network ID.\n\nAd networks obtain an ad network identifier during registration. Ad networks must share their ad network identifiers with participating app developers. Apps that display ads must include the ad network ID in their Info.plist to initiate the app install validation process. For more information about acquiring your ad network ID, see Registering an ad network.\n\nSee Also\nCreating a signature\ninit(sourceAppStoreItemIdentifier: NSNumber, advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String, adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp: NSNumber, signature: String, version: String)\nCreates an ad impression object using the supplied values.\nvar version: String\nThe version of the SKAdNetwork API.\nvar sourceIdentifier: NSNumber\nA four-digit integer that ad networks define to represent the ad campaign.\nvar adCampaignIdentifier: NSNumber\nA number that represents the advertising network’s campaign.\nvar advertisedAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that the ad impression advertises.\nvar adImpressionIdentifier: String\nA random value to use for added security.\nvar sourceAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that displays the ad.\nvar timestamp: NSNumber\nA number that represents the UNIX time, in milliseconds, of the ad impression."
  },
  {
    "title": "SKStoreProductParameterITunesItemIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameteritunesitemidentifier",
    "html": "Discussion\n\nThe value for this key, an iTunes item identifier, is an instance of NSNumber.\n\nTo find a product’s iTunes identifier, go to linkmaker.itunes.apple.com and search for the product, then locate the iTunes identifier in the link URL. For example, the iTunes identifier for the iBooks app is 364709193."
  },
  {
    "title": "version",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3727302-version",
    "html": "Discussion\n\nSet this instance property to the SKAdNetwork version you’re using to sign the view-through ad impression. View-through ads are available starting in version 2.2. For more information about versions and availability, see SKAdNetwork release notes.\n\nSee Also\nCreating a signature\ninit(sourceAppStoreItemIdentifier: NSNumber, advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String, adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp: NSNumber, signature: String, version: String)\nCreates an ad impression object using the supplied values.\nvar adNetworkIdentifier: String\nA string that represents the advertising network’s unique identifier.\nvar sourceIdentifier: NSNumber\nA four-digit integer that ad networks define to represent the ad campaign.\nvar adCampaignIdentifier: NSNumber\nA number that represents the advertising network’s campaign.\nvar advertisedAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that the ad impression advertises.\nvar adImpressionIdentifier: String\nA random value to use for added security.\nvar sourceAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that displays the ad.\nvar timestamp: NSNumber\nA number that represents the UNIX time, in milliseconds, of the ad impression."
  },
  {
    "title": "signature",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3727299-signature",
    "html": "Discussion\n\nThe ad network creates a cryptographic signature that it uses to sign ads. For instructions on generating this value, see Generating the signature to validate view-through ads."
  },
  {
    "title": "beginRefundRequest(in:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3816401-beginrefundrequest",
    "html": "Parameters\ncontroller\n\nThe NSViewController that the system displays the sheet on.\n\nReturn Value\n\nTransaction.RefundRequestStatus\n\nDiscussion\n\nCall this function from account settings or a help menu to enable customers to request a refund for an in-app purchase within your app. When you call this function, the system displays a refund sheet with the customer’s purchase details and a list of reason codes for the customer to choose from. For design guidance, see Human Interface Guidelines > In-app purchase > Providing help with in-app purchases.\n\nWhen a customer requests a refund for consumable in-app purchases through your app, the App Stores sends a CONSUMPTION_REQUEST notificationType to your server. If the customer provided consent, respond by sending consumption data to the App Store using the Send Consumption Information endpoint. If not, don’t respond to the CONSUMPTION_REQUEST notification.\n\nThe App Store takes up to 48 hours to either approve or deny a refund.\n\nFor information about setting up your server to receive notifications, see Enabling App Store Server Notifications.\n\nNote\n\nIf your app uses SwiftUI, use refundRequestSheet(for:isPresented:onDismiss:) instead. For example usage, see Food Truck: Building a SwiftUI multiplatform app.\n\nTest refund requests\n\nThe sandbox environment and StoreKit Testing in Xcode both support testing refund requests. For more information, see Testing refund requests.\n\nSee Also\nRequesting refunds\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds.\nfunc beginRefundRequest(in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a window scene.\nstatic func beginRefundRequest(for: UInt64, in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a window scene.\nstatic func beginRefundRequest(for: UInt64, in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a view controller.\nenum Transaction.RefundRequestError\nThe error codes for refund requests.\nenum Transaction.RefundRequestStatus\nThe status codes for refund requests."
  },
  {
    "title": "beginRefundRequest(in:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3803220-beginrefundrequest",
    "html": "Parameters\nscene\n\nThe UIWindowScene that the system displays the sheet on.\n\nReturn Value\n\nTransaction.RefundRequestStatus\n\nDiscussion\n\nCall this function from account settings or a help menu to enable customers to request a refund for an in-app purchase within your app. When you call this function, the system displays a refund sheet with the customer’s purchase details and a list of reason codes for the customer to choose from. For design guidance, see Human Interface Guidelines > In-app purchase > Providing help with in-app purchases.\n\nWhen a customer requests a refund for consumable in-app purchases through your app, the App Stores sends a CONSUMPTION_REQUEST notificationType to your server. If the customer provided consent, respond by sending consumption data to the App Store using the Send Consumption Information endpoint. If not, don’t respond to the CONSUMPTION_REQUEST notification.\n\nThe App Store takes up to 48 hours to either approve or deny a refund.\n\nFor information about setting up your server to receive notifications, see Enabling App Store Server Notifications.\n\nNote\n\nIf your app uses SwiftUI, use refundRequestSheet(for:isPresented:onDismiss:) instead. For example usage, see Food Truck: Building a SwiftUI multiplatform app.\n\nTest refund requests\n\nThe sandbox environment and StoreKit Testing in Xcode both support testing refund requests. For more information, see Testing refund requests.\n\nSee Also\nRequesting refunds\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds.\nfunc beginRefundRequest(in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a view controller.\nstatic func beginRefundRequest(for: UInt64, in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a window scene.\nstatic func beginRefundRequest(for: UInt64, in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a view controller.\nenum Transaction.RefundRequestError\nThe error codes for refund requests.\nenum Transaction.RefundRequestStatus\nThe status codes for refund requests."
  },
  {
    "title": "beginRefundRequest(for:in:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3816400-beginrefundrequest",
    "html": "Parameters\ntransactionID\n\nThe identifier of the transaction the user is requesting a refund for.\n\ncontroller\n\nThe NSViewController that the system displays the sheet on.\n\nReturn Value\n\nTransaction.RefundRequestStatus\n\nDiscussion\n\nCall this function from account settings or a help menu to enable customers to request a refund for an in-app purchase within your app. When you call this function, the system displays a refund sheet with the customer’s purchase details and a list of reason codes for the customer to choose from. For design guidance, see Human Interface Guidelines > In-app purchase > Providing help with in-app purchases.\n\nWhen a customer requests a refund for consumable in-app purchases through your app, the App Stores sends a CONSUMPTION_REQUEST notificationType to your server. If the customer provided consent, respond by sending consumption data to the App Store using the Send Consumption Information endpoint. If not, don’t respond to the CONSUMPTION_REQUEST notification.\n\nThe App Store takes up to 48 hours to either approve or deny a refund.\n\nFor information about setting up your server to receive notifications, see Enabling App Store Server Notifications.\n\nNote\n\nIf your app uses SwiftUI, use refundRequestSheet(for:isPresented:onDismiss:) instead. For example usage, see Food Truck: Building a SwiftUI multiplatform app.\n\nTest refund requests\n\nThe sandbox environment and StoreKit Testing in Xcode both support testing refund requests. For more information, see Testing refund requests.\n\nSee Also\nRequesting refunds\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds.\nfunc beginRefundRequest(in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a window scene.\nfunc beginRefundRequest(in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a view controller.\nstatic func beginRefundRequest(for: UInt64, in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a window scene.\nenum Transaction.RefundRequestError\nThe error codes for refund requests.\nenum Transaction.RefundRequestStatus\nThe status codes for refund requests."
  },
  {
    "title": "beginRefundRequest(for:in:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3803219-beginrefundrequest",
    "html": "Parameters\ntransactionID\n\nThe identifier of the transaction the user is requesting a refund for.\n\nscene\n\nThe UIWindowScene that the system displays the sheet on.\n\nReturn Value\n\nTransaction.RefundRequestStatus\n\nDiscussion\n\nCall this function from account settings or a help menu to enable customers to request a refund for an in-app purchase within your app. When you call this function, the system displays a refund sheet with the customer’s purchase details and a list of reason codes for the customer to choose from. For design guidance, see Human Interface Guidelines > In-app purchase > Providing help with in-app purchases.\n\nWhen a customer requests a refund for consumable in-app purchases through your app, the App Stores sends a CONSUMPTION_REQUEST notificationType to your server. If the customer provided consent, respond by sending consumption data to the App Store using the Send Consumption Information endpoint. If not, don’t respond to the CONSUMPTION_REQUEST notification.\n\nThe App Store takes up to 48 hours to either approve or deny a refund.\n\nFor information about setting up your server to receive notifications, see Enabling App Store Server Notifications.\n\nNote\n\nIf your app uses SwiftUI, use refundRequestSheet(for:isPresented:onDismiss:) instead. For example usage, see Food Truck: Building a SwiftUI multiplatform app.\n\nTest refund requests\n\nThe sandbox environment and StoreKit Testing in Xcode both support testing refund requests. For more information, see Testing refund requests.\n\nSee Also\nRequesting refunds\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds.\nfunc beginRefundRequest(in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a window scene.\nfunc beginRefundRequest(in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a view controller.\nstatic func beginRefundRequest(for: UInt64, in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a view controller.\nenum Transaction.RefundRequestError\nThe error codes for refund requests.\nenum Transaction.RefundRequestStatus\nThe status codes for refund requests."
  },
  {
    "title": "signedDate",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3822314-signeddate",
    "html": "Discussion\n\nUse the signedDate to verify whether the certificate used to sign the transaction was valid when the App Store signed the transaction.\n\nSee Also\nVerifying transactions\nlet deviceVerification: Data\nThe device verification value you use to verify whether the transaction belongs to the device.\nlet deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954434",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing and hashing app transactions\nstatic func == (AppTransaction, AppTransaction) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954435",
    "html": "See Also\nComparing and hashing app transactions\nstatic func != (AppTransaction, AppTransaction) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3792006",
    "html": "See Also\nComparing and hashing transactions\nstatic func != (Transaction, Transaction) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "debugDescription",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3792060-debugdescription",
    "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
  },
  {
    "title": "signedDate",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954449-signeddate",
    "html": "Discussion\n\nUse the signedDate to verify whether the certificate used to sign the app transaction was valid when the App Store signed the transaction.\n\nSee Also\nVerifying the app transaction\nlet deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nlet deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value."
  },
  {
    "title": "jsonRepresentation",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954446-jsonrepresentation",
    "html": "Discussion\n\nThe information contained in the jsonRepresentation is the same information as contained in the properties of the same instance of an AppTransaction."
  },
  {
    "title": "Transaction.RefundRequestError",
    "url": "https://developer.apple.com/documentation/storekit/transaction/refundrequesterror",
    "html": "Overview\n\nThe following methods throw refund request errors: beginRefundRequest(in:), beginRefundRequest(for:in:), beginRefundRequest(in:), and beginRefundRequest(for:in:).\n\nTopics\nError Enumeration\ncase duplicateRequest\nThe App Store has already received a refund request for this in-app purchase.\ncase failed\nThe refund request submission failed.\nError Descriptions\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar localizedDescription: String\nA localized error description.\nvar failureReason: String?\nA localized message describing the reason for the failure.\nvar helpAnchor: String?\nA message providing “help” text if the user requests help by pressing an alert panel help anchor button.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error.\nError Comparisons\nstatic func != (Transaction.RefundRequestError, Transaction.RefundRequestError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Transaction.RefundRequestError, Transaction.RefundRequestError) -> Bool\nvar hashValue: Int\nfunc hash(into: inout Hasher)\nRelationships\nConforms To\nError\nLocalizedError\nSee Also\nRequesting refunds\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds.\nfunc beginRefundRequest(in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a window scene.\nfunc beginRefundRequest(in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a view controller.\nstatic func beginRefundRequest(for: UInt64, in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a window scene.\nstatic func beginRefundRequest(for: UInt64, in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a view controller.\nenum Transaction.RefundRequestStatus\nThe status codes for refund requests."
  },
  {
    "title": "offerCodeRedemption(isPresented:onCompletion:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4203466-offercoderedemption",
    "html": "Parameters\nisPresented\n\nA binding to a Boolean value that determines whether the system displays the sheet. You set the Boolean value to true to cause the system to display the sheet. The system sets it to false when it dismisses the sheet.\n\nonCompletion\n\nA closure that returns the result of the presentation.\n\nIn Mac apps built with Mac Catalyst, the completion handler returns a failure with an error.\n\nDiscussion\n\nThe offerCodeRedemption(isPresented:onCompletion:) method displays a system sheet where customers can enter and redeem subscription offer codes. If you generate subscription offer codes in App Store Connect, call this function to enable users to redeem the offer. To display the sheet using UIKit, see presentOfferCodeRedeemSheet(in:).\n\nImportant\n\nSet up subscription offer codes in App Store Connect before calling this API. Customers can only redeem these offers in your app through the redemption sheet; don’t use a custom UI.\n\nFor more information, see Supporting subscription offer codes in your app.\n\nThe following code example shows a view that displays the offer code redemption sheet upon a button press:\n\nimport SwiftUI\nimport StoreKit\n\n\nstruct ContentView: View {\n    @State private var redeemSheetIsPresented = false\n    \n    var body: some View {\n        Button(\"Present offer code redemption sheet.\") {\n            redeemSheetIsPresented = true\n        }\n        .offerCodeRedemption(isPresented: $redeemSheetIsPresented) { result in\n            // Handle result\n        }\n    }\n}\n\n\nWhen customers redeem an offer code, StoreKit emits the resulting transaction in updates. Set up a transaction listener as soon as your app launches to receive new transactions while the app is running. For more information, see updates.\n\nIn Mac apps built with Mac Catalyst, the completion handler returns a failure with an error.\n\nSee Also\nPresenting the offer code redemption sheet\nSupporting subscription offer codes in your app\nProvide subscription service for customers who redeem offer codes through the App Store or within your app.\nstatic func presentOfferCodeRedeemSheet(in: UIWindowScene)\nDisplays a sheet in the window scene that enables users to redeem a subscription offer code that you configure in App Store Connect."
  },
  {
    "title": "appID",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954436-appid",
    "html": "Discussion\n\nThe App Store assigns this value. This value is the app's Apple ID in App Store Connect. In the sandbox and xcode environments, this value is nil.\n\nSee Also\nGetting app and version info\nlet bundleID: String\nThe bundle identifier that the app transaction applies to.\nlet appVersion: String\nThe app version that the app transaction applies to.\nlet originalAppVersion: String\nThe app version that the user originally purchased from the App Store.\nlet appVersionID: UInt64?\nThe number that the App Store uses to uniquely identify the version of the app."
  },
  {
    "title": "bundleID",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954439-bundleid",
    "html": "Discussion\n\nThe bundleID is the bundle identifier string that you entered in Xcode. For more information, see What is a bundle ID?\n\nSee Also\nGetting app and version info\nlet appVersion: String\nThe app version that the app transaction applies to.\nlet originalAppVersion: String\nThe app version that the user originally purchased from the App Store.\nlet appID: UInt64?\nThe unique identifier the App Store uses to identify the app.\nlet appVersionID: UInt64?\nThe number that the App Store uses to uniquely identify the version of the app."
  },
  {
    "title": "appVersion",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954437-appversion",
    "html": "Discussion\n\nThis value is the version string you entered in Xcode. This value is a machine-readable string composed of one to three period-separated integers, such as 10.4.1.\n\nSee Also\nGetting app and version info\nlet bundleID: String\nThe bundle identifier that the app transaction applies to.\nlet originalAppVersion: String\nThe app version that the user originally purchased from the App Store.\nlet appID: UInt64?\nThe unique identifier the App Store uses to identify the app.\nlet appVersionID: UInt64?\nThe number that the App Store uses to uniquely identify the version of the app."
  },
  {
    "title": "environment",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3963901-environment",
    "html": "See Also\nGetting the environment\nstruct AppStore.Environment\nConstants that represent the App Store server environment."
  },
  {
    "title": "AppStore.Environment",
    "url": "https://developer.apple.com/documentation/storekit/appstore/environment",
    "html": "Topics\nGetting the environment value\nstatic let production: AppStore.Environment\nA value that indicates the production server environment.\nstatic let sandbox: AppStore.Environment\nA value that indicates the sandbox server environment.\nstatic let xcode: AppStore.Environment\nA value that indicates the StoreKit Testing in Xcode environment.\nGetting the raw value\nlet rawValue: String\nThe underlying string value that describes the environment.\ntypealias AppStore.Environment.RawValue\nA string type that represents the raw value of an App Store environment.\nCreating an enviroment value\ninit(rawValue: String)\nCreates a new instance with the specified raw value.\nComparing and hashing the environment value\nstatic func != (AppStore.Environment, AppStore.Environment) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSendable"
  },
  {
    "title": "SKAdNetwork.CoarseConversionValue",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/coarseconversionvalue",
    "html": "Overview\n\nWhen you provide the coarse conversion value to the updatePostbackConversionValue(_:coarseValue:completionHandler:) or updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) methods, use the static constants low, medium, or high.\n\nThese constants have no special meaning. The app or ad network can define their meaning, as is useful for their ad campaigns. The app is responsible for assigning a coarse conversion value, as well as the fine conversion value, when it calls one of the conversion value methods. You can determine how the coarse and fine conversion values relate to the types of conversion events you want to measure.\n\nTopics\nProviding coarse conversion values\nstatic let high: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a high coarse conversion value.\nstatic let low: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a low coarse conversion value.\nstatic let medium: SKAdNetwork.CoarseConversionValue\nA string constant value for indicating a medium coarse conversion value.\ninit(rawValue: String)\nCreates a coarse conversion value from the raw value.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSendable\nSee Also\nProviding conversion information\nclass func updatePostbackConversionValue(Int, coarseValue: SKAdNetwork.CoarseConversionValue, lockWindow: Bool, completionHandler: (((any Error)?) -> Void)?)\nUpdates the fine and coarse conversion values and indicates whether to send the postback before the conversion window ends, and calls a completion handler if the update fails.\nclass func updatePostbackConversionValue(Int, coarseValue: SKAdNetwork.CoarseConversionValue, completionHandler: (((any Error)?) -> Void)?)\nUpdates the fine and coarse conversion values, and calls a completion handler if the update fails.\nclass func updatePostbackConversionValue(Int, completionHandler: (((any Error)?) -> Void)?)\nVerifies the first launch of an advertised app and, on subsequent calls, updates the conversion value or calls a completion handler if the update fails."
  },
  {
    "title": "canMakePayments",
    "url": "https://developer.apple.com/documentation/storekit/appstore/3822277-canmakepayments",
    "html": "Discussion\n\nUse canMakePayments to determine at runtime whether a person can authorize payments. If your app is configured with entitlements for the External Purchase APIs, canMakePayments informs your app at runtime whether it can call the External Purchase APIs or use the StoreKit In-App Purchase API.\n\nImportant\n\nYour app might need to alter its behavior or appearance when people aren’t allowed to make purchases. For example, don't enable your user interface for making in-app purchases when purchases are blocked.\n\nIf your app uses only StoreKit In-App Purchase APIs, and:\n\ncanMakePayments is true, someone can authorize purchases in the App Store.\n\ncanMakePayments is false, don't offer in-app purchases using StoreKit In-App Purchase APIs.\n\nThe following conditions can cause the value of canMakePayments to be false:\n\nA person sets the Content & Privacy Restrictions in Screen Time to block purchases. For more information, see Use parental controls on your child's iPhone, iPad, and iPod touch.\n\nThe device has a mobile device management (MDM) profile that blocks purchases. For more information, see Device Management.\n\nStoreKit In-App Purchase APIs are unavailable because the app must use the External Purchase APIs instead. See the section below, Interpret this value in apps that use the External Purchase APIs, for more details.\n\nInterpret this value in apps that use the External Purchase APIs\n\nIf your app has the entitlements to use the External Purchase APIs, use canMakePayments to determine at runtime whether to use the External Purchase or StoreKit In-App Purchase API based on the operating system, as follows:\n\nFor apps built with an SDK starting with iOS 17.4, iPadOS 17.4, macOS 14.4, Mac Catalyst 17.4, tvOS 17.4, watchOS 10.4, and Xcode 13.3, and:\n\ncanMakePayments is false, your app can use only External Purchase APIs.\n\ncanMakePayments is true, your app can use only the StoreKit In-App Purchase APIs and can offer in-app purchases.\n\nFor apps built with the iOS 15.4 through 17.3 SDKs, or iPadOS 15.4 through 17.3 SDKs:\n\nYour app must check canMakePayments before attempting to use External Purchase APIs.\n\nIf canMakePayments is true, your app may proceed to call External Purchase APIs.\n\nIf canMakePayments is false, don't call External Purchase APIs.\n\nFor all apps:\n\nAnytime canMakePayments is false, your app can't use StoreKit In-App Purchase for offering in-app purchases.\n\nNote\n\nThe StoreKit APIs always enable your app to view existing transactions and receive auto-renewable subscription renewals, so your app can support your customer’s existing purchases made through the App Store."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/message/3954508-hash",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing messages\nstatic func != (Message, Message) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Message, Message) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "StoreView",
    "url": "https://developer.apple.com/documentation/storekit/storeview",
    "html": "Overview\n\nA StoreView displays a collection of in-app purchase products, including their localized names, descriptions, and prices, and displays a purchase button.\n\nCreate a store view by providing a collection of product identifiers for the view to load from the App Store, or a collection of Product values you previously loaded. If you provide product identifiers, the store view automatically loads the product information from the App Store, and updates the view when the products are available.\n\nYou can provide a view to use as an icon or image for each individual product. If you provide product identifiers, you can optionally provide placeholder icons for the system to use instead of the automatic placeholder icon.\n\nIf you set up promoted images for your products in App Store Connect, you can choose to display those images for your products.\n\nManage the store layout\n\nThe StoreView arranges products in rows. If the view has enough horizontal space available, the store adds columns. In tvOS, the view arranges the products in columns and adds rows as space permits.\n\nThe store view grows to fit its container, and scrolls when the container doesn’t have enough space to display all the products. Use the fixedSize(horizontal:vertical:) modifier to change this behavior.\n\nTo achieve a custom layout, you can compose ProductView instances with other container views instead of using the StoreView.\n\nCustomize the store\n\nYou can customize the store by displaying additional buttons, and applying styles.\n\nTo display a button that syncs in-app purchase entitlements with the App Store, modify the in-app store view or an ancestor view using the storeButton(_:for:) modifier with the parameters Visibility.visible and restorePurchases. The app calls the sync() method when people use this button.\n\nYou can customize the appearance of the products using product view styles, such as CompactProductViewStyle, LargeProductViewStyle, and RegularProductViewStyle. To apply the style, call the productViewStyle(_:) modifier.\n\nTopics\nCreating store views that load products\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool)\nCreates a view to load and merchandise a collection of products from the App Store using product identifiers.\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon: (Product) -> Icon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using a custom image.\ninit(ids: some Collection<String>, prefersPromotionalIcon: Bool, icon: (Product) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using an image and a custom placeholder icon.\ninit(ids: some Collection<String>, icon: (Product, ProductIconPhase) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load a collection of products from the App Store using product identifiers, and merchandise them using their promotional images and a custom placeholder icon.\nCreating store views with preloaded products\ninit(products: some Collection<Product>, prefersPromotionalIcon: Bool)\nCreates a view to load and merchandise a collection of products from the App Store.\ninit(products: some Collection<Product>, prefersPromotionalIcon: Bool, icon: (Product) -> Icon)\nCreates a view to merchandise a collection of products using a custom icon.\ninit(products: some Collection<Product>, icon: (Product, ProductIconPhase) -> Icon)\nCreates a view to merchandise a collection of products with promotional images.\nLoading promotional images\nenum ProductIconPhase\nThe current phase of the asynchronous loading operation of a product’s promotional image.\nResponding to store events\nfunc inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) -> View\nAdds a function the system calls before it processes a purchase from a store view, which provides a set of purchase options.\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, any Error>) -> ())?) -> View\nAdds an action to perform when a purchase the person initiated from within a product view completes.\nfunc onInAppPurchaseStart(perform: ((Product) -> ())?) -> View\nAdds an action to perform when a user triggers the purchase button on a product within this view.\nenum EntitlementTaskState\nThe state of an entitlement task.\nStyling the store view\nfunc productViewStyle(some ProductViewStyle) -> View\nSets the style for in-app purchase product views within a view.\nConfiguring and styling products\nfunc storeButton(Visibility, for: StoreButtonKind...) -> View\nSpecifies the visibility of auxilliary buttons that store view and subscription store view instances may use.\nstruct StoreButtonKind\nA button to display in a store view or subscription store view.\nImplementing store views\nvar body: View\nThe content and behavior of the view.\ntypealias StoreView.Body\nThe type of view that represents the body of the store view.\nInstance Methods\nfunc productDescription(Visibility) -> View\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> View\nfunc subscriptionPromotionalOffer(offer: (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?, signature: (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) -> Product.SubscriptionOffer.Signature) -> View\nRelationships\nConforms To\nView\nSee Also\nMerchandising in-app purchases and subscriptions\nstruct ProductView\nA view that merchandises an individual in-app purchase product.\nstruct SubscriptionStoreView\nA view that merchandises a collection of auto-renewable subscription options in a subscription group."
  },
  {
    "title": "SubscriptionStoreControlStyle",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstorecontrolstyle",
    "html": "Overview\n\nTo configure the subscription store view control style for a view hierarchy, use the subscriptionStoreControlStyle(_:) view modifier.\n\nTopics\nGetting built-in subscription store view styles\nstatic var automatic: AutomaticSubscriptionStoreControlStyle\nA subscription store control style that resolves its appearance automatically, based on the current context.\nAvailable when Self is AutomaticSubscriptionStoreControlStyle.\nstatic var buttons: ButtonsSubscriptionStoreControlStyle\nA subscription store control style that displays a subscribe button for each subscription plan.\nAvailable when Self is ButtonsSubscriptionStoreControlStyle.\nstatic var picker: PickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a picker control, with a single button to subscribe.\nAvailable when Self is PickerSubscriptionStoreControlStyle.\nstatic var prominentPicker: ProminentPickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a prominent picker control, with a single button to subscribe.\nAvailable when Self is ProminentPickerSubscriptionStoreControlStyle.\nSupporting types\nstruct AutomaticSubscriptionStoreControlStyle\nThe default in-app subscription store control style that resolves its appearance based on the view’s context.\nstruct ButtonsSubscriptionStoreControlStyle\nA subscription store control style that displays a subscribe button for each subscription plan.\nstruct PickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a picker control, with a single button to subscribe.\nstruct ProminentPickerSubscriptionStoreControlStyle\nA subscription store control style that displays subscription plans as a prominent picker control, with a single button to subscribe.\nCreating custom subscription store views\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a subscription store control.\n\nRequired\n\ntypealias SubscriptionStoreControlStyle.Configuration\nA type that represents the properties of a subscription store control.\nstruct SubscriptionStoreControlStyleConfiguration\nThe properties of a subscription store view control.\nassociatedtype Body\nA view that represents the body of a subscription store control.\n\nRequired\n\nRelationships\nConforming Types\nAutomaticSubscriptionStoreControlStyle\nButtonsSubscriptionStoreControlStyle\nPickerSubscriptionStoreControlStyle\nProminentPickerSubscriptionStoreControlStyle\nSee Also\nStyling subscription store views\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> View\nSets the background style for picker items of the subscription store view instances within a view.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> View\nSets the control style for subscription store views within a view.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> View\nSets a view to use to decorate individual subscription options within a subscription store view.\nstruct SubscriptionStoreControlBackground"
  },
  {
    "title": "purchase(confirmIn:options:)",
    "url": "https://developer.apple.com/documentation/storekit/product/4115028-purchase",
    "html": "Parameters\nscene\n\nThe UIScene the system uses to show the purchase confirmation UI.\n\noptions\n\nA set of options (Product.PurchaseOption) you can associate with the purchase.\n\nReturn Value\n\nThe result of the purchase, Product.PurchaseResult.\n\nDiscussion\n\nStoreKit provides several APIs you can use to enable customers to initiate a purchase. Before using purchase(confirmIn:options:), consider the following APIs and choose the one that best suits your app’s implementation:\n\nUse PurchaseAction for apps that use SwiftUI, including multi-scene apps for visionOS.\n\nUse purchase(confirmIn:options:) for apps that use UIKit.\n\nUse purchase(options:) if your app runs on watchOS or macOS.\n\nImportant\n\nIf you use StoreKit views such as ProductView, StoreView, or SubscriptionStoreView you don’t need to call any other API to initiate a purchase. StoreKit manages the purchase action automatically, including presenting the purchase confirmation UI. For more information, see StoreKit views.\n\nThe purchase(confirmIn:options:) method may throw a Product.PurchaseError or StoreKitError.\n\nSee Also\nPurchasing a product\nfunc purchase(options: Set<Product.PurchaseOption>) -> Product.PurchaseResult\nInitiates a purchase for the product with the App Store and displays the confirmation sheet.\nstruct Product.PurchaseOption\nOptional settings for a product purchase.\nenum Product.PurchaseResult\nThe result of a purchase.\nenum Product.PurchaseError\nError information for product purchase errors."
  },
  {
    "title": "SubscriptionStoreView",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview",
    "html": "Overview\n\nA SubscriptionStoreView displays localized information about auto-renewable subscriptions, including their localized names, descriptions, and prices, and a purchase button.\n\nCreate a subscription store view by using one of the initializers and providing the following information:\n\nA subscription group identifier\n\nA collection of product identifiers\n\nA collection of product values you previously loaded from the App Store\n\nIf you provide a subscription group identifier or a collection of product identifiers, the subscription store view automatically loads the subscription data from the App Store, and updates the view when the data is available.\n\nProvide a background and a decorative icon\n\nThe subscription store view doesn’t draw a background by default. You can add a background as follows:\n\nTo layer a background behind the view, use a modifier, such as background(alignment:content:).\n\nTo set the container background of the subscription store using a view, use the containerBackground(_:for:) or containerBackground(for:alignment:content:) view modifier and specify a ContainerBackgroundPlacement, such as subscriptionStoreHeader.\n\nYou can optionally provide a view as a decorative icon next to each subscription option. Use the subscriptionStoreControlIcon(icon:) view modifier to set a view that decorates individual subscription options within a subscription store.\n\nOrder and filter subscriptions\n\nIf you create the subscription store view by providing a subscription group identifier, the system orders the subscription options according to their rank. If the customer is already subscribed, you may want to merchandise an upgrade or crossgrade option. By default, the subscription store view lists all the subscriptions in the group. To hide certain subscription options, provide a visibleRelationships parameter.\n\nIf you create the subscription store view using one of the other initializers, the view orders the subscriptions according to the collection parameter’s order. The view excludes any subscriptions that you don’t include in the collection parameter.\n\nAdd terms of service and privacy policies\n\nThe SubscriptionStoreView automatically displays buttons for the terms of service and privacy policy that you submit in App Store Connect. You may want to override the destination of these buttons with a URL to a custom terms of service and privacy policy page, or a custom view. You can do this using the modifiers subscriptionStorePolicyDestination(url:for:) and subscriptionStorePolicyDestination(for:destination:).\n\nIf the automatic style of these buttons is difficult to read against your store’s background, use modifiers like subscriptionStorePolicyForegroundStyle(_:) to customize the button’s style.\n\nAdd auxiliary buttons\n\nIn addition to the various initializers, you can further configure the subscription store using view modifiers to show auxiliary buttons, such as a sign-in button. You specify the button’s visibility within the subscription store using the storeButton(_:for:) view modifier.\n\nIf your subscription is available through other services, you can configure the subscription store view to display a sign-in button. You can use the button to provide a custom sign-in flow to support your current subscribers. Use the subscriptionStoreSignInAction(_:) modifier to set the function your app calls when someone uses the sign-in button.\n\nThe subscription store view shows a Close button automatically. To override this behavior, use the storeButton(_:for:) modifier to unconditionally show, or hide, the Close button.\n\nStyle the subscription store view\n\nYou can further customize the subscription store’s appearance using various control styles. Use the subscription store control styles to customize how subscription options display, and how people are able to interact with your store. To try out standard styles, such as PickerSubscriptionStoreControlStyle, apply the style using the subscriptionStoreControlStyle(_:) modifier.\n\nTopics\nCreating subscription store views with subscription group IDs\ninit(groupID: String, visibleRelationships: Product.SubscriptionRelationship)\nCreates a view to load all subscriptions in a subscription group from the App Store and merchandise them with automatic marketing content.\ninit(groupID: String, visibleRelationships: Product.SubscriptionRelationship, marketingContent: () -> (Content))\nCreates a view to load all the subscriptions in a subscription group from the App Store and merchandise them with custom marketing content.\nstruct AutomaticSubscriptionStoreMarketingContent\nA view that represents the default marketing content for a subscription store.\nCreating subscription store views with product IDs\ninit(productIDs: some Collection<String>)\nCreates a view to load a collection of subscriptions and merchandise them with automatic marketing content.\ninit(productIDs: some Collection<String>, marketingContent: () -> (Content))\nCreates a view to load a collection of subscriptions from the App Store and merchandise them with custom marketing content.\nCreating subscription store views with preloaded subscriptions\ninit(subscriptions: some Collection<Product>)\nCreates a view to display a collection of subscription options and merchandise them with automatic marketing content.\ninit(subscriptions: some Collection<Product>, marketingContent: () -> (Content))\nCreates a view to display a collection of subscription options and merchandise them with custom marketing content.\nResponding to store events\nfunc inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) -> View\nAdds a function the system calls before it processes a purchase from a store view, which provides a set of purchase options.\nfunc onInAppPurchaseStart(perform: ((Product) -> ())?) -> View\nAdds an action to perform when a person uses the purchase button for a product within the view.\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, any Error>) -> ())?) -> View\nAdds an action to perform when a purchase the person initiates from within a product view completes.\nfunc subscriptionStoreSignInAction((() -> ())?) -> View\nAdd an action to perform when a person uses the sign-in button on a subscription store view within the view.\nenum EntitlementTaskState\nThe state of an entitlement task.\nConfiguring subscription store view controls\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> View\nSets a view to use to decorate individual subscription options within a subscription store view.\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> View\nSets the background style for picker items of the subscription store view instances within a view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> View\nConfigures the subscription store views within a view to use a specified button label.\nstruct SubscriptionStoreButtonLabel\nThe label of the subscribe button that a subscription store view uses.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> View\nSets the control style for subscription store views within a view.\nAdding accessory feature buttons\nfunc storeButton(Visibility, for: StoreButtonKind...) -> View\nSpecifies the visibility of auxilliary buttons that store view and subscription store view instances may use.\nstruct StoreButtonKind\nA button to display in a store view or subscription store view.\nStyling the subscription store view\nstruct ContainerBackgroundPlacement\nThe placement of a container background.\nConfiguring the subscription store policies\nfunc subscriptionStorePolicyDestination(for: SubscriptionStorePolicyKind, destination: () -> some View) -> View\nConfigures a view as the destination for a policy button action in subscription store views.\nfunc subscriptionStorePolicyDestination(url: URL, for: SubscriptionStorePolicyKind) -> View\nConfigures a URL as the destination for a policy button action in subscription store views.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle) -> View\nSets the style for the terms of service and privacy policy buttons within a subscription store view.\nfunc subscriptionStorePolicyForegroundStyle(some ShapeStyle, some ShapeStyle) -> View\nSets the primary and secondary style for the terms of service and privacy policy buttons within a subscription store view.\nstruct SubscriptionStorePolicyKind\nThe type of policy, such as the terms of service or privacy policies.\nImplementing a subscription store view\nvar body: View\nThe content and behavior of the view.\ntypealias SubscriptionStoreView.Body\nThe type of view that represents the body of the subscription store view.\nInstance Methods\nfunc productDescription(Visibility) -> View\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> View\nfunc subscriptionPromotionalOffer(offer: (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?, signature: (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) -> Product.SubscriptionOffer.Signature) -> View\nRelationships\nConforms To\nView\nSee Also\nMerchandising in-app purchases and subscriptions\nstruct ProductView\nA view that merchandises an individual in-app purchase product.\nstruct StoreView\nA view that merchandises a collection of in-app purchase products."
  },
  {
    "title": "ProductViewStyle",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyle",
    "html": "Overview\n\nTo configure the in-app purchase product style for a view hierarchy, use the productViewStyle(_:) modifier.\n\nTo create a custom style, declare a type that conforms to the ProductViewStyle protocol. Implement the makeBody(configuration:) method to return a view that composes the elements of the configuration that the system provides to your method. The following code example shows how to create a custom product view style:\n\nstruct CustomProductViewStyle: ProductViewStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        switch configuration.state {\n        // Add other cases here.\n        case .success(let product):\n            VStack(alignment: .center) {\n                configuration.icon\n                Text(product.displayName)\n                Button(product.displayPrice) {}\n            }\n        }\n    }\n}\n\n\nProductView(id: \"com.example.product\")\n    .productViewStyle(CustomProductViewStyle())\n    // Add your code here.\n\n\nTopics\nGetting built-in product view styles\nstatic var automatic: AutomaticProductViewStyle\nAvailable when Self is AutomaticProductViewStyle.\nstatic var compact: CompactProductViewStyle\nAn product view style suitable for layouts where less space is available, or for displaying more items in a small amount of space.\nAvailable when Self is CompactProductViewStyle.\nstatic var large: LargeProductViewStyle\nA product view style suitable for layouts where the in-app purchase content is prominent.\nAvailable when Self is LargeProductViewStyle.\nstatic var regular: RegularProductViewStyle\nA product view style that uses a standard, platform-appropriate layout.\nAvailable when Self is RegularProductViewStyle.\nSupporting types\nstruct AutomaticProductViewStyle\nstruct CompactProductViewStyle\nA style for a product view that’s suitable for layouts with less available space, or for displaying more items in a small amount of space.\nstruct RegularProductViewStyle\nA style for a product view that uses a standard, platform-appropriate layout.\nstruct LargeProductViewStyle\nA style for a product view that’s suitable for layouts where the in-app purchase content is prominent.\nCreating custom product views\nfunc makeBody(configuration: Self.Configuration) -> Self.Body\nCreates a view that represents the body of a product view.\n\nRequired\n\ntypealias ProductViewStyle.Configuration\nA type that represents the properties of a product view style.\nassociatedtype Body\nA view that represents the body of a product view.\n\nRequired\n\nRelationships\nConforming Types\nAutomaticProductViewStyle\nCompactProductViewStyle\nLargeProductViewStyle\nRegularProductViewStyle\nSee Also\nStyling product views\nfunc productViewStyle(some ProductViewStyle) -> View\nSets the style for in-app purchase product views within a view.\nstruct ProductViewStyleConfiguration\nThe properties of an in-app purchase product for use by custom product view styles."
  },
  {
    "title": "ProductView",
    "url": "https://developer.apple.com/documentation/storekit/productview",
    "html": "Overview\n\nA ProductView shows information about an in-app purchase product, including its localized name, description, and price, and displays a purchase button.\n\nYou create a product view by providing a product identifier to load from the App Store, or a Product value you previously loaded. If you provide a product identifier, the view loads the product’s information from the App Store automatically, and updates the view when the product is available.\n\nYou can customize the view by providing a view to use as an icon, or image, for the in-app purchase product. If you provide a product identifier, you can optionally provide a placeholder icon for the system to use instead of the automatic placeholder icon. If you set up promoted images for your products in App Store Connect, you can choose to use those images as the icon.\n\nYou can customize the product view’s appearance using the standard styles, including the CompactProductViewStyle, RegularProductViewStyle, and LargeProductViewStyle styles. Apply the style using the productViewStyle(_:) view modifier.\n\nYou can also create your own custom styles by creating styles that conform to the ProductViewStyle protocol.\n\nTopics\nCreating product views that load products\ninit(id: Product.ID, prefersPromotionalIcon: Bool)\nCreates a view to load and merchandise an individual product from the App Store.\ninit(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon)\nCreates a view to load an individual product from the App Store and merchandise it using a custom icon.\ninit(id: Product.ID, prefersPromotionalIcon: Bool, icon: () -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load an individual product from the App Store and merchandise it using an image and a custom placeholder icon.\ninit(id: Product.ID, icon: (ProductIconPhase) -> Icon, placeholderIcon: () -> PlaceholderIcon)\nCreates a view to load an individual product from the App Store, and merchandise it using its promotional image and a custom placeholder icon.\nCreating product views with preloaded products\ninit(Product, prefersPromotionalIcon: Bool, icon: () -> Icon)\nCreates a view to merchandise an individual product using a custom icon.\ninit(Product, prefersPromotionalIcon: Bool)\nCreates a view to merchandise an individual product.\ninit(Product, icon: (ProductIconPhase) -> Icon)\nCreates a view to display a product that the system already loaded from the App Store, and merchandise it using its promotional image.\nCreating product views with a configuration\ninit(ProductViewStyleConfiguration)\nCreates a view to merchandise an individual product using a configuration for product view style.\nstruct AutomaticProductPlaceholderIcon\nA view that represents the default placeholder icon for an in-app store product.\nLoading promotional images\nenum ProductIconPhase\nThe current phase of the asynchronous loading operation of a product’s promotional image.\nResponding to store events\nfunc inAppPurchaseOptions(((Product) -> Set<Product.PurchaseOption>)?) -> View\nAdds a function the system calls before it processes a purchase from a product view, which provides a set of purchase options.\nfunc onInAppPurchaseStart(perform: ((Product) -> ())?) -> View\nAdds an action to perform when a person uses the purchase button for a product within the view.\nfunc onInAppPurchaseCompletion(perform: ((Product, Result<Product.PurchaseResult, any Error>) -> ())?) -> View\nAdds an action to perform when a purchase the person initiates from within a product view completes.\nenum EntitlementTaskState\nThe state of an entitlement task.\nStyling the product view\nfunc productViewStyle(some ProductViewStyle) -> View\nSets the style for in-app purchase product views within a view.\nImplementing a product view\nvar body: View\nThe content and behavior of the view.\ntypealias ProductView.Body\nThe type of view that represents the body of the product view.\nInstance Methods\nfunc productDescription(Visibility) -> View\nfunc searchPresentationToolbarBehavior(SearchPresentationToolbarBehavior) -> View\nfunc subscriptionPromotionalOffer(offer: (Product, Product.SubscriptionInfo) -> Product.SubscriptionOffer?, signature: (Product, Product.SubscriptionInfo, Product.SubscriptionOffer) -> Product.SubscriptionOffer.Signature) -> View\nRelationships\nConforms To\nView\nSee Also\nMerchandising in-app purchases and subscriptions\nstruct StoreView\nA view that merchandises a collection of in-app purchase products.\nstruct SubscriptionStoreView\nA view that merchandises a collection of auto-renewable subscription options in a subscription group."
  },
  {
    "title": "Product.PurchaseResult.success(_:)",
    "url": "https://developer.apple.com/documentation/storekit/product/purchaseresult/success",
    "html": "See Also\nGetting the Purchase Results\ncase userCancelled\nThe user canceled the purchase.\ncase pending\nThe purchase is pending, and requires action from the customer."
  },
  {
    "title": "subscriptionStoreControlStyle(_:)",
    "url": "https://developer.apple.com/documentation/storekit/storeview/4240620-subscriptionstorecontrolstyle",
    "html": "Discussion\n\nModify the control style of the in-app subscription store, SubscriptionStoreView. This has no effect on StoreView and ProductView instances.\n\nSee Also\nStyling subscription store views\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> View\nSets the background style for picker items of the subscription store view instances within a view.\nprotocol SubscriptionStoreControlStyle\nA type that specifies the appearance and interaction of controls in the subscription store view instances within the view hierarchy.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> View\nSets a view to use to decorate individual subscription options within a subscription store view.\nstruct SubscriptionStoreControlBackground"
  },
  {
    "title": "ProductViewStyleConfiguration",
    "url": "https://developer.apple.com/documentation/storekit/productviewstyleconfiguration",
    "html": "Overview\n\nUse the ProductViewStyleConfiguration to create a custom ProductViewStyle.\n\nTopics\nGetting a product's information\nvar product: Product?\nThe in-app purchase product to merchandise.\nlet state: Product.TaskState\nThe product task state that indicates the product’s loading phase.\nlet hasCurrentEntitlement: Bool\nA Boolean value that indicates whether an in-app purchase transaction exists for the product.\nGetting a product view's icon\nlet icon: ProductViewStyleConfiguration.Icon\nA decorative view for merchandising the product.\nstruct ProductViewStyleConfiguration.Icon\nA type-erased icon of an in-app purchase product.\nInitiating a purchase\nfunc purchase()\nInitiates a purchase action for the product.\nInstance Properties\nlet descriptionVisibility: Visibility\nSee Also\nStyling product views\nfunc productViewStyle(some ProductViewStyle) -> View\nSets the style for in-app purchase product views within a view.\nprotocol ProductViewStyle\nA type that specifies the appearance and interaction of in-app purchase products within the view hierarchy."
  },
  {
    "title": "price",
    "url": "https://developer.apple.com/documentation/storekit/product/3749586-price",
    "html": "Discussion\n\nUse this property to perform arithmetic calculations with the price of the product. For a localized string representation of the price to display to customers, use the displayPrice property instead.\n\nSee Also\nDisplaying a product description and price\nlet displayName: String\nThe localized display name of the product, if it exists.\nlet description: String\nThe localized description of the product.\nlet displayPrice: String\nThe localized string representation of the product price, suitable for display.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency\nThe format style for the numbers in the price of the product.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var subscriptionPeriodFormatStyle: Date.ComponentsFormatStyle\nThe format style for the date components related to a subscription’s duration.\nvar subscriptionPeriodUnitFormatStyle: Product.SubscriptionPeriod.Unit.FormatStyle\nThe format style for subscription period units, such as week, month, or year."
  },
  {
    "title": "description",
    "url": "https://developer.apple.com/documentation/storekit/product/3749578-description",
    "html": "Discussion\n\nThe storefront of the device determines the language of the description, not the preferred language set on the device. For more information, see Storefront.\n\nNote\n\nWhen you create a new product in App Store Connect or in a StoreKit configuration file, you can test it before you add a product localization. The description value is an empty string until you add a localization. For more information on localizations, see Add and remove localizations.\n\nSee Also\nDisplaying a product description and price\nlet displayName: String\nThe localized display name of the product, if it exists.\nlet displayPrice: String\nThe localized string representation of the product price, suitable for display.\nlet price: Decimal\nThe decimal representation of the cost of the product, in local currency.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency\nThe format style for the numbers in the price of the product.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var subscriptionPeriodFormatStyle: Date.ComponentsFormatStyle\nThe format style for the date components related to a subscription’s duration.\nvar subscriptionPeriodUnitFormatStyle: Product.SubscriptionPeriod.Unit.FormatStyle\nThe format style for subscription period units, such as week, month, or year."
  },
  {
    "title": "displayPrice",
    "url": "https://developer.apple.com/documentation/storekit/product/3749580-displayprice",
    "html": "Discussion\n\nUse this string to display the price, formatted for the locale. The storefront that the user’s device is connected to determines the locale. For more information, see Storefront.\n\nTo perform arithmetic calculations with the price, use the price property instead.\n\nSee Also\nDisplaying a product description and price\nlet displayName: String\nThe localized display name of the product, if it exists.\nlet description: String\nThe localized description of the product.\nlet price: Decimal\nThe decimal representation of the cost of the product, in local currency.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency\nThe format style for the numbers in the price of the product.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var subscriptionPeriodFormatStyle: Date.ComponentsFormatStyle\nThe format style for the date components related to a subscription’s duration.\nvar subscriptionPeriodUnitFormatStyle: Product.SubscriptionPeriod.Unit.FormatStyle\nThe format style for subscription period units, such as week, month, or year."
  },
  {
    "title": "productViewStyle(_:)",
    "url": "https://developer.apple.com/documentation/storekit/productview/4202371-productviewstyle",
    "html": "Parameters\nstyle\n\nThe style to apply to the in-app purchase product views within the view.\n\nDiscussion\n\nThis modifier styles any ProductView or StoreView instances within a view."
  },
  {
    "title": "inGracePeriod",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/renewalstate/3749521-ingraceperiod",
    "html": "Discussion\n\nAn auto-renewable subscription in this state is entitled to service.\n\nSee Also\nGetting the renewal state\nstatic let subscribed: Product.SubscriptionInfo.RenewalState\nThe user is currently subscribed.\nstatic let expired: Product.SubscriptionInfo.RenewalState\nThe subscription expired.\nstatic let inBillingRetryPeriod: Product.SubscriptionInfo.RenewalState\nThe subscription is in a billing retry period.\nstatic let revoked: Product.SubscriptionInfo.RenewalState\nThe App Store has revoked the user’s access to the subscription group."
  },
  {
    "title": "subscriptionStorePickerItemBackground(_:)",
    "url": "https://developer.apple.com/documentation/storekit/subscriptionstoreview/4204236-subscriptionstorepickeritembackg",
    "html": "See Also\nConfiguring subscription store view controls\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> View\nSets a view to use to decorate individual subscription options within a subscription store view.\nfunc subscriptionStoreButtonLabel(SubscriptionStoreButtonLabel) -> View\nConfigures the subscription store views within a view to use a specified button label.\nstruct SubscriptionStoreButtonLabel\nThe label of the subscribe button that a subscription store view uses.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> View\nSets the control style for subscription store views within a view."
  },
  {
    "title": "callAsFunction(_:options:)",
    "url": "https://developer.apple.com/documentation/storekit/purchaseaction/4246147-callasfunction",
    "html": "Parameters\nproduct\n\nThe in-app purchase Product the customer is purchasing.\n\noptions\n\nA set of options you may associate with the purchase (Product.PurchaseOption).\n\nReturn Value\n\nThe result of the purchase, Product.PurchaseResult.\n\nDiscussion\n\nDon’t call this method directly. SwiftUI calls it when you call the PurchaseAction structure with the product and options as arguments.\n\nThis method may throw a Product.PurchaseError or StoreKitError.\n\nFor information about how Swift uses the callAsFunction(_:options:) method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language."
  },
  {
    "title": "deviceVerification",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749690-deviceverification",
    "html": "Discussion\n\nWhenever StoreKit returns a verified transaction, the transaction is valid for the device. To perform your own verification, compute the device verification hash as follows:\n\nGet the lowercase UUID string representation of deviceVerificationNonce.\n\nAppend the lowercase UUID string representation of deviceVerificationID.\n\nCompute the SHA-384 hash of the ASCII representation of the combined string.\n\nCompare the value you calculated to the transaction’s deviceVerification value. If the values match, the transaction is valid for the device. Otherwise, the verification fails and the transaction isn’t valid for the device. The following example illustrates validating a transaction.\n\nguard let deviceVerificationUUID = AppStore.deviceVerificationID else {\n    print(\"Device Verification ID isn't available.\")\n    return\n}\n\n\n// Assemble the values to hash.\nlet deviceVerificationIDString = deviceVerificationUUID.uuidString.lowercased()\nlet nonceString = transaction.deviceVerificationNonce.uuidString.lowercased()\nlet hashTargetString = nonceString.appending(deviceVerificationIDString)\n\n\n// Compute the hash.\nlet hashTargetData = Data(hashTargetString.utf8)\nlet digest = SHA384.hash(data: hashTargetData)\nlet digestData = Data(digest)\nif digestData == transaction.deviceVerification {\n    print(\"Transaction is valid for this device.\")\n} else {\n    print(\"Transaction isn't valid for this device.\")\n}\n\n\nSee Also\nVerifying transactions\nlet deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nlet signedDate: Date\nThe date that the App Store signed the JWS transaction."
  },
  {
    "title": "finish()",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749694-finish",
    "html": "Discussion\n\nCall finish() to complete a transaction after you deliver the purchased content or enable the purchased service. For on-demand resources, don’t finish the transaction until the app completes downloading the resource or you’ve otherwise delivered the resource.\n\nSee Also\nFinishing the transaction\nstatic var unfinished: Transaction.Transactions\nA sequence that emits unfinished transactions for the user."
  },
  {
    "title": "deviceVerificationNonce",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3749691-deviceverificationnonce",
    "html": "Discussion\n\nUse the lowercased nonce when computing the deviceVerification value.\n\nSee Also\nVerifying transactions\nlet deviceVerification: Data\nThe device verification value you use to verify whether the transaction belongs to the device.\nlet signedDate: Date\nThe date that the App Store signed the JWS transaction."
  },
  {
    "title": "Supporting subscription offer codes in your app",
    "url": "https://developer.apple.com/documentation/storekit/appstore/supporting_subscription_offer_codes_in_your_app",
    "html": "Overview\n\nTo help you acquire, retain, and win back subscribers, you can use offer codes. Offer codes are alphanumeric codes that provide subscriptions at a discount or for free for a specific duration. Configure the offers and create offer codes in App Store Connect, and distribute them to your customers. Customers can redeem offer codes in the App Store, using offer code redemption URLs, or in your app if you’ve implemented one of the following APIs:\n\nofferCodeRedemption(isPresented:onCompletion:) or presentOfferCodeRedeemSheet(in:), which are available in iOS 16 and later and iPadOS 16 and later\n\npresentCodeRedemptionSheet(), which is available in iOS 14 and later and iPadOS 14 and later\n\nWhen customers redeem a valid offer code, your app receives a successful transaction. If customers redeem offer codes in the App Store and don’t have your app installed, they’re prompted to download it as part of the redemption flow. Successfully redeeming an offer code entitles the customer to the auto-renewable subscription, the same as a purchase does. Your app needs to provide service for the product.\n\nSet up offer codes in App Store Connect\n\nConfigure offers and manage your offer codes in App Store Connect. You can have up to 10 active offers per subscription, and create codes for a maximum of 1,000,000 redemptions per app, per quarter. There are two types of offer codes: one-time use codes, and custom codes. The offer code redemption APIs support both.\n\nDownload the offer codes from App Store Connect to distribute them to your customers. For more information on creating and distributing offer codes, and to learn which type of offer code may work for your campaign, see Set up offer codes.\n\nRedeem offer codes in your app\n\nTo display the system sheet for customers to redeem offer codes within your app, call one of the redemption APIs, depending on your app’s UI implementation:\n\nCall offerCodeRedemption(isPresented:onCompletion:) if your app uses SwiftUI.\n\nCall presentOfferCodeRedeemSheet(in:) if your app uses UIKit.\n\nCall presentCodeRedemptionSheet() for apps running on devices prior to iOS 16 and iPadOS 16.\n\nThe redemption sheet takes care of the redemption flow, including alerting users about invalid entries, as appropriate. Invalid entries may include, for example, expired offer codes, invalid codes, or codes that would result in a subscription downgrade.\n\nIncluding the redemption sheet in your app is recommended, but optional. For more guidance on supporting offer code redemption within your app, see Human Interface Guidelines > In-app purchase.\n\nSupport offer codes redeemed outside of your app\n\nCustomers may redeem offer codes outside your app, by entering the offer code in the App Store, or by using a redemption URL. To handle offer codes — and other transactions that can occur outside of your app — your app needs to use updates on Transaction to receive new transactions while the app is running. Create a Task to iterate through the transactions from the listener as soon as your app launches. For more information and sample code, see updates.\n\nWhen the app launches, it needs to check all or currentEntitlements on Transaction to get any transactions that may have occurred while the app wasn’t running. Process the transactions to ensure your app provides service for all products it’s entitled to.\n\nIdentify subscriptions purchased with offer codes\n\nWhen customers successfully redeem subscription offer codes, the transaction or subscription renewal information contain fields that identify the offer and its offer type. Find the offer code details in the transaction information, in your app and on your server, as follows.\n\nIn your app, use the following StoreKit APIs to locate the offer code information:\n\nSee the Transaction properties offerID and offerType. An offer type value of code indicates the customer redeemed an offer code.\n\nSome offer code redemptions may apply to an auto-renewable subscription’s next renewal period, for example, if the customer is already subscribed. In this case, see the Product.SubscriptionInfo.RenewalInfo properties offerID and offerType. An offer type value of code indicates the customer redeemed an offer code.\n\nOn your server, use the following server-side APIs to locate offer code information:\n\nIn the App Store Server API, when you call endpoints such as Get Transaction History, Get All Subscription Statuses, and others, the response contains the signed transaction, JWSTransaction. In its decoded payload, JWSTransactionDecodedPayload, look for the fields offerIdentifier and offerType. An offerType value of 3 indicates the customer redeemed an offer code.\n\nThe App Store Server Notifications V2 sends a notification with an OFFER_REDEEMED notificationType when someone redeems an offer code. The decoded payloads JWSTransactionDecodedPayload and JWSRenewalInfoDecodedPayload contain the fields offerIdentifier and offerType. An offerType value of 3 indicates the customer redeemed an offer code.\n\nProvide subscription service to new and existing customers\n\nWhen you acquire new customers with an offer code, they already have an auto-renewable subscription when they open your app for the first time. In addition to providing subscription service, you may need to update your backend system’s records. Your app follows these steps:\n\nWhen the app launches, check all or currentEntitlements on Transaction to get all transactions or current entitlements, respectively. StoreKit automatically validates the transactions, and returns verified results in VerificationResult.verified(_:). To perform your own validation, use the jwsRepresentation property.\n\nTo determine if a subscription results from an offer code redemption, check the offerID and offerType properties on the subscription’s Transaction.\n\nProvide the subscription service based on the offer and call finish() on Transaction.\n\nGuide new customers through your new-user experience, as needed. Update your backend system’s records.\n\nWhen an existing customer redeems an offer code within your app, the transaction comes in through the updates sequence on Transaction. Process the transaction as usual, providing service based on the offer, and call finish()."
  },
  {
    "title": "Supporting promoted in-app purchases in your app",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/supporting_promoted_in-app_purchases_in_your_app",
    "html": "Overview\n\nWith iOS, you can promote in-app purchases so users can browse them directly on the App Store. Promoted in-app purchases display on your product page, appear in search results, and may be featured on an appropriate tab on the App Store. Users can start a purchase on the App Store, which takes them into your app to continue the transaction.\n\nIf your app isn’t installed when the user selects to purchase the in-app product, the App Store automatically downloads the app or prompts the user to purchase it. If the installed version of your app is an older version that doesn’t support in-app purchase promotions, the App Store prompts the user to upgrade the app.\n\nPromoting in-app purchases requires two steps:\n\nIn your app, starting in iOS 16.4, implement PurchaseIntent to complete the purchase users initiate on the App Store. To support this feature in apps that run in iOS 11–16.3, see Promoting in-app purchases.\n\nIn App Store Connect, configure promoted in-app purchases. For more information, see Promote in-app purchases.\n\nImportant\n\nTo enable promoted in-app purchases, your app needs to use either PurchaseIntent (starting in iOS 16.4) or paymentQueue(_:shouldAddStorePayment:for:) (starting in iOS 11). Don’t use both at the same time. If necessary, use conditional compilation to identify the OS version the app is running in. For more information, see Running code on a specific platform or OS version.\n\nYou can optionally customize which promoted in-app purchases a users sees on a specific device using the Product.PromotionInfo API. Using Product.PromotionInfo isn’t required for your promoted in-app purchases to appear on the App Store.\n\nFor marketing guidance on this feature, see Promoting Your In-App Purchases.\n\nTo test promoted in-app purchases, see Testing promoted in-app purchases.\n\nNote\n\nPromoted in-app purchases aren’t available to compatible iPad or iPhone apps running in visionOS.\n\nSet up promoted in-app purchases using App Store Connect\n\nIn App Store Connect, set up promoted in-app purchases by uploading promotional images. Use the App Store Promotions feature in App Store Connect to manage their default order and visibility. For more information about the setup, see Promote in-app purchases.\n\nComplete the purchase in your app\n\nWhen users initiate an in-app purchase on the App Store, StoreKit automatically opens your app and sends the product information in the intents asynchronous sequence of PurchaseIntent. Your app needs to complete the purchase transaction and perform any related actions that are specific to it.\n\nTo complete the transaction, call the purchase(options:) method on the product of the PurchaseIntent. Follow the same workflow your app uses for any in-app purchase, such as unlocking the purchased content and finishing the transaction (finish()).\n\nThe following code example listens for purchase intents from the App Store. It receives a Product object when the user taps a promoted in-app purchase on the App Store, and performs its purchase workflow.\n\nfor await purchaseIntent in PurchaseIntent.intents {\n    // Complete the purchase workflow.\n    do {\n        try await purchaseIntent.product.purchase()\n    }\n    catch {\n        <#Handle Error#>\n    }\n}\n\n\nDefer or cancel the purchase\n\nIn some cases, your app may need to defer or cancel the purchase transaction. For example, you may need to defer the transaction if the user is in the middle of onboarding, and complete it after they finish. Or, you may need to cancel the transaction if the user has already unlocked the product they’re trying to buy.\n\nTo defer the transaction, store the purchase intent and process it later after the user finishes onboarding or other actions that require deferring.\n\nTo cancel the transaction, don’t call purchase(options:). Instead, provide feedback to the user. Although this step is optional, if you don’t provide feedback, the app’s lack of action after the user initiates the purchase on the App Store may seem like a bug.\n\nCustomize promoted product order and visibility on a device\n\nTo customize promoted in-app purchases on a device, you can override their default order and visibility using Product.PromotionInfo. Use it to show only promotions that are relevant to your user, based on their experience with your app, or based on their previous purchases. For example, suppose a game has in-app purchases to promote for each game level. You can show only the promoted products for the user’s game level, and hide those they already purchased.\n\nTo control whether a promoted in-app purchase appears in the App Store on the device, use any of these methods:\n\nAdd or remove it from the list. Set the product order by calling updateAll(_:) or updateProductOrder(byID:). Leave out the products you don’t want to display.\n\nSet its visibility. Show or hide the product by setting its visibility value and calling update() or updateAll(_:), or call updateProductVisibility(_:for:).\n\nThese overrides are specific to the device, and take effect after the user launches the app at least once.\n\nThe following code example uses an array of product identifiers to set their order. It calls currentOrder to get the Product.PromotionInfo objects, and sets their visibility directly. It then calls updateAll(_:) to save the changes.\n\n// Set the product order.\nlet orderedProductIdentifiers = [\n    \"com.example.ExampleApp.product1\",\n    \"com.example.ExampleApp.product2\",\n    \"com.example.ExampleApp.product3\"\n]\n\n\ndo {\n    try await Product.PromotionInfo.updateProductOrder(byID: orderedProductIdentifiers)\n}\ncatch {\n    <#Handle Error#>\n}\n\n\n// Get the current product order.\nvar promotions: [Product.PromotionInfo] = []\n\n\ndo {\n    promotions = try await Product.PromotionInfo.currentOrder\n}\ncatch {\n    <#Handle Error#>\n}\n\n\n// Set the visibility for all the products and save the changes.\nfor i in promotions.indices {\n    promotions[i].visibility = .visible\n}\n\n\ndo {\n    try await Product.PromotionInfo.updateAll(promotions)\n}\ncatch {\n    <#Handle Error#>\n}\n\n\nThe following code example hides a promoted product after the user purchases it:\n\n// Change the visibility to hide a promoted product after a user purchases it.\nlet purchasedProductIdentifier = \"com.example.ExampleApp.product1\"\n\n\ndo {\n    try await Product.PromotionInfo.updateProductVisibility(.hidden, for: purchasedProductIdentifier)\n}\ncatch {\n    <#Handle Error#>\n}\n\n\nControl a promotion's visibility from App Store Connect\n\nTo control a promotion’s visibility from App Store Connect, set its visibility value in the app to the default of Product.PromotionInfo.Visibility.appStoreConnectDefault. Products with this value are visible or hidden based on the setting you configure in App Store Connect. For more information about using App Store Connect, see Promote in-app purchases.\n\nFor example, to promote a product on a holiday for all users, ensure the app sets the product’s visibility to Product.PromotionInfo.Visibility.appStoreConnectDefault. In App Store Connect, start with its visibility set as hidden. On the holiday, use App Store Connect to manually change the product to be visible. The promoted product becomes visible in the App Store for all users automatically.\n\nCancel overrides\n\nTo reset changes your app makes to the promoted products' order and visibility, call the updateAll(_:) or updateProductOrder(byID:) methods with an empty array. This cancels the overrides so the user can see the promoted in-app purchases in their default order.\n\nCall currentOrder to get a list of your overrides. If the list is empty, the device displays promoted in-app purchases in their default order.\n\nSee Also\nPromoted in-app purchases\nstruct PurchaseIntent\nAn instance that emits purchase intents, which indicates that the customer initiated a promoted in-app purchase on the App Store for your app to complete.\nstruct Product.PromotionInfo\nInformation about a promoted in-app purchase that customizes its order and visibility on the device.\nTesting promoted in-app purchases\nTest your in-app purchases before making your app available in the App Store."
  },
  {
    "title": "unfinished",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3856631-unfinished",
    "html": "Discussion\n\nA transaction is unfinished until you call finish(). Use the unfinished sequence to find the transactions your app needs to process to deliver purchased content or enable service.\n\nSee Also\nFinishing the transaction\nfunc finish()\nIndicates to the App Store that the app delivered the purchased content or enabled the service to finish the transaction."
  },
  {
    "title": "AppStore",
    "url": "https://developer.apple.com/documentation/storekit/appstore",
    "html": "Overview\n\nUse these static functions and variables to perform tasks like showing the manage subscriptions sheet, getting the device verification ID, determining whether users can make purchases, and more.\n\nTopics\nChecking the environment\nstruct AppStore.Environment\nConstants that represent the App Store server environment.\nChecking payment setup\nstatic var canMakePayments: Bool\nA Boolean value that indicates whether the person can make purchases.\nVerifying devices\nstatic var deviceVerificationID: UUID?\nThe device verification identifier to use to verify whether signed information is valid for the current device.\nManaging subscriptions\nstatic func showManageSubscriptions(in: UIWindowScene)\nPresents the App Store sheet for managing subscriptions.\nstatic func showManageSubscriptions(in: UIWindowScene, subscriptionGroupID: String)\nPresents the App Store sheet for managing subscriptions for a subscription group.\nRequesting reviews\nstruct RequestReviewAction\nAn instance that tells StoreKit to request an App Store rating or review, if appropriate.\nstatic func requestReview(in: UIWindowScene)\nTells StoreKit to request an App Store rating or review from the user, if appropriate, using the specified scene.\nstatic func requestReview(in: NSViewController)\nTells StoreKit to request an App Store rating or review from the user, if appropriate, using the specified view controller.\nPresenting the offer code redemption sheet\nSupporting subscription offer codes in your app\nProvide subscription service for customers who redeem offer codes through the App Store or within your app.\nstatic func presentOfferCodeRedeemSheet(in: UIWindowScene)\nDisplays a sheet in the window scene that enables users to redeem a subscription offer code that you configure in App Store Connect.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: @MainActor (Result<Void, any Error>) -> Void) -> View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect.\nRestoring purchases\nstatic func sync()\nSynchronizes your app’s transaction information and subscription status with information from the App Store.\nSee Also\nApp Store interactions\nstruct AppTransaction\nInformation that represents the customer’s purchase of the app, cryptographically signed by the App Store."
  },
  {
    "title": "authorizationStatus()",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecontroller/1620631-authorizationstatus",
    "html": "Return Value\n\nThe type of authorization for music library access. See SKCloudServiceAuthorizationStatus for a list of possible values.\n\nDiscussion\n\nUse the authorization status to determine in what ways you can access the user’s music library.\n\nSee Also\nGetting Authorization to Access the Music Library\nRequesting Access to Apple Music Library\nPrompt the user to authorize access to Apple Music library.\nclass func requestAuthorization((SKCloudServiceAuthorizationStatus) -> Void)\nAsks the user for permission to access the music library on the device.\nenum SKCloudServiceAuthorizationStatus\nConstants that indicate the type of authorization the user has set for accessing the music library.\nRelated Documentation\nIn-App Purchase Programming Guide"
  },
  {
    "title": "Determining a User’s Apple Music Capabilities",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecontroller/determining_a_user_s_apple_music_capabilities",
    "html": "Overview\n\nAfter you request the user’s permission to access their Apple Music library (see Requesting Access to Apple Music Library), you confirm that authorization and then identify Apple Music capabilities on the user’s device.\n\nConfirm Whether the User Authorized Access to Apple Music Library\n\nUse SKCloudServiceController’s authorizationStatus() to check whether the user has authorized access to Apple Music Library. If the authorization status is SKCloudServiceAuthorizationStatus.notDetermined, call SKCloudServiceController’s requestAuthorization(_:) to prompt the user for access.\n\nguard SKCloudServiceController.authorizationStatus() == .notDetermined else { return }\n\n\nIf the authorization status is SKCloudServiceAuthorizationStatus.authorized, your app can proceed to determine which Apple Music capabilities (musicCatalogPlayback, musicCatalogSubscriptionEligible, or addToCloudMusicLibrary) are available on the user’s device.\n\nguard SKCloudServiceController.authorizationStatus() == .authorized else { return }\nfetchCurrentAppleMusicCapabilities()\n\n\nCreate a Cloud Service Controller and Its Handler to Fetch Capabilities\n\nFirst, create an SKCloudServiceController object:\n\nlet controller = SKCloudServiceController()\n\n\nThen call its requestCapabilities(completionHandler:) method to fetch the current Apple Music capabilities, as described in the sections that follow.\n\nCheck for the Capability to Play Apple Music Content\n\nIf you want your app to play Apple Music content, check whether capabilities includes musicCatalogPlayback:\n\ncontroller.requestCapabilities {(capabilities: SKCloudServiceCapability, error: Error?) in\n   guard error == nil else { return }\n   if capabilities.contains(.musicCatalogPlayback) {\n      // Allows playback of songs in the Apple Music catalog.\n   }\n}\n\n\nCheck for the Subscription-Eligible Capability\n\nA user is eligible for an Apple Music subscription offer when capabilities doesn’t include musicCatalogPlayback but contains musicCatalogSubscriptionEligible. If you want your app to present the user with an offer to subscribe to Apple Music, check capabilities for these features:\n\ncontroller.requestCapabilities {(capabilities: SKCloudServiceCapability, error: Error?) in\n   guard error == nil else { return } \n   if capabilities.contains(.musicCatalogSubscriptionEligible) && !capabilities.contains(.musicCatalogPlayback) {\n      // Allows subscription to the Apple Music catalog.\n   }\n}\n\n\nYou can present the offer using SKCloudServiceSetupViewController.\n\nCheck for the Capability to Add Songs to the User’s iCloud Music Library\n\nIf you want your app to add tracks to the user’s iCloud music library, check whether capabilities includes addToCloudMusicLibrary:\n\ncontroller.requestCapabilities {(capabilities: SKCloudServiceCapability, error: Error?) in\n   guard error == nil else { return }\n   if capabilities.contains(.addToCloudMusicLibrary) {\n       // Allows songs to be added to the user’s iCloud music library.\n    }\n}\n\n\nSee Also\nDetermining Capabilities\nfunc requestUserToken(forDeveloperToken: String, completionHandler: (String?, (any Error)?) -> Void)\nReturns a user token that you use to access personalized Apple Music content.\nfunc requestStorefrontCountryCode(completionHandler: (String?, (any Error)?) -> Void)\nGets the country code for the storefront associated with a user's iTunes account.\nfunc requestCapabilities(completionHandler: (SKCloudServiceCapability, (any Error)?) -> Void)\nGets the current capabilities associated with the music library on the device.\nstruct SKCloudServiceCapability\nConstants that specify the current capabilities of the user’s music library on the device.\nfunc requestStorefrontIdentifier(completionHandler: (String?, (any Error)?) -> Void)\nGets the device’s storefront identifier.\nfunc requestPersonalizationToken(forClientToken: String, withCompletionHandler: (String?, (any Error)?) -> Void)\nDeprecated"
  },
  {
    "title": "Message.Reason",
    "url": "https://developer.apple.com/documentation/storekit/message/reason",
    "html": "Overview\n\nFor more information about App Store messages, see Message.\n\nTopics\nGetting the message reasons\nstatic let billingIssue: Message.Reason\nA message the App Store sends that informs people of a billing problem and enables them to update billing information.\nstatic let generic: Message.Reason\nA message the App Store sends for a generic reason.\nstatic let priceIncreaseConsent: Message.Reason\nA message the App Store sends when you increase the price of an auto-renewable subscription and the price increase requires the user’s consent.\nGetting the localized description\nvar localizedDescription: String\nA localized description of the App Store message.\nCreating a message reason\ninit(rawValue: Int)\nCreates a message reason using the raw value.\ntypealias Message.Reason.RawValue\nA type representing the raw value of a message reason.\nlet rawValue: Int\nThe raw value of a message reason.\nComparing and hashing message reasons\nstatic func != (Message.Reason, Message.Reason) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nRawRepresentable\nSendable\nSee Also\nGetting messages and message reasons\nstatic var messages: Message.Messages\nThe asynchronous sequence that sends a message when the App Store creates it.\nlet reason: Message.Reason\nThe reason that the App Store sends the message.\nstruct Message.Messages\nAn asynchronous sequence of messages from the App Store."
  },
  {
    "title": "VerificationResult",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult",
    "html": "Overview\n\nStoreKit automatically verifies the Transaction, Product.SubscriptionInfo.RenewalInfo, and AppTransaction values. To access the wrapped values, check whether the values are verified or unverified.\n\nTopics\nGetting the verification results\ncase verified(SignedType)\nThe associated value passed StoreKit automatic verification checks.\ncase unverified(SignedType, VerificationResult<SignedType>.VerificationError)\nThe associated value failed StoreKit automatic verification checks.\nvar payloadValue: SignedType\nThe verified value of the signed type that StoreKit confirms as verified.\nvar unsafePayloadValue: SignedType\nThe associated value of the verification result that StoreKit doesn’t confirm as verified.\nenum VerificationResult.VerificationError\nError cases for StoreKit JWS verification.\nGetting properties for transactions\nvar jwsRepresentation: String\nThe transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Transaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the transaction belongs to the device.\nAvailable when SignedType is Transaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Transaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS transaction.\nAvailable when SignedType is Transaction.\nvar headerData: Data\nThe header component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar payloadData: Data\nThe payload component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signedData: Data\nThe transaction data covered by the signature.\nAvailable when SignedType is Transaction.\nvar signatureData: Data\nThe signature component of the JWS transaction.\nAvailable when SignedType is Transaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Transaction.\nGetting properties for subscription renewal info\nvar jwsRepresentation: String\nThe subscription renewal information signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the subscription renewal info belongs to the device.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedDate: Date\nThe date that the App Store signed the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar headerData: Data\nThe header component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar payloadData: Data\nThe payload component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signedData: Data\nThe subscription renewal info data covered by the signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signatureData: Data\nThe signature component of the JWS subscription renewal info.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is Product.SubscriptionInfo.RenewalInfo.\nGetting properties for app transactions\nvar jwsRepresentation: String\nThe app transaction signed by the App Store, in JWS compact serialization format.\nAvailable when SignedType is AppTransaction.\nvar deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nAvailable when SignedType is AppTransaction.\nvar deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nAvailable when SignedType is AppTransaction.\nvar signedDate: Date\nThe date that the App Store signed the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar headerData: Data\nThe header component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar payloadData: Data\nThe payload component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signedData: Data\nThe app transaction data covered by the signature.\nAvailable when SignedType is AppTransaction.\nvar signatureData: Data\nThe signature component of the JWS app transaction.\nAvailable when SignedType is AppTransaction.\nvar signature: P256.Signing.ECDSASignature\nThe signature component of the JSON web signature.\nAvailable when SignedType is AppTransaction.\nGetting a debug description\nvar debugDescription: String\nA description of the verification result that’s suitable for debugging.\nAvailable when SignedType conforms to CustomDebugStringConvertible.\nComparing and hashing verification results\nstatic func != (VerificationResult<SignedType>, VerificationResult<SignedType>) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nAvailable when SignedType conforms to Equatable.\nstatic func == (VerificationResult<SignedType>, VerificationResult<SignedType>) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nAvailable when SignedType conforms to Equatable.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nAvailable when SignedType conforms to Hashable.\nvar hashValue: Int\nThe hash value.\nAvailable when SignedType conforms to Hashable.\nRelationships\nConforms To\nCustomDebugStringConvertible\nConforms when SignedType conforms to CustomDebugStringConvertible.\nHashable\nConforms when SignedType conforms to Hashable.\nSee Also\nJWS verification\nenum VerificationResult.VerificationError\nError cases for StoreKit JWS verification."
  },
  {
    "title": "Requesting Access to Apple Music Library",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecontroller/requesting_access_to_apple_music_library",
    "html": "Overview\n\nYour app must obtain permission from the user before accessing Apple Music Library.\n\nProvide a Purpose String in Info.plist\n\nProvide a purpose string or usage description that describes how your app intends to use the user’s iCloud Music library or Apple Music catalog. Add the NSAppleMusicUsageDescription key to your app’s Info.plist. Set its value to a string that explains why your app needs access to Apple Music library. The system displays the string to the user when prompting them for authorization.\n\nImportant\n\nThis key is required for apps that access the user’s music library. Apps crash when the key is absent.\n\nSee Requesting access to protected resources for more details.\n\nRequest Authorization\n\nThe user determines whether apps can play items from the Apple Music catalog or add tracks to their iCloud Music library. They can grant or deny access when your app requests authorization. Because the user can change your app’s authorization status in Settings > Privacy > Media and Apple Music, be sure to call SKCloudServiceController’s authorizationStatus() before attempting to access their Apple Music library.\n\nguard SKCloudServiceController.authorizationStatus() == .notDetermined else { return }\n\n\nIf the authorization status is SKCloudServiceAuthorizationStatus.notDetermined, call SKCloudServiceController’s requestAuthorization(_:) to prompt the user for access.\n\nSKCloudServiceController.requestAuthorization {(status: SKCloudServiceAuthorizationStatus) in\n    switch status {\n    case .denied, .restricted: disableAppleMusicBasedFeatures()\n    case .authorized: enableAppleMusicBasedFeatures()\n    default: break\n    }\n}\n\n\nThe system remembers the user’s answer so that subsequent calls to requestAuthorization(_:) don’t prompt them again.\n\nSee Also\nGetting Authorization to Access the Music Library\nclass func authorizationStatus() -> SKCloudServiceAuthorizationStatus\nReturns the type of authorization the user has set for accessing the music library on the device.\nclass func requestAuthorization((SKCloudServiceAuthorizationStatus) -> Void)\nAsks the user for permission to access the music library on the device.\nenum SKCloudServiceAuthorizationStatus\nConstants that indicate the type of authorization the user has set for accessing the music library."
  },
  {
    "title": "init(configuration:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/3566702-init",
    "html": "Parameters\nconfiguration\n\nThe object that represents the overlay’s attributes; for example, its position on the screen.\n\nDiscussion\n\nPass an SKOverlay.AppConfiguration as the configuration parameter if you want to display the overlay in an app. To recommend an App Clip’s corresponding app, pass an SKOverlay.AppClipConfiguration object to the initializer. For more information, see Recommending your app to App Clip users.\n\nSee Also\nCreating an overlay\nvar configuration: SKOverlay.Configuration\nAn overlay’s attributes; for example, its position on the screen.\nclass SKOverlay.AppConfiguration\nAn object that represents the attributes of an overlay you use to recommend another app on the App Store.\nclass SKOverlay.AppClipConfiguration\nAn object that represents the attributes of an overlay you use to recommend an App Clip’s corresponding full app.\nclass SKOverlay.Configuration\nThe abstract superclass for all classes that represent an overlay’s attributes."
  },
  {
    "title": "callAsFunction(_:)",
    "url": "https://developer.apple.com/documentation/storekit/displaymessageaction/3963903-callasfunction",
    "html": "Parameters\nmessage\n\nThe App Store message to display.\n\nDiscussion\n\nDon’t call this method directly. SwiftUI calls it when you call the DisplayMessageAction structure using message as an argument.\n\nFor information about how Swift uses the callAsFunction() method to simplify call site syntax, see Methods with Special Names in The Swift Programming Language."
  },
  {
    "title": "Requesting App Store reviews",
    "url": "https://developer.apple.com/documentation/storekit/requesting_app_store_reviews",
    "html": "Overview\n\nPresent your users with a request for an App Store review using RequestReviewAction to get feedback on your app. Be aware that the system displays the review prompt to a user a maximum of three times within a 365-day period. You can determine when and where your app displays the prompt to request a review. Consider the best places and conditions in your app to show the request, and when it might be appropriate to delay it. Here are some best practices:\n\nMake the request at a time that doesn’t interrupt what someone is trying to achieve in your app, for example, at the end of a sequence of events that they successfully complete.\n\nAvoid showing a request for a review immediately when a user launches your app, even if it isn’t the first time it launches.\n\nAvoid requesting a review as the result of a user action.\n\nAlso, remember that people can disable requests for reviews from ever appearing on their device.\n\nPresent the review request\n\nThis sample project demonstrates a simulated three-step process. A person taps the Start Process button, and then taps Continue Process twice, after which the app presents a Process Completed scene. The request for review appears from this scene only.\n\nIn addition, the app and its use meets the following conditions before displaying the prompt:\n\nThe app hasn’t shown a review prompt for a version of the app bundle that matches the current bundle version. This ensures that a person doesn’t receive a prompt to review the same version of an app multiple times.\n\nThe person successfully completes the three-step process at least four times. This number is arbitrary and developers can choose something that fits well with how many times someone is likely to complete a process in their apps.\n\nA person must pause on the Process Completed scene for a few seconds. This requirement limits the possibility of the prompt interrupting them before they move to a different task in the app.\n\nTo present a review request, the app reads the requestReview environment value to get an instance of RequestReviewAction and calls it as a function:\n\n@Environment(\\.requestReview) private var requestReview\n\n\nThe conditions above exist purely to delay the call to requestReview, so days, weeks, or even months can elapse without the app prompting a user for a review.\n\n/// Presents the rating and review request view after a two-second delay.\nprivate func presentReview() {\n    Task {\n        // Delay for two seconds to avoid interrupting the person using the app.\n        try await Task.sleep(for: .seconds(2))\n        await requestReview()\n    }\n}\n\n\nTechniques to delay the call are valuable because they cause an app to show a review request when people are more experienced at using the app and can provide better feedback.\n\n/*\n    The lastVersionPromptedForReview property stores the version of the app that last prompts for a review.\n    The app presents the rating and review request view if the person completed the three-step process at least four times and\n    its current version is different from the version that last prompted them for review.\n*/\nif processCompletedCount >= 4, currentAppVersion != lastVersionPromptedForReview {\n    presentReview()\n        \n    // The app already displayed the rating and review request view. Store this current version.\n    lastVersionPromptedForReview = currentAppVersion\n}\n\n\nIn the following code, the app stores the usage data that delays the review request in AppStorage:\n\n/// An identifier for the three-step process the person completes before this app chooses to request a review.\n@AppStorage(\"processCompletedCount\") var processCompletedCount = 0\n\n\n/// The most recent app version that prompts for a review.\n@AppStorage(\"lastVersionPromptedForReview\") var lastVersionPromptedForReview = \"\"\n\n\nIn other apps, there might be more appropriate on-device storage options. For more information about best practices for requesting reviews, see Ratings and reviews in Human Interface Guidelines.\n\nManually request a review\n\nTo enable a person to initiate a review as a result of an action in the UI, the sample code uses a deep link to the App Store page for the app with the query parameter action=write-review appended to the URL:\n\n// Replace the placeholder value below with the App Store ID for your app.\n// You can find the App Store ID in your app's product URL.\nlet url = \"https://apps.apple.com/app/id<#Your App Store ID#>?action=write-review\"\n\n\nguard let writeReviewURL = URL(string: url) else {\n    fatalError(\"Expected a valid URL\")\n}\n\n\nopenURL(writeReviewURL)\n\n\nSee Also\nReviews\nclass SKStoreReviewController\nAn object that controls the process of requesting App Store ratings and reviews from users.\nstruct RequestReviewAction\nAn instance that tells StoreKit to request an App Store rating or review, if appropriate."
  },
  {
    "title": "configuration",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/3566699-configuration",
    "html": "See Also\nCreating an overlay\ninit(configuration: SKOverlay.Configuration)\nCreates an overlay you use to recommend another app on the App Store.\nclass SKOverlay.AppConfiguration\nAn object that represents the attributes of an overlay you use to recommend another app on the App Store.\nclass SKOverlay.AppClipConfiguration\nAn object that represents the attributes of an overlay you use to recommend an App Clip’s corresponding full app.\nclass SKOverlay.Configuration\nThe abstract superclass for all classes that represent an overlay’s attributes."
  },
  {
    "title": "adCampaignIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3727292-adcampaignidentifier",
    "html": "Discussion\n\nAd networks set their own campaign identifiers, which must be an integer >=1 and <=100.\n\nSee Also\nCreating a signature\ninit(sourceAppStoreItemIdentifier: NSNumber, advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String, adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp: NSNumber, signature: String, version: String)\nCreates an ad impression object using the supplied values.\nvar version: String\nThe version of the SKAdNetwork API.\nvar adNetworkIdentifier: String\nA string that represents the advertising network’s unique identifier.\nvar sourceIdentifier: NSNumber\nA four-digit integer that ad networks define to represent the ad campaign.\nvar advertisedAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that the ad impression advertises.\nvar adImpressionIdentifier: String\nA random value to use for added security.\nvar sourceAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that displays the ad.\nvar timestamp: NSNumber\nA number that represents the UNIX time, in milliseconds, of the ad impression."
  },
  {
    "title": "adImpressionIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3727294-adimpressionidentifier",
    "html": "Discussion\n\nAd networks set the value of this property to a random value (nonce) at the time of the ad impression.\n\nImportant\n\nWhen you generate signature, which is the signature value, you must sign the adImpressionIdentifier as an all-lowercase UUID string representation.\n\nSee Also\nCreating a signature\ninit(sourceAppStoreItemIdentifier: NSNumber, advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String, adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp: NSNumber, signature: String, version: String)\nCreates an ad impression object using the supplied values.\nvar version: String\nThe version of the SKAdNetwork API.\nvar adNetworkIdentifier: String\nA string that represents the advertising network’s unique identifier.\nvar sourceIdentifier: NSNumber\nA four-digit integer that ad networks define to represent the ad campaign.\nvar adCampaignIdentifier: NSNumber\nA number that represents the advertising network’s campaign.\nvar advertisedAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that the ad impression advertises.\nvar sourceAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that displays the ad.\nvar timestamp: NSNumber\nA number that represents the UNIX time, in milliseconds, of the ad impression."
  },
  {
    "title": "adPurchaserName",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3727296-adpurchasername",
    "html": "Discussion\n\nThis property is not used.\n\nSee Also\nDescribing ads\nvar adType: String?\nThe type of the ad.\nvar adDescription: String?\nA human-readable description of the ad."
  },
  {
    "title": "SKStoreProductParameterCampaignToken",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparametercampaigntoken",
    "html": "Discussion\n\nThe value for this key is an instance of NSString, containing any 40-byte string.\n\nThis token allows you to track the effectiveness of your Affiliate Program link and your App Analytics campaign.\n\nFor more information about the Affiliate Program, see the Affiliate Program at https://apple.com/itunes/affiliates. For more information about App Store Connect Analytics, see App Store Connect Developer Guide.\n\nSee Also\nAffiliate and Analytics Keys\nlet SKStoreProductParameterProductIdentifier: String\nThe key representing the product identifier for the promoted product you want the store to display at the top of the page.\nlet SKStoreProductParameterAdvertisingPartnerToken: String\nThe key representing the advertising partner you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterAffiliateToken: String\nThe key representing the affiliate identifier you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterProviderToken: String\nThe key representing the provider token for the developer that created the app specified by the SKStoreProductParameterITunesItemIdentifier key.\nlet SKStoreProductParameterCustomProductPageIdentifier: String"
  },
  {
    "title": "SKStoreProductParameterProviderToken",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductparameterprovidertoken",
    "html": "Discussion\n\nThe value for this key is an instance of NSString.\n\nUse your own provider token when cross promoting your own apps. This token lets you track the effectiveness of the cross promotion effort separate from any affiliate campaign that shares the same campaign token.\n\nWhen promoting apps for other developers, use their provider token instead. In this case, the token lets the developer track the effectiveness of your App Analytics campaign for their apps.\n\nThe key must be used in combination with your campaign token, SKStoreProductParameterCampaignToken. For more information, see App Store Connect Developer Guide.\n\nSee Also\nAffiliate and Analytics Keys\nlet SKStoreProductParameterProductIdentifier: String\nThe key representing the product identifier for the promoted product you want the store to display at the top of the page.\nlet SKStoreProductParameterAdvertisingPartnerToken: String\nThe key representing the advertising partner you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterAffiliateToken: String\nThe key representing the affiliate identifier you wish to use for any purchase made through the view controller.\nlet SKStoreProductParameterCampaignToken: String\nThe key representing an App Analytics campaign.\nlet SKStoreProductParameterCustomProductPageIdentifier: String"
  },
  {
    "title": "SKStoreProductViewController",
    "url": "https://developer.apple.com/documentation/storekit/skstoreproductviewcontroller",
    "html": "Overview\n\nTo display a store for users to purchase media from the App Store, follow these steps:\n\nCreate an SKStoreProductViewController object and set its delegate.\n\nIndicate a specific product to sell by passing its iTunes item identifier to the loadProduct(withParameters:completionBlock:) method.\n\nPresent the view controller modally from another view controller in your app. Your delegate dismisses the view controller when the user completes the purchase.\n\nPresent the SKStoreProductViewController object immediately when triggered by a user interaction, such as tapping a Buy button. Load the product information before presenting the view controller to ensure a seamless user experience.\n\nThis class ignores modalPresentationStyle settings, and those settings have no impact on the sheet’s presentation.\n\nTo recommend another app without displaying a full product page, and to recommend an App Clip’s corresponding app from within the App Clip, use SKOverlay.\n\nNote\n\nIn a compatible iPad or iPhone app running in visionOS, this method displays a minimal sheet to enable an app purchase or launch the App Store for more information. For an in-line experience that’s consistent across platforms, use SKOverlay instead.\n\nPreventing exceptions\n\nThe SKStoreProductViewController class doesn’t support subclassing or embedding, and must be used as-is.\n\nImportant\n\nIf you compile with the iOS 13 SDK, attempting to instantiate a subclass of SKStoreProductViewController results in a runtime exception.\n\nThis class throws the following runtime exceptions:\n\nSKUnsupportedClassException\n\nThrown if the app attempts to instantiate a subclass of SKStoreProductViewController.\n\nSKUnsupportedPresentationException\n\nThrown if the app attempts to use an unsupported presentation mode for SKStoreProductViewController, such as embedding it as a child view controller or attempting to use it in a popover.\n\nTopics\nSetting a delegate\nvar delegate: (any SKStoreProductViewControllerDelegate)?\nThe store view controller’s delegate.\nprotocol SKStoreProductViewControllerDelegate\nA protocol called when the user dismisses the store screen.\nLoading a new product screen\nOffering media for sale in your app\nAllow users to purchase media in the App Store from within your app.\nfunc loadProduct(withParameters: [String : Any], completionBlock: ((Bool, (any Error)?) -> Void)?)\nLoads a new product screen to display.\nfunc loadProduct(withParameters: [String : Any], impression: SKAdImpression, completionBlock: ((Bool, (any Error)?) -> Void)?)\nProduct Dictionary Keys\nKeys for identifying products and the tokens for affiliates and campaigns.\nInstance Methods\nfunc loadProduct(parameters: [String : Any], impression: AppImpression)\nRelationships\nInherits From\nNSViewController\nUIViewController\nSee Also\nRecommendations\nOffering media for sale in your app\nAllow users to purchase media in the App Store from within your app.\nclass SKOverlay\nA class that displays an overlay you can use to recommend another app or an App Clip’s corresponding full app."
  },
  {
    "title": "SKANError",
    "url": "https://developer.apple.com/documentation/storekit/skanerror",
    "html": "Topics\nGetting the Error Domain\nstatic var errorDomain: String\nA string containing the error domain for SKAdNetwork errors.\nGetting Error Properties\nvar code: Code\nThe error code.\nvar errorCode: Int\nThe integer error code.\nvar userInfo: [String : Any]\nThe user information dictionary associated with the error.\nvar errorUserInfo: [String : Any]\nThe error user information dictionary associated with the error.\nvar localizedDescription: String\nA string containing the localized description of the error.\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation.\nComparing and Hashing Errors\nstatic func != (SKANError, SKANError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (SKANError, SKANError) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nInitializing Errors\ninit(Code, userInfo: [String : Any])\nInitializes an error structure with a code and custom data.\nSee Also\nAd network attribution\nclass SKAdNetwork\nA class that validates advertisement-driven app installations.\nclass SKAdImpression\nA class that defines an ad impression for a view-through ad.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation.\nlet SKANErrorDomain: String\nA string that identifies the SKAdNetwork error domain."
  },
  {
    "title": "sourceIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/4090668-sourceidentifier",
    "html": "Discussion\n\nThe sourceIdentifier key is available for ad impressions that use SKAdNetwork 4 and later. The sourceIdentifier, also known as the hierarchical source identifier, replaces and extends the campaign identifier value, adCampaignIdentifier.\n\nAd networks and developers define the meaning of the hierarchical source identifier. This integer can have up to four digits. You can encode information about your advertisement in each set of digits; you may receive two, three, or all four digits of the sourceIdentifier in the first winning postback, depending on the ad impression’s postback data tier. For more information about the value you may get in the postback, see Receiving postbacks in multiple conversion windows.\n\nNote\n\nAn install-validation postback represents this integer as a string in its source-identifier parameter. For more details about the parameters of an install-validation postback, see Identifying the parameters in install-validation postbacks.\n\nSee Also\nCreating a signature\ninit(sourceAppStoreItemIdentifier: NSNumber, advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String, adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp: NSNumber, signature: String, version: String)\nCreates an ad impression object using the supplied values.\nvar version: String\nThe version of the SKAdNetwork API.\nvar adNetworkIdentifier: String\nA string that represents the advertising network’s unique identifier.\nvar adCampaignIdentifier: NSNumber\nA number that represents the advertising network’s campaign.\nvar advertisedAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that the ad impression advertises.\nvar adImpressionIdentifier: String\nA random value to use for added security.\nvar sourceAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that displays the ad.\nvar timestamp: NSNumber\nA number that represents the UNIX time, in milliseconds, of the ad impression."
  },
  {
    "title": "Identifying the parameters in install-validation postbacks",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/identifying_the_parameters_in_install-validation_postbacks",
    "html": "Overview\n\nThe following list describes all the possible parameters you may get in a postback, and their version availability. To verify that Apple signed the postback, see Verifying an install-validation postback.\n\nversion\n\nVersion 2 and later. The SKAdNetwork version that matches SKStoreProductParameterAdNetworkVersion or version. For more information about versions, see SKAdNetwork release notes.\n\nad-network-id\n\nVersion 1 and later. Your ad network ID, which matches the value you provide for SKStoreProductParameterAdNetworkIdentifier or adNetworkIdentifier.\n\nattribution-signature\n\nVersion 2 and later. Apple’s attribution signature that you verify.\n\napp-id\n\nVersion 1 and later. The App Store app ID of the advertised app.\n\nsource-identifier\n\nVersion 4 and later. The hierarchical source identifier that replaces the campaign-id. This string represents two, three, or four digits of the original value the ad network supplies in SKStoreProductParameterAdNetworkSourceIdentifier or sourceIdentifier.\n\ncampaign-id\n\nVersions 1–3. The campaign identifer you provide when displaying the ad, which matches SKStoreProductParameterAdNetworkCampaignIdentifier or adCampaignIdentifier. Version 4 and later ads use source-identifer instead.\n\nsource-app-id\n\nVersion 2 and later. The App Store app ID of the app that displays the ad. The source-app-id value matches SKStoreProductParameterAdNetworkSourceAppStoreIdentifier or sourceAppStoreItemIdentifier.\n\nNote: The source-app-id only appears in the postback if providing the parameter meets Apple’s privacy threshold.\n\nsource-domain\n\nVersion 4 and later, for web ads only. For more information, see SKAdNetwork for Web Ads.\n\nconversion-value\n\nVersion 2 and later. An unsigned 6-bit value that the installed app sets by calling a method to update the conversion value, such as updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:). The conversion-value only appears in the postback if the installed app provides it, and if providing the parameter meets Apple’s privacy threshold.\n\nNote: The signature doesn’t include the conversion-value. Postbacks may contain either conversion-value or coarse-conversion-value, not both.\n\ncoarse-conversion-value\n\nVersion 4 and later. Possible values are the strings \"low\", \"medium\", and \"high\". The installed app sets this value by calling a method to update conversion values, such as updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:).\n\nNote: The signature doesn’t include the coarse-conversion-value. Postbacks may contain either conversion-value or coarse-conversion-value, not both.\n\ndid-win\n\nVersion 3 and later. A Boolean value that’s true if the ad network wins the attribution, and false if the postback represents a qualifying ad impression that doesn't win the attribution.\n\nfidelity-type\n\nVersion 2.2 and later. A value of 0 indicates a view-through ad presentation; a value of 1 indicates a StoreKit-rendered ad or an SKAdNetwork-attributed web ad.\n\npostback-sequence-index\n\nVersion 4 and later. The possible integer values of 0, 1, and 2 signify the order of postbacks that result from the three conversion windows. For more information, see Receiving postbacks in multiple conversion windows.\n\nredownload\n\nVersion 2 and later. A Boolean value of true indicates that a device with the customer’s Apple ID previously installed the app.\n\ntransaction-id\n\nVersion 1 and later. A unique value for this validation; use it to deduplicate install-validation postbacks.\n\nTo ensure crowd anonymity, Apple assigns a postback data tier to app downloads. The postback data tier determines whether certain parameters appear in the postback, as well as the number of digits in the hierarchical source identifer. The following postback parameters are subject to the postback data tier:\n\nsource-identifier (affects the number of digits the postback returns)\n\ncoarse-conversion-value\n\nconversion-value\n\nsource-app-id\n\nsource-domain\n\nFor more information about receiving postbacks, see Receiving postbacks in multiple conversion windows.\n\nSee Also\nVerifying postbacks\nVerifying an install-validation postback\nEnsure the validity of a postback you receive after an ad conversion by verifying its cryptographic signature."
  },
  {
    "title": "SKANErrorDomain",
    "url": "https://developer.apple.com/documentation/storekit/skanerrordomain",
    "html": "See Also\nAd network attribution\nclass SKAdNetwork\nA class that validates advertisement-driven app installations.\nclass SKAdImpression\nA class that defines an ad impression for a view-through ad.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation.\nstruct SKANError\nAn error that an ad network attribution operation returns."
  },
  {
    "title": "Verifying an install-validation postback",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/verifying_an_install-validation_postback",
    "html": "Overview\n\nInstall-validation postbacks contain data that validate an ad conversion. You need to verify the postback signature to make sure it’s signed by Apple before you count the conversion. Follow these steps to validate the postback:\n\nReceive the postback at a URL you configure.\n\nRespond to the postback when you receive it.\n\nCheck the postback version.\n\nRecreate the byte array from the postback parameters in the version-specific order.\n\nVerify Apple’s signature.\n\nCount only unique postbacks with signatures you verify. For version 3 and later, check the did-win parameter to learn whether the postback represents a winning attribution.\n\nReceive the postback\n\nDevices send install-validation postbacks to ad networks and developers within a defined timeframe after a user installs and launches an advertised app. Ad networks receive postbacks at the URL they provide when they register to use SKAdNetwork. Developers who opt in receive copies of winning postbacks at the URL they configure in the app’s property list key, NSAdvertisingAttributionReportEndpoint. For more information about setting up your postback URL, see Registering an ad network and Configuring an advertised app.\n\nFor more information about the timeframe for receiving attribution, see Receiving ad attributions and postbacks Starting with version 4, you may receive postbacks in three conversion windows. For more information, see Receiving postbacks in multiple conversion windows.\n\nRespond to the postback\n\nWhen you receive a postback, respond with an HTTP status code 200 OK. If the device doesn’t receive the 200 status code, it attempts to send the postback up to nine times over a maximum of 9 days.\n\nCheck the postback version number\n\nPostbacks contain a version parameter, starting with SKAdNetwork 2. Use the version number to follow the version-specific instructions for verifying a postback signature. For a description of all the parameters in a postback, see Identifying the parameters in install-validation postbacks.\n\nThe postback version you receive depends on the version number the ad network uses to sign the ad, the iOS version on the device, and the SDK version that the source app uses. Expect to receive the same version number in the postback as the ad network uses to sign the ad if the device runs the latest iOS version, and the source app uses the latest SDK. For more information about version dependencies, see SKAdNetwork release notes. For more information about signing, see Signing and providing ads.\n\nRecreate the byte array from the postback parameters\n\nTo confirm that Apple sent the postback request, you need to verify Apple’s signature in the postback’s attribution-signature parameter. First, decode the signature with Apple’s public key. Next, compare the decoded signature to a byte array that you recreate using the postback parameters. To create the byte array, build a UTF-8 string by combining the parameter values with invisible separators, ‘\\u2063’, in an exact version-specific order.\n\nUse the version-specific instructions that correspond to the postback’s version:\n\nFor version 3-specific instructions and postback examples, see Combining parameters for SKAdNetwork 3 postbacks.\n\nFor earlier versions, see Combining parameters for previous SKAdNetwork postback versions.\n\nFor a version 4 postback, combine the postback parameter values in this order:\n\nversion\n\nad-network-id\n\nsource-identifier\n\napp-id\n\ntransaction-id\n\nredownload (Use the strings “true” or “false” to represent the Boolean value of the redownload parameter).\n\nsource-app-id (or source-domain for web ads)\n\nfidelity-type\n\ndid-win\n\npostback-sequence-index\n\nFor web ads, the postback may include a source-domain instead of a source-app-id.\n\nThe combined string doesn’t include all of the postback parameters. Include source-app-id only if you receive it in the postback. The signature doesn’t include conversion-value or coarse-conversion-value, even if either is present in the postback. Postbacks that win the attribution have a did-win value of true. Postbacks that don’t win the attribution have a did-win value of false, and don’t include source-app-id.\n\nThe following example of the UTF-8 string includes source-app-id:\n\nversion + '\\u2063' + ad-network-id + '\\u2063' + source-identifier + '\\u2063' + app-id + '\\u2063' + transaction-id + '\\u2063' + redownload + '\\u2063' + source-app-id + '\\u2063' + fidelity-type + '\\u2063' + did-win + '\\u2063' + postback-sequence-index\n\n\nThe following example of the UTF-8 string for a web ad includes source-domain:\n\nversion + '\\u2063' + ad-network-id + '\\u2063' + source-identifier + '\\u2063' + app-id + '\\u2063' + transaction-id + '\\u2063' + redownload + '\\u2063' + source-domain + '\\u2063' + fidelity-type + '\\u2063' + did-win + '\\u2063' + postback-sequence-index\n\n\nThe following example is a first postback from a web ad, in a high postback data tier. Notice that the source-identifier contains four digits, and the postback contains the fine-grained conversion-value.\n\n{\n  \"version\": \"4.0\",\n  \"ad-network-id\": \"com.example\",\n  \"source-identifier\": \"5239\",\n  \"app-id\": 525463029,\n  \"transaction-id\": \"6aafb7a5-0170-41b5-bbe4-fe71dedf1e30\",\n  \"redownload\": false,\n  \"source-domain\": \"example.com\", \n  \"fidelity-type\": 1, \n  \"did-win\": true,\n  \"conversion-value\": 63,\n  \"postback-sequence-index\": 0,\n  \"attribution-signature\": \"MEUCIGRmSMrqedNu6uaHyhVcifs118R5z/AB6cvRaKrRRHWRAiEAv96ne3dKQ5kJpbsfk4eYiePmrZUU6sQmo+7zfP/1Bxo=\"\n}\n\n\nThe following example is a first postback that results from a web ad, in a low postback data tier. Notice that the source-identifier contains two digits, and the postback includes a coarse-conversion-value.\n\n{\n  \"version\": \"4.0\",\n  \"ad-network-id\": \"com.example\",\n  \"source-identifier\": \"39\",\n  \"app-id\": 525463029,\n  \"transaction-id\": \"6aafb7a5-0170-41b5-bbe4-fe71dedf1e31\",\n  \"redownload\": false,\n  \"source-domain\": \"example.com\", \n  \"fidelity-type\": 1, \n  \"did-win\": true,\n  \"coarse-conversion-value\": \"high\",\n  \"postback-sequence-index\": 0,\n  \"attribution-signature\": \"MEUCIQD4rX6eh38qEhuUKHdap345UbmlzA7KEZ1bhWZuYM8MJwIgMnyiiZe6heabDkGwOaKBYrUXQhKtF3P/ERHqkR/XpuA=\"\n}\n\n\nThe attribution-signature value in both examples is a verified signature. Use the parameter values and signature in the examples to test your code. For more information about the postback data tiers and the parameters available in each tier, see Receiving postbacks in multiple conversion windows.\n\nVerify Apple's signature\n\nCopy Apple’s public key, below, which you need for the remaining steps. Apple’s NIST P-256 public key that you use to verify signatures for versions 2.1 and later is:\n\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEWdp8GPcGqmhgzEFj9Z2nSpQVddayaPe4FMzqM9wib1+aHaaIzoHoLN9zW4K8y4SPykE3YVK3sVqW6Af0lfx3gg==\n\n\nTo verify a signature for version 1 or 2, get the version-appropriate public key from SKAdNetwork release notes.\n\nThen, complete these steps:\n\nDecode Apple’s public key, which appears as a Base64-encoded string above. The result is a byte array.\n\nCreate an X.509 standard public key from the byte array.\n\nDecode Apple’s signature string value from its Base64 format.\n\nVerify Apple’s signed value from the attribution-signature parameter in the postback against the UTF-8 string you create by combining the postback parameters. Use Apple’s public key and a SHA-256 hash using the Elliptic Curve Digital Signature Algorithm (ECDSA).\n\nIf your verification passes, the postback is valid.\n\nImportant\n\nIf the attribution-signature fails your verification, consider the postback message invalid. Don’t use it to count a conversion.\n\nFor version 3 and later, valid postbacks with a did-win value of true represent an ad attribution.\n\nCount unique messages only\n\nUse the transaction-id value to ensure you’re counting unique ad conversions. If you receive more than one ad-conversion message with the same transaction-id, discard the duplicate message.\n\nReceive a postback during testing\n\nIn test scenarios, the postback always contains the source-app-id and conversion-value parameters with values of 0. To trigger test scenarios, use a development-signed source app with an SKStoreProductParameterAdNetworkSourceAppStoreIdentifier value equal to 0.\n\nTopics\nSKAdNetworks 3 and earlier postbacks\nCombining parameters for SKAdNetwork 3 postbacks\nRecreate the byte array for version 3 postbacks that win and don’t win attribution.\nCombining parameters for previous SKAdNetwork postback versions\nRecreate the byte array for versions 2.2 or earlier.\nSee Also\nVerifying postbacks\nIdentifying the parameters in install-validation postbacks\nLearn about the postback parameters in all SKAdNetwork versions."
  },
  {
    "title": "updatePostbackConversionValue(_:completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/3919928-updatepostbackconversionvalue",
    "html": "Parameters\nconversionValue\n\nAn unsigned 6-bit value ≥0 and ≤63. The app or the ad network defines the meaning of the conversion value. For ad impressions signed with SKAdNetwork 3 or earlier, you need to increase the conversionValue each time you call this method. For ad impressions signed with SKAdNetwork 4 or later, you may use any valid conversionValue each time you call this method.\n\ncompletion\n\nAn optional completion handler you provide to catch and handle any errors this method encounters when you update a conversion value. Set this value to nil if you don’t provide a handler.\n\nReturn Value\n\nInvalid conversion values cause the method to fail and return error SKANError.Code.invalidConversionValue.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nclass func updatePostbackConversionValue(_ conversionValue: Int) async throws\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nNote\n\nConsider using updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) instead of this method for newer implementations.\n\nApps call this method to update conversion values as people engage with the app. It’s up to the app or ad network to define the conversion value’s meaning. Call this method immediately when the user first launches the app to confirm the app’s launch. Call this method again, as needed, to reflect the person’s engagement with the app.\n\nThe final conversion value appears in the postback if sending the data meets Apple’s privacy threshold. Only postbacks that win the ad attribution can contain a conversion value. Nonwinning postbacks don’t contain conversion values. For more information, see Receiving ad attributions and postbacks.\n\nThe way this method behaves depends on the ad’s version, as described in the following sections. Ad networks determine an ad’s version when they sign the ad. For more information about signing ads, see Signing and providing ads.\n\nUpdate the conversion value for version 3 ads and earlier\n\nIf the ad network signs the winning ad with version 3 or earlier, calling this method behaves as follows:\n\nApps may call this method repeatedly before a rolling 24-hour timer expires.\n\nThe 24-hour timer restarts each time the app calls this method with a valid conversionValue that’s greater than the previous value.\n\nWhen the timer expires, the conversion value is final and subsequent calls to updatePostbackConversionValue(_:completionHandler:) have no effect.\n\nThe device sends the postback to the ad network’s URL within 0 to 24 hours after the timer expires. The postback contains the final conversion value only if sending the data meets Apple’s privacy threshold.\n\nUpdate the conversion value for version 4 ads and later\n\nNote\n\nThis method supports ads signed with version 4 and later, however, it doesn’t provide advanced features, such as multiple postbacks and coarse conversion values, available starting in version 4. To get those advanced features for ads signed with version 4 and later, use updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) instead of this method.\n\nIf the ad network signs the winning ad with version 4 or later, calling this method behaves as follows:\n\nApps may call this method repeatedly within the first conversion window.\n\nProvide any conversionValue within the valid range; the conversionValue doesn’t need to increase with each call.\n\nThis method is available only during the first conversion window. Use updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) to update conversion values in the subsequent conversion windows.\n\nWhen the first conversion window closes, the system sends the postback within 0 to 24 hours. The postback contains the final conversion value only if sending the data meets Apple’s privacy threshold.\n\nSee Also\nProviding conversion information\nclass func updatePostbackConversionValue(Int, coarseValue: SKAdNetwork.CoarseConversionValue, lockWindow: Bool, completionHandler: (((any Error)?) -> Void)?)\nUpdates the fine and coarse conversion values and indicates whether to send the postback before the conversion window ends, and calls a completion handler if the update fails.\nclass func updatePostbackConversionValue(Int, coarseValue: SKAdNetwork.CoarseConversionValue, completionHandler: (((any Error)?) -> Void)?)\nUpdates the fine and coarse conversion values, and calls a completion handler if the update fails.\nstruct SKAdNetwork.CoarseConversionValue\nCoarse values to use for updating conversion values."
  },
  {
    "title": "registerAppForAdNetworkAttribution()",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/2943654-registerappforadnetworkattributi",
    "html": "Deprecated\n\nUse updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) instead.\n\nDiscussion\n\nApps that an ad network campaign advertise call this method or updateConversionValue(_:) when the app first launches. Both methods generate an install notification, which is the cryptographically signed data that validates that a user installed and launched this app as a result of an ad.\n\nIn iOS 15.4 and earlier, the first call to registerAppForAdNetworkAttribution() generates the notification if the device has attribution data for that app, and starts a 24-hour timer. Subsequent calls to this method have no effect, unless the ad already has a conversion value set, in which case calling registerAppForAdNetworkAttribution() resets the conversion value to 0. You may, however, call updateConversionValue(_:) to provide an updated conversion value and restart the timer.\n\nThe device sends one or more install notifications to ad network postback URLs within 0-24 hours after the timer expires. For more information about attribution-winning and non-winning postbacks, see Receiving ad attributions and postbacks.\n\nAd networks must verify the postback after receiving it. For more information, see Verifying an install-validation postback.\n\nSee Also\nDeprecated\nclass func updateConversionValue(Int)\nUpdates the conversion value and verifies the first launch of an app installed as a result of an ad.\nDeprecated"
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3792062-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing transactions\nstatic func != (Transaction, Transaction) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Transaction, Transaction) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "shared",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/4020518-shared",
    "html": "Discussion\n\nUse this property to get a VerificationResult that contains the App Store-signed app transaction information for your app, including the first time the app launches. StoreKit automatically keeps the app transaction up-to-date.\n\nThis property throws an error if the AppTransaction isn't available or if the user isn't authenticated with the App Store. Getting an AppTransaction may require network connectivity.\n\nThe following example shows how to get the AppTransaction.\n\ndo {\n    let verificationResult = try await AppTransaction.shared\n\n\n    switch verificationResult {\n    case .verified(let appTransaction):\n        // StoreKit verified that the user purchased this app and\n        // the properties in the AppTransaction instance.\n        // Add your code here.\n    case .unverified(let appTransaction, let verificationError):\n        // The app transaction didn't pass StoreKit's verification.        \n        // Handle unverified app transaction information according\n        // to your business model.\n        // Add your code here.\n    }\n}\ncatch {\n  // Handle errors.\n}\n\n\n\n\nIf your app fails to get an AppTransaction by accessing the shared property, see refresh()."
  },
  {
    "title": "deviceVerification",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954441-deviceverification",
    "html": "Discussion\n\nFor more information, see deviceVerificationID.\n\nSee Also\nVerifying the app transaction\nlet deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nlet signedDate: Date\nThe date that the App Store signed the JWS app transaction."
  },
  {
    "title": "deviceVerificationNonce",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954442-deviceverificationnonce",
    "html": "Discussion\n\nFor more information, see deviceVerificationID.\n\nSee Also\nVerifying the app transaction\nlet deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nlet signedDate: Date\nThe date that the App Store signed the JWS app transaction."
  },
  {
    "title": "originalPurchaseDate",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954448-originalpurchasedate",
    "html": "Discussion\n\nThe original purchase date remains the same, even if the user deletes and reinstalls the app.\n\nSee Also\nGetting purchase dates\nlet preorderDate: Date?\nThe date the customer placed an order for the app before it’s available in the App Store."
  },
  {
    "title": "preorderDate",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/4013175-preorderdate",
    "html": "Discussion\n\nThis date is present if your app is available for preorder and the customer places an order before your app is available in the App Store. When your app becomes available, the App Store fulfills the customer’s order. The preorderDate remains the same.\n\nUse this date to recognize customers who place preorders.\n\nFor more infomation about preorders, see Offering Your Apps for Pre-Order.\n\nSee Also\nGetting purchase dates\nlet originalPurchaseDate: Date\nThe date the user originally purchased the app from the App Store."
  },
  {
    "title": "refresh()",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/4020517-refresh",
    "html": "Return Value\n\nReturns a VerificationResult with a single AppTransaction.\n\nDiscussion\n\nThis method queries the App Store server to refresh the app transaction information. This method returns a VerificationResult that contains the App Store-signed app transaction information for your app.\n\nImportant\n\nCalling refresh() displays a system prompt that asks users to authenticate with their App Store credentials. Call this function only in response to an explicit user action, like tapping or clicking a button.\n\nUse this method to get an AppTransaction in the following cases:\n\nThe shared property throws an error.\n\nThe shared property returns an unverified (VerificationResult.unverified(_:_:) ) result.\n\nThis method throws an error if the user cancels the authentication prompt, if there’s no network connectivity, or if the call fails to update the app transaction."
  },
  {
    "title": "presentOfferCodeRedeemSheet(in:)",
    "url": "https://developer.apple.com/documentation/storekit/appstore/3954431-presentoffercoderedeemsheet",
    "html": "Parameters\nscene\n\nThe UIWindowScene that StoreKit uses to display the offer code redemption sheet.\n\nDiscussion\n\nThe presentOfferCodeRedeemSheet(in:) method displays a system sheet in the window scene, where customers can enter and redeem subscription offer codes. If you generate subscription offer codes in App Store Connect, call this function to enable users to redeem the offer. To display the sheet using SwiftUI, see offerCodeRedemption(isPresented:onCompletion:).\n\nImportant\n\nSet up subscription offer codes in App Store Connect before calling this API. Customers can only redeem these offers in your app through the redemption sheet; don’t use a custom UI.\n\nFor more information on offer codes, see Supporting subscription offer codes in your app.\n\nWhen customers redeem an offer code, StoreKit emits the resulting transaction in updates. Set up a transaction listener as soon as your app launches to receive new transactions while the app is running. For more information, see updates.\n\nIn Mac apps built with Mac Catalyst, this method throws a StoreKitError.unknown error.\n\nSee Also\nPresenting the offer code redemption sheet\nSupporting subscription offer codes in your app\nProvide subscription service for customers who redeem offer codes through the App Store or within your app.\nfunc offerCodeRedemption(isPresented: Binding<Bool>, onCompletion: @MainActor (Result<Void, any Error>) -> Void) -> View\nPresents a sheet that enables users to redeem subscription offer codes that you configure in App Store Connect."
  },
  {
    "title": "debugDescription",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954440-debugdescription",
    "html": "Relationships\nFrom Protocol\nCustomDebugStringConvertible"
  },
  {
    "title": "sync()",
    "url": "https://developer.apple.com/documentation/storekit/appstore/3791906-sync",
    "html": "Discussion\n\nInclude some mechanism in your app, such as a Restore Purchases button, to let users restore their in-app purchases. In rare cases when a user suspects the app isn’t showing all the transactions, call sync(). By calling sync(), you force the app to obtain transaction information and subscription status from the App Store.\n\nImportant\n\nCalling sync()displays a system prompt that asks users to authenticate with their App Store credentials. Call this function only in response to an explicit user action, like tapping or clicking a button.\n\nIn regular operations, there’s no need to call sync(). StoreKit automatically keeps up to date transaction information and subscription status available to your app. When users reinstall your app or download it on a new device, the app automatically has all transactions available to it upon initial launch. There’s no need for users to ask your app to restore transactions — your app can immediately get the current entitlements using currentEntitlements and transaction history using all. For more information about transactions, see Transaction."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954444-hash",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing app transactions\nstatic func != (AppTransaction, AppTransaction) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (AppTransaction, AppTransaction) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954445-hashvalue",
    "html": "Relationships\nFrom Protocol\nHashable\nSee Also\nComparing and hashing app transactions\nstatic func != (AppTransaction, AppTransaction) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (AppTransaction, AppTransaction) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher."
  },
  {
    "title": "requestReview(in:)",
    "url": "https://developer.apple.com/documentation/storekit/appstore/3954432-requestreview",
    "html": "Parameters\nscene\n\nThe UIWindowScene that StoreKit uses to present the rating and review request interface.\n\nDiscussion\n\nWhen you call this method in your shipping app and the system displays a rating and review request view, the system handles the entire process for you. Although you normally call this method when it makes sense in the user experience flow of your app, App Store policy governs the actual display of a rating and review request view. When your app calls this API, StoreKit uses the following criteria:\n\nIf the person hasn’t rated or reviewed your app on this device, StoreKit displays the ratings and review request a maximum of three times within a 365-day period.\n\nIf the person has rated or reviewed your app on this device, StoreKit displays the ratings and review request if the app version is new, and if more than 365 days have passed since the person’s previous review.\n\nNote\n\nBecause this method may not present an alert, don’t call requestReview() or requestReview(in:) in response to a button tap or other user action.\n\nIt’s up to your app to decide on the best timing for requesting reviews. For design guidance, see Human Interface Guidelines > Ratings and reviews.\n\nTest review requests\n\nWhen your app calls this method while it’s in development mode, StoreKit always displays the rating and review request view, so you can test the user interface and experience. However, this method has no effect in apps that you distribute for beta testing using TestFlight.\n\nProvide a persistent link to your product page (optional)\n\nYour customers can review your app at any time on the App Store. To make it easier for people to leave reviews, you may include a persistent link to your App Store product page in your app’s settings or configuration screens. Append the query parameter action=write-review to your product page URL to automatically open the App Store page where users can write a review.\n\nSee Also\nRequesting reviews\nstruct RequestReviewAction\nAn instance that tells StoreKit to request an App Store rating or review, if appropriate.\nstatic func requestReview(in: NSViewController)\nTells StoreKit to request an App Store rating or review from the user, if appropriate, using the specified view controller."
  },
  {
    "title": "requestReview(in:)",
    "url": "https://developer.apple.com/documentation/storekit/appstore/3965045-requestreview",
    "html": "Parameters\ncontroller\n\nThe NSViewController that StoreKit uses to present the rating and review request interface.\n\nDiscussion\n\nWhen you call this method in your shipping app and the system displays a rating and review request view, the system handles the entire process for you. Although you normally call this method when it makes sense in the user experience flow of your app, App Store policy governs the actual display of a rating and review request view. When your app calls this API, StoreKit uses the following criteria:\n\nIf the person hasn’t rated or reviewed your app on this device, StoreKit displays the ratings and review request a maximum of three times within a 365-day period.\n\nIf the person has rated or reviewed your app on this device, StoreKit displays the ratings and review request if the app version is new, and if more than 365 days have passed since the person’s previous review.\n\nNote\n\nBecause this method may not present an alert, don’t call requestReview(in:) in response to a button tap or other user action.\n\nIt’s up to your app to decide on the best timing for requesting reviews. For design guidance, see Human Interface Guidelines > Ratings and reviews.\n\nTest review requests\n\nWhen your app calls this method while it’s in development mode, StoreKit always displays the rating and review request view, so you can test the user interface and experience. However, this method has no effect in apps that you distribute for beta testing using TestFlight.\n\nProvide a persistent link to your product page (optional)\n\nYour customers can review your app at any time on the App Store. To make it easier for people to leave reviews, you may include a persistent link to your App Store product page in your app’s settings or configuration screens. Append the query parameter action=write-review to your product page URL to automatically open the App Store page where users can write a review.\n\nSee Also\nRequesting reviews\nstruct RequestReviewAction\nAn instance that tells StoreKit to request an App Store rating or review, if appropriate.\nstatic func requestReview(in: UIWindowScene)\nTells StoreKit to request an App Store rating or review from the user, if appropriate, using the specified scene."
  },
  {
    "title": "updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/4097267-updatepostbackconversionvalue",
    "html": "Parameters\nfineValue\n\nAn unsigned 6-bit value ≥0 and ≤63. The app or the ad network defines the meaning of the fine conversion value.\n\ncoarseValue\n\nAn SKAdNetwork.CoarseConversionValue value of low, medium, or high. The app or the ad network defines the meaning of the coarse conversion value.\n\nlockWindow\n\nA Boolean value that indicates whether to send the postback before the conversion window ends. Use true to tell the system to send the postback without waiting for the end of the conversion window. The default value is false.\n\ncompletion\n\nAn optional completion handler you provide to catch and handle any errors this method encounters when you update a conversion value. Set this value to nil if you don’t provide a handler.\n\nReturn Value\n\nThis method returns SKANError.Code.invalidConversionValue if the fineValue is outside of the allowed range.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nclass func updatePostbackConversionValue(_ fineValue: Int, coarseValue: SKAdNetwork.CoarseConversionValue, lockWindow: Bool) async throws\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nCall this method when the user first launches an app to register the app installation, and again to update conversion values as the user engages with the app. It’s up to your app to decide what the conversion values signify in your app, both the fineValue and the coarseValue.\n\nThis method supports ads signed with any verison of SKAdNetwork, and you can use it instead of calling updatePostbackConversionValue(_:completionHandler:) and updatePostbackConversionValue(_:coarseValue:completionHandler:). The system automatically determines the method’s behavior based on the ad’s version, as the following sections describe — the app doesn’t need to know the ad version. To take advantage of the multiple postbacks available starting in version 4, use this method or updatePostbackConversionValue(_:coarseValue:completionHandler:).\n\nImportant\n\nThe system ignores calls to this method if the fineValue is outside of the valid range. Valid conversion updates your app sends before or after an invalid conversion remain available.\n\nUpdate conversion values for ads signed with SKAdNetwork 4 or later\n\nFor ads that ad networks sign using version 4 or later, calling this method behaves as follows:\n\nBoth the fineValue and coarseValue represent conversion values. The method ignores the fineValue after the first conversion window.\n\nSetting the lockWindow parameter to true indicates a final update for the conversion value for the current conversion window. The system ignores additional calls to update the conversion value until the end of the conversion window.\n\nSetting the lockWindow parameter to false continues updating the conversion value throughout the conversion window.\n\nFor information about the data you may receive in postbacks, see Receiving postbacks in multiple conversion windows.\n\nUpdate conversion values for ads signed with SKAdNetwork 3 or earlier\n\nFor ads that ad networks sign using version 3 or earlier, calling this method behaves as follows:\n\nThe fineValue represents the conversion value.\n\nThe method ignores the coarseValue and lockWindow parameters.\n\nThere’s a single conversion period that ends after a rolling 24-hour timer expires. The 24-hour timer restarts each time the app calls this method with a valid conversion value greater than the previous value. When the timer expires, the conversion value is final and subsequent calls to this method have no effect.\n\nThe device sends the postback 0–24 hours after the timer expires.\n\nThe postback contains the final conversion value only if the postback data tier contains the value.\n\nFor more information about SKAdNetwork versions, see SKAdNetwork release notes.\n\nSee Also\nProviding conversion information\nclass func updatePostbackConversionValue(Int, coarseValue: SKAdNetwork.CoarseConversionValue, completionHandler: (((any Error)?) -> Void)?)\nUpdates the fine and coarse conversion values, and calls a completion handler if the update fails.\nstruct SKAdNetwork.CoarseConversionValue\nCoarse values to use for updating conversion values.\nclass func updatePostbackConversionValue(Int, completionHandler: (((any Error)?) -> Void)?)\nVerifies the first launch of an advertised app and, on subsequent calls, updates the conversion value or calls a completion handler if the update fails."
  },
  {
    "title": "Generating the signature to validate StoreKit-rendered ads",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/generating_the_signature_to_validate_storekit-rendered_ads",
    "html": "Overview\n\nInstall validation informs an ad network when users install and launch an app they purchase after viewing an ad. Ad networks first provide an ad with cryptographically signed information that includes their ad network ID. Later, if the ad results in a conversion, the customer’s device sends install-validation postbacks. For information about attribution-winning and nonwinning postbacks, see Receiving ad attributions and postbacks.\n\nNote\n\nThese instructions are for signing StoreKit-rendered ads. If you’re presenting a view-through ad, see Generating the signature to validate view-through ads.\n\nTo display a StoreKit-rendered ad and initiate a validation, an app needs to call loadProduct(withParameters:completionBlock:) with a signature key that the ad network generates, SKStoreProductParameterAdNetworkAttributionSignature. To generate the signature, combine the required values from Ad network install-validation keys and cryptographically sign the resulting string. Use the ad network ID and PKCS#8 private key that you establish when registering to use the API. For more information, see Registering an ad network.\n\nChoose parameters based on signature version\n\nSelect the required values of Ad network install-validation keys based on the version of the signature you’re generating. The API supports multiple versions of signed ads. Use the most recent version available in the SDK whenever possible. For information about availability, see SKAdNetwork release notes.\n\nThe following table lists the required signature parameters for version 4 and later. Combine them in a UTF-8 string as the example shows in the Combine the parameters section below.\n\nSignature parameter\n\n\t\n\nEquivalent key\n\n\n\n\nversion\n\n\t\n\nSKStoreProductParameterAdNetworkVersion\n\n\n\n\nad-network-id\n\n\t\n\nSKStoreProductParameterAdNetworkIdentifier\n\n\n\n\nsource-identifier\n\n\t\n\nSKStoreProductParameterAdNetworkSourceIdentifier This value replaces SKStoreProductParameterAdNetworkCampaignIdentifier from previous versions.\n\n\n\n\nitunes-item-id\n\n\t\n\nSKStoreProductParameterITunesItemIdentifier\n\n\n\n\nnonce\n\n\t\n\nSKStoreProductParameterAdNetworkNonce\n\nLowercase the string representation of the nonce value in the signature.\n\n\n\n\nsource-app-id\n\n\t\n\nSKStoreProductParameterAdNetworkSourceAppStoreIdentifier\n\nDuring testing, use an ID of 0 if you’re using a development-signed build and not an app from the App Store.\n\n\n\n\nfidelity-type\n\n\t\n\nVersion 2.2 and later signatures require this parameter.\n\nSet fidelity-type to 1 for StoreKit-rendered ads.\n\n\n\n\ntimestamp\n\n\t\n\nSKStoreProductParameterAdNetworkTimestamp\n\nTo create signatures for previous SKAdNetwork versions, see:\n\nCombining parameters to generate signatures for SKAdNetwork 2.2 and 3.\n\nCombining parameters to generate a signature for SKAdNetwork 2.\n\nIf you build your app with iOS SDK 11.3 through 13.7, see Combining parameters to generate a signature for SKAdNetwork 1.\n\nCombine the parameters\n\nCreate the UTF-8 string using the parameters in the example below.\n\nImportant\n\nLowercase the string representation of the nonce: SKStoreProductParameterAdNetworkNonce. Failing to do so results in an invalid signature. Only ads with valid signatures can get ad attributions.\n\nFor version 4 and later, combine the values into a UTF-8 string with an invisible separator (‘\\u2063’) between them, in the exact order the code below shows:\n\n// Parameter values combined, in order, for version 4 and later.\nversion + '\\u2063' + ad-network-id + '\\u2063' + source-identifier + '\\u2063' + itunes-item-id + '\\u2063' + nonce + '\\u2063' + source-app-id + '\\u2063' + fidelity-type + '\\u2063' + timestamp\n\n\n\n\nSign the combined string\n\nSign the combined UTF-8 string with the following key and algorithm:\n\nYour PKCS#8 private key.\n\nThe Elliptic Curve Digital Signature Algorithm (ECDSA) with a SHA-256 hash.\n\nThe resulting Digital Encoding Rules (DER)-formatted binary value is the signature.\n\nEncode the signature\n\nEncode the binary signature you generate into a Base64 string. The result is your ad network attribution signature, SKStoreProductParameterAdNetworkAttributionSignature. The signature string should look similar to the following:\n\nMEQCIEQlmZRNfYzKBSE8QnhLTIHZZZWCFgZpRqRxHss65KoFAiAJgJKjdrWdkLUOCCjuEx2RmFS7daRzSVZRVZ8RyMyUXg==\n\n\nFor more information about Base64 encoding, see base64EncodedString(options:).\n\nUse the generated signature string\n\nAfter you generate the signature, you have all the required Ad network install-validation keys an app needs to call loadProduct(withParameters:completionBlock:) to intiate a validation.\n\nIf the user installs and launches the advertised app, the attribution-winning ad network receives an install-validation postback. For more information about postbacks, see Verifying an install-validation postback.\n\nTopics\nSignatures for SKAdNetwork 1, 2, and 2.2–3\nCombining parameters to generate signatures for SKAdNetwork 2.2 and 3\nGenerate signatures to sign your ad with versions 2.2 and 3.\nCombining parameters to generate a signature for SKAdNetwork 2\nGenerate signatures to sign your ad with version 2.\nCombining parameters to generate a signature for SKAdNetwork 1\nGenerate signatures for apps compiled with earlier SDKs.\nSee Also\nSigning StoreKit-rendered ads\nAd network install-validation keys\nSpecify key values that validate and associate an app installation with an ad campaign."
  },
  {
    "title": "updatePostbackConversionValue(_:coarseValue:completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/4090669-updatepostbackconversionvalue",
    "html": "Parameters\nfineValue\n\nAn unsigned 6-bit value ≥0 and ≤63. The app or the ad network defines the meaning of the conversion value.\n\ncoarseValue\n\nAn SKAdNetwork.CoarseConversionValue value. The app or the ad network defines the meaning of this value.\n\ncompletion\n\nAn optional completion handler you provide to catch and handle any errors this method encounters when you update a conversion value. Set this value to nil if you don’t provide a handler.\n\nReturn Value\n\nThis method returns SKANError.Code.invalidConversionValue if the fineValue is outside of the allowed range.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nclass func updatePostbackConversionValue(_ fineValue: Int, coarseValue: SKAdNetwork.CoarseConversionValue) async throws\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nCall this method when the user first launches an app to register the app installation, and optionally again, to update conversion values as the user engages with the app.\n\nThis method is identical to calling updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) with the lockWindow parameter set to false.\n\nImportant\n\nThe system ignores calls to this method if the fineValue is outside of the valid range. Valid conversion updates your app sends before or after an invalid conversion remain available.\n\nSee Also\nProviding conversion information\nclass func updatePostbackConversionValue(Int, coarseValue: SKAdNetwork.CoarseConversionValue, lockWindow: Bool, completionHandler: (((any Error)?) -> Void)?)\nUpdates the fine and coarse conversion values and indicates whether to send the postback before the conversion window ends, and calls a completion handler if the update fails.\nstruct SKAdNetwork.CoarseConversionValue\nCoarse values to use for updating conversion values.\nclass func updatePostbackConversionValue(Int, completionHandler: (((any Error)?) -> Void)?)\nVerifies the first launch of an advertised app and, on subsequent calls, updates the conversion value or calls a completion handler if the update fails."
  },
  {
    "title": "Configuring a source app",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/configuring_a_source_app",
    "html": "Overview\n\nA source app is an app that participates in ad campaigns by displaying ads that an ad network signs. To participate in install validation, the source app needs to include ad network IDs in its Info.plist file. Ad networks are responsible for publishing or providing their ad network IDs to developers.\n\nOnly ads from ad networks that have an entry in the app’s Info.plist file are eligible for install validation. To work with multiple ad networks, include each of the ad network IDs in the source app’s Info.plist file, as follows:\n\nSelect Info.plist in the Project navigator in Xcode.\n\nClick the Add button (+) beside a key in the property list editor and press Return.\n\nType the key name SKAdNetworkItems.\n\nChoose Array from the pop-up menu in the Type column.\n\nCreate an array that contains one dictionary for each allowed ad network, using the single key SKAdNetworkIdentifier. The string value for the key is the ad network ID.\n\nImportant\n\nLowercase the ad network ID string; otherwise, the system doesn’t recognize it as valid.\n\nThe following example shows an array with two dictionaries that represent the example ad network IDs example100.skadnetwork and example200.skadnetwork:\n\n<array>\n    <dict>\n        <key>SKAdNetworkIdentifier</key>\n        <string>example100.skadnetwork</string>\n    </dict>\n    <dict>   \n         <key>SKAdNetworkIdentifier</key>\n         <string>example200.skadnetwork</string>\n    </dict>\n</array>\n\n\n\n\nFor more information about property lists, see Edit property lists.\n\nSee Also\nRegistering ad networks and configuring apps\nRegistering an ad network\nUse the install-validation APIs for your ad campaigns after registering your ad network with Apple.\nConfiguring an advertised app\nPrepare an advertised app to participate in ad campaigns.\nproperty list key SKAdNetworkItems\nAn array of dictionaries containing a list of ad network IDs.\nproperty list key NSAdvertisingAttributionReportEndpoint\nThe URL where Private Click Measurement and SKAdNetwork send attribution information."
  },
  {
    "title": "Registering an ad network",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/registering_an_ad_network",
    "html": "Overview\n\nAd networks provide and cryptographically sign ads that are eligible for ad attribution through SKAdNetwork. Ad networks need to register with Apple before using the SKAdNetwork API.\n\nTo register your ad network, go to Ad Network ID Request Form, which prompts you to sign in to Apple Developer and opens the request form.\n\nWhen registering, you:\n\nReceive your ad network ID.\n\nCreate an elliptic curve cryptographic key pair and share your public key with Apple for signature verification.\n\nProvide a URL for receiving SKAdNetwork install-validation postback requests.\n\nShare your ad network ID with developers\n\nThe ad network ID is a unique lowercased identifier in the format of “example123.skadnetwork”. Share your ad network ID with app developers who display your ads. Developers need to include your ad network ID in their app’s information property list to initiate the app install-validation process.\n\nImportant\n\nLowercase the ad network ID string; otherwise, the system doesn’t recognize it as valid.\n\nGenerate your private key\n\nAd networks use a private cryptographic key to generate a signature for each ad that an app displays. During registration, ad networks create a public-private key pair, and send the public key to Apple. The private key you create uses an Elliptic Curve Digital Signature Algorithm (ECDSA) with a prime256v1 curve.\n\nTo create your private key, open Terminal and enter the following command:\n\nopenssl ecparam -name prime256v1 -genkey -noout -out companyname_skadnetwork_private_key.pem\n\n\nIn the command, replace companyname with the name of your company. For example, the name of the private key file for a company named Example is example_skadnetwork_private_key.pem.\n\nImportant\n\nSecure your private keys as you do other credentials, such as passwords. Don’t share your private keys, store keys in a code repository, or include keys in client-side code. Share only your public key.\n\nGenerate and share your public key\n\nNext, you create a public key from the private key you created in the previous section. The public key is a PEM-encoded PKCS#8 EC key that uses the prime256v1 curve. In Terminal, enter the following command, again replacing companyname with the name of your company:\n\nopenssl ec -in companyname_skadnetwork_private_key.pem -pubout -out companyname_skadnetwork_public_key.pem\n\n\nThis command creates the file companyname_skadnetwork_public_key.pem, which contains your public key. Run this command any time to generate a copy of your public key file.\n\nSend your public key file to Apple when you register your ad network.\n\nSee Also\nRegistering ad networks and configuring apps\nConfiguring a source app\nSet up a source app to participate in ad campaigns.\nConfiguring an advertised app\nPrepare an advertised app to participate in ad campaigns.\nproperty list key SKAdNetworkItems\nAn array of dictionaries containing a list of ad network IDs.\nproperty list key NSAdvertisingAttributionReportEndpoint\nThe URL where Private Click Measurement and SKAdNetwork send attribution information."
  },
  {
    "title": "Configuring an advertised app",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/configuring_an_advertised_app",
    "html": "Overview\n\nAn advertised app is an app a user installs after viewing an ad that an ad network signs. The advertised app doesn’t require any configuration to participate in install validation. However, to register ad attributions, the app needs to call one of the methods that update conversion values when the app first launches. Those methods are: updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:), updatePostbackConversionValue(_:coarseValue:completionHandler:), and updatePostbackConversionValue(_:completionHandler:).\n\nDevelopers opt in to get copies of winning install-validation postbacks.\n\nConfigure your app to receive copies of winning install-validation postbacks\n\nTo opt in to receive copies of winning install-validation postbacks for your advertised app, add the NSAdvertisingAttributionReportEndpoint key in your app’s Info.plist file, and configure your server to receive the postbacks.\n\nTo add the key in your app’s Info.plist file:\n\nSelect Info.plist in the Project navigator in Xcode.\n\nClick the Add button (+) beside a key in the property list editor and press Return.\n\nType the key name NSAdvertisingAttributionReportEndpoint.\n\nChoose String from the pop-up menu in the Type column.\n\nType a valid URL in the format of “https://example.com” that contains your domain name in place of example.com.\n\nFor more information about editing property lists, see Edit property lists.\n\nThe system uses the registrable part of the domain name you provide in the key, and ignores any subdomains. Using your domain name, the system generates a well-known path and sends postbacks to that URL. To receive postbacks, your domain needs to have a valid SSL certificate. Configure your server to accept HTTPS POST messages at the following well-known path:\n\nhttps://example.com/.well-known/skadnetwork/report-attribution/\n\nReplace example.com with your domain name.\n\nFor more information about receiving postbacks, see Receiving ad attributions and postbacks.\n\nSee Also\nRegistering ad networks and configuring apps\nRegistering an ad network\nUse the install-validation APIs for your ad campaigns after registering your ad network with Apple.\nConfiguring a source app\nSet up a source app to participate in ad campaigns.\nproperty list key SKAdNetworkItems\nAn array of dictionaries containing a list of ad network IDs.\nproperty list key NSAdvertisingAttributionReportEndpoint\nThe URL where Private Click Measurement and SKAdNetwork send attribution information."
  },
  {
    "title": "purchase(options:)",
    "url": "https://developer.apple.com/documentation/storekit/product/3791971-purchase",
    "html": "Parameters\noptions\n\nA set of options you can associate with the purchase.\n\nReturn Value\n\nReturns a Product.PurchaseResult.\n\nDiscussion\n\nStoreKit provides several APIs you can use to enable customers to initiate a purchase. Before using purchase(options:) consider the following APIs and choose the one that best suits your app’s implementation:\n\nUse PurchaseAction for apps that use SwiftUI, including multi-scene apps for visionOS.\n\nUse purchase(confirmIn:options:) for apps that use UIKit.\n\nUse purchase(options:) if your app runs on watchOS or macOS.\n\nImportant\n\nIf you use StoreKit views such as ProductView, StoreView, or SubscriptionStoreView you don’t need to call any other API to initiate a purchase. StoreKit manages the purchase action automatically, including presenting the purchase confirmation UI. For more information, see StoreKit views.\n\nUse the purchase API\n\nCall the purchase(options:) method when a customer initiates a purchase, either within your app or after selecting a promoted in-app purchase on the App Store. This method brings up the system-confirmation sheet. The user can confirm to complete the transaction or cancel it.\n\nInclude the purchase options to provide additional information about the purchase, such as:\n\nappAccountToken(_:) to associate the purchase with the resulting transaction\n\npromotionalOffer(offerID:keyID:nonce:signature:timestamp:), if the customer is redeeming a promotional offer for an auto-renewable subscription\n\nquantity(_:), if the customer is purchasing more than one of the product\n\nThe following example illustrates calling purchase(options:) using the options parameter to provide an app account token:\n\nlet appAccountToken = <# Generate an app account token. #>\nlet purchaseResult = try await product.purchase(options: [\n    .appAccountToken(appAccountToken)\n])\n\n\nIf you’re testing your app in the sandbox environment, test an Ask to Buy scenario by setting the simulatesAskToBuyInSandbox(_:) purchase option to true. For more information about Ask to Buy, see Approve what kids buy with Ask to Buy.\n\nThis method may throw a Product.PurchaseError or StoreKitError.\n\nFor more information about purchases that users initiate on the App Store, see Promoting in-app purchases.\n\nSee Also\nPurchasing a product\nfunc purchase(confirmIn: some UIScene, options: Set<Product.PurchaseOption>) -> Product.PurchaseResult\nInitiates a purchase for the product with the App Store and displays the confirmation sheet.\nstruct Product.PurchaseOption\nOptional settings for a product purchase.\nenum Product.PurchaseResult\nThe result of a purchase.\nenum Product.PurchaseError\nError information for product purchase errors."
  },
  {
    "title": "SKAdNetwork release notes",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/skadnetwork_release_notes",
    "html": "Overview\n\nUse the most recent version of SKAdNetwork available.\n\nIn version 2.0 and later, ad networks use a version number when signing ads. For StoreKit-rendered ads, you set the version number in the SKStoreProductParameterAdNetworkVersion parameter. For view-through ads, you set the version number in the version property.\n\nWhen you receive an install-validation postback, it contains the version number. Each version of SKAdNetwork has specific instructions for signing ads and validating the postback.\n\nDevelopers of advertised apps are eligible to receive copies of winning postbacks, versions 2 and later, if the participants meet the following conditions:\n\nThe developer of the advertised app opts-in to receive postbacks. For instructions on opting-in, see Configuring an advertised app.\n\nThe device is running iOS 15 or later.\n\nTopics\nSKAdNetwork versions\nSKAdNetwork 4 release notes\nA version of SKAdNetwork available in iOS 16.1 and later.\nSKAdNetwork 3 release notes\nA version of SKAdNetwork available in iOS 14.6 and later.\nSKAdNetwork 2.2 release notes\nA version of SKAdNetwork available in iOS 14.5 and later.\nSKAdNetwork 2.1 release notes\nA version of SKAdNetwork available in iOS 14 and later.\nSKAdNetwork 2 release notes\nA version of SKAdNetwork available in iOS 14 and later.\nSKAdNetwork 1 release notes\nA version of SKAdNetwork available in iOS 11.3 and later.\nSee Also\nEssentials\nSigning and providing ads\nAdvertise apps by signing and providing StoreKit-rendered ads, view-through ads, or attributable web ads.\nReceiving ad attributions and postbacks\nLearn about timeframes and priorities for ad impressions that result in ad attributions, and how additional impressions qualify for postbacks.\nReceiving postbacks in multiple conversion windows\nLearn about the data that postbacks may contain in each conversion window."
  },
  {
    "title": "Product.PromotionInfo",
    "url": "https://developer.apple.com/documentation/storekit/product/promotioninfo",
    "html": "Overview\n\nThe Product.PromotionInfo structure represents promoted in-app purchases available in your app. You set up promoted in-app purchases using App Store Connect, including their default display order and visibility settings. Use this API to override and customize their order and visibility. Overrides are per device. They can take effect after the user launches the app at least once.\n\nYou don’t instantiate this structure. To get a list of Product.PromotionInfo objects, call the static method updateProductOrder(byID:) with a list of product identifiers that represent your promoted in-app purchases. Then call currentOrder to get the list of Product.PromotionInfo objects. To change their order, call updateAll(_:) with the promoted in-app purchases listed in the desired order. To change the order using product identifiers, call updateProductOrder(byID:).\n\nTo prevent a promoted in-app purchase from appearing in the App Store on the device, there are two options:\n\nHide the product by setting the visibility value to Product.PromotionInfo.Visibility.hidden and calling update(), or call updateProductVisibility(_:for:).\n\nRemove the product from the list by excluding it when you call updateAll(_:) or updateProductOrder(byID:).\n\nTo cancel your overrides and return to the default order and visibility, call updateAll(_:) or updateProductOrder(byID:) with an empty array.\n\nFor more information about promoting in-app purchases, see Supporting promoted in-app purchases in your app.\n\nTopics\nGetting the product ID\nlet productID: Product.ID\nThe product identifier of the promoted in-app purchase.\nManaging promotion order\nstatic func updateProductOrder(byID: some Collection<String>)\nSets the display order of promoted in-app purchases in the App Store, using product identifiers.\nGetting overridden order\nstatic var currentOrder: [Product.PromotionInfo]\nGets the customized order of the promotion info objects the represent promoted products.\nManaging promotion visibility\nvar visibility: Product.PromotionInfo.Visibility\nA value that indicates whether the promoted in-app purchase is visible or hidden on the user’s device.\nenum Product.PromotionInfo.Visibility\nThe visibility states for product promotion information.\nstatic func updateProductVisibility(Product.PromotionInfo.Visibility, for: Product.ID)\nUpdates a value that indicates whether a promoted in-app purchase appears in the App Store on the user's device.\nUpdating order and visibility\nfunc update()\nSaves your changes to the promoted product’s visibility.\nstatic func updateAll(some Collection<Product.PromotionInfo>)\nSets the order and visibility of all the promoted products and saves your changes.\nComparing promotion info\nstatic func != (Product.PromotionInfo, Product.PromotionInfo) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.PromotionInfo, Product.PromotionInfo) -> Bool\nReturns a Boolean value that indicates whether two values are equal."
  },
  {
    "title": "Receiving ad attributions and postbacks",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/receiving_ad_attributions_and_postbacks",
    "html": "Overview\n\nAd networks receive attributions in the form of install-validation postbacks. Before an ad network can receive a postback, the following events need to occur within limited time-windows:\n\nAd networks sign and present ads in the form of StoreKit-rendered ads, view-through ads, or attributable web ads. StoreKit records the ad impressions.\n\nUsers install the advertised app.\n\nUsers launch the app.\n\nThe app updates the conversion values when the user first launches the app, and continues to update it as needed.\n\nIf all these events occur within their respective time-windows, the ad impression qualifies for an install-validation postback. The following table shows the time-windows for the events:\n\nEvent\n\n\t\n\nTime-window\n\n\n\n\nThe ad network presents a StoreKit-rendered ad.\n\n\t\n\nThe user has 30 days to install the app.\n\n\n\n\nThe ad network presents a view-through ad.\n\n\t\n\nThe user has 24 hours to install the app.\n\n\n\n\nThe user taps an attributable web ad.\n\n\t\n\nThe user has 30 days to install the app.\n\n\n\n\nThe user installs the app.\n\n\t\n\nThe user has 60 days to launch the app.\n\n\n\n\nThe user launches the app and the app calls any conversion update method, such as updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:),\n\n\t\n\nThe device has 60 days after the user installs the app to send the first conversion value update.\n\n\n\n\nThe user launches the app and the app calls a conversion update method, such as updatePostbackConversionValue(_:completionHandler:) for ads signed with version 3 or earlier.\n\n\t\n\nFor ads signed with version 3 or earlier, the device sends install-validation postbacks 0–24 hours after a 24-hour timer expires following the final call to update the conversion value. The total delay from the final conversion update to receiving the postback is 24–48 hours.\n\nThe minimum elapsed time between an ad impression and the time the ad network receives an install-validation postback is 24 to 48 hours. To reduce that time to 5 to 10 minutes during testing, see Testing ad attributions with a downloaded profile.\n\nDevices send one or more postbacks depending on the SKAdNetwork and iOS versions:\n\nFor ads signed with SKAdNetwork 1 through 2.2, devices send a single, winning postback.\n\nStarting in iOS 14.6 for ads signed with version 3.0 or later, devices send a single winning postback, and up to five nonwinning postbacks.\n\nStarting in iOS 15, devices also send a copy of the winning postback to the advertised app’s developer, if the developer opts in to receive it.\n\nStarting in iOS 16.1 for ads signed using SKAdNetwork 4, devices can send up to three postbacks for the winning ad attribution, in three conversion windows.\n\nTime-windows for events apply equally to winning and nonwinning postbacks.\n\nReceive a winning postback\n\nWhen multiple ad impressions qualify for install-validation postbacks, a device sends the winning postback to the ad network based on the following rules:\n\nIn versions 1 through 2.1, the attribution goes to the most recent ad impression.\n\nStarting in version 2.2, the attribution goes to the most recent ad impression with the highest fidelity-type value.\n\nThe ad presentation option defines the fidelity-type value:\n\nStoreKit-rendered ads have the highest fidelity-type value of 1.\n\nView-through ads have a fidelity-type value of 0.\n\nIndicate the fidelity-type when you generate the ad signature. Recorded ad impressions with a fidelity-type of 1 always take precedence over those with a fidelity-type of 0. For example, if users see a StoreKit-rendered ad followed by a view-through ad for the same app, the StoreKit-rendered ad takes precedence over the view-through ad, despite the view-through ad being more recent. The source app can display StoreKit-rendered ads using an SKOverlay or SKStoreProductViewController; the fidelity-type value is 1 in either case. For information about the fidelity of ads that an ad network presents on a Safari web page using the SKAdNetwork for Web Ads API, see signature.\n\nIn version 3 and later, the system indicates winning postbacks with a did-win parameter of value true.\n\nReceive a nonwinning postback\n\nStarting in iOS 14.6, devices can send multiple postbacks to ad networks that sign ads using version 3 or later. The system indicates nonwinning postbacks with a did-win parameter of value false. These postbacks don’t include conversion-value or source-app-id.\n\nEach ad network can receive only one install-validation postback, winning or not winning. If you receive the winning postback, you don’t receive any nonwinning postbacks even if your ads have multiple qualifying ad impressions.\n\nUp to five ad networks receive one nonwinning postback each. The system orders the recorded ad impressions using recency and fidelity-type, with the most recent ad views and highest fidelity-type taking precedence. Devices send nonwinning postbacks for the top five ad impressions from different ad networks that qualify for ad attribution.\n\nOpt in to receive a copy of the winning postback\n\nStarting in iOS 15, devices can send a copy of the winning install-validation postback to the developer of the advertised app. Developers opt in to receive the postback by specifying a server endpoint in their app’s Info.plist file. For more information about opting in and specifying the endpoint, see Configuring an advertised app.\n\nThe postback that developers receive is an exact copy of the winning install-validation postback that the device sends to the ad network. The device sends the postback to developers at the same time it sends the winning postback to the ad network. To verify the postback, see Verifying an install-validation postback.\n\nLimit view-through ad impressions\n\nStoreKit records a maximum of 15 view-through ad impressions per source app before discarding the oldest one. The recorded ad impressions may advertise various products, and are each eligible to become pending attributions until they expire (after 24 hours).\n\nTest ad impressions and postbacks\n\nUse the StoreKit Test framework to validate your ad impressions and test your postbacks by creating unit tests. For more information, see SKAdTestSession and Testing and validating ad impression signatures and postbacks for SKAdNetwork.\n\nSee Also\nEssentials\nSigning and providing ads\nAdvertise apps by signing and providing StoreKit-rendered ads, view-through ads, or attributable web ads.\nReceiving postbacks in multiple conversion windows\nLearn about the data that postbacks may contain in each conversion window.\nSKAdNetwork release notes\nLearn about the features in each SKAdNetwork version."
  },
  {
    "title": "Receiving postbacks in multiple conversion windows",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/receiving_postbacks_in_multiple_conversion_windows",
    "html": "Overview\n\nSKAdNetwork supports three conversion windows that may result in up to three postbacks for a winning ad attribution. The conversion window begins when the user first launches the app. The first conversion window spans days 0 to 2; the second window spans days 3 to 7; and the third window spans days 8 to 35. Apps can update conversion values during all three time-windows.\n\nTo be eligible to receive multiple postbacks, all participants need to meet the following conditions:\n\nThe ad network needs to sign the ad using SKAdNetwork 4 or later.\n\nThe advertised app needs to call updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) or updatePostbackConversionValue(_:coarseValue:completionHandler:)to update the conversion values during each conversion window.\n\nYou may receive a single postback in the following cases:\n\nIf the app's postback data tier is Tier 0, the system sends only the first postback.\n\nNonwinning ad attributions receive only the first postback.\n\nFor ads signed using SKAdNetwork 3 or earlier, you receive only one winning postback.\n\nLock conversion values to receive postbacks sooner\n\nBy default, the system waits until the end of a conversion window to get the final conversion value. Apps can continue to update the conversion value until the end of the conversion window. When the conversion window ends, the system prepares the postback and sends it after a random delay, as the following diagram shows:\n\nThe random delay is 24–48 hours for the first postback, and 24–144 hours for the second and third postbacks.\n\nThe updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) method provides an option for you to lock in and finalize a conversion value before the conversion window ends. You may choose to lock the conversion value in any or all conversion windows. The diagram below shows an app that locks the conversion value during the second conversion window:\n\nAfter receiving a locked conversion value, the system immediately prepares the postback and ignores any further conversion value updates in the same conversion window. The system sends the postbacks after the same random delay following the locked conversion: a 24–48-hour delay for the first postback, and a 24–144-hour delay for the second and third postbacks. The system ignores further updates to the conversion value for the remaining time in the same conversion window.\n\nNote\n\nThe earliest you may receive the first postback is unchanged from version 3 to version 4: the total delay is 24–48 hours after the app updates its final conversion value.\n\nIn version 3, the app finalizes the conversion value when a 24-hour timer expires after the last conversion value update. Then, the device sends the postback after a random 0–24 hour delay, making the earliest postback 24–48 hours after the app sets the final conversion value.\n\nIn version 4, the app may finalize the conversion value by locking it. Then, the device sends the postback after a random 24–48 hour delay.\n\nAs a result, both version 3 and 4 have a total delay of 24–48 hours to receive the first postback after the app finalizes the conversion value.\n\nReceive the highest level of data that ensures crowd anonymity\n\nTo maintain users’ privacy and ensure crowd anonymity, the device may limit the data that SKAdNetwork sends in postbacks. Apple determines a postback data tier that it assigns to each app download. The following diagram depicts the relationship between the tiers and relative crowd sizes. It's for illustrative purposes only.\n\nThe postback data tier takes into account the crowd size associated with the app or domain displaying the ad, the advertised app, and the hierarchical source identifier the ad network provides. The system computes the postback data tier for the two-, three-, and four-digit hierarchical source identifiers. It selects the source identifier with the highest postback data tier. If multiple source identifiers share the highest postback data tier, the system selects the source identifier with the most digits. If the highest postback data tier is Tier 1 or Tier 0, the system always selects the two-digit source identifier.\n\nThe postback data tier affects the following fields in the postback, which may be present or absent, or may contain a limited number of digits:\n\nsource-identifier, the hierarchical source identifier that may include two, three, or four digits\n\nconversion-value, a fine-grained conversion value available only in the first postback\n\ncoarse-conversion-value, a coarse conversion value, which the system sends instead of the conversion-value in lower postback data tiers, and in the second and third postbacks\n\nsource-app-id for ads that display in apps, or source-domain for attributable web ads\n\nThe remaining postback data fields aren't dependent on the postback date tier and appear in all postbacks, based on the SKAdNetwork version of the postback.\n\nReceive the first postback\n\nThe first conversion window ends two days after the user first launches the app. The system prepares the postback after the conversion window ends, unless you use a lock. If you use a lock, the system prepares the first postback when the app calls updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) with the lock in an enabled state. The system then sends the postback after a random 24–48-hour delay.\n\nThe postback data tier determines the data you receive in the first postback, as follows:\n\nFor ads in Tier 3, the first postback contains:\n\nsource-identifier, the hierarchical source identifer with two, three, or four digits\n\nconversion-value, the fine-grained conversion value, if the app provides one\n\nsource-app-id for ads that display in apps, or source-domain for attributable web ads\n\nFor ads in Tier 2, the first postback contains:\n\nsource-identifier, the hierarchical source identifer with two, three, or four digits\n\nconversion-value, the fine-grained conversion value, if the app provides one\n\nFor ads in Tier 1, the first postback contains:\n\nsource-identifier, the hierarchical source identifer with two digits\n\ncoarse-conversion-value, a coarse value, if the app provides one\n\nFor ads in Tier 0, the first postback contains the source-identifier, the hierarchical source identifer, with two digits.\n\nReceive the second and third postbacks\n\nThe second conversion window ends seven days after the user first launches the app, and the third conversion window ends after 35 days. The system prepares the second and third postbacks after their conversion windows end, and sends them after a random 24–144-hour delay.\n\nIf you use a lock with the second or third conversion value updates, the system prepares the postback when you call updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:) with the lock in an enabled state. The system sends the postback after a random 24–144-hour delay.\n\nThe postback data tier determines the data you receive in the postbacks, as follows:\n\nFor ads in Tier 1, Tier 2, and Tier 3, the second and third postbacks contain:\n\nsource-identifier, the hierarchical source identifer with two digits\n\ncoarse-conversion-value, the coarse conversion value, if the app provides one\n\nFor ads in Tier 0, the system doesn’t send a second or third postback.\n\nAds signed with version 4 and later are eligible for second and third postbacks after a winning ad impression. Ads signed with version 3 and earlier are eligible for one winning postback.\n\nSee Also\nEssentials\nSigning and providing ads\nAdvertise apps by signing and providing StoreKit-rendered ads, view-through ads, or attributable web ads.\nReceiving ad attributions and postbacks\nLearn about timeframes and priorities for ad impressions that result in ad attributions, and how additional impressions qualify for postbacks.\nSKAdNetwork release notes\nLearn about the features in each SKAdNetwork version."
  },
  {
    "title": "Signing and providing ads",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/signing_and_providing_ads",
    "html": "Overview\n\nSKAdNetwork supports several ways for ad networks to provide ads:\n\nStoreKit-rendered ads, where StoreKit displays an App Store product page as the ad impression\n\nView-through ads, where the ad network presents an ad in any format and reports the ad impression using the SKAdNetwork API\n\nAttributable web ads, where the ad network presents an ad on a Safari web page using the SKAdNetwork for Web Ads API\n\nTo differentiate StoreKit-rendered ads from view-through ads, SKAdNetwork defines a fidelity-type parameter, which you include in the ad signature, and receive in the install-validation postback. Use a fidelity-type value of 1 for StoreKit-rendered ads and attributable web ads, and 0 for view-through ads. The following table compares the ad presentation options:\n\nAd presentation option\n\n\t\n\nDescription\n\n\t\n\nFidelity type\n\n\t\n\nAvailability\n\n\n\n\nStoreKit-rendered ads\n\n\t\n\nApp Store product page that StoreKit renders\n\n\t\n\n1\n\n\t\n\nAll SKAdNetwork versions\n\n\n\n\nView-through ads\n\n\t\n\nCustom, from the ad network\n\n\t\n\n0\n\n\t\n\nSKAdNetwork 2.2 and later\n\n\n\n\nAttributable web ads (SKAdNetwork for Web Ads)\n\n\t\n\nCustom, from the ad network\n\n\t\n\n1\n\n\t\n\nSKAdNetwork 4 and later\n\nFor more information about availability and versions, see SKAdNetwork release notes.\n\nThe fidelity-type can affect which ad receives attribution when the user experiences multiple ad impressions. For more information about how fidelity-type and the time of the ad impression affect attributions, see Receiving ad attributions and postbacks.\n\nAd networks must cryptographically sign the ads. The signature contains information that includes a campaign identifier. If ads result in conversions, ad networks receive an install-validation postback that includes the campaign identifier. For more information about the postback, see Verifying an install-validation postback.\n\nProvide a StoreKit-rendered ad\n\nFollow these steps to display a StoreKit-rendered ad in your app:\n\nSet Ad network install-validation keys with values that represent the ad impression.\n\nOn the ad network’s server, generate the signature using those key values. Then, set the SKStoreProductParameterAdNetworkAttributionSignature key with the signature value. For information about generating the signature, see Generating the signature to validate StoreKit-rendered ads.\n\nCall loadProduct(withParameters:completionBlock:) using your ad network install-validation keys to load the ad.\n\nPresent the ad in your app according to your app’s design. You can use either an SKOverlay or an SKStoreProductViewController to display a StoreKit-rendered ad. The fidelity-type value of a StoreKit-rendered ad is 1 in either case.\n\nProvide a view-through ad\n\nFollow these steps to provide a view-through ad:\n\nCreate an SKAdImpression instance and set its properties to represent the ad impression.\n\nOn the ad network’s server, generate the signature based on those properties. Then set the signature property in the SKAdImpression instance to the generated signature. For more information, see Generating the signature to validate view-through ads.\n\nCall startImpression(_:completionHandler:) and then present your custom ad to the user according to your app’s design.\n\nCall endImpression(_:completionHandler:) when you finish presenting the ad.\n\nProvide an attributable web ad\n\nAd networks can sign attributable ads that websites can display in Safari. For more information, see SKAdNetwork for Web Ads.\n\nSee Also\nEssentials\nReceiving ad attributions and postbacks\nLearn about timeframes and priorities for ad impressions that result in ad attributions, and how additional impressions qualify for postbacks.\nReceiving postbacks in multiple conversion windows\nLearn about the data that postbacks may contain in each conversion window.\nSKAdNetwork release notes\nLearn about the features in each SKAdNetwork version."
  },
  {
    "title": "Transaction",
    "url": "https://developer.apple.com/documentation/storekit/transaction",
    "html": "Overview\n\nA transaction represents a successful in-app purchase. The App Store generates a transaction each time a customer purchases an in-app purchase product or renews a subscription. For each transaction that represents a current purchase, your app unlocks the purchased content or service and finishes the transaction.\n\nUse the Transaction type to perform these transaction-related tasks:\n\nGet the user’s transaction history, latest transactions, and current entitlements to unlock content and services.\n\nAccess transaction properties.\n\nFinish a transaction after your app delivers the purchased content or service.\n\nAccess the raw JSON Web Signature (JWS) string and supporting values to verify the transaction information.\n\nListen for new transactions while the app is running.\n\nBegin a refund request from within your app.\n\nAccess transaction history and current entitlements\n\nYour app doesn’t create transaction objects. Instead, StoreKit automatically makes up-to-date transactions available to your app, including when the user launches the app for the first time. You access transactions in several ways:\n\nGet transaction history anytime by accessing the static all sequence, or get just the most recent transaction for a product with the latestTransaction property of Product.\n\nGet notified of new transactions while your app is running when users complete a transaction on another device, through the transaction listener, updates.\n\nAccess the latest transaction for a subscription group through the subscription status API, using transaction.\n\nAfter a successful in-app purchase, StoreKit returns the transaction through Product.PurchaseResult.success(_:).\n\nThe most important use of transaction information is for determining which in-app purchases the user has paid access to, so your app can unlock the content or service. The currentEntitlements API provides the information you need to unlock all of the user’s paid content in your app. Use currentEntitlements to get a list of transactions for all the products the user is currently entitled to, including non-consumable in-app purchases and currently active subscriptions.\n\nRelated sessions from WWDC22\n\nSession 110404: Implement proactive in-app purchase restore\n\nVerify transactions\n\nThe App Store cryptographically signs transaction information, in JWS format. The transaction type provides the raw JWS string, jwsRepresentation, and makes the transaction information immediately available in the Transaction properties. StoreKit automatically validates the transaction information, returning it wrapped in a VerificationResult. If you get a transaction through VerificationResult.verified(_:), the information passed validation. If you get it through VerificationResult.unverified(_:_:), the transaction information didn’t pass StoreKit’s automatic validation. If you choose to perform your own validation, do so on the transaction’s jwsRepresentation string, or use the provided convenience properties headerData, payloadData, and signatureData. For more information about JWS, see the IETF RFC 7515 specification.\n\nIf StoreKit returns the transaction as verified, then the transaction is valid for the device. For more information about verifying a transaction for a device, see deviceVerification.\n\nAccess purchases made with the original api\n\nAll in-app purchases that users make are equally available to your app in both APIs: in this Transaction API, and in receipts using the Original API for in-app purchase.\n\nNew purchases that users make with the original in-app purchase APIs are available immediately using the Transaction API. Purchases that users make with the purchase(options:) method are available in the original API, when your app refreshes the receipt. For more information, see SKReceiptRefreshRequest.\n\nTopics\nTransaction properties\nTransaction properties\nThe properties of a transaction, including identifiers, purchase and revocation dates and details, status, and offer details.\nMonitoring transaction-related changes\nstatic var updates: Transaction.Transactions\nThe asynchronous sequence that emits a transaction when the system creates or updates transactions that occur outside of the app or on other devices.\nstruct Transaction.Transactions\nAn asynchronous sequence of transactions.\nGetting transaction history\nstatic func latest(for: String) -> VerificationResult<Transaction>?\nGets the user’s latest transaction for an in-app purchase.\nstatic var all: Transaction.Transactions\nA sequence that emits all the transactions for the user for your app.\nstatic var unfinished: Transaction.Transactions\nA sequence that emits unfinished transactions for the user.\nGetting current entitlements\nstatic var currentEntitlements: Transaction.Transactions\nA sequence of the latest transactions that entitle a user to in-app purchases and subscriptions.\nstatic func currentEntitlement(for: String) -> VerificationResult<Transaction>?\nGets the latest transactions that entitle the user to a specified product.\nFinishing the transaction\nfunc finish()\nIndicates to the App Store that the app delivered the purchased content or enabled the service to finish the transaction.\nstatic var unfinished: Transaction.Transactions\nA sequence that emits unfinished transactions for the user.\nVerifying transactions\nlet deviceVerification: Data\nThe device verification value you use to verify whether the transaction belongs to the device.\nlet deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nlet signedDate: Date\nThe date that the App Store signed the JWS transaction.\nGetting transaction info in JSON format\nvar jsonRepresentation: Data\nThe raw JSON representation of the transaction information.\nRequesting refunds\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds.\nfunc beginRefundRequest(in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a window scene.\nfunc beginRefundRequest(in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the transaction in a view controller.\nstatic func beginRefundRequest(for: UInt64, in: UIWindowScene) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a window scene.\nstatic func beginRefundRequest(for: UInt64, in: NSViewController) -> Transaction.RefundRequestStatus\nPresents the refund request sheet for the specified transaction in a view controller.\nenum Transaction.RefundRequestError\nThe error codes for refund requests.\nenum Transaction.RefundRequestStatus\nThe status codes for refund requests.\nComparing and hashing transactions\nstatic func != (Transaction, Transaction) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Transaction, Transaction) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nGetting a debug description\nvar debugDescription: String\nInstance Properties\n@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2, visionOS 1.1) var currency: Locale.Currency?\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0) var currencyCode: String?\nDeprecated\n@backDeployed(before: iOS 17.2, macOS 14.2, tvOS 17.2, watchOS 10.2, visionOS 1.1) var price: Decimal?\nRelationships\nConforms To\nCustomDebugStringConvertible\nEquatable\nHashable\nIdentifiable"
  },
  {
    "title": "PurchaseIntent",
    "url": "https://developer.apple.com/documentation/storekit/purchaseintent",
    "html": "Overview\n\nUsing PurchaseIntent is required if you’re promoting in-app purchases on the App Store. You set up promoted in-app purchases using App Store Connect.\n\nImportant\n\nTo enable promoted in-app purchases, your app must use either PurchaseIntent (starting in iOS 16.4) or paymentQueue(_:shouldAddStorePayment:for:) (starting in iOS 11). Don’t use both at the same time. If necessary, use conditional compilation to identify the OS version the app is running in. For more information, see Running code on a specific platform or OS version.\n\nWhen a customer selects a promoted product on the App Store, it initiates a purchase that they complete in your app. If they don’t have your app installed, the system prompts them to download it. After the app downloads, the transaction continues in the app, which receives a purchase intent from the intents sequence.\n\nThe purchase intent identifies the product the customer selected. To enable customers to complete the purchase, call purchase(options:) on this product instance. The following example code receives the purchase intent, and calls a method to complete the purchase workflow:\n\nfunc purchaseProduct(_ product: Product) async {\n    // Complete the purchase workflow.\n    do {\n        try await product.purchase()\n    }\n    catch {\n        <#Handle Error#>\n    }\n    <#Add remaining purchase workflow.#>\n}\n\n\nfor await purchaseIntent in PurchaseIntent.intents {\n    // Complete the purchase workflow.\n    await purchaseProduct(purchaseIntent.product)\n}\n\n\n\n\nFor more information, see Supporting promoted in-app purchases in your app. For information about setting up promoted in-app purchases using App Store Connect, see Promote in-app purchases.\n\nIn Mac apps built with Mac Catalyst, this instance doesn’t emit purchase intents because the Mac App Store doesn’t support this feature.\n\nNote\n\nPurchaseIntent and promoted in-app purchases aren’t available to compatible iPad or iPhone apps running in visionOS.\n\nTopics\nIdentifying the product\nvar id: Product.ID\nThe product identifier of the promoted in-app purchase that the user selects to purchase on the App Store.\nlet product: Product\nThe product information of the promoted in-app purchase the user selects to purchase on the App Store.\nGetting purchase intents\nstatic var intents: PurchaseIntent.PurchaseIntents\nThe asynchronous sequence that emits a purchase intent when the user selects a promoted in-app purchase on the App Store.\nstruct PurchaseIntent.PurchaseIntents\nAn asynchronous sequence of purchase intents for in-app purchases that users initiate on the App Store.\nComparing purchase intents\nstatic func != (PurchaseIntent, PurchaseIntent) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (PurchaseIntent, PurchaseIntent) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nRelationships\nConforms To\nSendable\nSee Also\nPromoted in-app purchases\nSupporting promoted in-app purchases in your app\nDisplay promoted in-app purchases on your product page and handle purchases that users initiate on the App Store.\nstruct Product.PromotionInfo\nInformation about a promoted in-app purchase that customizes its order and visibility on the device.\nTesting promoted in-app purchases\nTest your in-app purchases before making your app available in the App Store."
  },
  {
    "title": "Product.SubscriptionInfo.Status",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo/status",
    "html": "Overview\n\nThe subscription status provides renewal information signed by the App Store for subscriptions that a customer purchases.\n\nTopics\nMonitoring subscription status changes\nstatic var updates: Product.SubscriptionInfo.Status.Statuses\nThe asynchronous sequence that emits status information when a subscription’s status changes.\nstatic var all: AsyncStream<(groupID: String, statuses: [Product.SubscriptionInfo.Status])>\nstruct Product.SubscriptionInfo.Status.Statuses\nAn asynchronous sequence that listens for new subscription status information.\nGetting subscription status information\nlet state: Product.SubscriptionInfo.RenewalState\nThe renewal state of the auto-renewable subscription.\nlet renewalInfo: VerificationResult<Product.SubscriptionInfo.RenewalInfo>\nThe signed renewal information for the auto-renewable subscription.\nlet transaction: VerificationResult<Transaction>\nThe latest transaction for the subscription group.\nstruct Product.SubscriptionInfo.RenewalInfo\nThe renewal information for an auto-renewable subscription.\nstruct Product.SubscriptionInfo.RenewalState\nThe renewal states of auto-renewable subscriptions.\nComparing and hashing status\nstatic func != (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo.Status, Product.SubscriptionInfo.Status) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nSee Also\nDetermining the subscription status\nvar status: [Product.SubscriptionInfo.Status]\nAn array that contains status information for a subscription group, including renewal and transaction information.\nstatic func status(for: String) -> [Product.SubscriptionInfo.Status]\nGets the subscription status for a subscription group identifier."
  },
  {
    "title": "Testing promoted in-app purchases",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_promoted_in-app_purchases",
    "html": "Overview\n\nUsers can buy promoted in-app purchases from the App Store, but you need to test this flow before making your product publicly available. Apple provides a system URL that triggers your app using the itms-services:// protocol, so you can test in-app purchases before they’re available in the App Store.\n\nProtocol\n\n\t\n\nitms-services://\n\n\n\n\nParameter action\n\n\t\n\npurchaseIntent\n\n\n\n\nParameter bundleId\n\n\t\n\nThe bundle ID for your app; for example:\n\ncom.example.app\n\n\n\n\nParameter productIdentifier\n\n\t\n\nThe in-app purchase product name you want to test; for example:\n\nproduct_name\n\nThe resulting URL looks like this:\n\nitms-services://?action=purchaseIntent&bundleId=com.example.app&productIdentifier=product_name\n\nSend this URL to yourself in an email or iMessage, and open it from your device. You’ll know the test is running when your app opens automatically. You can then test how your app handles the promoted in-app purchase.\n\nSee Also\nPromoted in-app purchases\nSupporting promoted in-app purchases in your app\nDisplay promoted in-app purchases on your product page and handle purchases that users initiate on the App Store.\nstruct PurchaseIntent\nAn instance that emits purchase intents, which indicates that the customer initiated a promoted in-app purchase on the App Store for your app to complete.\nstruct Product.PromotionInfo\nInformation about a promoted in-app purchase that customizes its order and visibility on the device."
  },
  {
    "title": "VerificationResult.VerificationError",
    "url": "https://developer.apple.com/documentation/storekit/verificationresult/verificationerror",
    "html": "Topics\nError Description\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA localized message describing the reason for the failure.\nvar helpAnchor: String?\nA message providing “help” text if the user requests help by pressing an alert panel help anchor button.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error.\nError Codes\ncase invalidCertificateChain\nAn error indicating that the certificate chain is invalid.\ncase invalidDeviceVerification\nAn error that indicates the signed value wasn’t generated for the current device.\ncase invalidEncoding\nAn error that indicates the signature, certificate chain, or other part of value uses invalid encoding.\ncase invalidSignature\nAn error that indicates that the signature didn’t match the header and payload.\ncase missingRequiredProperties\nAn error that indicates the header or payload are missing information that’s required to verify the signature.\ncase revokedCertificate\nAn error that indicates the certificate chain includes a revoked certificate.\nError Comparisons\nstatic func != (VerificationResult<SignedType>.VerificationError, VerificationResult<SignedType>.VerificationError) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (VerificationResult<SignedType>.VerificationError, VerificationResult<SignedType>.VerificationError) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nError\nLocalizedError\nSee Also\nGetting the verification results\ncase verified(SignedType)\nThe associated value passed StoreKit automatic verification checks.\ncase unverified(SignedType, VerificationResult<SignedType>.VerificationError)\nThe associated value failed StoreKit automatic verification checks.\nvar payloadValue: SignedType\nThe verified value of the signed type that StoreKit confirms as verified.\nvar unsafePayloadValue: SignedType\nThe associated value of the verification result that StoreKit doesn’t confirm as verified."
  },
  {
    "title": "Testing at all stages of development with Xcode and the sandbox",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_at_all_stages_of_development_with_xcode_and_the_sandbox",
    "html": "Overview\n\nUse the Apple sandbox and Xcode test environments to test your implementation of in-app purchases using the StoreKit framework. Comprehensive testing can help you:\n\nEnsure a seamless purchase flow to provide a positive customer experience in your app.\n\nImplement sound logic that covers all scenarios, such as purchases, restores, and subscription offers.\n\nValidate that purchases behave correctly in production after your app is available in the App Store.\n\nThe tools you need to test in-app purchases, non-renewing subscriptions, and auto-renewable subscriptions from early development through beta testing are:\n\nStoreKit Testing in Xcode\n\nFor early development, continuous integration, and debugging. For more information, see StoreKit Test.\n\nSandbox\n\nFor testing scenarios using in-app purchase data you set up in App Store Connect. For more information, see Testing in-app purchases with sandbox.\n\nTestFlight\n\nFor managing beta testing with internal and external testers. TestFlight uses a beta build of your app or App Clip that you upload to App Store Connect. For more information, see Beta Testing Made Simple with TestFlight.\n\nChoose the tools that support the test scenarios you need. Make sure you’re able to perform the setup required for the tools you choose.\n\nDuring the early stages of development, you may not be ready to configure in-app purchases in App Store Connect. StoreKit Testing in Xcode lets you configure the information locally. You can test StoreKit transactions before you create Sandbox Apple IDs, without a network connection. You can test your app in Simulator or on real devices.\n\nAfter you set up in-app purchases in App Store Connect, start using the sandbox environment to test the product information your app will use in production. Testing in the sandbox lets you test transactions from end-to-end and from your app to your server. You can also test any server-to-server functionalities your app depends on, such as transaction validation and App Store Server Notifications.\n\nTestFlight lets you get feedback from members of your team or from external testers. TestFlight uses the sandbox environment for in-app purchases. Transactions and purchases that occur in the sandbox don’t incur charges. The following table compares the test environments and features:\n\nTest environment\n\n\t\n\nRequires App Store Connect setup\n\n\t\n\nProvides receipts and JSON Web Signature (JWS) transactions signed by the App Store\n\n\t\n\nProvides subscription renewal information signed by the App Store\n\n\n\n\nStoreKit Testing in Xcode\n\n\t\n\nNo\n\n\t\n\nNo (signed by Xcode)\n\n\t\n\nNo (signed by Xcode)\n\n\n\n\nSandbox\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nTestFlight (uses the sandbox)\n\n\t\n\nYes\n\n\t\n\nYes\n\n\t\n\nYes\n\nNone of the test environments charge users when they test buying a product. The App Store doesn’t send emails for purchases or refunds made in the test environments.\n\nControl the test environment\n\nTo set up and run test scenarios, you often need to control the test environment. For example, you may want to reset a test account to rerun the same test multiple times, or mimic actions users take outside your app that affect the test conditions. The following table shows the capabilities each tool has to control the test environment:\n\nTest scenario\n\n\t\n\nSandbox\n\n\t\n\nStoreKit Testing in Xcode\n\n\n\n\nTest different storefronts to affect price tiers and locale\n\n\t\n\nYes\n\n\t\n\nLimited (no price tiers)\n\n\n\n\nClear the purchase history\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nTest subscription upgrades, downgrades, cross-grades, and auto-renew cancellations\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nReset eligibility for introductory offers\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nIntroduce forced StoreKit errors for testing\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nSpeed up or slow down the rate of time for testing subscription renewals\n\n\t\n\nYes\n\n\t\n\nYes\n\nFor more information about speeding up renewal periods for testing, see Test in-app purchases.\n\nTest common StoreKit scenarios\n\nAll apps that offer in-app purchases need to support restoring purchases, displaying in-app purchases to the customer, and handling basic transactions. The following table lists common test scenarios and whether they’re testable in the sandbox or Xcode:\n\nTest scenario\n\n\t\n\nSandbox\n\n\t\n\nStoreKit Testing in Xcode\n\n\n\n\nRestore purchases\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nFinish a transaction with finish() or finishTransaction(_:)\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nBuy a consumable or non-consumable in-app purchase\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nRepurchase a non-consumable purchase for repeated testing\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nPurchase an auto-renewable subscription\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nPurchase a non-renewing subscription\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nRefund an in-app purchase\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nTest an interrupted purchase, where the user must complete actions outside the app\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nTest a failed purchase attempt when payment authorization fails\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nRetrieve configured in-app purchases from App Store Connect\n\n\t\n\nYes\n\n\t\n\nYes (optionally); can also retrieve data from a StoreKit configuration file\n\n\n\n\nManage subscriptions within your app with showManageSubscriptions(in:) and manageSubscriptionsSheet(isPresented:)\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nInitiate a refund request. For more information, see Testing refund requests.\n\n\t\n\nYes\n\n\t\n\nYes\n\nTest subscriptions and Ask to Buy\n\nDepending on the in-app purchases your app offers, you may need to test scenarios that involve auto-renewing subscriptions, introductory offers, promotional offers, and Ask to Buy. The following table lists test scenarios and whether they’re testable in the sandbox or Xcode:\n\nTest scenario\n\n\t\n\nSandbox\n\n\t\n\nStoreKit Testing in Xcode\n\n\n\n\nInitiate an Ask to Buy transaction that results in a deferred state\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nResolve an Ask to Buy transaction by approving or rejecting it\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nRedeem an introductory offer for an auto-renewable subscription\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nRedeem a promotional offer for an auto-renewable subscription\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nRedeem an offer code for an auto-renewable subscription\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nProcess a subscription renewal\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nProcess a revoked or refunded subscription\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nRespond to a customer canceling a subscription and disabling auto-renew\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nRespond to an expired subscription\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nProcess a subscription upgrade or downgrade\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nProcess a subscription cross-grade with the same or different duration\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nTest a price increase for an auto-renewable subscription\n\n\t\n\nNo\n\n\t\n\nYes\n\n\n\n\nTest billing retry and billing grace period\n\n\t\n\nNo\n\n\t\n\nYes\n\nFor more information, see Approve what kids buy with Ask to Buy and Testing introductory offers.\n\nSee Also\nTesting in-app purchases\nTesting in-app purchases with sandbox\nTest your implementation of in-app purchases using real product information and server-to-server transactions in the sandbox environment.\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds."
  },
  {
    "title": "Testing in-app purchases with sandbox",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/testing_in-app_purchases_with_sandbox",
    "html": "Overview\n\nUse the Apple sandbox environment to test your implementation of in-app purchases that use the StoreKit framework on devices with real product information from App Store Connect. Your development-signed app uses the sandbox environment when you sign in to the App Store using a Sandbox Apple ID. You build and run your app from Xcode.\n\nNote\n\nChanges that you make to product metadata in App Store Connect can take up to one hour to appear in the sandbox environment.\n\nTo create a Sandbox Apple ID in App Store Connect, see Create Sandbox Apple IDs.\n\nTo enable App Store Server Notifications for the sandbox environment, see Enabling App Store Server Notifications. As you test your app, your server receives notifications for in-app purchase transactions. The notification payload identifies the sandbox environment in the environment property of the data object. For a list of possible notifications, see notificationType.\n\nPrepare for sandbox testing\n\nBefore you start testing in-app purchases in the sandbox environment, make sure that:\n\nYour Apple Developer Program account is active. For more information, see What you need to enroll.\n\nYour membership Account Holder has signed the Paid Applications Agreement, as described in Sign and update agreements.\n\nYou set up the product information in App Store Connect for the app you’re testing. At minimum, set up a product reference name, product ID, a localized name, and a price.\n\nYou’re running a development-signed build of your app. Production-signed builds use the production environment.\n\nIf you’re testing on iOS, watchOS, or visionOS devices, grant permission for locally installed apps to run on the device. For more information, see Enabling Developer Mode on a device.\n\nFor more information, see App Store Connect workflow and Overview for configuring in-app purchases.\n\nNote\n\nTesting in-app purchases in the sandbox environment doesn’t require uploading your app binary to App Store Connect. You build and run your app from Xcode.\n\nSign in to the App Store with your Sandbox Apple ID\n\nTo run your app using your Sandbox Apple ID, build and run your app from Xcode.\n\nIn iOS and iPadOS, the sandbox account appears in Settings > App Store after the first time you use the device to attempt a purchase in a development-signed app. There’s no need to sign out of the non-Sandbox Apple ID. Sign in using a Sandbox Apple ID.\n\nIn macOS, the sandbox account appears in App Store Settings after the first time you use the device to make an in-app purchase. Open App Store > Settings and click the Sign In button to sign in using a Sandbox Apple ID. When you’re done testing, sign out of the Sandbox Apple ID from the App Store Settings.\n\nNote\n\nIf your test device has macOS 11.1 or earlier installed, sign out of the Mac App Store, then build your app in Xcode and launch it from Finder.\n\nMake an in-app purchase\n\nThe first time you make a purchase in a development-signed app, sign in to the App Store using your Sandbox Apple ID to begin testing. When you sign in, the text [Environment: Sandbox] appears, indicating that you’ve connected to the test environment. If [Environment: Sandbox] doesn’t appear, you’re using the production environment.\n\nTest in-app purchases for all regions\n\nIn-app products that you create through App Store Connect are available for sale in every App Store region. You may also maintain a list of product identifiers that you make available in specific regions. To test in-app purchases in multiple regions using the same Sandbox Apple ID, open App Store Connect, click the Sandbox Apple ID, and change the App Store Country or Region setting. For more information, see Manage Sanbox Apple ID settings.\n\nTo activate a storefront after you change the region in App Store Connect, sign out of the Sandbox Apple ID account on the device and sign back in. The tester should see the in-app purchases appropriate to the region assigned to their Sandbox Apple ID. Changing the App Store Country or Region setting affects the storefront value in your app. For more information, see Storefront and SKStorefront.\n\nClear the purchase history for a Sandbox Apple ID\n\nTo make it easier to manage repeated testing using the same Sandbox Apple ID, you can clear its purchase history in App Store Connect or from Account Settings in iOS. On your iOS device, follow these steps:\n\nOpen Settings and select App Store.\n\nSelect the Sandbox Apple ID.\n\nOn the popup sheet, select Manage.\n\nOn the Account Settings page, select Clear Purchase History.\n\nFor information about clearing the purchase history from App Store Connect, see Manage Sandbox Apple ID settings.\n\nClearing the purchase history for Sandbox Apple IDs with a high number of purchases may take longer. When the process completes, the transaction history is empty and the Sandbox Apple ID is eligible for introductory offers. The tester logged in with the Sandbox Apple ID can purchase subscriptions they were previously subscribed to without causing duplicate purchases.\n\nNote\n\nClearing the purchase history doesn’t affect in-app purchases that customers make on the App Store.\n\nManage sandbox settings from App Store Connect or iOS Account Settings\n\nSandbox settings enable you to control the testing environment to set up your tests. You can manage the settings in App Store Connect or in iOS Account Settings, whichever you prefer. The settings affect the sandbox the same way, regardless of which method you choose. However, some settings are available only in App Store Connect. The following table compares the settings on both platforms:\n\nSandbox setting or feature\n\n\t\n\nAvailable in App Store Connect\n\n\t\n\nAvailable in iOS\n\n\n\n\nCreate or delete a Sandbox Apple ID\n\n\t\n\nYes\n\n\t\n\nNo\n\n\n\n\nCreate or delete a Sandbox Test Family\n\n\t\n\nYes\n\n\t\n\nNo\n\n\n\n\nRemove a member from a Sandbox Test Family\n\n\t\n\nYes\n\n\t\n\nNo\n\n\n\n\nChange the storefront country or region\n\n\t\n\nYes\n\n\t\n\nNo\n\n\n\n\nChange the subscription renewal rate\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nEnable interrupted purchases\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nClear purchase history for a Sandbox Apple ID\n\n\t\n\nYes\n\n\t\n\nYes\n\n\n\n\nChange sharing status for a Sandbox Test Family member\n\n\t\n\nYes\n\n\t\n\nYes\n\nTo access the Account Settings in iOS, follow these steps on an iOS device:\n\nOpen Settings and select App Store.\n\nSelect the Sandbox Apple ID.\n\nOn the popup sheet, select Manage. The Account Settings page appears.\n\nFor information on all aspects of managing sandbox settings in App Store Connect, see Overview of testing in sandbox.\n\nTopics\nProduct identifiers and requests\nTesting fetching product identifiers\nVerify that your app receives the correct product identifiers by inspecting or replicating your app’s process for retrieving the identifiers.\nTesting invalid product identifier handling\nVerify that your app correctly handles invalid product identifiers.\nTesting a product request\nVerify that requests for products function properly in the sandbox environment by inspecting the App Store response.\nPayment transactions\nTesting purchases made outside your app\nVerify that your app receives and handles transactions that occur outside of your app, such as subscription purchases, renewals, and offer and promo code redemptions.\nTesting an interrupted purchase\nVerify that your app handles an interrupted purchase by inspecting and invoking payment transactions.\nTesting failing subscription renewals and in-app purchases\nVerify that your app handles failed subscription renewals that are in the billing retry or billing grace period states, as well as failed in-app purchases.\nTesting a payment request\nVerify that requests for payment function properly in the sandbox environment by inspecting the calls to the payment transaction observer.\nSubscriptions\nTesting an auto-renewable subscription\nVerify that your app handles a subscription lapse properly using the accelerated time rates within the sandbox environment.\nTesting resubscribing from the subscriptions page\nVerify that your app can reactivate an expired subscription by receiving a transaction callback or inspecting an updated receipt.\nTesting disabling auto-renew\nVerify that your app receives subscription updates when a user cancels a subscription by verifying the receipt or receiving a notification.\nFamily Sharing\nTesting Family Sharing\nVerify that your app handles auto-renewable subscriptions and non-consumable in-app purchases that family members share with Family Sharing.\nRefunds\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds.\nServer notifications\nTesting App Store server notifications\nConfirm that App Store Server Notifications service responds properly in the sandbox environment.\nTransaction observer\nTesting transaction observer code\nVerify that your app activates its payment transaction observer by using breakpoints.\nTesting a successful transaction\nConfirm that your app can make a successful transaction in the sandbox environment by inspecting the transaction.\nTesting complete transactions\nVerify that your app completes transactions properly by confirming that any downloadable purchases are present on your test device.\nSee Also\nTesting in-app purchases\nTesting at all stages of development with Xcode and the sandbox\nVerify your implementation of in-app purchases by testing your code throughout its development.\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds."
  },
  {
    "title": "Storefront",
    "url": "https://developer.apple.com/documentation/storekit/storefront",
    "html": "Overview\n\nIn-app products you create through App Store Connect are available for sale in each region with an App Store. You can use the storefront information to determine the customer’s region, and offer in-app products suitable for that region.\n\nYou need to maintain your own list of product identifiers and the storefronts where you want to make them available.\n\nNote\n\nDon’t save the storefront information with your user information because storefront information can change at any time. Get the storefront identifier immediately before you display product information or availability in your app. Don't use storefront information to develop or enhance a user profile, or to track customers for advertising or marketing purposes.\n\nChange the App Store country or region in the sandbox environment\n\nWhen you change the App Store Country or Region in App Store Connect for a Sandbox Apple ID, it changes the storefront in your app. Change the region to test in-app purchases for different regions in your app. For more information about changing the App Store Country or Region in App Store Connect, see Test in-app purchases.\n\nImportant\n\nTo successfully activate a storefront after you change the region in App Store Connect, sign out of the Sandbox Apple ID account on the device and sign back in.\n\nTopics\nIdentifying the storefront\nstatic var current: Storefront?\nThe current App Store storefront for product purchases.\nlet countryCode: String\nThe three-letter code that represents the country or region associated with the App Store storefront.\nlet id: String\nAn Apple-defined value that uniquely identifies an App Store storefront.\ntypealias Storefront.ID\nThe type that represents a storefront identifier.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Storefront conforms to AnyObject.\nListening for storefront changes\nstatic var updates: Storefront.Storefronts\nThe asynchronous sequence that emits storefront information when the system updates the storefront.\nstruct Storefront.Storefronts\nAn asynchronous sequence that listens for changes to the storefront.\nRelationships\nConforms To\nIdentifiable"
  },
  {
    "title": "Testing refund requests",
    "url": "https://developer.apple.com/documentation/storekit/transaction/testing_refund_requests",
    "html": "Overview\n\nThe sandbox environment and StoreKit Testing in Xcode both support testing refund requests, which enable your customers to request a refund from within your app. Your app displays the refund request sheet by calling any of these methods: beginRefundRequest(for:in:) , beginRefundRequest(in:), beginRefundRequest(for:in:), beginRefundRequest(in:), or refundRequestSheet(for:isPresented:onDismiss:). Customers fill out the sheet to submit the request.\n\nDepending on your testing setup, the App Store automatically approves or declines the refund request in the testing environment. Note that the App Store doesn’t send emails for refund requests in testing environments.\n\nTest approved refunds\n\nTo set up a test for approved refunds, select any refund reason on the refund request sheet, and submit the sheet. The App Store automatically approves the refund request in the testing environment.\n\nYour app receives a Transaction with refund information in the revocationDate and revocationReason properties. If you’re testing in the sandbox environment and your server receives App Store Server Notifications V2 for the sandbox, it gets a notification with a REFUND notificationType.\n\nTest declined refunds\n\nTo set up a test for declined refunds, follow these steps on the refund request sheet with your app running in the sandbox environment:\n\nUnder Issue, select Other.\n\nIn the text box, type REJECT.\n\nTap Request Refund.\n\nThe App Store automatically rejects the refund request in the testing environment.\n\nIf your server receives App Store Server Notifications V2 for the sandbox environment, it gets a notification with a REFUND_DECLINED notificationType.\n\nFor more information on receiving server notifications for the sandbox environment, see Enabling App Store Server Notifications. For more information on testing, see Testing at all stages of development with Xcode and the sandbox and Setting up StoreKit Testing in Xcode.\n\nSee Also\nTesting in-app purchases\nTesting at all stages of development with Xcode and the sandbox\nVerify your implementation of in-app purchases by testing your code throughout its development.\nTesting in-app purchases with sandbox\nTest your implementation of in-app purchases using real product information and server-to-server transactions in the sandbox environment."
  },
  {
    "title": "Original API for in-app purchase",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase",
    "html": "Overview\n\nThe In-App Purchase APIs, including the original API and the Swift-based In-App Purchase API, allow you to offer customers the opportunity to purchase in-app content and features. Customers can make the purchases within your app, and find your promoted products on the App Store.\n\nThe StoreKit framework connects to the App Store on your app’s behalf to prompt for and securely process payments. The framework then notifies your app, which delivers the purchased products. To validate purchases, you can verify receipts on your server with the App Store or on the device. For auto-renewable subscriptions, the App Store can also notify your server of key subscription events.\n\nFor more information about in-app purchases, including configuration, testing, marketing, and more, see In-app purchase.\n\nConfigure in-app purchases in App Store Connect\n\nTo use the in-app purchase API, you need to configure the products in App Store Connect. As you develop your app, you can add or remove products and refine or reconfigure existing products. For more information, see Workflow for configuring in-app purchases.\n\nYou can also offer apps and in-app purchases that run on multiple platforms as a single purchase. For more information about universal purchase, see App Store Connect Help.\n\nUnderstand product types\n\nThere are four in-app purchase types you can offer:\n\nConsumables are a type that are depleted after one use. Customers can purchase them multiple times.\n\nNon-consumables are a type that customers purchase once. They don’t expire. Non-consumable in-app purchases can offer Family Sharing.\n\nAuto-renewable subscriptions to services or content are a type that customers purchase once and that renew automatically on a recurring basis until customers decide to cancel. Auto-renewable subscriptions can offer Family Sharing.\n\nNon-renewing subscriptions to services or content provide access over a limited duration and don’t renew automatically. Customers need to purchase a new subscription once it concludes if they want to retain access.\n\nYou can sync and restore non-consumables and auto-renewable subscriptions across devices using StoreKit. When a user purchases an auto-renewable or non-renewing subscription, your app is responsible for making it available across all the user’s devices, and for enabling users to restore past purchases.\n\nTopics\nEssentials\nSetting up the transaction observer for the payment queue\nEnable your app to receive and handle transactions by adding an observer.\nOffering, completing, and restoring in-app purchases\nFetch, display, purchase, validate, and finish transactions in your app.\nclass SKPaymentQueue\nA queue of payment transactions for the App Store to process.\nprotocol SKPaymentTransactionObserver\nA set of methods that process transactions, unlock purchased functionality, and continue promoted in-app purchases.\nprotocol SKPaymentQueueDelegate\nThe protocol that provides information needed to complete transactions.\nclass SKRequest\nAn abstract class that represents a request to the App Store.\nProduct information\nLoading in-app product identifiers\nLoad the unique identifiers for your in-app products to retrieve product information from the App Store.\nFetching product information from the App Store\nRetrieve up-to-date information about the products for sale in your app to display to your customers.\nclass SKProductsRequest\nAn object that can retrieve localized information from the App Store about a specified list of products.\nclass SKProductsResponse\nAn App Store response to a request for information about a list of products.\nclass SKProduct\nInformation about a registered product in App Store Connect.\nStorefronts\nclass SKStorefront\nAn object containing the location and unique identifier of an Apple App Store storefront.\nPurchases\nRequesting a payment from the App Store\nSubmit a payment request to the App Store when a user selects a product to buy.\nProcessing a transaction\nRegister a transaction queue observer to get and handle transaction updates from the App Store.\nclass SKPayment\nA request to the App Store to process payment for additional functionality that your app offers.\nclass SKMutablePayment\nA mutable request to the App Store to process payment for additional functionality that your app offers.\nclass SKPaymentTransaction\nAn object in the payment queue.\nPurchase validation\nChoosing a receipt validation technique\nSelect the type of receipt validation, on the device or on your server, that works for your app.\nValidating receipts with the App Store\nVerify transactions with the App Store on a secure server.\nvar appStoreReceiptURL: URL?\nThe file URL for the bundle’s App Store receipt.\nclass SKReceiptRefreshRequest\nA request to the App Store to get the app receipt, which represents the user’s transactions with your app.\nContent delivery\nUnlocking purchased content\nDeliver content to the user after validating the purchase.\nPersisting a purchase\nKeep a persistent record of a purchase to continue making the product available as needed.\nFinishing a transaction\nFinish the transaction to complete the purchase process.\nclass SKDownload\nDownloadable content associated with a product.\nDeprecated\nRefunds\nHandling refund notifications\nRespond to notifications about customer refunds for consumable, non-consumable, and non-renewing subscription products.\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds.\nProviding access to previously purchased products\nRestoring purchased products\nGive users functionality that restores their purchases in your app to maintain access to purchased content.\nclass SKReceiptRefreshRequest\nA request to the App Store to get the app receipt, which represents the user’s transactions with your app.\nclass SKRequest\nAn abstract class that represents a request to the App Store.\nclass SKPaymentTransaction\nAn object in the payment queue.\nfunc SKTerminateForInvalidReceipt()\nTerminates an app if the license to use the app has expired.\nFamily Sharing\nSupporting Family Sharing in your app\nProvide service to share subscriptions and non-consumable products to family members.\nvar isFamilyShareable: Bool\nA Boolean value that indicates whether the product is available for Family Sharing in App Store Connect.\nfunc paymentQueue(SKPaymentQueue, didRevokeEntitlementsForProductIdentifiers: [String])\nTells an observer that the user is no longer entitled to one or more Family Sharing purchases.\nSubscriptions\nSubscriptions and offers\nOffer users additional time-based content and services through purchases they make within your app.\nPromotions\nPromoting in-app purchases\nShow promoted in-app purchases on your product page and handle purchases that users initiate on the App Store.\nTesting promoted in-app purchases\nTest your in-app purchases before making your app available in the App Store.\nclass SKProductStorePromotionController\nA product promotion controller for customizing the order and visibility of in-app purchases per device.\nTesting in-app purchases\nTesting at all stages of development with Xcode and the sandbox\nVerify your implementation of in-app purchases by testing your code throughout its development.\nSetting up StoreKit Testing in Xcode\nPrepare your test environment to test in-app purchases with data you configure locally.\nTesting in-app purchases in Xcode\nUse locally configured product data to test and debug your in-app purchases implementation.\nTesting in-app purchases with sandbox\nTest your implementation of in-app purchases using real product information and server-to-server transactions in the sandbox environment.\nErrors\nHandling errors\nDetermine the underlying cause of errors that result from StoreKit requests.\nenum SKError.Code\nError codes for StoreKit errors.\nstruct SKError\nStoreKit error descriptions, codes, and domains.\nlet SKErrorDomain: String\nThe error domain name for StoreKit errors.\nSee Also\nOriginal API for in-app purchase\nChoosing a StoreKit API for in-app purchases\nUse the latest API to support in-app purchases in new or existing apps, or the original API to support in-app purchases in earlier operating systems."
  },
  {
    "title": "PaymentMethodBinding",
    "url": "https://developer.apple.com/documentation/storekit/paymentmethodbinding",
    "html": "Overview\n\nThis functionality is available only to eligible apps with server entitlements. The initializer init(id:) throws an error if your app doesn’t have the appropriate entitlement to use this API, or if the user isn’t eligible.\n\nImportant\n\nThe init(id:) and bind() methods may display a system prompt that asks users to authenticate with their Apple ID. Call these methods only after an explicit user action, like tapping or clicking a button.\n\nInitialize this structure using the in-app binding identifier that your server receives from the Apple server when your server initiates payment method binding. Call the bind() method to prompt users to confirm adding the payment method and making it their primary payment method.\n\nTopics\nDetermining eligiblity\ninit(id: String)\nCreates the payment method binding for eligible apps and users.\nCreating and identifying bindings\nlet id: String\nThe in-app binding identifier.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when PaymentMethodBinding conforms to AnyObject.\ntypealias PaymentMethodBinding.ID\nA type that represents the identifier of a payment account binding.\nBinding payment methods\nfunc bind()\nAsks the user to confirm whether to add the payment method to their Apple payment methods.\nReading errors\nenum PaymentMethodBinding.PaymentMethodBindingError\nError information for payment method binding.\nComparing and hashing bindings\nstatic func != (PaymentMethodBinding, PaymentMethodBinding) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (PaymentMethodBinding, PaymentMethodBinding) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nIdentifiable\nSendable"
  },
  {
    "title": "StoreKitError",
    "url": "https://developer.apple.com/documentation/storekit/storekiterror",
    "html": "Topics\nStoreKit Error Codes\ncase networkError(URLError)\nA network error occurred.\ncase systemError(any Error)\nA system error occurred.\ncase userCancelled\nThe user canceled.\ncase notAvailableInStorefront\nThe function isn’t available on devices configured for this storefront.\ncase notEntitled\nThe app doesn’t have the appropriate entitlements to use the functionality.\ncase unknown\nAn unknown error occurred.\nError Descriptions\nvar localizedDescription: String\nA string containing the localized description of the error.\nvar errorDescription: String?\nA description of the error, suitable for debugging.\nvar failureReason: String?\nA message describing the reason for the failure.\nvar helpAnchor: String?\nA localized message that provides additional information if the user requests help.\nvar recoverySuggestion: String?\nA message containing a suggestion for recovering from the error.\nRelationships\nConforms To\nError\nLocalizedError"
  },
  {
    "title": "Choosing a StoreKit API for in-app purchases",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/choosing_a_storekit_api_for_in-app_purchases",
    "html": "Overview\n\nThe StoreKit framework provides two APIs to implement a store in your app and offer in-app purchases:\n\nIn-App Purchase is a Swift-based API that provides App Store-signed transactions in JSON Web Signature (JWS) format, available starting in iOS 15, macOS 12, tvOS 15, watchOS 8, and visionOS 1.\n\nOriginal API for in-app purchase provides transaction information using App Store receipts, available starting in iOS 3, macOS 10.7, tvOS 9, watchOS 6.2, and visionOS 1.\n\nIf your app has a minimum required operating system that the In-App Purchase API supports, use this API to take advantage of Swift concurrency and simplified in-app purchase workflows. Use this API for visionOS apps that use multiple scenes.\n\nUse the Original API for in-app purchase to maintain and update app versions that have a minimum required operating system of the following versions: macOS 11 or earlier, iOS 14 or earlier, iPadOS 14 or earlier, tvOS 14 or earlier, or watchOS 7 or earlier.\n\nAn app can use both the In-App Purchase API and the Original API for in-app purchase if the app runs in iOS 15, macOS 12, tvOS 15, watchOS 8, and visionOS 1 or later. However, only the In-App Purchase API supports multi-scene apps for visionOS.\n\nBoth APIs provide access to your data in the App Store, such as your configured in-app purchases and transaction information for your customers. In-app purchases that users make using either API are fully available to both APIs.\n\nUse the In-App Purchase API to access new features\n\nThe following features are available only with the Swift-based In-App Purchase APIs:\n\nStoreKit views, which provide the UI to build a store in your app\n\nRefund request sheets, such as beginRefundRequest(for:in:), that enable customers to request refunds\n\nInformation about a subscription's renewal status, such as auto-renew preferences. For more information, see Product.SubscriptionInfo.Status.\n\nInformation about available promotional offers and a subscriber’s eligibility for an introductory offer. For more information, see Product.SubscriptionInfo.\n\nDeferring or suppressing Billing Issue messages that the system displays. For more information, see Message.\n\nPresenting the App Store sheet for managing subscriptions. For more information, see showManageSubscriptions(in:subscriptionGroupID:).\n\nTransaction information in JSON Web Signature (JWS) format. For more information, see Transaction.\n\nUse the Original API to support certain features\n\nYou might need to use the Original API for in-app purchase for the following features, if your app supports them:\n\nPromoting in-app purchases in apps that run in iOS 11 through 16.3. For more informaton, see Promoting in-app purchases. For information about this feature in iOS 16.4, see Supporting promoted in-app purchases in your app.\n\nThe Volume Purchase Program (VPP). For more information, see Device Management.\n\nSee Also\nOriginal API for in-app purchase\nOriginal API for in-app purchase\nOffer users additional content and services using the original In-App Purchase API."
  },
  {
    "title": "canOpen",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchaselink/3925690-canopen",
    "html": "Discussion\n\nCheck this property, as shown below, to determine whether your app can successfully call open().\n\nawait ExternalPurchaseLink.canOpen\n\n\nIf the result is true, configure any user-interface controls that enable people to open the external purchase link. You configure that link in the SKExternalPurchaseLink property list key in the Info.plist file. There’s no need to call canOpen again, unless the App Store storefront changes. For more information about the App Store storefront, see Storefront.\n\nThis property is true if all the following conditions are met:\n\nThe current App Store storefront allows external purchase and the person is eligible to make external purchases.\n\nYour app configures the com.apple.developer.storekit.external-purchase-link entitlement.\n\nYour app configures a link for the current App Store storefront in SKExternalPurchaseLink.\n\nOtherwise, this property is false.\n\nWhen this property is false, check canMakePayments to determine whether your app can offer in-app purchases using the StoreKit In-App Purchase APIs. For more information, see canMakePayments.\n\nSee Also\nOffering an external purchase link\nstatic func open()\nPresents a continuation sheet that enables people to choose whether your app shows its link for external purchases.\nproperty list key SKExternalPurchaseLink\nA dictionary that contains URLs to websites where people using your app can make external purchases, for supported regions."
  },
  {
    "title": "ExternalPurchase.NoticeResult.continuedWithExternalPurchaseToken(token:)",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchase/noticeresult/continuedwithexternalpurchasetoken_token",
    "html": "Parameters\ntoken\n\nThe external purchase token.\n\nDiscussion\n\nWhen your app calls presentNoticeSheet() and it results in this value: ExternalPurchase.NoticeResult.continuedWithExternalPurchaseToken(token:), your app can proceed to present external purchases.\n\nImportant\n\nRecord and use the token to report the customer’s external purchases to Apple. For more information, see External Purchase Server API.\n\nSee Also\nGetting notice sheet results\ncase cancelled\nDescribes when people chose to cancel and not view external purchases."
  },
  {
    "title": "presentNoticeSheet()",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchase/3925688-presentnoticesheet",
    "html": "Return Value\n\nThis returns ExternalPurchase.NoticeResult.\n\nDiscussion\n\nThis method is only available to apps with the com.apple.developer.storekit.external-purchase entitlement. For more information, see ExternalPurchase.\n\nCall this method each time your app is ready to present an external purchase. To use this method, follow these steps:\n\nCall canPresent. If it’s false, don’t call presentNoticeSheet() and don’t show external purchases.\n\nIf canPresent is true, display buttons or other user-interface elements to enable deliberate user interaction. Then, in response to a deliberate user interaction such as tapping a button, call presentNoticeSheet() as shown below:\n\ntry await ExternalPurchase.presentNoticeSheet()\n\n\n3. If the result is ExternalPurchase.NoticeResult.continuedWithExternalPurchaseToken(token:) your app can show external purchases. Otherwise, you must not show external purchases.\n\nImportant\n\nRecord and use the token from the result to report to Apple the customer’s external purchases. For more information on reporting, see External Purchase Server API.\n\nThis method throws a StoreKitError in any of the following conditions:\n\nYour app doesn’t have the com.apple.developer.storekit.external-purchase entitlement.\n\nYour app doesn’t have external purchases configured for the current App Store storefront; see SKExternalPurchase and Storefront.\n\nThe current App Store storefront doesn’t support external purchases.\n\nThe person is ineligible to make external purchases.\n\nA network or system error occurs.\n\nThis method also throws a StoreKitError if its functionality is unavailable for the following reasons:\n\nYour app is built with Mac Catalyst and you compile with an SDK earlier than iOS 17.4 or iPadOS 17.4.\n\nYour app is a compatible iPad or iPhone app running in macOS or visionOS and uses an SDK earlier than iOS 17.4 or iPadOS 17.4.\n\nFor apps compiled with SDKs earlier than iOS 17.4 or iPadOS 17.4, your app can show external purchases if the result is ExternalPurchase.NoticeResult.continued.\n\nSee Also\nOffering an external purchase\nstatic var canPresent: Bool\nA Boolean value that indicates whether the app can successfully present the notice sheet to inform people about external purchases.\nenum ExternalPurchase.NoticeResult\nThe options available to people while viewing the external purchase notice sheet.\nproperty list key SKExternalPurchase\nA string array of country codes that indicates your app supports external purchases."
  },
  {
    "title": "requestUserToken(forDeveloperToken:completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecontroller/2909079-requestusertoken",
    "html": "Parameters\ndeveloperToken\n\nA signed and encrypted JWT token used to authenticate the developer in Apple Music API requests.\n\ncompletionHandler\n\nA completion block that includes the following parameters:\n\nuserToken\n\nA token that identifies the user.\n\nerror\n\nThe error that occurred, if any.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc requestUserToken(forDeveloperToken developerToken: String) async throws -> String\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nUse this method with your developer token to get a token that authenticates the user in personalized Apple Music API requests. Note that personalized requests return user-specific data. Errors 401 and 403 only occur when requesting a music user token. They do not occur for any of the other Apple Music API requests.\n\nSee Also\nDetermining Capabilities\nDetermining a User’s Apple Music Capabilities\nDetermine which Apple Music capabilities are available on a user’s device.\nfunc requestStorefrontCountryCode(completionHandler: (String?, (any Error)?) -> Void)\nGets the country code for the storefront associated with a user's iTunes account.\nfunc requestCapabilities(completionHandler: (SKCloudServiceCapability, (any Error)?) -> Void)\nGets the current capabilities associated with the music library on the device.\nstruct SKCloudServiceCapability\nConstants that specify the current capabilities of the user’s music library on the device.\nfunc requestStorefrontIdentifier(completionHandler: (String?, (any Error)?) -> Void)\nGets the device’s storefront identifier.\nfunc requestPersonalizationToken(forClientToken: String, withCompletionHandler: (String?, (any Error)?) -> Void)\nDeprecated"
  },
  {
    "title": "requestPersonalizationToken(forClientToken:withCompletionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecontroller/2835181-requestpersonalizationtoken",
    "html": "See Also\nDetermining Capabilities\nDetermining a User’s Apple Music Capabilities\nDetermine which Apple Music capabilities are available on a user’s device.\nfunc requestUserToken(forDeveloperToken: String, completionHandler: (String?, (any Error)?) -> Void)\nReturns a user token that you use to access personalized Apple Music content.\nfunc requestStorefrontCountryCode(completionHandler: (String?, (any Error)?) -> Void)\nGets the country code for the storefront associated with a user's iTunes account.\nfunc requestCapabilities(completionHandler: (SKCloudServiceCapability, (any Error)?) -> Void)\nGets the current capabilities associated with the music library on the device.\nstruct SKCloudServiceCapability\nConstants that specify the current capabilities of the user’s music library on the device.\nfunc requestStorefrontIdentifier(completionHandler: (String?, (any Error)?) -> Void)\nGets the device’s storefront identifier."
  },
  {
    "title": "canPresent",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchase/4319981-canpresent",
    "html": "Discussion\n\nCheck this property, as shown below, to determine whether your app can successfully call presentNoticeSheet() to inform people before showing external purchases:\n\nawait externalPurchase.canPresent \n\n\nCheck the value of this property again whenever the App Store storefront changes by using the updates asynchronous sequence of Storefront.\n\nThis property is true if all the following conditions are met:\n\nThe current App Store storefront allows external purchase, and the person is eligible to make external purchases.\n\nYour app configures the com.apple.developer.storekit.external-purchase entitlement.\n\nYour app configures the country code for the current App Store storefront in SKExternalPurchase.\n\nOtherwise, this property is false.\n\nWhen this property is false, check canMakePayments to determine whether your app can offer in-app purchases using the StoreKit In-App Purchase APIs. For more information, see canMakePayments.\n\nSee Also\nOffering an external purchase\nstatic func presentNoticeSheet() -> ExternalPurchase.NoticeResult\nPresents a notice sheet from Apple that informs people before showing external purchases and determines whether your app can present external purchases.\nenum ExternalPurchase.NoticeResult\nThe options available to people while viewing the external purchase notice sheet.\nproperty list key SKExternalPurchase\nA string array of country codes that indicates your app supports external purchases."
  },
  {
    "title": "requestStorefrontIdentifier(completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecontroller/1620618-requeststorefrontidentifier",
    "html": "Parameters\ncompletionHandler\n\nA block that is called when the storefront ID is returned. The block takes the following parameters:\n\nstorefrontIdentifier\n\nThe identifier of a specific storefront.\n\nerror\n\nAn error value that indicates the reason for failure. Possible values are SKError.Code.unknown, SKError.Code.cloudServicePermissionDenied, and SKError.Code.cloudServiceNetworkConnectionFailed.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc requestStorefrontIdentifier() async throws -> String\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nYou need to get the appropriate storefront before you specify a product, because product identifiers are meaningful within the context of a store.\n\nSee Also\nDetermining Capabilities\nDetermining a User’s Apple Music Capabilities\nDetermine which Apple Music capabilities are available on a user’s device.\nfunc requestUserToken(forDeveloperToken: String, completionHandler: (String?, (any Error)?) -> Void)\nReturns a user token that you use to access personalized Apple Music content.\nfunc requestStorefrontCountryCode(completionHandler: (String?, (any Error)?) -> Void)\nGets the country code for the storefront associated with a user's iTunes account.\nfunc requestCapabilities(completionHandler: (SKCloudServiceCapability, (any Error)?) -> Void)\nGets the current capabilities associated with the music library on the device.\nstruct SKCloudServiceCapability\nConstants that specify the current capabilities of the user’s music library on the device.\nfunc requestPersonalizationToken(forClientToken: String, withCompletionHandler: (String?, (any Error)?) -> Void)\nDeprecated"
  },
  {
    "title": "SKCloudServiceCapability",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecapability",
    "html": "Topics\nInitializing\ninit(rawValue: UInt)\nInitializes a cloud service capability with the provided raw value.\nIdentifying Cloud Service Capabilities\nstatic var musicCatalogPlayback: SKCloudServiceCapability\nThe device allows playback of Apple Music catalog tracks.\nstatic var musicCatalogSubscriptionEligible: SKCloudServiceCapability\nThe device allows subscription to the Apple Music catalog.\nstatic var addToCloudMusicLibrary: SKCloudServiceCapability\nThe device allows tracks to be added to the user’s music library.\nRelationships\nConforms To\nOptionSet\nSendable\nSee Also\nDetermining Capabilities\nDetermining a User’s Apple Music Capabilities\nDetermine which Apple Music capabilities are available on a user’s device.\nfunc requestUserToken(forDeveloperToken: String, completionHandler: (String?, (any Error)?) -> Void)\nReturns a user token that you use to access personalized Apple Music content.\nfunc requestStorefrontCountryCode(completionHandler: (String?, (any Error)?) -> Void)\nGets the country code for the storefront associated with a user's iTunes account.\nfunc requestCapabilities(completionHandler: (SKCloudServiceCapability, (any Error)?) -> Void)\nGets the current capabilities associated with the music library on the device.\nfunc requestStorefrontIdentifier(completionHandler: (String?, (any Error)?) -> Void)\nGets the device’s storefront identifier.\nfunc requestPersonalizationToken(forClientToken: String, withCompletionHandler: (String?, (any Error)?) -> Void)\nDeprecated"
  },
  {
    "title": "requestCapabilities(completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecontroller/1620610-requestcapabilities",
    "html": "Parameters\ncompletionHandler\n\nA block that is called when the device’s current capabilities are determined. The block takes the following parameters:\n\ncapabilities\n\nFlags that indicate the device’s capabilities. For possible values, see SKCloudServiceCapability.\n\nerror\n\nAn error value that indicates the reason for failure. Possible values are SKError.Code.unknown, SKError.Code.cloudServicePermissionDenied, and SKError.Code.cloudServiceNetworkConnectionFailed.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc requestCapabilities() async throws -> SKCloudServiceCapability\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nSee Also\nDetermining Capabilities\nDetermining a User’s Apple Music Capabilities\nDetermine which Apple Music capabilities are available on a user’s device.\nfunc requestUserToken(forDeveloperToken: String, completionHandler: (String?, (any Error)?) -> Void)\nReturns a user token that you use to access personalized Apple Music content.\nfunc requestStorefrontCountryCode(completionHandler: (String?, (any Error)?) -> Void)\nGets the country code for the storefront associated with a user's iTunes account.\nstruct SKCloudServiceCapability\nConstants that specify the current capabilities of the user’s music library on the device.\nfunc requestStorefrontIdentifier(completionHandler: (String?, (any Error)?) -> Void)\nGets the device’s storefront identifier.\nfunc requestPersonalizationToken(forClientToken: String, withCompletionHandler: (String?, (any Error)?) -> Void)\nDeprecated"
  },
  {
    "title": "requestStorefrontCountryCode(completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecontroller/2909076-requeststorefrontcountrycode",
    "html": "Parameters\ncompletionHandler\n\nA block that is called when the storefront country code is returned. The block takes the following parameters:\n\nstorefrontCountryCode\n\nThe country code of a specific storefront.\n\nerror\n\nAn error value that indicates the reason for failure. See SKError.Code for possible error values.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nfunc requestStorefrontCountryCode() async throws -> String\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nYou need to get the appropriate storefront country code before you specify a product as each country or region contains different products.\n\nSee Also\nDetermining Capabilities\nDetermining a User’s Apple Music Capabilities\nDetermine which Apple Music capabilities are available on a user’s device.\nfunc requestUserToken(forDeveloperToken: String, completionHandler: (String?, (any Error)?) -> Void)\nReturns a user token that you use to access personalized Apple Music content.\nfunc requestCapabilities(completionHandler: (SKCloudServiceCapability, (any Error)?) -> Void)\nGets the current capabilities associated with the music library on the device.\nstruct SKCloudServiceCapability\nConstants that specify the current capabilities of the user’s music library on the device.\nfunc requestStorefrontIdentifier(completionHandler: (String?, (any Error)?) -> Void)\nGets the device’s storefront identifier.\nfunc requestPersonalizationToken(forClientToken: String, withCompletionHandler: (String?, (any Error)?) -> Void)\nDeprecated"
  },
  {
    "title": "ExternalPurchaseLink",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchaselink",
    "html": "Overview\n\nThis functionality is only available to and required by apps with the com.apple.developer.storekit.external-purchase-link entitlement. For more information, see:\n\nDistributing apps using alternative payment providers in the European Union\n\nDistributing dating apps in the Netherlands\n\nDistributing apps in Russia that provide an external purchase link\n\nDistributing apps in the U.S. that provide an external purchase link\n\nDistributing music streaming apps in the EEA that provide an external purchase link\n\nNote\n\nIf your app is running on iOS 15.4 through 17.3 or iPadOS 15.4 through 17.3 and is configured to use the External Purchase API, you must check canMakePayments before calling the External Purchase APIs. If canMakePayments is false, do not call the ExternalPurchaseLink or ExternalPurchase APIs.\n\nTopics\nOffering an external purchase link\nstatic var canOpen: Bool\nA Boolean value that indicates whether the app can successfully open the configured external purchase link in the current App Store storefront.\nstatic func open()\nPresents a continuation sheet that enables people to choose whether your app shows its link for external purchases.\nproperty list key SKExternalPurchaseLink\nA dictionary that contains URLs to websites where people using your app can make external purchases, for supported regions.\nRelationships\nConforms To\nSendable\nSee Also\nOffering an external purchase link\ncom.apple.developer.storekit.external-purchase-link\nA Boolean value that indicates whether your app can include a link that directs people to a website to make an external purchase.\nproperty list key SKExternalPurchaseLink\nA dictionary that contains URLs to websites where people using your app can make external purchases, for supported regions."
  },
  {
    "title": "ExternalPurchase",
    "url": "https://developer.apple.com/documentation/storekit/externalpurchase",
    "html": "Overview\n\nThis functionality is only available to and required by apps with the com.apple.developer.storekit.external-purchase entitlement. For more information, see:\n\nDistributing apps using alternative payment providers in the European Union\n\nDistributing dating apps in the Netherlands\n\nDistributing apps using a third-party payment provider in South Korea\n\nNote\n\nIf your app is running on iOS 15.4 through 17.3 or the iPadOS 15.4 through 17.3 and configured to use the External Purchase API, you must check canMakePayments before calling the External Purchase APIs. If canMakePayments is false, do not call the ExternalPurchaseLink or ExternalPurchase APIs.\n\nTopics\nOffering an external purchase\nstatic var canPresent: Bool\nA Boolean value that indicates whether the app can successfully present the notice sheet to inform people about external purchases.\nstatic func presentNoticeSheet() -> ExternalPurchase.NoticeResult\nPresents a notice sheet from Apple that informs people before showing external purchases and determines whether your app can present external purchases.\nenum ExternalPurchase.NoticeResult\nThe options available to people while viewing the external purchase notice sheet.\nproperty list key SKExternalPurchase\nA string array of country codes that indicates your app supports external purchases.\nRelationships\nConforms To\nSendable\nSee Also\nOffering external purchases\ncom.apple.developer.storekit.external-purchase\nA Boolean value that indicates whether your app can offer external purchases.\nproperty list key SKExternalPurchase\nA string array of country codes that indicates your app supports external purchases."
  },
  {
    "title": "Receiving and decoding external purchase tokens",
    "url": "https://developer.apple.com/documentation/storekit/external_purchase/receiving_and_decoding_external_purchase_tokens",
    "html": "Overview\n\nAn external purchase token is a unique string that your app or website receives when your app’s customer chooses to view your external purchase offerings. You receive external purchase tokens in two ways: within your app, or appended to your website URL for link out, as follows:\n\nIn your app, the API returns the token when your app calls presentNoticeSheet() and the response is ExternalPurchase.NoticeResult.continuedWithExternalPurchaseToken(token:).\n\nFor link out, when your app calls open(), the API appends the token to the current storefront’s destination URL that you configure in the SKExternalPurchaseLink property list key.\n\nDecode the token to obtain its externalPurchaseId, which you use to report the tokens and associated transactions to Apple using the Send External Purchase Report endpoint of the External Purchase Server API.\n\nDecode external purchase tokens\n\nThe token your app or website’s server receives is a string that is Base64URL-encoded JSON. Decode the token using Base64URL decoding to read the JSON, which contains the following fields:\n\nThe appAppleId and bundleId, which uniquely identify the app to which the token applies\n\nThe tokenCreationDate, which is the UNIX time, in milliseconds, when the system created the token\n\nThe externalPurchaseId, which is a unique value the system created to identify the token\n\nThe externalPurchaseId field is required by the Send External Purchase Report endpoint when you report tokens and transactions. To get the externalPurchaseId, follow these steps:\n\nDecode the token string using Base64URL decoding. For example, if the token string is:\n\newoJImFwcEFwcGxlSWQiOjEyMzQ1Njc4OTAsCgkiYnVuZGxlSWQiOiJjb20uZXhhbXBsZSIsCgkidG9rZW5DcmVhdGlvbkRhdGUiOjE3MDYxNjk2MDAwMDAsCgkiZXh0ZXJuYWxQdXJjaGFzZUlkIjoiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwIgp9\n\nThen, the token’s value after Base64URL decoding is the following JSON:\n\n{  \n  \"appAppleId\":1234567890,  \n  \"bundleId\":\"com.example\",  \n  \"tokenCreationDate\":1706169600000,\n  \"externalPurchaseId\":\"00000000-0000-0000-0000-000000000000\"\n}\n\n\nUse the value of the externalPurchaseId property to identify the token when you call the Send External Purchase Report endpoint.\n\nRecognize tokens from the testing environment\n\nThe External Purchase API returns external purchase tokens that are specific to the app’s environment: production or sandbox. You can recognize a token for the sandbox environment by its externalPurchaseId property, which always begins with \"SANDBOX\".\n\nThe following example is an external purchase token that the system created in the sandbox environment. The sandbox token string is:\n\newoJImFwcEFwcGxlSWQiOjEyMzQ1Njc4OTAsCgkiYnVuZGxlSWQiOiJjb20uZXhhbXBsZSIsCgkidG9rZW5DcmVhdGlvbkRhdGUiOjE3MDYxNjk2MDAwMDAsCgkiZXh0ZXJuYWxQdXJjaGFzZUlkIjoiU0FOREJPWF8wMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAiCn0K\n\nThe token’s JSON content after Base64URL decoding is:\n\n{\n    \"appAppleId\":1234567890,\n    \"bundleId\":\"com.example\",\n    \"tokenCreationDate\":1706169600000,\n    \"externalPurchaseId\":\"SANDBOX_00000000-0000-0000-0000-000000000000\"\n}\n\n\nThe externalPurchaseId includes the \"SANDBOX\" prefix in the testing environment."
  },
  {
    "title": "SKCloudServiceAuthorizationStatus",
    "url": "https://developer.apple.com/documentation/storekit/skcloudserviceauthorizationstatus",
    "html": "Topics\nConstants\ncase notDetermined\nThe authorization type cannot be determined.\ncase denied\nThe user does not authorize any access to their music library.\ncase restricted\nAccess to the music library is restricted in a way that the user cannot change, so your app should not prompt for authorization. An example of this situation is if the device is in an education mode.\ncase authorized\nThe user authorizes playback of Apple Music tracks and the addition of tracks to their music library.\nRelationships\nConforms To\nSendable\nSee Also\nGetting Authorization to Access the Music Library\nRequesting Access to Apple Music Library\nPrompt the user to authorize access to Apple Music library.\nclass func authorizationStatus() -> SKCloudServiceAuthorizationStatus\nReturns the type of authorization the user has set for accessing the music library on the device.\nclass func requestAuthorization((SKCloudServiceAuthorizationStatus) -> Void)\nAsks the user for permission to access the music library on the device."
  },
  {
    "title": "Message.Messages",
    "url": "https://developer.apple.com/documentation/storekit/message/messages",
    "html": "Overview\n\nThe Message.Messages structure provides a sequence of messages that the App Store sends to your app. Iterate over the contents of this structure asynchronously to retrieve each message if your app needs to delay the message.\n\nDon't create this structure directly. Instead, use messages method to retrieve the messages.\n\nTopics\nCreating an iterator\nfunc makeAsyncIterator() -> Message.Messages.AsyncIterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Message.Messages.AsyncIterator\nThe asynchronous iterator that produces elements of the asynchronous sequence.\ntypealias Message.Messages.Element\nThe type of element traversed by the iterator.\nFinding messages\nfunc allSatisfy((Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc contains(Message) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nfunc contains(where: (Message) -> Bool) -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Message) -> Bool) -> Message?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Message, Message) -> Bool) -> Message?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Message, Message) -> Bool) -> Message?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nSelecting messages\nfunc prefix(Int) -> AsyncPrefixSequence<Message.Messages>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Message) -> Bool) -> AsyncPrefixWhileSequence<Message.Messages>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nExcluding messages\nfunc drop(while: (Message) -> Bool) -> AsyncDropWhileSequence<Message.Messages>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Message.Messages>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Message) -> Bool) -> AsyncFilterSequence<Message.Messages>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nTransforming a sequence\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Message) -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Message.Messages, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Message) -> Transformed) -> AsyncThrowingMapSequence<Message.Messages, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Message) -> SegmentOfResult) -> AsyncFlatMapSequence<Message.Messages, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc reduce<Result>(Result, (Result, Message) -> Result) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Message) -> Void) -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.\nRelationships\nConforms To\nAsyncSequence\nSendable\nSee Also\nGetting messages and message reasons\nstatic var messages: Message.Messages\nThe asynchronous sequence that sends a message when the App Store creates it.\nlet reason: Message.Reason\nThe reason that the App Store sends the message.\nstruct Message.Reason\nReasons for the App Store messages."
  },
  {
    "title": "display(in:)",
    "url": "https://developer.apple.com/documentation/storekit/message/3963915-display",
    "html": "Parameters\nscene\n\nThe UIWindowScene that StoreKit uses to display the App Store message.\n\nDiscussion\n\nThe system displays the message if the message is applicable; for example, if the user has previously seen the same App Store message, the system may determine whether to display the message again.\n\nNote\n\nIf your app uses SwiftUI views, use DisplayMessageAction instead of display(in:).\n\nFor more information about using display(in:), see Message."
  },
  {
    "title": "messages",
    "url": "https://developer.apple.com/documentation/storekit/message/3954510-messages",
    "html": "Discussion\n\nIf your app doesn’t implement this message listener, StoreKit retrieves any messages from the App Store each time your app launches, and presents them by default.\n\nFor more information about listening for and displaying messages, see Message.\n\nSee Also\nGetting messages and message reasons\nlet reason: Message.Reason\nThe reason that the App Store sends the message.\nstruct Message.Messages\nAn asynchronous sequence of messages from the App Store.\nstruct Message.Reason\nReasons for the App Store messages."
  },
  {
    "title": "SKOverlay.AppClipConfiguration",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/appclipconfiguration",
    "html": "Topics\nCreating an App Clip Configuration\ninit(position: SKOverlay.Position)\nCreates an object that represents the attributes of an overlay you use to recommend an App Clip’s corresponding app.\nvar position: SKOverlay.Position\nThe position of the overlay on the screen.\nenum SKOverlay.Position\nConstants that identify the position of an overlay on the screen.\nVerifying Advertising Campaigns\nvar campaignToken: String?\nA token you use to represent an ad campaign and measure its effectiveness.\nvar providerToken: String?\nA token that represents the provider of an app promotion campaign, and that you use to measure the campaign’s effectiveness.\nfunc setAdditionalValue(Any?, forKey: String)\nSets an additional value for a key, such as a value for measuring the effectiveness of an ad campaign.\nfunc additionalValue(forKey: String) -> Any?\nReturns the object associated with the key.\nPromoting the Latest App Version\nvar latestReleaseID: String?\nThe release ID of the latest version of your parent app as displayed in App Store Connect.\nAdvertising Another App\nvar customProductPageIdentifier: String?\nAn identifier for a parent app’s custom product page.\nRelationships\nInherits From\nSKOverlay.Configuration\nSee Also\nCreating an overlay\ninit(configuration: SKOverlay.Configuration)\nCreates an overlay you use to recommend another app on the App Store.\nvar configuration: SKOverlay.Configuration\nAn overlay’s attributes; for example, its position on the screen.\nclass SKOverlay.AppConfiguration\nAn object that represents the attributes of an overlay you use to recommend another app on the App Store.\nclass SKOverlay.Configuration\nThe abstract superclass for all classes that represent an overlay’s attributes."
  },
  {
    "title": "dismiss(in:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/3566701-dismiss",
    "html": "Parameters\nscene\n\nThe window scene used to display the overlay."
  },
  {
    "title": "present(in:)",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/3566703-present",
    "html": "Parameters\nscene\n\nThe window scene used to display the overlay."
  },
  {
    "title": "SKOverlayDelegate",
    "url": "https://developer.apple.com/documentation/storekit/skoverlaydelegate",
    "html": "Topics\nResponding to the Overlay’s Appearance and Disappearance\nfunc storeOverlayWillStartPresentation(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform presents an overlay.\nfunc storeOverlayDidFinishPresentation(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform finished presenting an overlay.\nfunc storeOverlayWillStartDismissal(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that the platform dismisses an overlay.\nfunc storeOverlayDidFinishDismissal(SKOverlay, transitionContext: SKOverlay.TransitionContext)\nIndicates that platform finished dismissing an overlay.\nclass SKOverlay.TransitionContext\nA context object you can use to animate UI changes while the platform presents or dismisses an overlay.\nResponding to Failures\nfunc storeOverlayDidFailToLoad(SKOverlay, error: any Error)\nIndicates that an overlay failed to load.\nRelationships\nInherits From\nNSObjectProtocol\nSee Also\nSetting a delegate\nvar delegate: (any SKOverlayDelegate)?\nThe overlay’s delegate."
  },
  {
    "title": "SKCloudServiceSetupViewController",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicesetupviewcontroller",
    "html": "Overview\n\nUse the view presented by this view controller to allow users to set up cloud services that are associated with their iTunes Store account, like an Apple Music subscription.\n\nTo enable the Apple Music subscriber setup flow in particular, you first request the current set of capabilities from SKCloudServiceController. Then, present the setup view controller only when the musicCatalogSubscriptionEligible capability is enabled and the musicCatalogPlayback capability is disabled.\n\nFor information about other capabilities that you can enable by using this view controller, see SKCloudServiceCapability.\n\nTopics\nSetting a Delegate\nvar delegate: (any SKCloudServiceSetupViewControllerDelegate)?\nThe cloud service view controller's delegate.\nprotocol SKCloudServiceSetupViewControllerDelegate\nA protocol that defines the methods a cloud service setup view controller can use to get the status of the view, including when it is dismissed.\nLoading the Setup View\nOffering Apple Music Subscription in Your App\nAllow eligible users to subscribe to Apple Music library.\nfunc load(options: [SKCloudServiceSetupOptionsKey : Any], completionHandler: ((Bool, (any Error)?) -> Void)?)\nLoads the cloud service setup view with the specified options.\nstruct SKCloudServiceSetupOptionsKey\nKeys used to specify the types of setup options for a cloud service.\nRelationships\nInherits From\nUIViewController\nSee Also\nApple Music\nclass SKCloudServiceController\nAn object that determines the current capabilities of the user’s Music library."
  },
  {
    "title": "SKOverlay.Configuration",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay/configuration",
    "html": "Relationships\nInherits From\nNSObject\nSee Also\nCreating an overlay\ninit(configuration: SKOverlay.Configuration)\nCreates an overlay you use to recommend another app on the App Store.\nvar configuration: SKOverlay.Configuration\nAn overlay’s attributes; for example, its position on the screen.\nclass SKOverlay.AppConfiguration\nAn object that represents the attributes of an overlay you use to recommend another app on the App Store.\nclass SKOverlay.AppClipConfiguration\nAn object that represents the attributes of an overlay you use to recommend an App Clip’s corresponding full app."
  },
  {
    "title": "advertisedAppStoreItemIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3727298-advertisedappstoreitemidentifier",
    "html": "Discussion\n\nSet this property to the App Store item identifier of the app that you’re advertising.\n\nSee Also\nCreating a signature\ninit(sourceAppStoreItemIdentifier: NSNumber, advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String, adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp: NSNumber, signature: String, version: String)\nCreates an ad impression object using the supplied values.\nvar version: String\nThe version of the SKAdNetwork API.\nvar adNetworkIdentifier: String\nA string that represents the advertising network’s unique identifier.\nvar sourceIdentifier: NSNumber\nA four-digit integer that ad networks define to represent the ad campaign.\nvar adCampaignIdentifier: NSNumber\nA number that represents the advertising network’s campaign.\nvar adImpressionIdentifier: String\nA random value to use for added security.\nvar sourceAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that displays the ad.\nvar timestamp: NSNumber\nA number that represents the UNIX time, in milliseconds, of the ad impression."
  },
  {
    "title": "timestamp",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3727301-timestamp",
    "html": "Discussion\n\nAd networks generate the timestamp, represented as UNIX time in milliseconds, at the time you begin to serve the ad to users.\n\nSee Also\nCreating a signature\ninit(sourceAppStoreItemIdentifier: NSNumber, advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String, adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp: NSNumber, signature: String, version: String)\nCreates an ad impression object using the supplied values.\nvar version: String\nThe version of the SKAdNetwork API.\nvar adNetworkIdentifier: String\nA string that represents the advertising network’s unique identifier.\nvar sourceIdentifier: NSNumber\nA four-digit integer that ad networks define to represent the ad campaign.\nvar adCampaignIdentifier: NSNumber\nA number that represents the advertising network’s campaign.\nvar advertisedAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that the ad impression advertises.\nvar adImpressionIdentifier: String\nA random value to use for added security.\nvar sourceAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that displays the ad."
  },
  {
    "title": "adType",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3727297-adtype",
    "html": "Discussion\n\nThis property is not used.\n\nSee Also\nDescribing ads\nvar adDescription: String?\nA human-readable description of the ad.\nvar adPurchaserName: String?\nThe name of the entity that purchased the ad."
  },
  {
    "title": "sourceAppStoreItemIdentifier",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3727300-sourceappstoreitemidentifier",
    "html": "Discussion\n\nSet this property to the App Store item identifier of the app that’s displaying the ad.\n\nIf you’re using a development-signed build to display the ads and not an app from App Store during testing, use 0 as the item identifier.\n\nSee Also\nCreating a signature\ninit(sourceAppStoreItemIdentifier: NSNumber, advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String, adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp: NSNumber, signature: String, version: String)\nCreates an ad impression object using the supplied values.\nvar version: String\nThe version of the SKAdNetwork API.\nvar adNetworkIdentifier: String\nA string that represents the advertising network’s unique identifier.\nvar sourceIdentifier: NSNumber\nA four-digit integer that ad networks define to represent the ad campaign.\nvar adCampaignIdentifier: NSNumber\nA number that represents the advertising network’s campaign.\nvar advertisedAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that the ad impression advertises.\nvar adImpressionIdentifier: String\nA random value to use for added security.\nvar timestamp: NSNumber\nA number that represents the UNIX time, in milliseconds, of the ad impression."
  },
  {
    "title": "adDescription",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression/3727293-addescription",
    "html": "Discussion\n\nThis property is not used.\n\nSee Also\nDescribing ads\nvar adType: String?\nThe type of the ad.\nvar adPurchaserName: String?\nThe name of the entity that purchased the ad."
  },
  {
    "title": "AppTransaction",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction",
    "html": "Overview\n\nRelated sessions from WWDC22\n\nSession 10007: What's new with in-app purchase\n\nTopics\nGetting the app transaction\nstatic var shared: VerificationResult<AppTransaction>\nGets the App Store-signed app transaction information for the app.\nGetting the environment\nlet environment: AppStore.Environment\nThe server environment that signs the app transaction.\nstruct AppStore.Environment\nConstants that represent the App Store server environment.\nGetting app and version info\nlet bundleID: String\nThe bundle identifier that the app transaction applies to.\nlet appVersion: String\nThe app version that the app transaction applies to.\nlet originalAppVersion: String\nThe app version that the user originally purchased from the App Store.\nlet appID: UInt64?\nThe unique identifier the App Store uses to identify the app.\nlet appVersionID: UInt64?\nThe number that the App Store uses to uniquely identify the version of the app.\nGetting purchase dates\nlet originalPurchaseDate: Date\nThe date the user originally purchased the app from the App Store.\nlet preorderDate: Date?\nThe date the customer placed an order for the app before it’s available in the App Store.\nVerifying the app transaction\nlet deviceVerification: Data\nThe device verification value to use to verify whether the app transaction belongs to the device.\nlet deviceVerificationNonce: UUID\nThe UUID used to compute the device verification value.\nlet signedDate: Date\nThe date that the App Store signed the JWS app transaction.\nGetting app transaction info in JSON format\nvar jsonRepresentation: Data\nThe raw JSON representation of the app transaction information.\nGetting app transaction from the server\nstatic func refresh() -> VerificationResult<AppTransaction>\nGets the App Store-signed app transaction information from the App Store server.\nComparing and hashing app transactions\nstatic func != (AppTransaction, AppTransaction) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (AppTransaction, AppTransaction) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nGetting debug information\nvar debugDescription: String\nA string represenation of the instance, suitable for debugging.\nRelationships\nConforms To\nCustomDebugStringConvertible\nHashable\nSendable\nSee Also\nApp transaction\nSupporting business model changes by using the app transaction\nAccess the app transaction to learn when a customer first purchased an app, to determine the app features they’re entitled to."
  },
  {
    "title": "SKANError.Code",
    "url": "https://developer.apple.com/documentation/storekit/skanerror/code",
    "html": "Topics\nError Codes\ncase adNetworkIdMissing\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\ncase impressionMissingRequiredValue\nA required value is missing from a view-through ad impression.\ncase impressionNotFound\nThe system can’t find the ad impression.\ncase impressionTooShort\ncase invalidAdvertisedAppId\nThe App Store ID of the advertised app is invalid.\ncase invalidCampaignId\nThe campaign identifier that you provided is invalid.\ncase invalidConversionValue\nThe conversion value is invalid.\ncase invalidSourceAppId\nThe App Store ID of the app displaying the ad is invalid.\ncase invalidVersion\nThe SKAdNetwork version number is invalid.\ncase mismatchedSourceAppId\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\ncase unknown\nAn unknown error occurred.\ncase unsupported\nYour app attempted to use functionality that isn’t supported in the specified version.\nRelationships\nConforms To\nSendable\nSee Also\nGetting Error Codes\nstatic var adNetworkIdMissing: SKANError.Code\nThe ad network identifier in the ad impression doesn’t match the value in the information property list.\nstatic var impressionMissingRequiredValue: SKANError.Code\nA required value is missing from a view-through ad impression.\nstatic var impressionNotFound: SKANError.Code\nThe system can’t find the ad impression.\nstatic var impressionTooShort: SKANError.Code\nstatic var invalidAdvertisedAppId: SKANError.Code\nThe App Store ID of the advertised app is invalid.\nstatic var invalidCampaignId: SKANError.Code\nThe campaign identifier that you provided is invalid.\nstatic var invalidConversionValue: SKANError.Code\nThe conversion value is invalid.\nstatic var invalidSourceAppId: SKANError.Code\nThe App Store ID of the app displaying the ad is invalid.\nstatic var invalidVersion: SKANError.Code\nThe SKAdNetwork version number is invalid.\nstatic var mismatchedSourceAppId: SKANError.Code\nThe source app identifier in the ad impression doesn’t match the app identifier in the source app.\nstatic var unknown: SKANError.Code\nAn unknown error occurred.\nstatic var unsupported: SKANError.Code\nYour app attempted to use functionality that isn’t supported in the specified version."
  },
  {
    "title": "Generating the signature to validate view-through ads",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/generating_the_signature_to_validate_view-through_ads",
    "html": "Overview\n\nInstall validation informs an ad network when users install and launch an app they purchase after viewing an ad. Ad networks provide an ad with cryptographically signed information that includes their ad network ID. If the ad results in a conversion, the customer’s device sends install-validation postbacks. For information about attribution-winning and nonwinning postbacks, see Receiving ad attributions and postbacks.\n\nStarting in iOS 14.5 with SKAdNetwork 2.2, ad networks can present view-through ads to provide custom ads using any media.\n\nNote\n\nThese instructions are for signing view-through ads. If you’re presenting a StoreKit-rendered ad, see Generating the signature to validate StoreKit-rendered ads.\n\nTo provide a view-through ad and initiate a validation, the app calls startImpression(_:completionHandler:), presents the ad, and then calls endImpression(_:completionHandler:). The ad network needs to generate the signature in the SKAdImpression instance that both methods share.\n\nAd networks generate the signature on their server using their ad network ID and the PKCS#8 private key they establish when registering to use the API. For more information, see Registering an ad network.\n\nCreate an ad impression instance\n\nCreate an instance of SKAdImpression to set the properties for the ad impression. These properties contain the same values you use to generate the signature.\n\nThe following table maps the parameters you use in the signature string to their equivalent SKAdImpression properties, as the code example demonstrates in the Combine parameter values section below:\n\nSignature parameter\n\n\t\n\nEquivalent properties\n\n\n\n\nversion\n\n\t\n\nversion. For view-through ads, use version 2.2 and later.\n\n\n\n\nad-network-id\n\n\t\n\nadNetworkIdentifier\n\n\n\n\ncampaign-id\n\n\t\n\nadCampaignIdentifier for version 3 or earlier. For version 4 and later, the sourceIdentifier replaces this parameter.\n\n\n\n\nsource-identifier\n\n\t\n\nsourceIdentifier for version 4 and later. This parameter replaces the adCampaignIdentifier parameter.\n\n\n\n\nitunes-item-id\n\n\t\n\nadvertisedAppStoreItemIdentifier\n\n\n\n\nnonce\n\n\t\n\nadImpressionIdentifier\n\n\n\n\nsource-app-id\n\n\t\n\nsourceAppStoreItemIdentifier\n\n\n\n\nfidelity-type\n\n\t\n\nAn additional parameter in the signature that isn't part of SKAdImpression. Required for version 2.2 and later signatures. For view-through ads, use a fidelity type value of 0.\n\n\n\n\ntimestamp\n\n\t\n\ntimestamp\n\nCombine parameter values\n\nThe order and content of the signature parameters depends on the version of the signature you're creating. Choose one of the parameter combinations below, based on your version.\n\nTo generate a signature for version 4 or later, combine the signature parameter values into a UTF-8 string with an invisible separator (‘\\u2063’) between them, in the exact order the code below shows:\n\nversion + '\\u2063' + ad-network-id + '\\u2063' + source-identifier + '\\u2063' + itunes-item-id + '\\u2063' + nonce + '\\u2063' + source-app-id + '\\u2063' + fidelity-type + '\\u2063' + timestamp\n\n\n\n\nTo generate a signature for versions 2.2 and 3, combine the signature parameter values into a UTF-8 string with an invisible separator (‘\\u2063’) between them, in the exact order the code below shows:\n\nversion + '\\u2063' + ad-network-id + '\\u2063' + campaign-id + '\\u2063' + itunes-item-id + '\\u2063' + nonce + '\\u2063' + source-app-id + '\\u2063' + fidelity-type + '\\u2063' + timestamp\n\n\n\n\nUse the most recent version available in the SDK whenever possible. For information about availability, see SKAdNetwork release notes.\n\nSign the combined string\n\nSign the combined UTF-8 string with the following key and algorithm:\n\nYour PKCS#8 private key.\n\nThe Elliptic Curve Digital Signature Algorithm (ECDSA) with a SHA-256 hash.\n\nThe resulting Digital Encoding Rules (DER)-formatted binary value is the signature.\n\nEncode the signature\n\nEncode the binary signature you generate into a Base64 string. The result is your ad network attribution signature, signature, to use for view-through ads. The signature string should resemble the following:\n\nMEQCIEQlmZRNfYzKBSE8QnhLTIHZZZWCFgZpRqRxHss65KoFAiAJgJKjdrWdkLUOCCjuEx2RmFS7daRzSVZRVZ8RyMyUXg==\n\n\nFor more information about Base64 encoding, see base64EncodedString(options:).\n\nUse the generated signature string\n\nAfter you generate the signature, you have all the required values for your SKAdImpression instance and can use it to call startImpression(_:completionHandler:). Present your view-through ad, and then call endImpression(_:completionHandler:) using the same SKAdImpression instance.\n\nSee Also\nSigning view-through ads\nclass SKAdImpression\nA class that defines an ad impression for a view-through ad.\nclass func startImpression(SKAdImpression, completionHandler: (((any Error)?) -> Void)?)\nIndicates that your app is presenting a view-through ad to the user.\nclass func endImpression(SKAdImpression, completionHandler: (((any Error)?) -> Void)?)\nIndicates that your app is no longer presenting a view-through ad to the user."
  },
  {
    "title": "endImpression(_:completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/3727303-endimpression",
    "html": "Parameters\nimpression\n\nAn instance of SKAdImpression with the properties set for the view-through ad that you presented. This must be the same instance you provide in startImpression(_:completionHandler:).\n\ncompletion\n\nThe callback handler you provide to handle any tasks relevant to concluding the ad impression.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nclass func endImpression(_ impression: SKAdImpression) async throws\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nCall this method when you end the presentation of a view-through ad and it’s no longer visible to the user. To help ensure it’s a valid impression, StoreKit only records the impression if the ad displays for a minimum amount of time. That minimum is 2 seconds on devices running iOS 15.4 and iPadOS 15.4 and later, and 3 seconds on devices running earlier versions of iOS and iPadOS. If the app displays the ad for fewer than the minimum number of seconds, StoreKit doesn’t record the ad impression for attribution.\n\nNote\n\nTo ensure that SKAdNetwork records the impression, call endImpression(_:completionHandler:) after the impression ends, regardless of whether startImpression(_:completionHandler:) returns an error in the completion handler.\n\nStoreKit records a maximum of 15 view-through ad impressions per source app for various products before discarding the oldest-recorded impression.\n\nFor more information about ad impressions and attributions, see Receiving ad attributions and postbacks.\n\nSee Also\nSigning view-through ads\nGenerating the signature to validate view-through ads\nInitiate install validation by displaying a view-through ad with signed parameters.\nclass SKAdImpression\nA class that defines an ad impression for a view-through ad.\nclass func startImpression(SKAdImpression, completionHandler: (((any Error)?) -> Void)?)\nIndicates that your app is presenting a view-through ad to the user."
  },
  {
    "title": "Ad network install-validation keys",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/ad_network_install-validation_keys",
    "html": "Overview\n\nAd networks use these keys when calling the product view controller’s loadProduct(withParameters:completionBlock:) method. These keys describe an ad impression in an advertising campaign. The information they contain associates an app installation with an ad campaign. The SKStoreProductParameterITunesItemIdentifier key identifies the advertised app.\n\nInclude all the required validation keys in the parameter dictionary for the SKAdNetwork version you're using.\n\nYou also use the values of these keys to generate a signature for the ad impression. For more information, see Generating the signature to validate StoreKit-rendered ads.\n\nTopics\nRequired keys for SKAdNetwork 4 and later\nlet SKStoreProductParameterAdNetworkSourceIdentifier: String\nA four-digit integer that ad networks define to represent the ad campaign.\nRequired keys for SKAdNetwork 2 and later\nlet SKStoreProductParameterAdNetworkVersion: String\nThe key that represents the version of the ad network API.\nlet SKStoreProductParameterAdNetworkSourceAppStoreIdentifier: String\nThe key that represents the App Store ID of the app that displays the ad.\nRequired keys\nlet SKStoreProductParameterAdNetworkIdentifier: String\nThe key that represents the advertising network’s unique identifier.\nlet SKStoreProductParameterAdNetworkCampaignIdentifier: String\nThe key that represents the advertising network’s campaign.\nlet SKStoreProductParameterAdNetworkTimestamp: String\nThe key that represents the UNIX time, in milliseconds, of the ad impression.\nlet SKStoreProductParameterAdNetworkNonce: String\nThe key that represents a random value to use for added security.\nlet SKStoreProductParameterAdNetworkAttributionSignature: String\nThe key that represents the advertising network’s cryptographic signature to use for install validation.\nSee Also\nSigning StoreKit-rendered ads\nGenerating the signature to validate StoreKit-rendered ads\nInitiate install validation by displaying a StoreKit-rendered ad with signed parameters."
  },
  {
    "title": "startImpression(_:completionHandler:)",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork/3727304-startimpression",
    "html": "Parameters\nimpression\n\nAn instance of SKAdImpression with the properties set for the view-through ad that you’re presenting.\n\ncompletion\n\nThe callback handler you provide to handle any tasks relevant to the start of the ad impression.\n\nDiscussion\n\nConcurrency Note\n\nYou can call this method from synchronous code using a completion handler, as shown on this page, or you can call it as an asynchronous method that has the following declaration:\n\nclass func startImpression(_ impression: SKAdImpression) async throws\n\n\nFor information about concurrency and asynchronous code in Swift, see Calling Objective-C APIs Asynchronously.\n\nCall this method when you start presenting the view-through ad to the user. If you call startImpression(_:completionHandler:) more than once for the same advertised app before calling endImpression(_:completionHandler:), the latest impression overwrites the earlier impression.\n\nCall endImpression(_:completionHandler:) when the impression ends and is no longer visible to the user.\n\nNote\n\nTo ensure that SKAdNetwork records the impression, call endImpression(_:completionHandler:) after the impression ends, regardless of whether startImpression(_:completionHandler:) returns an error in the completion handler.\n\nSee Also\nSigning view-through ads\nGenerating the signature to validate view-through ads\nInitiate install validation by displaying a view-through ad with signed parameters.\nclass SKAdImpression\nA class that defines an ad impression for a view-through ad.\nclass func endImpression(SKAdImpression, completionHandler: (((any Error)?) -> Void)?)\nIndicates that your app is no longer presenting a view-through ad to the user."
  },
  {
    "title": "Product.SubscriptionInfo",
    "url": "https://developer.apple.com/documentation/storekit/product/subscriptioninfo",
    "html": "Topics\nDetermining the subscription status\nvar status: [Product.SubscriptionInfo.Status]\nAn array that contains status information for a subscription group, including renewal and transaction information.\nstatic func status(for: String) -> [Product.SubscriptionInfo.Status]\nGets the subscription status for a subscription group identifier.\nstruct Product.SubscriptionInfo.Status\nThe renewal status information for an auto-renewable subscription.\nIdentifying the subscription group\nlet subscriptionGroupID: String\nThe subscription group identifier for this subscription.\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var groupDisplayName: String\nThe localized name of the subscription group, suitable for display.\n@backDeployed(before: iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0) var groupLevel: Int\nThe rank of the subscription relative to other subscriptions in the same subscription group.\nGetting the subscription period\nlet subscriptionPeriod: Product.SubscriptionPeriod\nThe duration of time between subscription renewals.\nstruct Product.SubscriptionPeriod\nValues that represent the duration of time between subscription renewals.\nGetting subscription offer details\nvar isEligibleForIntroOffer: Bool\nA Boolean value that indicates whether the customer is eligible for an introductory offer.\nstatic func isEligibleForIntroOffer(for: String) -> Bool\nReturns a Boolean value that determines the customer's eligibility for an introductory offer within the provided subscription group.\nlet introductoryOffer: Product.SubscriptionOffer?\nInformation about the introductory offer available for the auto-renewable subscription.\nlet promotionalOffers: [Product.SubscriptionOffer]\nAn array of promotional offers available for the auto-renewable subscription.\nstruct Product.SubscriptionOffer\nInformation about a subscription offer that you configure in App Store Connect.\nComparing and hashing subscription information\nstatic func != (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product.SubscriptionInfo, Product.SubscriptionInfo) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nSee Also\nGetting subscription information\nlet subscription: Product.SubscriptionInfo?\nThe subscription information for an auto-renewable subscripton.\nstruct Product.SubscriptionPeriod\nValues that represent the duration of time between subscription renewals.\nstruct Product.SubscriptionOffer\nInformation about a subscription offer that you configure in App Store Connect.\nstruct Product.SubscriptionInfo.Status\nThe renewal status information for an auto-renewable subscription."
  },
  {
    "title": "Product",
    "url": "https://developer.apple.com/documentation/storekit/product",
    "html": "Overview\n\nThe Product type represents the in-app purchases that you configure in App Store Connect and make available for purchase within your app. Use Product to perform all product-related tasks in your app, from displaying in-app purchases and offers to making a purchase and getting transaction and subscription status information.\n\nTo get a Product instance, call products(for:) and provide one or more in-app purchase product identifiers. Use a Product instance to display in-app purchases and subscription offers in your store, as follows:\n\nShow the localized name, description, and pricing information using displayName, description, and displayPrice, respectively.\n\nDetermine whether a user is eligible for an introductory offer for the product using isEligibleForIntroOffer.\n\nDisplay your subscription offers using the subscription information in subscription.\n\nWhen users initiate a purchase, call purchase(options:) or purchase(confirmIn:options:) on the product instance. If your app uses SwiftUI, you can also use PurchaseAction. Set purchase options (Product.PurchaseOption) to define an optional app account token, apply a promotional offer, or set a product quantity. Purchase options can also simulate an Ask to Buy scenario when you’re testing your app in the sandbox environment.\n\nUse a Product instance to learn whether a user is entitled to a product by checking currentEntitlement, which holds the transaction that entitles the user to the product. This transaction information, as well as the transaction in latestTransaction, are cryptographically signed by the App Store in JSON Web Signature (JWS) format.\n\nIf the product is an auto-renewable subscription, use the status and renewalInfo in the subscription information to help manage subscriptions and inform business decisions, such as presenting subscription offers.\n\nTopics\nRequesting products from the App Store\nstatic func products<Identifiers>(for: Identifiers) -> [Product]\nRequests product data from the App Store.\nDisplaying a product description and price\nlet displayName: String\nThe localized display name of the product, if it exists.\nlet description: String\nThe localized description of the product.\nlet displayPrice: String\nThe localized string representation of the product price, suitable for display.\nlet price: Decimal\nThe decimal representation of the cost of the product, in local currency.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var priceFormatStyle: Decimal.FormatStyle.Currency\nThe format style for the numbers in the price of the product.\n@backDeployed(before: iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, macCatalyst 16.0) var subscriptionPeriodFormatStyle: Date.ComponentsFormatStyle\nThe format style for the date components related to a subscription’s duration.\nvar subscriptionPeriodUnitFormatStyle: Product.SubscriptionPeriod.Unit.FormatStyle\nThe format style for subscription period units, such as week, month, or year.\nPurchasing a product\nfunc purchase(options: Set<Product.PurchaseOption>) -> Product.PurchaseResult\nInitiates a purchase for the product with the App Store and displays the confirmation sheet.\nfunc purchase(confirmIn: some UIScene, options: Set<Product.PurchaseOption>) -> Product.PurchaseResult\nInitiates a purchase for the product with the App Store and displays the confirmation sheet.\nstruct Product.PurchaseOption\nOptional settings for a product purchase.\nenum Product.PurchaseResult\nThe result of a purchase.\nenum Product.PurchaseError\nError information for product purchase errors.\nReceiving current entitlement information\nvar currentEntitlement: VerificationResult<Transaction>?\nThe transaction that entitles the user to the product.\nGetting the latest transaction\nvar latestTransaction: VerificationResult<Transaction>?\nThe most recent transaction for the product.\nGetting subscription information\nlet subscription: Product.SubscriptionInfo?\nThe subscription information for an auto-renewable subscripton.\nstruct Product.SubscriptionInfo\nInformation about an auto-renewable subscription, such as its status, period, subscription group, and subscription offer details.\nstruct Product.SubscriptionPeriod\nValues that represent the duration of time between subscription renewals.\nstruct Product.SubscriptionOffer\nInformation about a subscription offer that you configure in App Store Connect.\nstruct Product.SubscriptionInfo.Status\nThe renewal status information for an auto-renewable subscription.\nGetting product identifiers and type\nlet id: String\nThe unique product identifier.\ntypealias Product.ID\nA type representing a unique product identifier.\nlet type: Product.ProductType\nThe in-app purchase product type.\nstruct Product.ProductType\nThe types of in-app purchases.\nvar id: ObjectIdentifier\nThe stable identity of the entity associated with this instance.\nAvailable when Product conforms to AnyObject.\nGetting Family Sharing status\nlet isFamilyShareable: Bool\nA Boolean value that indicates whether the product is available for Family Sharing in App Store Connect.\nManaging promoted in-app purchases\nstruct Product.PromotionInfo\nInformation about a promoted in-app purchase that customizes its order and visibility on the device.\nLoading products\nenum Product.CollectionTaskState\nenum Product.TaskState\nGetting product info in JSON format\nvar jsonRepresentation: Data\nThe raw JSON representation of the product information.\nComparing and hashing products\nstatic func != (Product, Product) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Product, Product) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nGetting debug information\nvar debugDescription: String\nA string representation of the product structure, suitable for debugging.\nGetting subscription relationship\nstruct Product.SubscriptionRelationship\nRelationships\nConforms To\nCustomDebugStringConvertible\nHashable\nIdentifiable\nSee Also\nProducts and subscriptions\nImplementing a store in your app using the StoreKit API\nOffer in-app purchases and manage entitlements using signed transactions and status information.\nstruct Product.SubscriptionInfo\nInformation about an auto-renewable subscription, such as its status, period, subscription group, and subscription offer details.\nstruct PurchaseAction\nAn action that starts an in-app purchase."
  },
  {
    "title": "products(for:)",
    "url": "https://developer.apple.com/documentation/storekit/product/3851116-products",
    "html": "Parameters\nidentifiers\n\nA collection of unique in-app purchase product identifiers that you previously configured in App Store Connect. StoreKit ignores any duplicate identifiers in the collection.\n\nReturn Value\n\nAn array of products, returned from the App Store.\n\nDiscussion\n\nUse this method to get an instance of Product. Your app must have its product identifiers available to provide them to this function. The following example illustrates requesting two products using hard-coded identifiers.\n\nlet productIdentifiers = [\"com.example.productA\", \"com.example.productB\"]\nlet appProducts = try await Product.products(for: productIdentifiers)\n\n\nYou initially create product identifiers when you configure in-app purchases in App Store Connect; for more information, see Create an in-app purchase. Your app can store or retrieve product identifiers in several ways, such as embedding the identifiers in the app bundle, or fetching them from your server.\n\nIf any identifiers are invalid or the App Store can’t find them, the App Store excludes them from the return value. The products(for:) function can throw a StoreKitError for system-related errors."
  },
  {
    "title": "updates",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3851206-updates",
    "html": "Discussion\n\nUse updates to receive new transactions while the app is running. This sequence receives transactions that occur outside of the app, such as Ask to Buy transactions, subscription offer code redemptions, and purchases that customers make in the App Store. It also emits transactions that customers complete in your app on another device.\n\nNote that after a successful in-app purchase on the same device, StoreKit returns the transaction through Product.PurchaseResult.success(_:).\n\nImportant\n\nCreate a Task to iterate through the transactions from the listener as soon as your app launches. If your app has unfinished transactions, the updates listener receives them once, immediately after the app launches. Without the Task to listen for these transactions, your app may miss them.\n\nThe following example shows a class that creates a Task when it initializes. The task retrieves and processes any unfinished transactions.\n\nfinal class TransactionObserver {\n    \n    var updates: Task<Void, Never>? = nil\n    \n    init() {\n        updates = newTransactionListenerTask()\n    }\n\n\n    deinit {\n        // Cancel the update handling task when you deinitialize the class.\n        updates?.cancel()\n    }\n    \n    private func newTransactionListenerTask() -> Task<Void, Never> {\n        Task(priority: .background) {\n            for await verificationResult in Transaction.updates {\n                self.handle(updatedTransaction: verificationResult)\n            }\n        }\n    }\n    \n    private func handle(updatedTransaction verificationResult: VerificationResult<Transaction>) {\n        guard case .verified(let transaction) = verificationResult else {\n            // Ignore unverified transactions.\n            return\n        }\n\n\n        if let revocationDate = transaction.revocationDate {\n            // Remove access to the product identified by transaction.productID.\n            // Transaction.revocationReason provides details about\n            // the revoked transaction.\n            <#...#>\n        } else if let expirationDate = transaction.expirationDate,\n            expirationDate < Date() {\n            // Do nothing, this subscription is expired.\n            return\n        } else if transaction.isUpgraded {\n            // Do nothing, there is an active transaction\n            // for a higher level of service.\n            return\n        } else {\n            // Provide access to the product identified by\n            // transaction.productID.\n            <#...#>\n        }\n    }\n    \n}\n\n\nThe updates listener receives unfinished transactions just once at app launch, but you can use the unfinished listener to get your app’s unfinished transactions at any time. For information on finishing transactions, see finish().\n\nSee Also\nMonitoring transaction-related changes\nstruct Transaction.Transactions\nAn asynchronous sequence of transactions.\nRelated Documentation\nSupporting subscription offer codes in your app\nProvide subscription service for customers who redeem offer codes through the App Store or within your app."
  },
  {
    "title": "Implementing a store in your app using the StoreKit API",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/implementing_a_store_in_your_app_using_the_storekit_api",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC22 session 110404: Implement proactive in-app purchase restore.\n\nIt’s also associated with WWDC21 session 10114: Meet StoreKit 2.\n\nConfigure the sample code project\n\nThis sample code project uses StoreKit testing in Xcode so you can build and run the sample app without completing any setup in App Store Connect. The project defines in-app products for the StoreKit testing server in the Products.storekit file. The project includes the Products.plist as a resource file, which contains product identifiers that map to emoji characters.\n\nBy default, StoreKit testing in Xcode is in a disable state. Follow these steps to select the Products.storekit configuration file and enable StoreKit testing in Xcode:\n\nClick the scheme to open the Scheme menu and choose Edit Scheme.\n\nIn the scheme editor, select the Run action.\n\nClick Options in the action settings.\n\nFor the StoreKit Configuration option, select the Products.storekit configuration file.\n\nWhen the app initializes a store, the system reads Products.plist and uses the product identifiers to request products from the StoreKit testing server.\n\nSee Also\nProducts and subscriptions\nstruct Product\nInformation about a product that you configure in App Store Connect.\nstruct Product.SubscriptionInfo\nInformation about an auto-renewable subscription, such as its status, period, subscription group, and subscription offer details.\nstruct PurchaseAction\nAn action that starts an in-app purchase."
  },
  {
    "title": "StoreKit views",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase/storekit_views",
    "html": "Overview\n\nThe StoreKit views APIs provide UI to help you build a store for your in-app purchases, and provide a way for customers to complete the purchase. The views support localization, so your customers see the product names, descriptions, and prices appropriate to their App Store storefront.\n\nStoreKit manages the layouts across all platforms, so the views look great on any device. You can use SwiftUI APIs to customize how the views integrate with your app.\n\nTo use StoreKit views, configure your in-app purchase metadata in App Store Connect, or in a StoreKit configuration file in Xcode if you’re testing your app. Next, create the views using StoreView, ProductView, or SubscriptionStoreView. Finally, customize the default views to match your app by using your own icons, backgrounds, and other styling to match your app. Use Previews in Xcode to see your progress as you iterate on your design.\n\nFor more information on configuring your in-app purchase metadata, see Manage in-app purchases. For more information on StoreKit configuration files in Xcode, see Setting up StoreKit Testing in Xcode.\n\nTopics\nMerchandising in-app purchases and subscriptions\nstruct ProductView\nA view that merchandises an individual in-app purchase product.\nstruct StoreView\nA view that merchandises a collection of in-app purchase products.\nstruct SubscriptionStoreView\nA view that merchandises a collection of auto-renewable subscription options in a subscription group.\nStyling product views\nfunc productViewStyle(some ProductViewStyle) -> View\nSets the style for in-app purchase product views within a view.\nprotocol ProductViewStyle\nA type that specifies the appearance and interaction of in-app purchase products within the view hierarchy.\nstruct ProductViewStyleConfiguration\nThe properties of an in-app purchase product for use by custom product view styles.\nStyling subscription store views\nfunc subscriptionStorePickerItemBackground(some ShapeStyle) -> View\nSets the background style for picker items of the subscription store view instances within a view.\nfunc subscriptionStoreControlStyle(some SubscriptionStoreControlStyle) -> View\nSets the control style for subscription store views within a view.\nprotocol SubscriptionStoreControlStyle\nA type that specifies the appearance and interaction of controls in the subscription store view instances within the view hierarchy.\nfunc subscriptionStoreControlIcon(icon: (Product, Product.SubscriptionInfo) -> some View) -> View\nSets a view to use to decorate individual subscription options within a subscription store view.\nstruct SubscriptionStoreControlBackground\nAdding a subscription store background\nstruct ContainerBackgroundPlacement\nThe placement of a container background.\nstatic var subscriptionStore: ContainerBackgroundPlacement\nA background placement inside a .\nstatic var subscriptionStoreHeader: ContainerBackgroundPlacement\nA background placement inside the marketing content of a\nstatic var subscriptionStoreFullHeight: ContainerBackgroundPlacement\nA background placement that spans the full height of a ."
  },
  {
    "title": "PurchaseAction",
    "url": "https://developer.apple.com/documentation/storekit/purchaseaction",
    "html": "Overview\n\nStoreKit provides several APIs you can use to enable customers to initiate a purchase. Choose the API that suits your app’s implementation, specifically:\n\nUse PurchaseAction for apps that use SwiftUI, including multi-scene apps for visionOS.\n\nUse purchase(confirmIn:options:) for apps that use UIKit.\n\nUse purchase(options:) if your app runs on watchOS or macOS.\n\nImportant\n\nIf you use StoreKit views such as ProductView, StoreView, or SubscriptionStoreView you don’t need to call any other API to initiate a purchase. StoreKit manages the purchase action automatically, including presenting the purchase confirmation UI. For more information, see StoreKit views.\n\nUse the purchase action API\n\nUse PurchaseAction instead of purchase(options:) for SwiftUI implementations, including multi-scene apps for visionOS. Call the instance to start an in-app purchase.\n\nTo use this API, read the PurchaseAction environment value to get an instance of the structure for a given Environment. You call the instance directly because it defines a callAsFunction(_:options:) method that Swift calls when you call the instance.\n\nWhen you initiate an in-app purchase, the system presents UI for the customer to confirm the purchase details. The purchase action you get from the environment automatically includes the UI context. It presents the confirmation UI in proximity to the scene in which the view displays.\n\nThe following code shows an example of starting an in-app purchase when a person taps a button:\n\nstruct PurchaseExample: View {\n    @Environment(\\.purchase) private var purchase: PurchaseAction\n    let product: Product\n    let purchaseOptions: [Product.PurchaseOption]\n\n\n    var body: some View {\n        Button {\n            Task {\n                let purchaseResult = try? await purchase(product, options: purchaseOptions)\n                 // Process the purchase result.\n            }\n        } label: {\n            Text(product.displayName)\n        }\n    }\n}\n\n\nNote that the second line in the code example can omit the type name, as follows, because the compiler can infer the type:\n\n@Environment(\\.purchase) private var purchase\n\n\nTopics\nCalling the action\nfunc callAsFunction(Product, options: Set<Product.PurchaseOption>) -> Product.PurchaseResult\nStarts an in-app purchase for the indicated product and purchase options.\nSee Also\nProducts and subscriptions\nImplementing a store in your app using the StoreKit API\nOffer in-app purchases and manage entitlements using signed transactions and status information.\nstruct Product\nInformation about a product that you configure in App Store Connect.\nstruct Product.SubscriptionInfo\nInformation about an auto-renewable subscription, such as its status, period, subscription group, and subscription offer details."
  },
  {
    "title": "currentEntitlements",
    "url": "https://developer.apple.com/documentation/storekit/transaction/3851204-currententitlements",
    "html": "Discussion\n\nThe current entitlements sequence emits the latest transaction for each product the user has an entitlement to, specifically:\n\nA transaction for each non-consumable in-app purchase\n\nThe latest transaction for each auto-renewable subscription that has a Product.SubscriptionInfo.RenewalState state of subscribed or inGracePeriod\n\nThe latest transaction for each non-renewing subscription, including finished ones\n\nProducts that the App Store has refunded or revoked don’t appear in the current entitlements. Consumable in-app purchases also don't appear in the current entitlements. To get transactions for unfinished consumables, use the unfinished or all sequences in Transaction.\n\nThe following example illustrates iterating through the current entitlements:\n\nfunc refreshPurchasedProducts() async {\n    // Iterate through the user's purchased products.\n    for await verificationResult in Transaction.currentEntitlements {\n        switch verificationResult {\n        case .verified(let transaction):\n            // Check the type of product for the transaction\n            // and provide access to the content as appropriate.\n            ...\n        case .unverified(let unverifiedTransaction, let verificationError):\n            // Handle unverified transactions based on your\n            // business model.\n            ...\n        }\n    }\n}\n\n\nSee Also\nGetting current entitlements\nstatic func currentEntitlement(for: String) -> VerificationResult<Transaction>?\nGets the latest transactions that entitle the user to a specified product."
  },
  {
    "title": "originalAppVersion",
    "url": "https://developer.apple.com/documentation/storekit/apptransaction/3954447-originalappversion",
    "html": "Discussion\n\nUse this value to determine which app version the user first purchased or downloaded. This value is comparable to the appVersion value.\n\nThe originalAppVersion remains constant and doesn't change when the user upgrades the app. The string value contains the original value of the CFBundleShortVersionString for apps running in macOS, and the original value of the CFBundleVersion for apps running on all other platforms.\n\nFor more information about using the originalAppVersion, see Supporting business model changes by using the app transaction.\n\nSee Also\nGetting app and version info\nlet bundleID: String\nThe bundle identifier that the app transaction applies to.\nlet appVersion: String\nThe app version that the app transaction applies to.\nlet appID: UInt64?\nThe unique identifier the App Store uses to identify the app.\nlet appVersionID: UInt64?\nThe number that the App Store uses to uniquely identify the version of the app."
  },
  {
    "title": "canOpen",
    "url": "https://developer.apple.com/documentation/storekit/externallinkaccount/4047546-canopen",
    "html": "Discussion\n\nCheck this property before showing any user-interface controls that enable people to open the external link account.\n\nDon’t check this property again in response to user input; instead, call open() immediately.\n\nImportant\n\nOnly show user-interface controls that call the open() method if this property is true. The open() method always throws an error when canOpen is false.\n\nSee Also\nLinking to external accounts\nstatic func open()\nPresents a continuation sheet that enables people to choose whether to open your app’s link to an external website for account creation or management."
  },
  {
    "title": "ExternalLinkAccount",
    "url": "https://developer.apple.com/documentation/storekit/externallinkaccount",
    "html": "Overview\n\nThis functionality is only available to apps with the com.apple.developer.storekit.external-link.account entitlement. For more information, see Distributing “reader” apps with a link to your website.\n\nTopics\nLinking to external accounts\nstatic var canOpen: Bool\nA Boolean value that indicates whether the app can open the external link account.\nstatic func open()\nPresents a continuation sheet that enables people to choose whether to open your app’s link to an external website for account creation or management.\nRelationships\nConforms To\nSendable\nSee Also\nExternal accounts\ncom.apple.developer.storekit.external-link.account\nA Boolean value that indicates whether your app can link to an external website for account creation or management.\nproperty list key SKExternalLinkAccount\nA dictionary that contains localized URLs to an external website for account creation or management."
  },
  {
    "title": "RequestReviewAction",
    "url": "https://developer.apple.com/documentation/storekit/requestreviewaction",
    "html": "Overview\n\nRead the requestReview environment value to get an instance of this structure for a given Environment. Call the instance to tell StoreKit to ask the user to rate or review your app, if appropriate. You call the instance directly because it defines a callAsFunction() method that Swift calls when you call the instance.\n\nWhen you call this API in your shipping app and the system displays a rating and review request view, the system handles the entire process for you. Although you normally call this method when it makes sense in the user experience flow of your app, App Store policy governs the actual display of a rating and review request view. When your app calls this API, StoreKit uses the following criteria:\n\nIf the person hasn’t rated or reviewed your app on this device, StoreKit displays the ratings and review request a maximum of three times within a 365-day period.\n\nIf the person has rated or reviewed your app on this device, StoreKit displays the ratings and review request if the app version is new, and if more than 365 days have passed since the person’s previous review.\n\nNote\n\nBecause this API may not present an alert, don’t call it in response to a button tap or other user action.\n\nIt’s up to your app to decide on the best timing for requesting reviews. For design guidance, see Human Interface Guidelines > Ratings and reviews.\n\nTest review requests\n\nWhen your app calls this method while it’s in development mode, StoreKit always displays the rating and review request view, so you can test the user interface and experience. However, this method has no effect in apps that you distribute for beta testing using TestFlight.\n\nProvide a persistent link to your product page (optional)\n\nPeople can review your app at any time on the App Store. To make it easier for people to leave reviews, you may include a persistent link to your App Store product page in your app’s settings or configuration screens. Append the query parameter action=write-review to your product page URL to automatically open the App Store page where users can write a review.\n\nTopics\nCall as function\nfunc callAsFunction()\nTells StoreKit to ask the user to rate or review your app, if appropriate.\nEnvironment value\nvar requestReview: RequestReviewAction\nSee Also\nReviews\nRequesting App Store reviews\nImplement best practices for prompting users to review your app in the App Store.\nclass SKStoreReviewController\nAn object that controls the process of requesting App Store ratings and reviews from users."
  },
  {
    "title": "Message",
    "url": "https://developer.apple.com/documentation/storekit/message",
    "html": "Overview\n\nA StoreKit message represents a sheet that appears over your app to display important information from the App Store to the user. Messages have a reason, indicated by the reason value. StoreKit retrieves any messages from the App Store each time your app launches, and presents them by default.\n\nYou can optionally use the Message API to control message presentation by delaying or suppressing messages. Your app can listen for messages with the messages asynchronous sequence, and can display them at a particular time by calling display(in:), or DisplayMessageAction for SwiftUI views. For example, you may choose to delay messages in views where an interrupting sheet might confuse users, such as in the middle of an onboarding flow, or if your app is providing real-time instructions.\n\nStoreKit presents message sheets only if a message is still relevant. For example, if the user resolves the issue outside your app before it calls display(in:), StoreKit doesn’t present the message. StoreKit ensures that it presents each unique message once, even if the app asks to display messages multiple times.\n\nListen for and display messages\n\nIf you want to defer or suppress App Store messages, set up the message listener in your app when your app launches.\n\nTo control when a message may display, call display(in:) or DisplayMessageAction when your app’s ready to have StoreKit present the message. If your app doesn’t call either of these APIs after it listens for messages, it suppresses the messages. The following example is for apps that use UIKit:\n\n// Listen for App Store messages.\nfor await message in StoreKit.Message.messages {\n    // Call display on the message when the app is ready.\n}\n\n\n// Indicate the app is ready to display the message.\nguard let windowScene = self.view.window?.windowScene else {\n    fatalError(\"Could not get window scene.\")\n}\ntry? message.display(in: windowScene)\n\n\nFor a code example that uses SwiftUI, see DisplayMessageAction.\n\nTopics\nGetting messages and message reasons\nstatic var messages: Message.Messages\nThe asynchronous sequence that sends a message when the App Store creates it.\nlet reason: Message.Reason\nThe reason that the App Store sends the message.\nstruct Message.Messages\nAn asynchronous sequence of messages from the App Store.\nstruct Message.Reason\nReasons for the App Store messages.\nDisplaying messages\nfunc display(in: UIWindowScene)\nRequests the system to display the App Store message in the window scene.\nComparing and hashing messages\nstatic func != (Message, Message) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Message, Message) -> Bool\nReturns a Boolean value that indicates whether two values are equal.\nfunc hash(into: inout Hasher)\nHashes the essential components of the value by feeding them into the given hasher.\nvar hashValue: Int\nThe hash value.\nRelationships\nConforms To\nHashable\nSendable\nSee Also\nMessages\nstruct DisplayMessageAction\nAn instance that tells StoreKit to display an App Store message, if appropriate."
  },
  {
    "title": "DisplayMessageAction",
    "url": "https://developer.apple.com/documentation/storekit/displaymessageaction",
    "html": "Overview\n\nA StoreKit message represents a sheet that appears over your app to display important information from the App Store to the user. Messages have a reason, indicated by the reason value. StoreKit retrieves any messages from the App Store each time your app launches, and presents them by default. Your app can delay or suppress App Store messages by listening for the messages and determining the appropriate time for the system to display them.\n\nTo use this API, read the displayStoreKitMessage environment value to get an instance of the structure for a given Environment. Call the instance to ask StoreKit to display the App Store message. StoreKit displays a message only if it’s still pending. It doesn’t display expired messages to the user. You call the instance directly because it defines a callAsFunction(_:) method that Swift calls when you call the instance.\n\nNote\n\nIf your app uses UIWindowScene and not SwiftUI views, use display(in:) instead.\n\nThe following code example listens for App Store messages and decides whether to defer them by saving them to an array, or whether to display them immediately. A private function that the app calls according to its logic asks the system to display all the deferred messages.\n\nimport SwiftUI\nimport StoreKit\n\n\nstruct MessageExampleView: View {\n    @Environment(\\.displayStoreKitMessage) private var displayStoreMessage\n    @State private var deferredMessages = [Message]()\n    \n    var body: some View {\n        Text(\"Hello World\")\n        .task {\n            for await message in StoreKit.Message.messages {\n                if self.shouldDeferMessage(message) {\n                    // Save the message and display it later.\n                    deferredMessages.append(message)\n                }\n                else {\n                    // Ask the system to display the message now.\n                    try? displayStoreMessage(message)\n                }\n            }\n        }\n    }\n    \n    private func shouldDeferMessage(_ message: Message) -> Bool {\n        var shouldDefer = false\n\n\n        // Add your logic here to determine whether your app needs to defer\n        // displaying the message. Return true if so.\n\n\n        return shouldDefer\n    }\n    \n    // Call when the app is ready to display deferred messages.\n    @MainActor private func displayDeferredMessages() {\n        for message in deferredMessages {\n            try? displayStoreMessage(message)\n        }\n        deferredMessages.removeAll()\n    }\n}\n\n\nTopics\nDisplaying the message\nfunc callAsFunction(Message)\nTells StoreKit to display the App Store message, if appropriate.\nSee Also\nMessages\nstruct Message\nAn instance for receiving and displaying App Store messages in your app."
  },
  {
    "title": "SKStoreReviewController",
    "url": "https://developer.apple.com/documentation/storekit/skstorereviewcontroller",
    "html": "Overview\n\nUse the requestReview(in:) method to indicate when it makes sense within the logic of your app to ask the user for ratings and reviews.\n\nTopics\nIndicating an appropriate time for a review\nclass func requestReview(in: UIWindowScene)\nTells StoreKit to ask the user to rate or review the app, if appropriate, using the specified scene.\nclass func requestReview()\nTells StoreKit to ask the user to rate or review your app, if appropriate.\nRelationships\nInherits From\nNSObject\nConforms To\nSendable\nSee Also\nReviews\nRequesting App Store reviews\nImplement best practices for prompting users to review your app in the App Store.\nstruct RequestReviewAction\nAn instance that tells StoreKit to request an App Store rating or review, if appropriate."
  },
  {
    "title": "SKOverlay",
    "url": "https://developer.apple.com/documentation/storekit/skoverlay",
    "html": "Overview\n\nBy displaying an overlay, you can recommend another app to users and enable them to download it immediately. To recommend media that’s not an app, or to display a product page within your app, use SKStoreProductViewController.\n\nImportant\n\nIf you display an overlay in your App Clip, you may only recommend the App Clip’s corresponding full app and need to initialize the overlay with an SKOverlay.AppClipConfiguration object. For more information, see Recommending your app to App Clip users.\n\nIf you’re using SwiftUI, make use of the appStoreOverlay(isPresented:configuration:) modifier. For example usage, see Fruta: Building a Feature-Rich App with SwiftUI.\n\nTo display an App Store overlay in an app that uses UIKit:\n\nCreate an SKOverlay.AppConfiguration with the iTunes identifier of the app you want to recommend.\n\nInitialize SKOverlay with the configuration object.\n\nPresent the overlay.\n\nThe following code displays an overlay at the bottom of the visible scene:\n\nfunc displayOverlay() {\n    guard let scene = view.window?.windowScene else { return }\n\n\n    let config = SKOverlay.AppConfiguration(appIdentifier: \"The iTunes identifier of another app.\", position: .bottom)\n    let overlay = SKOverlay(configuration: config)\n    overlay.present(in: scene)\n}\n\n\nTo respond to the overlay’s appearance, dismissal, or failure to load, set the delegate and implement the methods defined in SKOverlayDelegate.\n\nNote\n\nApp extensions can’t display an overlay.\n\nTopics\nCreating an overlay\ninit(configuration: SKOverlay.Configuration)\nCreates an overlay you use to recommend another app on the App Store.\nvar configuration: SKOverlay.Configuration\nAn overlay’s attributes; for example, its position on the screen.\nclass SKOverlay.AppConfiguration\nAn object that represents the attributes of an overlay you use to recommend another app on the App Store.\nclass SKOverlay.AppClipConfiguration\nAn object that represents the attributes of an overlay you use to recommend an App Clip’s corresponding full app.\nclass SKOverlay.Configuration\nThe abstract superclass for all classes that represent an overlay’s attributes.\nPresenting an overlay\nfunc present(in: UIWindowScene)\nPresents an overlay in a window scene.\nDismissing an overlay\nclass func dismiss(in: UIWindowScene)\nDismisses an App Store overlay.\nSetting a delegate\nvar delegate: (any SKOverlayDelegate)?\nThe overlay’s delegate.\nprotocol SKOverlayDelegate\nMethods for responding to the overlay’s appearance, dismissal, or failure to load.\nRelationships\nInherits From\nNSObject\nSee Also\nRecommendations\nOffering media for sale in your app\nAllow users to purchase media in the App Store from within your app.\nclass SKStoreProductViewController\nA view controller that provides a page where the user can purchase media from the App Store."
  },
  {
    "title": "Offering media for sale in your app",
    "url": "https://developer.apple.com/documentation/storekit/offering_media_for_sale_in_your_app",
    "html": "Overview\n\nThis sample code project shows how to let users purchase media from your app using the SKStoreProductViewController class. Additionally, the sample demonstrates how to measure the effectiveness of a cross-promotional campaign for your apps or third-party apps using the SKStoreProductParameterCampaignToken and SKStoreProductParameterProviderToken keys. When cross-promoting your apps, set SKStoreProductParameterProviderToken to your own provider token. When promoting apps for other developers, set it to their provider token.\n\nThe app in this sample project displays a list of media items that the user can tap to make purchases from the App Store. You can also track advertising and promotions from this interactive list of media items for sale.\n\nThe sample app requires an iOS or iPadOS device.\n\nConfigure the sample code project\n\nThis sample code project defines a Product data type to represent media information it saves in the Products.plist file. Products.plist contains a single Product entry. Before you can run this sample on your device, you need to update this entry with your own data.\n\nSet the sample’s productIdentifier key to your media’s iTunes identifier. For more information about iTunes identifiers, see SKStoreProductParameterITunesItemIdentifier.\n\nSet the title key to your media’s name.\n\nSet the isApplication key to YES if your media is an app, and NO, otherwise.\n\nSet the campaignToken and providerToken keys to the appropriate tokens if you’re cross-promoting apps, and leave them empty if you’re not. For more information about generating campaign and provider tokens, see Manage campaigns, Campaign Token, and Provider Token.\n\nTo add more data, duplicate and update the Product entry in Products.plist as necessary.\n\nDisplay media from the App Store\n\nThis sample launches to the TableViewController, which shows a list of media associated with iTunes identifiers in Products.plist. When the user taps any item in the list, TableViewController presents a page where they can purchase the media from the App Store.\n\nThe sample creates a parameters dictionary and sets the SKStoreProductParameterITunesItemIdentifier key to the media’s iTunes identifier.\n\nvar parametersDictionary = [SKStoreProductParameterITunesItemIdentifier: product.productIdentifier]\n\n\nThe sample creates an SKStoreProductViewController object and sets the view controller class as its delegate. Then it passes the dictionary to the loadProduct(withParameters:completionBlock:) method of the SKStoreProductViewController object.\n\n// Create a store product view controller.\nlet store = SKStoreProductViewController()\nstore.delegate = self\n\n\nThen the sample presents the SKStoreProductViewController object modally.\n\n /*\n    Attempt to load the selected product from the App Store. Display the\n    store product view controller if successful. Print an error message,\n    otherwise.\n*/\n store.loadProduct(withParameters: parametersDictionary, completionBlock: {[unowned self] (result: Bool, error: Error?) in\n     if result {\n         self.present(store, animated: true, completion: {\n             print(\"The store view controller was presented.\")\n         })\n     } else {\n         if let error = error {\n             print(\"Error: \\(error.localizedDescription)\")\n         }\n     }})\n\n\nThe delegate needs to dismiss the store view controller when the purchase completes, or if the user cancels it. TableViewController implements the SKStoreProductViewControllerDelegate method to dismiss the presented store product view controller. Apps can also use this method to resume any activities that they pause before presenting the store.\n\nTrack advertising and promotions\n\nThe SKStoreProductParameterCampaignToken and SKStoreProductParameterProviderToken keys track advertising and promotion for the app. When the user taps an item in the list, TableViewController adds these keys and their values to a dictionary, which already contains SKStoreProductParameterItunesItemIdentifier with the iTunes identifier.\n\nTableViewController passes the dictionary to a created SKStoreProductViewController object, and then displays the store product view controller modally.\n\n/*\n    Update `parametersDictionary` with the `campaignToken` and\n    `providerToken` values if they exist and the specified `product`\n    is an app.\n*/\nif product.isApplication, !product.campaignToken.isEmpty, !product.providerToken.isEmpty {\n    parametersDictionary[SKStoreProductParameterCampaignToken] = product.campaignToken\n    parametersDictionary[SKStoreProductParameterProviderToken] = product.providerToken\n}\n\nSee Also\nRecommendations\nclass SKStoreProductViewController\nA view controller that provides a page where the user can purchase media from the App Store.\nclass SKOverlay\nA class that displays an overlay you can use to recommend another app or an App Clip’s corresponding full app."
  },
  {
    "title": "SKAdImpression",
    "url": "https://developer.apple.com/documentation/storekit/skadimpression",
    "html": "Overview\n\nCreate a SKAdImpression instance when you’re preparing to present a view-through ad. In the instance, you set:\n\nValues known to you, including your ad network ID, the App Store IDs of the source app and the advertised app, and the version.\n\nA value you determine – the campaign ID.\n\nValues you generate, including the timestamp, a nonce (ad-impression identifier), and the cryptographic signature.\n\nFor information about generating the cryptographic signature, see Generating the signature to validate view-through ads.\n\nUse your SKAdImpression instance when you call startImpression(_:completionHandler:) to begin presenting your view-through ad. Use the same instance when you call endImpression(_:completionHandler:) to end the ad presentation.\n\nTopics\nProviding a signature\nvar signature: String\nThe advertising network’s cryptographic signature for the ad impression.\nCreating a signature\ninit(sourceAppStoreItemIdentifier: NSNumber, advertisedAppStoreItemIdentifier: NSNumber, adNetworkIdentifier: String, adCampaignIdentifier: NSNumber, adImpressionIdentifier: String, timestamp: NSNumber, signature: String, version: String)\nCreates an ad impression object using the supplied values.\nvar version: String\nThe version of the SKAdNetwork API.\nvar adNetworkIdentifier: String\nA string that represents the advertising network’s unique identifier.\nvar sourceIdentifier: NSNumber\nA four-digit integer that ad networks define to represent the ad campaign.\nvar adCampaignIdentifier: NSNumber\nA number that represents the advertising network’s campaign.\nvar advertisedAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that the ad impression advertises.\nvar adImpressionIdentifier: String\nA random value to use for added security.\nvar sourceAppStoreItemIdentifier: NSNumber\nThe App Store ID of the app that displays the ad.\nvar timestamp: NSNumber\nA number that represents the UNIX time, in milliseconds, of the ad impression.\nDescribing ads\nvar adType: String?\nThe type of the ad.\nvar adDescription: String?\nA human-readable description of the ad.\nvar adPurchaserName: String?\nThe name of the entity that purchased the ad.\nRelationships\nInherits From\nNSObject\nSee Also\nAd network attribution\nclass SKAdNetwork\nA class that validates advertisement-driven app installations.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation.\nstruct SKANError\nAn error that an ad network attribution operation returns.\nlet SKANErrorDomain: String\nA string that identifies the SKAdNetwork error domain."
  },
  {
    "title": "SKAdNetwork",
    "url": "https://developer.apple.com/documentation/storekit/skadnetwork",
    "html": "Overview\n\nImportant\n\nUse AdAttributionKit for app ad campaigns on the App Store and alternative marketplaces. See the ad attribution developer support page for information on how AdAttributionKit helps advertisers measure the success of ad campaigns while helping maintain user privacy. For information on interoperability between SKAdNetwork and AdAttributionKit, see Understanding AdAttributionKit and SKAdNetwork interoperability.\n\nThe ad network API helps advertisers measure the success of ad campaigns while maintaining user privacy. The API involves three participants:\n\nAd networks that sign ads and receive install-validation postbacks after ads result in conversions\n\nSource apps that display ads from the ad networks, or websites that display the ads in Safari\n\nAdvertised apps that update conversion values as people engage with the app\n\nAd networks register with Apple to get an ad network ID and to use the API. Developers configure their apps to accept attributable ads from ad networks, and to receive copies of winning postbacks. For information about setup, see Registering an ad network, Configuring a source app, and Configuring an advertised app. For information about displaying ads in Safari, see SKAdNetwork for Web Ads.\n\nThe following diagram shows the path of an ad impression that wins ad attribution. The ad network serves an ad that an app or Safari web page displays. A user taps the ad and downloads the advertised app.\n\nApple determines a postback data tier for the app download, and the device uses the tier later to determine the level of detail the postback can contain to ensure crowd anonymity. For more information about the postback contents and the data tiers, see Receiving postbacks in multiple conversion windows.\n\nIf the user launches the app within an attribution time-window, the ad impression is eligible for install-attribution postbacks. As the user engages with the app, the app updates the conversion value. Starting in iOS 16.1, apps can update conversion values during three conversion windows, which results in up to three postbacks for an ad signed using version 4. The system sends the postbacks to the ad network, and to the app’s developer if they opt in to receive postbacks.\n\nDevices send install-validation postbacks to multiple ad networks that sign their ads using version 3 or later.\n\nOne ad network receives a postback with a did-win parameter value of true for the ad impression that wins the ad attribution.\n\nUp to five other ad networks receive a postback with a did-win parameter value of false if their ad impressions qualify for the attribution, but don’t win.\n\nThe following diagram shows the path of ad impressions that qualify for, but don’t win, the ad attribution. Up to five ad networks receive a single nonwinning postback.\n\nFor more information about receiving ad attributions, including time-window details and other constraints, see Receiving ad attributions and postbacks.\n\nThe information in the postback that Apple cryptographically signs doesn’t include user- or device-specific data. It may include values from the ad network and the advertised app if providing those values meets Apple’s privacy threshold. For more information about postback values and postback data tiers, see Receiving postbacks in multiple conversion windows. For more information about the contents of postbacks for each SKAdNetwork version, see Verifying an install-validation postback.\n\nPresenting ads, updating conversion values, and receiving attribution\n\nEach participant has specific responsibilities when using the ad network APIs to present ads and receive attribution.\n\nThe ad network’s responsibilities are to:\n\nRegister and provide its ad network identifier to developers. See Registering an ad network.\n\nServe signed ads to the source app. See Signing and providing ads.\n\nServe signed ads for display in Safari web pages. See the SKAdNetwork for Web Ads API.\n\nReceive install-validation postbacks at the URL it establishes during registration.\n\nVerify the postbacks. See Verifying an install-validation postback.\n\nThe source app’s responsibilities are to:\n\nAdd the ad network identifiers to its Info.plist file. See Configuring a source app.\n\nDisplay ads that the ad network signs. See Signing and providing ads.\n\nThe advertised app’s responsibilities are to:\n\nRegister an app installation by updating the conversion value when the user first launches the app by calling one of the conversion updating methods, such as updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:).\n\nOptionally, continue to update the conversion value as the user engages with the app, by calling one of the conversion updating methods, such as updatePostbackConversionValue(_:coarseValue:lockWindow:completionHandler:).\n\nOptionally, specify a server URL in its Info.plist file to receive a copy of the winning install-validation postback. See Configuring an advertised app.\n\nApple designs SKAdNetwork APIs to maintain user privacy. Apps don’t need to use App Tracking Transparency before calling SKAdNetwork APIs, and can call these APIs regardless of their tracking authorization status. For more information about privacy, see User Privacy and Data Use.\n\nNote\n\nThe SKAdNetwork APIs have no effect, return empty strings, or return values that indicate unavailability when you call the APIs from a compatible iPad or iPhone app running in macOS or visionOS, from a Mac app built with Mac Catalyst, or from an App Clip’s code. For more information about App Clips, see App Clips.\n\nTopics\nEssentials\nSigning and providing ads\nAdvertise apps by signing and providing StoreKit-rendered ads, view-through ads, or attributable web ads.\nReceiving ad attributions and postbacks\nLearn about timeframes and priorities for ad impressions that result in ad attributions, and how additional impressions qualify for postbacks.\nReceiving postbacks in multiple conversion windows\nLearn about the data that postbacks may contain in each conversion window.\nSKAdNetwork release notes\nLearn about the features in each SKAdNetwork version.\nRegistering ad networks and configuring apps\nRegistering an ad network\nUse the install-validation APIs for your ad campaigns after registering your ad network with Apple.\nConfiguring a source app\nSet up a source app to participate in ad campaigns.\nConfiguring an advertised app\nPrepare an advertised app to participate in ad campaigns.\nproperty list key SKAdNetworkItems\nAn array of dictionaries containing a list of ad network IDs.\nproperty list key NSAdvertisingAttributionReportEndpoint\nThe URL where Private Click Measurement and SKAdNetwork send attribution information.\nSigning StoreKit-rendered ads\nGenerating the signature to validate StoreKit-rendered ads\nInitiate install validation by displaying a StoreKit-rendered ad with signed parameters.\nAd network install-validation keys\nSpecify key values that validate and associate an app installation with an ad campaign.\nSigning view-through ads\nGenerating the signature to validate view-through ads\nInitiate install validation by displaying a view-through ad with signed parameters.\nclass SKAdImpression\nA class that defines an ad impression for a view-through ad.\nclass func startImpression(SKAdImpression, completionHandler: (((any Error)?) -> Void)?)\nIndicates that your app is presenting a view-through ad to the user.\nclass func endImpression(SKAdImpression, completionHandler: (((any Error)?) -> Void)?)\nIndicates that your app is no longer presenting a view-through ad to the user.\nProviding conversion information\nclass func updatePostbackConversionValue(Int, coarseValue: SKAdNetwork.CoarseConversionValue, lockWindow: Bool, completionHandler: (((any Error)?) -> Void)?)\nUpdates the fine and coarse conversion values and indicates whether to send the postback before the conversion window ends, and calls a completion handler if the update fails.\nclass func updatePostbackConversionValue(Int, coarseValue: SKAdNetwork.CoarseConversionValue, completionHandler: (((any Error)?) -> Void)?)\nUpdates the fine and coarse conversion values, and calls a completion handler if the update fails.\nstruct SKAdNetwork.CoarseConversionValue\nCoarse values to use for updating conversion values.\nclass func updatePostbackConversionValue(Int, completionHandler: (((any Error)?) -> Void)?)\nVerifies the first launch of an advertised app and, on subsequent calls, updates the conversion value or calls a completion handler if the update fails.\nVerifying postbacks\nVerifying an install-validation postback\nEnsure the validity of a postback you receive after an ad conversion by verifying its cryptographic signature.\nIdentifying the parameters in install-validation postbacks\nLearn about the postback parameters in all SKAdNetwork versions.\nTesting ad attributions and postbacks\nTesting ad attributions with a downloaded profile\nReduce the time-window for ad attributions and inspect postbacks using a proxy during testing.\nTesting and validating ad impression signatures and postbacks for SKAdNetwork\nValidate your ad impressions and test your postbacks by creating unit tests using the StoreKit Test framework.\nDeprecated\nclass func registerAppForAdNetworkAttribution()\nVerifies the first launch of an app installed as a result of an ad.\nDeprecated\nclass func updateConversionValue(Int)\nUpdates the conversion value and verifies the first launch of an app installed as a result of an ad.\nDeprecated\nRelationships\nInherits From\nNSObject\nSee Also\nAd network attribution\nclass SKAdImpression\nA class that defines an ad impression for a view-through ad.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation.\nstruct SKANError\nAn error that an ad network attribution operation returns.\nlet SKANErrorDomain: String\nA string that identifies the SKAdNetwork error domain."
  },
  {
    "title": "In-App Purchase",
    "url": "https://developer.apple.com/documentation/storekit/in-app_purchase",
    "html": "Overview\n\nThe In-App Purchase API takes advantage of Swift features like concurrency to simplify your in-app purchase workflows. Use this API to load product information, display in-app purchases in your store, manage access to content and subscriptions, and receive App Store-signed transaction information. The API leverages Swift concurrency during asynchronous operations to return results inline, rather than using a delegate object.\n\nRelated session from WWDC21\n\nSession 10114: Meet StoreKit 2\n\nThe in-app purchase API offers:\n\nTransaction information that’s App Store-signed in JSON Web Signature (JWS) format.\n\nTransaction and subscription status information that’s simple to parse on the client.\n\nAn entitlements API, currentEntitlements, that simplifies determining entitlements to unlock content and services for your customers.\n\nTo support a store in your app, implement the following functionality:\n\nListen for transaction state changes using the transaction listener, updates, to provide up-to-date service and content while the app is running.\n\nRequest the products to display in your app from the App Store, using a product request, products(for:).\n\nEnable users to purchase your in-app products from the App Store using purchase(options:).\n\nIterate through the user’s in-app purchases using the transaction function currentEntitlements and unlock the purchased content and services.\n\nOptionally, validate the signed transactions and signed subscription status information that you receive from the API.\n\nConfigure in-app purchases in App Store Connect\n\nTo use the In-App Purchase API, you need to first configure the products in App Store Connect. As you develop your app, you can add or remove products and refine or reconfigure existing products. For more information, see Workflow for configuring in-app purchases.\n\nYou can also offer apps and in-app purchases that run on multiple platforms as a single purchase. For more information about universal purchase, see Offering Univeral Purchase.\n\nTopics\nIn-app purchase merchandising\nStoreKit views\nDisplay a customizable in-app purchase store using StoreKit views for SwiftUI.\nProducts and subscriptions\nImplementing a store in your app using the StoreKit API\nOffer in-app purchases and manage entitlements using signed transactions and status information.\nstruct Product\nInformation about a product that you configure in App Store Connect.\nstruct Product.SubscriptionInfo\nInformation about an auto-renewable subscription, such as its status, period, subscription group, and subscription offer details.\nstruct PurchaseAction\nAn action that starts an in-app purchase.\nPromoted in-app purchases\nSupporting promoted in-app purchases in your app\nDisplay promoted in-app purchases on your product page and handle purchases that users initiate on the App Store.\nstruct PurchaseIntent\nAn instance that emits purchase intents, which indicates that the customer initiated a promoted in-app purchase on the App Store for your app to complete.\nstruct Product.PromotionInfo\nInformation about a promoted in-app purchase that customizes its order and visibility on the device.\nTesting promoted in-app purchases\nTest your in-app purchases before making your app available in the App Store.\nTransaction history and entitlements\nstruct Transaction\nInformation that represents the customer’s purchase of a product in your app.\nSubscription status\nstruct Product.SubscriptionInfo.Status\nThe renewal status information for an auto-renewable subscription.\nSubscription offer codes\nSupporting subscription offer codes in your app\nProvide subscription service for customers who redeem offer codes through the App Store or within your app.\nJWS verification\nenum VerificationResult\nA type that describes the result of a StoreKit verification.\nenum VerificationResult.VerificationError\nError cases for StoreKit JWS verification.\nApp Store interactions\nenum AppStore\nInteractions with the App Store, such as managing subscriptions, verifying devices, authorizing payments, synchronizing transactions, getting the environment, and more.\nstruct AppTransaction\nInformation that represents the customer’s purchase of the app, cryptographically signed by the App Store.\nStorefront\nstruct Storefront\nThe region and unique identifier of the App Store storefront for the device.\nTesting in-app purchases\nTesting at all stages of development with Xcode and the sandbox\nVerify your implementation of in-app purchases by testing your code throughout its development.\nTesting in-app purchases with sandbox\nTest your implementation of in-app purchases using real product information and server-to-server transactions in the sandbox environment.\nTesting refund requests\nTest your app’s implementation of refund requests, and your app’s and server’s handling of approved and declined refunds.\nErrors\nenum StoreKitError\nStoreKit in-app purchase error codes.\nOriginal API for in-app purchase\nChoosing a StoreKit API for in-app purchases\nUse the latest API to support in-app purchases in new or existing apps, or the original API to support in-app purchases in earlier operating systems.\nOriginal API for in-app purchase\nOffer users additional content and services using the original In-App Purchase API."
  },
  {
    "title": "Supporting business model changes by using the app transaction",
    "url": "https://developer.apple.com/documentation/storekit/supporting_business_model_changes_by_using_the_app_transaction",
    "html": "Overview\n\nThe originalAppVersion property indicates the app version that the customer purchased. If you change your business model from a paid app to a free app that offers in-app purchases, use this property to learn whether the customer purchased your app before you changed the business model. Then, use that information to determine your customers’ entitlement to features that were available in the paid app.\n\nFor example, an app that is a paid app in version 1 has premium features available to everyone who buys it. For version 2, the developer changes the business model, making it a free app that offers in-app purchases. Version 2 of the app has the same premium features, but now they’re available as in-app purchases.\n\nIn version 2, the developer wants to continue to provide the premium features to customers who purchased version 1. To do so, the app performs the following steps:\n\nThe app’s code includes a constant that indicates the version the business model changed; that constant is \"2\" in this example.\n\nThe app compares the originalAppVersion value with the constant. If the customer purchased the app before the business model changed, the app determines that they’re entitled to the premium features.\n\nThe app also checks the currentEntitlements sequence and delivers any in-app purchases the customers may have made.\n\nAn app that performs these steps ensures that paid customers can access the premium features that were included with the app they purchased.\n\nThe code example below demonstrates how an app gets an AppTransaction, compares the originalAppVersion with a constant that represents an app version, and determines the customer’s entitlements.\n\ndo {\n    // Get the appTransaction.\n    let shared = try await AppTransaction.shared\n    if case .verified(let appTransaction) = shared {\n        // Hard-code the major version number in which the app's business model changed.\n        let newBusinessModelMajorVersion = \"2\" \n\n\n        // Get the major version number of the version the customer originally purchased.\n        let versionComponents = appTransaction.originalAppVersion.split(separator: \".\")\n        let originalMajorVersion = versionComponents[0]\n\n\n        if originalMajorVersion < newBusinessModelMajorVersion {\n            // This customer purchased the app before the business model changed.\n            // Deliver content that they're entitled to based on their app purchase.\n        }\n        else {\n            // This customer purchased the app after the business model changed.\n        }\n    }\n}\ncatch {\n    // Handle errors.\n}\n\n\n// Iterate through any other products the customer purchased.\nfor await result in Transaction.currentEntitlements {\n    if case .verified(let transaction) = result {\n        // Deliver the content based on the customer's current entitlements.\n    }\n}\n\n\nRelated sessions from WWDC22\n\nSession 10007: What's new with in-app purchase\n\nSee Also\nApp transaction\nstruct AppTransaction\nInformation that represents the customer’s purchase of the app, cryptographically signed by the App Store."
  },
  {
    "title": "External Purchase",
    "url": "https://developer.apple.com/documentation/storekit/external_purchase",
    "html": "Overview\n\nIf you develop a qualifying app, you may complete a request for one or two optional entitlements that allow you to offer external purchases. For more information about whether your app qualifies and requesting an entitlement, see:\n\nDistributing apps using alternative payment providers in the European Union\n\nDistributing dating apps in the Netherlands\n\nDistributing apps in Russia that provide an external purchase link\n\nDistributing apps using a third-party payment provider in South Korea\n\nDistributing apps in the U.S. that provide an external purchase link\n\nDistributing music streaming apps in the EEA that provide an external purchase link\n\nOffer external purchases using alternative payment service providers\n\nIf your account receives the StoreKit External Purchase entitlement, implement the following to offer external purchases within your app:\n\nConfigure the entitlement for your app. For more information, see com.apple.developer.storekit.external-purchase.\n\nConfigure the SKExternalPurchase property list key.\n\nUse the ExternalPurchase type’s canPresent property to determine whether external purchase is available.\n\nCall the presentNoticeSheet() method and use the external purchase token you receive from the ExternalPurchase.NoticeResult.continuedWithExternalPurchaseToken(token:) result to record purchases.\n\nFrom your server, report your customer’s purchases associated with the tokens by using the External Purchase Server API.\n\nOffer external purchase link outs\n\nIf your account receives the StoreKit External Purchase Link entitlement, implement the following to offer an external purchase link:\n\nConfigure the entitlement for your app. For more information, see com.apple.developer.storekit.external-purchase-link.\n\nConfigure the SKExternalPurchaseLink property list key.\n\nUse the ExternalPurchaseLink type’s canOpen property to determine whether external purchase link is available.\n\nCall the open() method. StoreKit appends the external purchase token to your website’s URL. Use the token to record purchases.\n\nFrom your server, report your customer’s purchases associated with the tokens by using the External Purchase Server API.\n\nRecord and report external purchase tokens and associated transactions\n\nAn external purchase token is a unique string that your app or website receives when your app’s customer chooses to view your external purchase offerings. Record external purchase tokens in your system and report them and all associated transactions using the External Purchase Server API. For more information about tokens, see Receiving and decoding external purchase tokens.\n\nCheck API availability\n\nThe External Purchase APIs, including ExternalPurchaseLink and ExternalPurchase, provide external purchase tokens that you use to report transactions to Apple. These APIs are available on multiple platforms starting with iOS 17.4, iPadOS 17.4, macOS 14.4, Mac Catalyst 17.4, tvOS 17.4, watchOS 10.4, and Xcode 13.3.\n\nFor apps that run on iOS 15.4 through 17.3 and iPadOS 15.4 through 17.3, the External Purchase APIs have the following behavior:\n\nExternalPurchase and ExternalPurchaseLink APIs throw errors or return false for compatible iPad or iPhone apps running in visionOS, on a Mac with Apple silicon, or on a Mac app built with Mac Catalyst.\n\nThe APIs don’t provide external purchase tokens.\n\nThe APIs are available in iOS and iPadOS only.\n\nTopics\nOffering external purchases\ncom.apple.developer.storekit.external-purchase\nA Boolean value that indicates whether your app can offer external purchases.\nproperty list key SKExternalPurchase\nA string array of country codes that indicates your app supports external purchases.\nenum ExternalPurchase\nEnables qualifying apps to offer external purchases within the app.\nOffering an external purchase link\ncom.apple.developer.storekit.external-purchase-link\nA Boolean value that indicates whether your app can include a link that directs people to a website to make an external purchase.\nproperty list key SKExternalPurchaseLink\nA dictionary that contains URLs to websites where people using your app can make external purchases, for supported regions.\nenum ExternalPurchaseLink\nEnables qualifying apps to offer an external purchase link.\nManaging external purchase tokens\nReceiving and decoding external purchase tokens\nReceive tokens for external purchases that you use to report transactions to Apple."
  },
  {
    "title": "SKCloudServiceController",
    "url": "https://developer.apple.com/documentation/storekit/skcloudservicecontroller",
    "html": "Overview\n\nUse an SKCloudServiceController object to determine the current capabilities of the user’s music library, like whether the device allows playback of Apple Music catalog tracks and the addition of tracks to the library.\n\nTopics\nGetting Authorization to Access the Music Library\nRequesting Access to Apple Music Library\nPrompt the user to authorize access to Apple Music library.\nclass func authorizationStatus() -> SKCloudServiceAuthorizationStatus\nReturns the type of authorization the user has set for accessing the music library on the device.\nclass func requestAuthorization((SKCloudServiceAuthorizationStatus) -> Void)\nAsks the user for permission to access the music library on the device.\nenum SKCloudServiceAuthorizationStatus\nConstants that indicate the type of authorization the user has set for accessing the music library.\nDetermining Capabilities\nDetermining a User’s Apple Music Capabilities\nDetermine which Apple Music capabilities are available on a user’s device.\nfunc requestUserToken(forDeveloperToken: String, completionHandler: (String?, (any Error)?) -> Void)\nReturns a user token that you use to access personalized Apple Music content.\nfunc requestStorefrontCountryCode(completionHandler: (String?, (any Error)?) -> Void)\nGets the country code for the storefront associated with a user's iTunes account.\nfunc requestCapabilities(completionHandler: (SKCloudServiceCapability, (any Error)?) -> Void)\nGets the current capabilities associated with the music library on the device.\nstruct SKCloudServiceCapability\nConstants that specify the current capabilities of the user’s music library on the device.\nfunc requestStorefrontIdentifier(completionHandler: (String?, (any Error)?) -> Void)\nGets the device’s storefront identifier.\nfunc requestPersonalizationToken(forClientToken: String, withCompletionHandler: (String?, (any Error)?) -> Void)\nDeprecated\nNotifications\nstatic let SKStorefrontIdentifierDidChange: NSNotification.Name\nA notification name for indicating a change in the storefront identifier associated with the device.\nstatic let SKCloudServiceCapabilitiesDidChange: NSNotification.Name\nA notification name for indicating a change in the capabilities associated with the music library on the device.\nstatic let SKStorefrontCountryCodeDidChange: NSNotification.Name\nA notification name for indicating a change in the storefront country or region code associated with the device.\nRelationships\nInherits From\nNSObject\nSee Also\nApple Music\nclass SKCloudServiceSetupViewController\nA view controller that helps users perform setup for a cloud service, like an Apple Music subscription."
  },
  {
    "title": "External link account",
    "url": "https://developer.apple.com/documentation/storekit/external_link_account",
    "html": "Overview\n\nIf you develop a qualifying app, you can complete a request for an entitlement that allows you to link to an external website for account creation or management. For more information about whether your app qualifies and how to request an entitlement, see Distributing “reader” apps with a link to your website.\n\nIf your account has the com.apple.developer.storekit.external-link.account entitlement, implement the following to link to an external website for account creation and management:\n\nConfigure the SKExternalLinkAccount property list key.\n\nUse the ExternalLinkAccount type’s canOpen property and open() method.\n\nNote\n\nIn a compatible iPad or iPhone app running in visionOS, on a Mac with Apple silicon, or on a Mac app built with Mac Catalyst, the External Link Account APIs throw an error or return false.\n\nTopics\nExternal accounts\ncom.apple.developer.storekit.external-link.account\nA Boolean value that indicates whether your app can link to an external website for account creation or management.\nproperty list key SKExternalLinkAccount\nA dictionary that contains localized URLs to an external website for account creation or management.\nenum ExternalLinkAccount\nEnables qualifying apps to link to an external website for account creation or management."
  },
  {
    "title": "StoreKit",
    "url": "https://developer.apple.com/documentation/StoreKit",
    "html": "Overview\n\nUse the StoreKit framework to provide the following features and services for your apps and in-app purchases:\n\nIn-App Purchase\n\nOffer and promote in-app purchases for content and services.\n\nApp transaction\n\nVerify the customer’s app purchase with an App Store-signed transaction.\n\nAd network attribution\n\nValidate advertisement-driven app installations.\n\nRecommendations\n\nProvide recommendations for third-party content.\n\nReviews\n\nRequest App Store reviews and ratings from your customers.\n\nMessages\n\nDisplay App Store messages in your app.\n\nThe StoreKit framework also lets you check a customer’s Apple Music capabilities, and provides functionality for External Purchase, External link account, and PaymentMethodBinding.\n\nTopics\nIn-app purchase\nIn-App Purchase\nOffer users additional content and services by using a Swift-based interface.\nApp transaction\nSupporting business model changes by using the app transaction\nAccess the app transaction to learn when a customer first purchased an app, to determine the app features they’re entitled to.\nstruct AppTransaction\nInformation that represents the customer’s purchase of the app, cryptographically signed by the App Store.\nAd network attribution\nclass SKAdNetwork\nA class that validates advertisement-driven app installations.\nclass SKAdImpression\nA class that defines an ad impression for a view-through ad.\nenum SKANError.Code\nConstants that indicate the type of error for an ad network attribution operation.\nstruct SKANError\nAn error that an ad network attribution operation returns.\nlet SKANErrorDomain: String\nA string that identifies the SKAdNetwork error domain.\nRecommendations\nOffering media for sale in your app\nAllow users to purchase media in the App Store from within your app.\nclass SKStoreProductViewController\nA view controller that provides a page where the user can purchase media from the App Store.\nclass SKOverlay\nA class that displays an overlay you can use to recommend another app or an App Clip’s corresponding full app.\nReviews\nRequesting App Store reviews\nImplement best practices for prompting users to review your app in the App Store.\nclass SKStoreReviewController\nAn object that controls the process of requesting App Store ratings and reviews from users.\nstruct RequestReviewAction\nAn instance that tells StoreKit to request an App Store rating or review, if appropriate.\nMessages\nstruct Message\nAn instance for receiving and displaying App Store messages in your app.\nstruct DisplayMessageAction\nAn instance that tells StoreKit to display an App Store message, if appropriate.\nApple Music\nclass SKCloudServiceSetupViewController\nA view controller that helps users perform setup for a cloud service, like an Apple Music subscription.\nclass SKCloudServiceController\nAn object that determines the current capabilities of the user’s Music library.\nExternal purchase\nExternal Purchase\nEnable qualifying apps to offer external purchases.\nExternal link account\nExternal link account\nEnable qualifying apps to link to an external website for account creation or management.\nPayment method binding\nstruct PaymentMethodBinding\nA binding that makes payment methods available in apps for an Apple ID.\nSee Also\nRelated Documentation\nApp Store Server API\nManage your customers’ App Store transactions from your server.\nStoreKit Test\nCreate and automate tests in Xcode for your app’s subscription and in-app purchase transactions, and SKAdNetwork implementations.\nApp Store Server Notifications\nMonitor in-app purchase events in real time and learn of unreported external purchase tokens, with server notifications from the App Store.\nApp Store Receipts\nValidate app and in-app purchase receipts with the App Store.\nApp Store Connect API\nAutomate the tasks you perform on the Apple Developer website and in App Store Connect."
  }
]