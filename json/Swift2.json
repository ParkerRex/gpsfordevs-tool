[
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/map(_:)-1pwvv",
    "html": "Parameters\nkeyPath\n\nThe key path of a property on Output.\n\nReturn Value\n\nA publisher that publishes the value of the key path.\n\nDiscussion\n\nIn the following example, the Publisher/map(_:)-6sm0a operator uses the Swift key path syntax to access the die member of the DiceRoll structure published by the Just publisher.\n\nThe downstream sink subscriber receives only the value of this Int, not the entire DiceRoll.\n\nstruct DiceRoll {\n    let die: Int\n}\n\n\ncancellable = Just(DiceRoll(die:Int.random(in:1...6)))\n    .map(\\.die)\n    .sink {\n        print (\"Rolled: \\($0)\")\n    }\n// Prints \"Rolled: 3\" (or some other random value).\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/map(_:)-8ivo",
    "html": "Parameters\ntransform\n\nA closure that takes one element as its parameter and returns a new element.\n\nReturn Value\n\nA publisher that uses the provided closure to map elements from the upstream publisher to new elements that it then publishes.\n\nDiscussion\n\nCombine’s Publisher/map(_:)-99evh operator performs a function similar to that of doc://com.apple.documentation/documentation/Swift/Sequence/3018373-map in the Swift standard library: it uses a closure to transform each element it receives from the upstream publisher. You use Publisher/map(_:)-99evh to transform from one kind of element to another.\n\nThe following example uses an array of numbers as the source for a collection based publisher. A Publisher/map(_:)-99evh operator consumes each integer from the publisher and uses a dictionary to transform it from its Arabic numeral to a Roman equivalent, as a String. If the Publisher/map(_:)-99evh’s closure fails to look up a Roman numeral, it returns the string (unknown).\n\nlet numbers = [5, 4, 3, 2, 1, 0]\nlet romanNumeralDict: [Int : String] =\n   [1:\"I\", 2:\"II\", 3:\"III\", 4:\"IV\", 5:\"V\"]\ncancellable = numbers.publisher\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"V IV III II I (unknown)\"\n\n\nIf your closure can throw an error, use Combine’s tryMap(_:) operator instead."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyindex/==(_:_:)",
    "html": "Parameters\nlhs\n\nAn index to compare.\n\nrhs\n\nAnother index to compare.\n\nDiscussion\n\nThe types of the two underlying indices must be identical."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyindex/'...(_:)-53asy",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyindex/'...(_:)-69ts0",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyindex/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideable/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideable/distance(to:)-1mibk",
    "html": "Parameters\nother\n\nThe value to calculate the distance to.\n\nReturn Value\n\nThe distance from this value to other.\n\nDiscussion\n\nFor two values x and y, and a distance n = x.distance(to: y), x.advanced(by: n) == y."
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideable/advanced(by:)-9b2es",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nFor a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/+(_:_:)-929xp",
    "html": "Parameters\nlhs\n\nA range-replaceable collection.\n\nrhs\n\nAnother range-replaceable collection.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of two integer arrays.\n\nlet lowerNumbers = [1, 2, 3, 4]\nlet higherNumbers: ContiguousArray = [5, 6, 7, 8, 9, 10]\nlet allNumbers = lowerNumbers + higherNumbers\nprint(allNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of the argument on the left-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/_=(_:_:)-6zxj9",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/'...(_:)-6ct6a",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/regex/match/subscript(_:)-9bzv4",
    "html": "Parameters\nname\n\nThe name of the capture to access.\n\nReturn Value\n\nAn element providing information about the capture, if there is a capture named name; otherwise, nil."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/map(_:)-35oli",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "makeIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/makeiterator()",
    "html": "Discussion\n\nComplexity\n\nO(1)."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/joined(separator:)-9jt9s",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/joined()-1h38v",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/flatmap(_:)-9tejp",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "BidirectionalCollection Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/bidirectionalcollection-implementations",
    "html": "Topics\nInstance Properties\nvar last: Self.Element?\nThe last element of the collection.\nInstance Methods\nfunc difference<C>(from: C) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection.\nAvailable when Element conforms to Equatable.\nfunc difference<C>(from: C, by: (C.Element, Self.Element) -> Bool) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test.\nfunc distance(from: Self.Index, to: Self.Index) -> Int\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(Self.Index, offsetBy: Int) -> Self.Index\nfunc index(Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Self.Index?\nfunc index(before: LazyDropWhileSequence<Base>.Index) -> LazyDropWhileSequence<Base>.Index\nReturns the position immediately before the given index.\nAvailable when Base conforms to BidirectionalCollection.\nfunc joined(separator: String) -> String\nReturns a new string by concatenating the elements of the sequence, adding the given separator between each element.\nAvailable when Element is String.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "LazySequenceProtocol Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/lazysequenceprotocol-implementations",
    "html": "Topics\nInstance Properties\nvar elements: Self\nIdentical to self.\nAvailable when Self is Self.Elements.\nvar lazy: Self.Elements\nInstance Methods\nfunc compactMap<ElementOfResult>((Self.Elements.Element) -> ElementOfResult?) -> LazyMapSequence<LazyFilterSequence<LazyMapSequence<Self.Elements, ElementOfResult?>>, ElementOfResult>\nReturns the non-nil results of mapping the given transformation over this sequence.\nfunc drop(while: (Self.Elements.Element) -> Bool) -> LazyDropWhileSequence<Self.Elements>\nReturns a lazy sequence that skips any initial elements that satisfy predicate.\nfunc filter((Self.Elements.Element) -> Bool) -> LazyFilterSequence<Self.Elements>\nReturns the elements of self that satisfy isIncluded.\nfunc flatMap<SegmentOfResult>((Self.Elements.Element) -> SegmentOfResult) -> LazySequence<FlattenSequence<LazyMapSequence<Self.Elements, SegmentOfResult>>>\nReturns the concatenated results of mapping the given transformation over this sequence.\nfunc flatMap<ElementOfResult>((Self.Elements.Element) -> ElementOfResult?) -> LazyMapSequence<LazyFilterSequence<LazyMapSequence<Self.Elements, ElementOfResult?>>, ElementOfResult>\nReturns the non-nil results of mapping the given transformation over this sequence.\nfunc joined() -> LazySequence<FlattenSequence<Self.Elements>>\nReturns a lazy sequence that concatenates the elements of this sequence of sequences.\nAvailable when Element conforms to Sequence.\nfunc map<U>((Self.Element) -> U) -> LazyMapSequence<Self.Elements, U>\nReturns a LazyMapSequence over this Sequence. The elements of the result are computed lazily, each time they are read, by calling transform function on a base element.\nfunc prefix(while: (Self.Elements.Element) -> Bool) -> LazyPrefixWhileSequence<Self.Elements>\nReturns a lazy sequence of the initial consecutive elements that satisfy predicate.\nType Aliases\ntypealias Elements\nA Sequence that can contain the same elements as this one, possibly with a simpler type.\nAvailable when Base conforms to Sequence."
  },
  {
    "title": "Collection Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/collection-implementations",
    "html": "Topics\nInstance Properties\nvar count: Int\nThe number of elements in the collection.\nvar endIndex: LazyDropWhileSequence<Base>.Index\nThe collection’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nAvailable when Base conforms to Collection.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar startIndex: LazyDropWhileSequence<Base>.Index\nThe position of the first element in a nonempty collection.\nAvailable when Base conforms to Collection.\nInstance Methods\nfunc distance(from: Self.Index, to: Self.Index) -> Int\nReturns the distance between two indices.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(Self.Index, offsetBy: Int) -> Self.Index\nReturns an index that is the specified distance from the given index.\nfunc index(Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Self.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc index(after: LazyDropWhileSequence<Base>.Index) -> LazyDropWhileSequence<Base>.Index\nReturns the position immediately after the given index.\nAvailable when Base conforms to Collection.\nfunc index(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc randomElement() -> Self.Element?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> Self.Element?\nReturns a random element of the collection, using the given generator as a source for randomness.\nfunc split(separator: Self.Element, maxSplits: Int, omittingEmptySubsequences: Bool) -> [Self.SubSequence]\nReturns the longest possible subsequences of the collection, in order, around elements equal to the given element.\nAvailable when Element conforms to Equatable.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection.\nSubscripts\nsubscript(LazyDropWhileSequence<Base>.Index) -> LazyDropWhileSequence<Base>.Element\nAccesses the element at the specified position.\nAvailable when Base conforms to Collection.\nsubscript(Range<Self.Index>) -> Slice<Self>\nAccesses a contiguous subrange of the collection’s elements.\nAvailable when SubSequence is Slice<Self>.\nsubscript((UnboundedRange_) -> ()) -> Self.SubSequence\nsubscript<R>(R) -> Self.SubSequence\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nType Aliases\ntypealias Index\nA type that represents a position in the collection.\nAvailable when Base conforms to Collection.\ntypealias Indices\nA type that represents the indices that are valid for subscripting the collection, in ascending order.\nAvailable when Base conforms to Collection.\ntypealias SubSequence\nA collection representing a contiguous subrange of this collection’s elements. The subsequence shares indices with the original collection.\nAvailable when Base conforms to Collection."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/'...(_:)-94kop",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/'...(_:)-9gkod",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/additivearithmetic/zero-7ss88",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/split(separator:maxsplits:omittingemptysubsequences:)-9indh",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "append(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/append(_:)-5uy8n",
    "html": "Parameters\nnewElement\n\nThe element to append to the collection.\n\nDiscussion\n\nIf the collection does not have sufficient capacity for another element, additional storage is allocated before appending newElement. The following example adds a new number to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(100)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 100]\"\n\n\nComplexity\n\nO(1) on average, over many calls to append(_:) on the same collection."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/+(_:_:)-61ucr",
    "html": "Parameters\nlhs\n\nA collection or finite sequence.\n\nrhs\n\nA range-replaceable collection.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of a Range<Int> instance and an integer array.\n\nlet numbers = [7, 8, 9, 10]\nlet moreNumbers = (1...6) + numbers\nprint(moreNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of argument on the right-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": "init(repeating:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/init(repeating:count:)",
    "html": "Parameters\nrepeatedValue\n\nThe element to repeat.\n\ncount\n\nThe number of times to repeat the value passed in the repeating parameter. count must be zero or greater.\n\nDiscussion\n\nHere’s an example of creating an array initialized with five strings containing the letter Z.\n\nlet fiveZs = Array(repeating: \"Z\", count: 5)\nprint(fiveZs)\n// Prints \"[\"Z\", \"Z\", \"Z\", \"Z\", \"Z\"]\"\n"
  },
  {
    "title": "append(contentsOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/append(contentsof:)-24zxd",
    "html": "Parameters\nnewElements\n\nA sequence of Unicode scalar values.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the resulting view."
  },
  {
    "title": "append(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/append(_:)-j82m",
    "html": "Parameters\nc\n\nThe character to append to the string."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/_(_:_:)-5pqow",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/_(_:_:)-53h6k",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/_=(_:_:)-7csjf",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/_=(_:_:)-3sizb",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/managedbufferpointer/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/regex/match/4049811-subscript",
    "html": "Parameters\nname\n\nThe name of the capture to access.\n\nReturn Value\n\nAn element providing information about the capture, if there is a capture named name; otherwise, nil."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/regex/match/init(_:)",
    "html": "Parameters\nmatch\n\nA regular expression match to convert to a match with type-erased captures.\n\nDiscussion\n\nYou can use this initializer to convert a Regex.Match with strongly-typed captures into a match with the type-eraser AnyRegexOutput as its output type."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/'...(_:)-4mm5q",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/regex/match/4031504-init",
    "html": "Parameters\nmatch\n\nA regular expression match to convert to a match with type-erased captures.\n\nDiscussion\n\nYou can use this initializer to convert a Regex.Match with strongly-typed captures into a match with the type-eraser AnyRegexOutput as its output type."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/init(exactly:)-1dg3p",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 100, while the attempt to initialize the constant y from 1_000 fails because the Int8 type can represent 127 at maximum:\n\nlet x = Int8(exactly: 100)\n// x == Optional(100)\nlet y = Int8(exactly: 1_000)\n// y == nil\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/compactmap(_:)-8mdnk",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "IteratorProtocol Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/iterator/iteratorprotocol-implementations",
    "html": "Topics\nInstance Methods\nfunc next() -> LazyDropWhileSequence<Base>.Iterator.Element?\nAdvances to the next element and returns it, or nil if no next element exists.\nAvailable when Base conforms to Sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/removelast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(k), where k is the specified number of elements."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/__(_:_:)-570t7",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/replacesubrange(_:with:)-5z8uw",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, the complexity is O(m)."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_(_:_:)-4iyb6",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_(_:_:)-fe58",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_(_:_:)-24u4z",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_=(_:_:)-1ii4",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_=(_:_:)-6cfcm",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/_=(_:_:)-4d7sn",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_=(_:_:)-5txp",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_=(_:_:)-7tms1",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_=(_:_:)-9x0o8",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_=(_:_:)-8lyhk",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/_(_:_:)-7yy2z",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "signum() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/signum()-1xj79",
    "html": "Return Value\n\nThe sign of this number, expressed as an integer of the same type."
  },
  {
    "title": "isMultiple(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/ismultiple(of:)-3ings",
    "html": "Parameters\nother\n\nThe value to test.\n\nDiscussion\n\nFor two integers a and b, a is a multiple of b if there exists a third integer q such that a = q*b. For example, 6 is a multiple of 3 because 6 = 2*3. Zero is a multiple of everything because 0 = 0*x for any integer x.\n\nTwo edge cases are worth particular attention:\n\nx.isMultiple(of: 0) is true if x is zero and false otherwise.\n\nT.min.isMultiple(of: -1) is true for signed integer T, even though the quotient T.min / -1 isn’t representable in type T."
  },
  {
    "title": "isMultiple(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/ismultiple(of:)-8eqba",
    "html": "Parameters\nother\n\nThe value to test.\n\nDiscussion\n\nFor two integers a and b, a is a multiple of b if there exists a third integer q such that a = q*b. For example, 6 is a multiple of 3 because 6 = 2*3. Zero is a multiple of everything because 0 = 0*x for any integer x.\n\nTwo edge cases are worth particular attention:\n\nx.isMultiple(of: 0) is true if x is zero and false otherwise.\n\nT.min.isMultiple(of: -1) is true for signed integer T, even though the quotient T.min / -1 isn’t representable in type T."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe array to append to.\n\nrhs\n\nA collection or finite sequence.\n\nDiscussion\n\nUse this operator to append the elements of a sequence to the end of range-replaceable collection with same Element type. This example appends the elements of a Range<Int> instance to an array of integers.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers += 10...15\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]\"\n\n\nComplexity\n\nO(m), where m is the length of the right-hand-side argument."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/+(_:_:)-8g18j",
    "html": "Parameters\nlhs\n\nA range-replaceable collection.\n\nrhs\n\nA collection or finite sequence.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of an integer array and a Range<Int> instance.\n\nlet numbers = [1, 2, 3, 4]\nlet moreNumbers = numbers + (5...10)\nprint(moreNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of the argument on the left-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/_(_:_:)-9ghlg",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "makeIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/makeiterator()",
    "html": "Discussion\n\nComplexity\n\nO(1)."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/==(_:_:)",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the equality of instances of any BinaryInteger types using the equal-to operator (==). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are equal: \\(firstUTF8 == firstScalar)\")\n}\n// Prints \"First code values are equal: true\"\n\nSee Also\nComparison\nstatic func != <Other>(Self, Other) -> Bool\nReturns a Boolean value indicating whether the two given values are not equal.\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "&=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/&=(_:_:)",
    "html": "Required\n\nParameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nvar x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nx &= y                    // 0b00000100\n\nSee Also\nBitwise Operations\nstatic func & (Self, Self) -> Self\nReturns the result of performing a bitwise AND operation on the two given values.\n\nRequired Default implementation provided.\n\nstatic func ~ (Self) -> Self\nReturns the inverse of the bits set in the argument.\n\nRequired Default implementation provided."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "quotientAndRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/quotientandremainder(dividingby:)-3pj1x",
    "html": "Parameters\nrhs\n\nThe value to divide this value by.\n\nReturn Value\n\nA tuple containing the quotient and remainder of this value divided by rhs.\n\nDiscussion\n\nUse this method to calculate the quotient and remainder of a division at the same time.\n\nlet x = 1_000_000\nlet (q, r) = x.quotientAndRemainder(dividingBy: 933)\n// q == 1071\n// r == 757\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "applying(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/applying(_:)",
    "html": "Parameters\ndifference\n\nThe difference to be applied.\n\nReturn Value\n\nAn instance representing the state of the receiver with the difference applied, or nil if the difference is incompatible with the receiver’s state.\n\nDiscussion\n\nComplexity\n\nO(n + c), where n is self.count and c is the number of changes contained by the parameter."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "append(contentsOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/append(contentsof:)-ton6",
    "html": "Parameters\nnewElements\n\nThe elements to append to the collection.\n\nDiscussion\n\nThe collection being appended to allocates any additional necessary storage to hold the new elements.\n\nThe following example appends the elements of a Range<Int> instance to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(contentsOf: 10...15)\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]\"\n\n\nComplexity\n\nO(m), where m is the length of newElements."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned collection.\n\nReturn Value\n\nA collection of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "insert(contentsOf:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/insert(contentsof:at:)",
    "html": "Parameters\nnewElements\n\nThe new elements to insert into the collection.\n\ni\n\nThe position at which to insert the new elements. index must be a valid index of the collection.\n\nDiscussion\n\nThe new elements are inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new elements are appended to the collection.\n\nHere’s an example of inserting a range of integers into an array of the same type:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(contentsOf: 100...103, at: 3)\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 101, 102, 103, 4, 5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If i == endIndex, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "insert(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/insert(_:at:)",
    "html": "Parameters\nnewElement\n\nThe new element to insert into the collection.\n\ni\n\nThe position at which to insert the new element. index must be a valid index into the collection.\n\nDiscussion\n\nThe new element is inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new element is appended to the collection.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(100, at: 3)\nnumbers.insert(200, at: numbers.endIndex)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 4, 5, 200]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection. If i == endIndex, this method is equivalent to append(_:)."
  },
  {
    "title": "remove(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/remove(at:)",
    "html": "Parameters\nposition\n\nThe position of the element to remove. position must be a valid index of the collection that is not equal to the collection’s end index.\n\nReturn Value\n\nThe removed element.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes the middle element from an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.6]\nlet removed = measurements.remove(at: 2)\nprint(measurements)\n// Prints \"[1.2, 1.5, 1.2, 1.6]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/poplast()",
    "html": "Return Value\n\nThe last element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeAll(keepingCapacity:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/removeall(keepingcapacity:)",
    "html": "Parameters\nkeepCapacity\n\nPass true to request that the collection avoid releasing its storage. Retaining the collection’s storage can be a useful optimization when you’re planning to grow the collection again. The default value is false.\n\nDiscussion\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/removelast()",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeAll(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/removeall(where:)",
    "html": "Parameters\nshouldBeRemoved\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.\n\nDiscussion\n\nUse this method to remove every element in a collection that meets particular criteria. The order of the remaining elements is preserved. This example removes all the vowels from a string:\n\nvar phrase = \"The rain in Spain stays mainly in the plain.\"\n\n\nlet vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nphrase.removeAll(where: { vowels.contains($0) })\n// phrase == \"Th rn n Spn stys mnly n th pln.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/removefirst()",
    "html": "Return Value\n\nThe removed element.\n\nDiscussion\n\nThe collection must not be empty.\n\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst()\nprint(bugs)\n// Prints \"[\"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/removefirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst(3)\nprint(bugs)\n// Prints \"[\"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/removesubrange(_:)-62wlg",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/removesubrange(_:)-6rv02",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/replacesubrange(_:with:)-cbfr",
    "html": "Parameters\nsubrange\n\nThe range of elements to replace. The bounds of the range must be valid indices of the view.\n\nnewElements\n\nThe new Unicode scalar values to add to the string.\n\nDiscussion\n\nCalling this method invalidates any existing indices for use with this string.\n\nComplexity\n\nO(m), where m is the combined length of the view and newElements. If the call to replaceSubrange(_:with:) simply removes elements at the end of the string, the complexity is O(n), where n is equal to bounds.count."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/replacesubrange(_:with:)-914bq",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "reserveCapacity(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/reservecapacity(_:)-1766f",
    "html": "Parameters\nn\n\nThe minimum number of ASCII character’s worth of storage to allocate.\n\nDiscussion\n\nBecause a Unicode scalar value can require more than a single ASCII character’s worth of storage, additional allocation may be necessary when adding to a Unicode scalar view after a call to reserveCapacity(_:).\n\nComplexity\n\nO(n), where n is the capacity being reserved."
  },
  {
    "title": "reserveCapacity(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/reservecapacity(_:)-4ygoa",
    "html": "Parameters\nn\n\nThe requested number of elements to store.\n\nDiscussion\n\nIf you will be adding a known number of elements to a collection, use this method to avoid multiple reallocations. A type that conforms to RangeReplaceableCollection can choose how to respond when this method is called. Depending on the type, it may make sense to allocate more or less storage than requested or to take no action at all."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/customplaygroundquicklook",
    "html": "Discussion\n\nIf this type has value semantics, the PlaygroundQuickLook instance should be unaffected by subsequent mutations."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/__=(_:_:)-6b58i",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx <<= 2\n// x == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny <<= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na <<= -3\n// a == 3                         // 0b00000011\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb >>= 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": ">>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/__=(_:_:)-9725q",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >>= operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx >>= 2\n// x == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny >>= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na >>= -3\n// a == 240                       // 0b11110000\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb <<= 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nvar q: Int8 = -30                 // 0b11100010\nq >>= 2\n// q == -8                        // 0b11111000\n\n\nvar r: Int8 = -30                 // 0b11100010\nr >>= 11\n// r == -1                        // 0b11111111\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/init(_:)-6u4mr",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer. The value passed as source must be representable in this type.\n\nDiscussion\n\nUse this initializer to convert from another integer type when you know the value is within the bounds of this type. Passing a value that can’t be represented in this type results in a runtime error.\n\nIn the following example, the constant y is successfully created from x, an Int instance with a value of 100. Because the Int8 type can represent 127 at maximum, the attempt to create z with a value of 1000 results in a runtime error.\n\nlet x = 100\nlet y = Int8(x)\n// y == 100\nlet z = Int8(x * 10)\n// Error: Not enough bits to represent the given value\n"
  },
  {
    "title": "init(clamping:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/init(clamping:)-6bply",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nIf the value passed as source is greater than the maximum representable value in this type, the result is the type’s max value. If source is less than the smallest representable value in this type, the result is the type’s min value.\n\nIn this example, x is initialized as an Int8 instance by clamping 500 to the range -128...127, and y is initialized as a UInt instance by clamping -500 to the range 0...UInt.max.\n\nlet x = Int8(clamping: 500)\n// x == 127\n// x == Int8.max\n\n\nlet y = UInt(clamping: -500)\n// y == 0\n"
  },
  {
    "title": "init(truncatingIfNeeded:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/init(truncatingifneeded:)-54a40",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nWhen the bit width of T (the type of source) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of source. For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of source are used.\n\nlet p: Int16 = -500\n// 'p' has a binary representation of 11111110_00001100\nlet q = Int8(truncatingIfNeeded: p)\n// q == 12\n// 'q' has a binary representation of 00001100\n\n\nWhen the bit width of T is less than this type’s bit width, the result is sign-extended to fill the remaining bits. That is, if source is negative, the result is padded with ones; otherwise, the result is padded with zeros.\n\nlet u: Int8 = 21\n// 'u' has a binary representation of 00010101\nlet v = Int16(truncatingIfNeeded: u)\n// v == 21\n// 'v' has a binary representation of 00000000_00010101\n\n\nlet w: Int8 = -21\n// 'w' has a binary representation of 11101011\nlet x = Int16(truncatingIfNeeded: w)\n// x == -21\n// 'x' has a binary representation of 11111111_11101011\nlet y = UInt16(truncatingIfNeeded: w)\n// y == 65515\n// 'y' has a binary representation of 11111111_11101011\n"
  },
  {
    "title": "isSigned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/issigned-9pdrm",
    "html": "Discussion\n\nThis property is always false for unsigned integer types."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/!=(_:_:)-9ooa7",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the inequality of instances of any BinaryInteger types using the not-equal-to operator (!=). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is not equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are different: \\(firstUTF8 != firstScalar)\")\n}\n// Prints \"First code values are different: false\"\n\nSee Also\nComparison\nstatic func == <Other>(Self, Other) -> Bool\nReturns a Boolean value indicating whether the two given values are equal.\nstatic func != (Self, Self) -> Bool"
  },
  {
    "title": "isSigned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/issigned-1e7u9",
    "html": "Discussion\n\nThis property is always true for signed integer types."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/!=(_:_:)-4ljme",
    "html": "See Also\nComparison\nstatic func == <Other>(Self, Other) -> Bool\nReturns a Boolean value indicating whether the two given values are equal.\nstatic func != <Other>(Self, Other) -> Bool\nReturns a Boolean value indicating whether the two given values are not equal."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/init(_:)-5yrn0",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer. The value passed as source must be representable in this type.\n\nDiscussion\n\nUse this initializer to convert from another integer type when you know the value is within the bounds of this type. Passing a value that can’t be represented in this type results in a runtime error.\n\nIn the following example, the constant y is successfully created from x, an Int instance with a value of 100. Because the Int8 type can represent 127 at maximum, the attempt to create z with a value of 1000 results in a runtime error.\n\nlet x = 100\nlet y = Int8(x)\n// y == 100\nlet z = Int8(x * 10)\n// Error: Not enough bits to represent the given value\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_(_:_:)-4e53m",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/_=(_:_:)-4c5w5",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "isSigned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/issigned",
    "html": "Discussion\n\nThis property is always false for unsigned integer types."
  },
  {
    "title": "IteratorProtocol Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/iterator/iteratorprotocol-implementations",
    "html": "Topics\nInstance Methods\nfunc next() -> JoinedSequence<Base>.Iterator.Element?\nAdvances to the next element and returns it, or nil if no next element exists.\nAvailable when Base conforms to Sequence and Base.Element conforms to Sequence.\nType Aliases\ntypealias Element\nThe type of element traversed by the iterator.\nAvailable when Base conforms to Sequence and Base.Element conforms to Sequence."
  },
  {
    "title": "magnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/magnitude-swift.property",
    "html": "Discussion\n\nEvery unsigned integer is its own magnitude, so for any value x, x == x.magnitude.\n\nThe global abs(_:) function provides more familiar syntax when you need to find an absolute value. In addition, because abs(_:) always returns a value of the same type, even in a generic context, using the function instead of the magnitude property is encouraged."
  },
  {
    "title": "~(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/~(_:)-91dtt",
    "html": "Required Default implementation provided.\n\nDiscussion\n\nThe bitwise NOT operator (~) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are 1 in the argument are 0 in the result, and bits that are 0 in the argument are 1 in the result. This is equivalent to the inverse of a set. For example:\n\nlet x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010\n\n\nPerforming a bitwise NOT operation on 0 returns a value with every bit set to 1.\n\nlet allOnes = ~UInt8.min   // 0b11111111\n\n\nComplexity\n\nO(1).\n\nDefault Implementations\nBinaryInteger Implementations\nstatic func ~ (Self) -> Self\nReturns the inverse of the bits set in the argument.\nSee Also\nBitwise Operations\nstatic func & (Self, Self) -> Self\nReturns the result of performing a bitwise AND operation on the two given values.\n\nRequired Default implementation provided.\n\nstatic func &= (inout Self, Self)\nStores the result of performing a bitwise AND operation on the two given values in the left-hand-side variable.\n\nRequired"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/&(_:_:)-sk15",
    "html": "Required Default implementation provided.\n\nParameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n\nDefault Implementations\nBinaryInteger Implementations\nstatic func & (Self, Self) -> Self\nReturns the result of performing a bitwise AND operation on the two given values.\nSee Also\nBitwise Operations\nstatic func &= (inout Self, Self)\nStores the result of performing a bitwise AND operation on the two given values in the left-hand-side variable.\n\nRequired\n\nstatic func ~ (Self) -> Self\nReturns the inverse of the bits set in the argument.\n\nRequired Default implementation provided."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/-=(_:_:)",
    "html": "Required\n\nParameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nSee Also\nArithmetic with Assignment\nstatic func += (inout Self, Self)\nAdds two values and stores the result in the left-hand-side variable.\n\nRequired\n\nstatic func *= (inout Self, Self)\nMultiplies two values and stores the result in the left-hand-side variable.\n\nRequired"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/+=(_:_:)",
    "html": "Required\n\nParameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nSee Also\nArithmetic with Assignment\nstatic func -= (inout Self, Self)\nSubtracts the second value from the first and stores the difference in the left-hand-side variable.\n\nRequired\n\nstatic func *= (inout Self, Self)\nMultiplies two values and stores the result in the left-hand-side variable.\n\nRequired"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/*(_:_:)",
    "html": "Required\n\nParameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\n2 * 3                   // 6\n100 * 21                // 2100\n-10 * 15                // -150\n3.5 * 2.25              // 7.875\n\n\nYou cannot use * with arguments of different types. To multiply values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) * y              // 21000000\n\nSee Also\nArithmetic\nstatic func + (Self, Self) -> Self\nAdds two values and produces their sum.\n\nRequired\n\nstatic func - (Self, Self) -> Self\nSubtracts one value from another and produces their difference.\n\nRequired"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/-(_:_:)",
    "html": "Required\n\nParameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\n8 - 3                   // 5\n-10 - 5                 // -15\n100 - -5                // 105\n10.5 - 100.0            // -89.5\n\n\nYou cannot use - with arguments of different types. To subtract values of different types, convert one of the values to the other value’s type.\n\nlet x: UInt8 = 21\nlet y: UInt = 1000000\ny - UInt(x)             // 999979\n\nSee Also\nArithmetic\nstatic func + (Self, Self) -> Self\nAdds two values and produces their sum.\n\nRequired\n\nstatic func * (Self, Self) -> Self\nMultiplies two values and produces their product.\n\nRequired"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/+(_:_:)",
    "html": "Required\n\nParameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\n1 + 2                   // 3\n-10 + 15                // 5\n-15 + -5                // -20\n21.5 + 3.25             // 24.75\n\n\nYou cannot use + with arguments of different types. To add values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) + y              // 1000021\n\nSee Also\nArithmetic\nstatic func - (Self, Self) -> Self\nSubtracts one value from another and produces their difference.\n\nRequired\n\nstatic func * (Self, Self) -> Self\nMultiplies two values and produces their product.\n\nRequired"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/init(exactly:)-8briw",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 21.0, while the attempt to initialize the constant y from 21.5 fails:\n\nlet x = Int(exactly: 21.0)\n// x == Optional(21)\nlet y = Int(exactly: 21.5)\n// y == nil\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/init(exactly:)-uz93",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 100, while the attempt to initialize the constant y from 1_000 fails because the Int8 type can represent 127 at maximum:\n\nlet x = Int8(exactly: 100)\n// x == Optional(100)\nlet y = Int8(exactly: 1_000)\n// y == nil\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/__(_:_:)-9f03g",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "&+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe masking addition assignment operator (&+=) silently wraps any overflow that occurs during the operation. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &+= 21\n// x == 31\nvar y: Int8 = 100\ny &+= 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "&*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe overflow multiplication operator (&*) discards any bits that overflow the fixed width of the integer type. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &* 5\n// x == 50\nlet y: Int8 = 10 &* 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&-=(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe masking subtraction assignment operator (&-=) silently wraps any overflow that occurs during the operation. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 21\nx &-= 10\n// x == 11\nvar y: UInt8 = 10\ny &-= 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&__(_:_:)-4xvpf",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&__(_:_:)-2kxq1",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&__(_:_:)-5zh57",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe overflow subtraction operator (&-) discards any bits that overflow the fixed width of the integer type. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: UInt8 = 21 &- 10\n// x == 11\nlet y: UInt8 = 10 &- 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&__(_:_:)-83cmc",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&__(_:_:)-76nen",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "init(base:separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/iterator/init(base:separator:)",
    "html": "Discussion\n\nComplexity\n\nO(separator.count)."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(_:)-2lidr",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer. The value passed as source must be representable in this type.\n\nDiscussion\n\nUse this initializer to convert from another integer type when you know the value is within the bounds of this type. Passing a value that can’t be represented in this type results in a runtime error.\n\nIn the following example, the constant y is successfully created from x, an Int instance with a value of 100. Because the Int8 type can represent 127 at maximum, the attempt to create z with a value of 1000 results in a runtime error.\n\nlet x = 100\nlet y = Int8(x)\n// y == 100\nlet z = Int8(x * 10)\n// Error: Not enough bits to represent the given value\n"
  },
  {
    "title": "min | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/min",
    "html": "Discussion\n\nFor unsigned integer types, this value is always 0."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(exactly:)-568o1",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 100, while the attempt to initialize the constant y from 1_000 fails because the Int8 type can represent 127 at maximum:\n\nlet x = Int8(exactly: 100)\n// x == Optional(100)\nlet y = Int8(exactly: 1_000)\n// y == nil\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/_(_:_:)-1nppt",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/flatmap(_:)-56uyh",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/map(_:)-94hi8",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/joined(separator:)-3n0qi",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/joined(separator:)-5tb1r",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/*=(_:_:)",
    "html": "Required\n\nParameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nSee Also\nArithmetic with Assignment\nstatic func += (inout Self, Self)\nAdds two values and stores the result in the left-hand-side variable.\n\nRequired\n\nstatic func -= (inout Self, Self)\nSubtracts the second value from the first and stores the difference in the left-hand-side variable.\n\nRequired"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/flatmap(_:)-5cevu",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/==(_:_:)-4wftu",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/__(_:_:)-2xfje",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_=(_:_:)-7v58u",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than-or-equal-to operator (>=), even if the two instances are of different types."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_=(_:_:)-yeqy",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than-or-equal-to operator (<=), even if the two instances are of different types."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/endindex",
    "html": "Discussion\n\nIn an empty Unicode scalars view, endIndex is equal to startIndex."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/index(after:)",
    "html": "Discussion\n\nPrecondition\n\nThe next location exists."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/subscript(_:)-6aml8",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/index(before:)",
    "html": "Discussion\n\nPrecondition\n\nThe previous location exists."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/_(_:_:)-3hhq",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "&+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe overflow addition operator (&+) discards any bits that overflow the fixed width of the integer type. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &+ 21\n// x == 31\nlet y: Int8 = 100 &+ 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&__(_:_:)-vou2",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&__=(_:_:)-13mjf",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &<<= operator performs a masking shift, where the value used as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &<<= 2\n// x == 120                       // 0b01111000\n\n\nHowever, if you pass 19 as rhs, the method first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &<<= 19\n// y == 240                       // 0b11110000\n"
  },
  {
    "title": "&>>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&__=(_:_:)-704vn",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &>>= operator performs a masking shift, where the value passed as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &>>= 2\n// x == 7                         // 0b00000111\n\n\nHowever, if you use 19 as rhs, the operation first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &>>= 19\n// y == 3                         // 0b00000011\n"
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/__(_:_:)-60q9j",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "min | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/min",
    "html": "Discussion\n\nFor unsigned integer types, this value is always 0."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/random(in:using:)-8r8yl",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n\n\nNote\n\nThe algorithm used to create random values may change in a future version of Swift. If you’re passing a generator that results in the same sequence of integer values each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(_:)-5j67w",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer. source must be representable in this type after rounding toward zero.\n\nDiscussion\nlet x = Int(21.5)\n// x == 21\nlet y = Int(-21.5)\n// y == -21\n\n\nIf source is outside the bounds of this type after rounding toward zero, a runtime error may occur.\n\nlet z = UInt(-21.5)\n// Error: ...outside the representable range\n"
  },
  {
    "title": "&>>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&__=(_:_:)-4hmss",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &>>= operator performs a masking shift, where the value passed as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &>>= 2\n// x == 7                         // 0b00000111\n\n\nHowever, if you use 19 as rhs, the operation first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &>>= 19\n// y == 3                         // 0b00000011\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(_:)-6f9pj",
    "html": "Parameters\ndescription\n\nThe ASCII representation of a number.\n\nDiscussion\n\nThe string passed as description may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9).\n\nlet x = Int(\"123\")\n// x == 123\n\n\nIf description is in an invalid format, or if the value it denotes in base 10 is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"10000000000000000000000000\") // Out of range\n"
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/random(in:using:)-3dwvw",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n"
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/random(in:)-8zzqt",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling random(in:using:), passing in the system’s default random generator."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/random(in:using:)-4lsb1",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n\n\nNote\n\nThe algorithm used to create random values may change in a future version of Swift. If you’re passing a generator that results in the same sequence of integer values each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&(_:_:)-1gv93",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "isMultiple(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/ismultiple(of:)",
    "html": "Parameters\nother\n\nThe value to test.\n\nDiscussion\n\nFor two integers a and b, a is a multiple of b if there exists a third integer q such that a = q*b. For example, 6 is a multiple of 3 because 6 = 2*3. Zero is a multiple of everything because 0 = 0*x for any integer x.\n\nTwo edge cases are worth particular attention:\n\nx.isMultiple(of: 0) is true if x is zero and false otherwise.\n\nT.min.isMultiple(of: -1) is true for signed integer T, even though the quotient T.min / -1 isn’t representable in type T."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(integerliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": "quotientAndRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/quotientandremainder(dividingby:)",
    "html": "Parameters\nrhs\n\nThe value to divide this value by.\n\nReturn Value\n\nA tuple containing the quotient and remainder of this value divided by rhs.\n\nDiscussion\n\nUse this method to calculate the quotient and remainder of a division at the same time.\n\nlet x = 1_000_000\nlet (q, r) = x.quotientAndRemainder(dividingBy: 933)\n// q == 1071\n// r == 757\n"
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/!=(_:_:)-4jpi0",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the inequality of instances of any BinaryInteger types using the not-equal-to operator (!=). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is not equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are different: \\(firstUTF8 != firstScalar)\")\n}\n// Prints \"First code values are different: false\"\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&(_:_:)-8gwdr",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\n2 * 3                   // 6\n100 * 21                // 2100\n-10 * 15                // -150\n3.5 * 2.25              // 7.875\n\n\nYou cannot use * with arguments of different types. To multiply values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) * y              // 21000000\n\n\nThe product of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 * 21 is greater than the maximum representable Int8 value:\n\nx * 21                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow multiplication operator (&*).\n\nx &* 21                // -115\n"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/subscript(_:)-2op53",
    "html": "Parameters\nposition\n\nA valid index of the character view. position must be less than the view’s end index.\n\nOverview\n\nThe following example searches a string’s Unicode scalars view for a capital letter and then prints the character and Unicode scalar value at the found index:\n\nlet greeting = \"Hello, friend!\"\nif let i = greeting.unicodeScalars.firstIndex(where: { \"A\"...\"Z\" ~= $0 }) {\n    print(\"First capital letter: \\(greeting.unicodeScalars[i])\")\n    print(\"Unicode scalar value: \\(greeting.unicodeScalars[i].value)\")\n}\n// Prints \"First capital letter: H\"\n// Prints \"Unicode scalar value: 72\"\n"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_(_:_:)-70g4r",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\n1 + 2                   // 3\n-10 + 15                // 5\n-15 + -5                // -20\n21.5 + 3.25             // 24.75\n\n\nYou cannot use + with arguments of different types. To add values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) + y              // 1000021\n\n\nThe sum of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 + 120 is greater than the maximum representable Int8 value:\n\nx + 120                 // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow addition operator (&+).\n\nx &+ 120                // -115\n"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_(_:_:)-3r6zk",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than operator (<), even if the two instances are of different types."
  },
  {
    "title": "%(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_(_:_:)-5hyxb",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nThe result of the remainder operator (%) has the same sign as lhs and has a magnitude less than rhs.magnitude.\n\nlet x = 22 % 5\n// x == 2\nlet y = 22 % -5\n// y == 2\nlet z = -22 % -5\n// z == -2\n\n\nFor any two integers a and b, their quotient q, and their remainder r, a == b * q + r."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_(_:_:)-e9z4",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\n8 - 3                   // 5\n-10 - 5                 // -15\n100 - -5                // 105\n10.5 - 100.0            // -89.5\n\n\nYou cannot use - with arguments of different types. To subtract values of different types, convert one of the values to the other value’s type.\n\nlet x: UInt8 = 21\nlet y: UInt = 1000000\ny - UInt(x)             // 999979\n\n\nThe difference of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 - 50 is less than zero, the minimum representable UInt8 value:\n\nx - 50                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow subtraction operator (&-).\n\nx &- 50                // 227\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_(_:_:)-7d589",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than operator (>), even if the two instances are of different types."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/startindex",
    "html": "Discussion\n\nIf the string is empty, startIndex is equal to endIndex."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarview/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "&*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/&*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe masking multiplication assignment operator (&*=) silently wraps any overflow that occurs during the operation. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &*= 5\n// x == 50\nvar y: Int8 = 10\ny &*= 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/__(_:_:)-635q0",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "~(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/~(_:)",
    "html": "Discussion\n\nThe bitwise NOT operator (~) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are 1 in the argument are 0 in the result, and bits that are 0 in the argument are 1 in the result. This is equivalent to the inverse of a set. For example:\n\nlet x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010\n\n\nPerforming a bitwise NOT operation on 0 returns a value with every bit set to 1.\n\nlet allOnes = ~UInt8.min   // 0b11111111\n\n\nComplexity\n\nO(1)."
  },
  {
    "title": "init(bigEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(bigendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the big-endian representation of the new integer."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(_:)-2hmhy",
    "html": "Parameters\ndescription\n\nThe ASCII representation of a number.\n\nDiscussion\n\nThe string passed as description may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9).\n\nlet x = Int(\"123\")\n// x == 123\n\n\nIf description is in an invalid format, or if the value it denotes in base 10 is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"10000000000000000000000000\") // Out of range\n"
  },
  {
    "title": "bigEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/bigendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a big-endian platform, for any integer x, x == x.bigEndian."
  },
  {
    "title": "init(littleEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(littleendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the little-endian representation of the new integer."
  },
  {
    "title": "init(_:radix:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(_:radix:)",
    "html": "Parameters\ntext\n\nThe ASCII representation of a number in the radix passed as radix.\n\nradix\n\nThe radix, or base, to use for converting text to an integer value. radix must be in the range 2...36. The default is 10.\n\nDiscussion\n\nThe string passed as text may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9) or letters (a-z or A-Z). Parsing of the string is case insensitive.\n\nlet x = Int(\"123\")\n// x == 123\n\n\nlet y = Int(\"-123\", radix: 8)\n// y == -83\nlet y = Int(\"+123\", radix: 8)\n// y == +83\n\n\nlet z = Int(\"07b\", radix: 16)\n// z == 123\n\n\nIf text is in an invalid format or contains characters that are out of bounds for the given radix, or if the value it denotes in the given radix is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"zzzzzzzzzzzzz\", radix: 36)   // Out of range\n"
  },
  {
    "title": "init(clamping:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(clamping:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nIf the value passed as source is greater than the maximum representable value in this type, the result is the type’s max value. If source is less than the smallest representable value in this type, the result is the type’s min value.\n\nIn this example, x is initialized as an Int8 instance by clamping 500 to the range -128...127, and y is initialized as a UInt instance by clamping -500 to the range 0...UInt.max.\n\nlet x = Int8(clamping: 500)\n// x == 127\n// x == Int8.max\n\n\nlet y = UInt(clamping: -500)\n// y == 0\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(exactly:)-7yhn2",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 21.0, while the attempt to initialize the constant y from 21.5 fails:\n\nlet x = Int(exactly: 21.0)\n// x == Optional(21)\nlet y = Int(exactly: 21.5)\n// y == nil\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(_:)-6gt9n",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer. source must be representable in this type after rounding toward zero.\n\nDiscussion\nlet x = Int(21.5)\n// x == 21\nlet y = Int(-21.5)\n// y == -21\n\n\nIf source is outside the bounds of this type after rounding toward zero, a runtime error may occur.\n\nlet z = UInt(-21.5)\n// Error: ...outside the representable range\n"
  },
  {
    "title": "init(truncatingIfNeeded:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/init(truncatingifneeded:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nWhen the bit width of T (the type of source) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of source. For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of source are used.\n\nlet p: Int16 = -500\n// 'p' has a binary representation of 11111110_00001100\nlet q = Int8(truncatingIfNeeded: p)\n// q == 12\n// 'q' has a binary representation of 00001100\n\n\nWhen the bit width of T is less than this type’s bit width, the result is sign-extended to fill the remaining bits. That is, if source is negative, the result is padded with ones; otherwise, the result is padded with zeros.\n\nlet u: Int8 = 21\n// 'u' has a binary representation of 00010101\nlet v = Int16(truncatingIfNeeded: u)\n// v == 21\n// 'v' has a binary representation of 00000000_00010101\n\n\nlet w: Int8 = -21\n// 'w' has a binary representation of 11101011\nlet x = Int16(truncatingIfNeeded: w)\n// x == -21\n// 'x' has a binary representation of 11111111_11101011\nlet y = UInt16(truncatingIfNeeded: w)\n// y == 65515\n// 'y' has a binary representation of 11111111_11101011\n"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "isSigned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/issigned",
    "html": "Discussion\n\nThis property is always false for unsigned integer types."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(exactly:)-8b2n7",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 100, while the attempt to initialize the constant y from 1_000 fails because the Int8 type can represent 127 at maximum:\n\nlet x = Int8(exactly: 100)\n// x == Optional(100)\nlet y = Int8(exactly: 1_000)\n// y == nil\n"
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/index(_:offsetby:)-t8sl",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/__(_:_:)-97tkd",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/__=(_:_:)-66xfr",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx <<= 2\n// x == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny <<= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na <<= -3\n// a == 3                         // 0b00000011\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb >>= 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nFor a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n."
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/distance(to:)",
    "html": "Parameters\nother\n\nThe value to calculate the distance to.\n\nReturn Value\n\nThe distance from this value to other.\n\nDiscussion\n\nFor two values x and y, and a distance n = x.distance(to: y), x.advanced(by: n) == y."
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/-=(_:_:)-2aqt7",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/+=(_:_:)-5g9il",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "&*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe overflow multiplication operator (&*) discards any bits that overflow the fixed width of the integer type. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &* 5\n// x == 50\nlet y: Int8 = 10 &* 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "&*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe masking multiplication assignment operator (&*=) silently wraps any overflow that occurs during the operation. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &*= 5\n// x == 50\nvar y: Int8 = 10\ny &*= 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe masking addition assignment operator (&+=) silently wraps any overflow that occurs during the operation. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &+= 21\n// x == 31\nvar y: Int8 = 100\ny &+= 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe overflow addition operator (&+) discards any bits that overflow the fixed width of the integer type. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &+ 21\n// x == 31\nlet y: Int8 = 100 &+ 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe overflow subtraction operator (&-) discards any bits that overflow the fixed width of the integer type. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: UInt8 = 21 &- 10\n// x == 11\nlet y: UInt8 = 10 &- 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&-=(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe masking subtraction assignment operator (&-=) silently wraps any overflow that occurs during the operation. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 21\nx &-= 10\n// x == 11\nvar y: UInt8 = 10\ny &-= 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&__(_:_:)-20r54",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&__(_:_:)-4ncka",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&__(_:_:)-47n63",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&__(_:_:)-8qsy",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&__(_:_:)-9phvf",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/__(_:_:)-25f5d",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/__(_:_:)-5so09",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "~(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/~(_:)",
    "html": "Discussion\n\nThe bitwise NOT operator (~) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are 1 in the argument are 0 in the result, and bits that are 0 in the argument are 1 in the result. This is equivalent to the inverse of a set. For example:\n\nlet x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010\n\n\nPerforming a bitwise NOT operation on 0 returns a value with every bit set to 1.\n\nlet allOnes = ~UInt8.min   // 0b11111111\n\n\nComplexity\n\nO(1)."
  },
  {
    "title": "littleEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/littleendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a little-endian platform, for any integer x, x == x.littleEndian."
  },
  {
    "title": "init(clamping:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(clamping:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nIf the value passed as source is greater than the maximum representable value in this type, the result is the type’s max value. If source is less than the smallest representable value in this type, the result is the type’s min value.\n\nIn this example, x is initialized as an Int8 instance by clamping 500 to the range -128...127, and y is initialized as a UInt instance by clamping -500 to the range 0...UInt.max.\n\nlet x = Int8(clamping: 500)\n// x == 127\n// x == Int8.max\n\n\nlet y = UInt(clamping: -500)\n// y == 0\n"
  },
  {
    "title": "init(bigEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(bigendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the big-endian representation of the new integer."
  },
  {
    "title": "init(_:radix:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(_:radix:)",
    "html": "Parameters\ntext\n\nThe ASCII representation of a number in the radix passed as radix.\n\nradix\n\nThe radix, or base, to use for converting text to an integer value. radix must be in the range 2...36. The default is 10.\n\nDiscussion\n\nThe string passed as text may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9) or letters (a-z or A-Z). Parsing of the string is case insensitive.\n\nlet x = Int(\"123\")\n// x == 123\n\n\nlet y = Int(\"-123\", radix: 8)\n// y == -83\nlet y = Int(\"+123\", radix: 8)\n// y == +83\n\n\nlet z = Int(\"07b\", radix: 16)\n// z == 123\n\n\nIf text is in an invalid format or contains characters that are out of bounds for the given radix, or if the value it denotes in the given radix is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"zzzzzzzzzzzzz\", radix: 36)   // Out of range\n"
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/random(in:)-9mjpk",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling the version that takes a generator, passing in the system’s default random generator."
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_(_:_:)-2yuuu",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nFor integer types, any remainder of the division is discarded.\n\nlet x = 21 / 5\n// x == 4\n"
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/_(_:_:)-1e0ey",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/==(_:_:)-1zalq",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the equality of instances of any BinaryInteger types using the equal-to operator (==). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are equal: \\(firstUTF8 == firstScalar)\")\n}\n// Prints \"First code values are equal: true\"\n"
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/random(in:)-5grii",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling the version that takes a generator, passing in the system’s default random generator."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "bigEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/bigendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a big-endian platform, for any integer x, x == x.bigEndian."
  },
  {
    "title": "init(truncatingIfNeeded:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(truncatingifneeded:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nWhen the bit width of T (the type of source) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of source. For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of source are used.\n\nlet p: Int16 = -500\n// 'p' has a binary representation of 11111110_00001100\nlet q = Int8(truncatingIfNeeded: p)\n// q == 12\n// 'q' has a binary representation of 00001100\n\n\nWhen the bit width of T is less than this type’s bit width, the result is sign-extended to fill the remaining bits. That is, if source is negative, the result is padded with ones; otherwise, the result is padded with zeros.\n\nlet u: Int8 = 21\n// 'u' has a binary representation of 00010101\nlet v = Int16(truncatingIfNeeded: u)\n// v == 21\n// 'v' has a binary representation of 00000000_00010101\n\n\nlet w: Int8 = -21\n// 'w' has a binary representation of 11101011\nlet x = Int16(truncatingIfNeeded: w)\n// x == -21\n// 'x' has a binary representation of 11111111_11101011\nlet y = UInt16(truncatingIfNeeded: w)\n// y == 65515\n// 'y' has a binary representation of 11111111_11101011\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(exactly:)-7m1hy",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 21.0, while the attempt to initialize the constant y from 21.5 fails:\n\nlet x = Int(exactly: 21.0)\n// x == Optional(21)\nlet y = Int(exactly: 21.5)\n// y == nil\n"
  },
  {
    "title": "multipliedFullWidth(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/multipliedfullwidth(by:)-50fum",
    "html": "Parameters\nother\n\nThe value to multiply this value by.\n\nReturn Value\n\nA tuple containing the high and low parts of the result of multiplying this value and other.\n\nDiscussion\n\nUse this method to calculate the full result of a product that would otherwise overflow. Unlike traditional truncating multiplication, the multipliedFullWidth(by:) method returns a tuple containing both the high and low parts of the product of this value and other. The following example uses this method to multiply two Int8 values that normally overflow when multiplied:\n\nlet x: Int8 = 48\nlet y: Int8 = -40\nlet result = x.multipliedFullWidth(by: y)\n// result.high == -8\n// result.low  == 128\n\n\nThe product of x and y is -1920, which is too large to represent in an Int8 instance. The high and low components of the result value represent -1920 when concatenated to form a double-width integer; that is, using result.high as the high byte and result.low as the low byte of an Int16 instance.\n\nlet z = Int16(result.high) << 8 | Int16(result.low)\n// z == -1920\n"
  },
  {
    "title": "littleEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/littleendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a little-endian platform, for any integer x, x == x.littleEndian."
  },
  {
    "title": "max | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/max",
    "html": "Discussion\n\nFor unsigned integer types, this value is (2 ** bitWidth) - 1, where ** is exponentiation."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/==(_:_:)-4gy2m",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/customplaygroundquicklook",
    "html": "Deprecated\n\nUInt.customPlaygroundQuickLook will be removed in a future Swift version"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/compactmap(_:)-420ej",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/flatmap(_:)-8fefz",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": ">>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/__=(_:_:)-9p0cx",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >>= operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx >>= 2\n// x == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny >>= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na >>= -3\n// a == 240                       // 0b11110000\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb <<= 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nvar q: Int8 = -30                 // 0b11100010\nq >>= 2\n// q == -8                        // 0b11111000\n\n\nvar r: Int8 = -30                 // 0b11100010\nr >>= 11\n// r == -1                        // 0b11111111\n"
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/__(_:_:)-6ne6o",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/__(_:_:)-7llmt",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/zero",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&__(_:_:)-67e3c",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&__=(_:_:)-487ah",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &<<= operator performs a masking shift, where the value used as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &<<= 2\n// x == 120                       // 0b01111000\n\n\nHowever, if you pass 19 as rhs, the method first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &<<= 19\n// y == 240                       // 0b11110000\n"
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/distance(from:to:)-92lzm",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/count-3tpmd",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if Self conforms to RandomAccessCollection; O(n) otherwise."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/distance(from:to:)-396sb",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/startindex",
    "html": "Discussion\n\nIn an empty collection, startIndex == endIndex."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/opaquepointer/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/joined(separator:)-26r7k",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/joined(separator:)-7b5x0",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/map(_:)-6ywnv",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/joined(separator:)-5e92i",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/random(in:)-4xxb6",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling random(in:using:), passing in the system’s default random generator."
  },
  {
    "title": "magnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/magnitude-swift.property",
    "html": "Discussion\n\nEvery unsigned integer is its own magnitude, so for any value x, x == x.magnitude.\n\nThe global abs(_:) function provides more familiar syntax when you need to find an absolute value. In addition, because abs(_:) always returns a value of the same type, even in a generic context, using the function instead of the magnitude property is encouraged."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/customplaygroundquicklook",
    "html": "Deprecated\n\nUInt64.customPlaygroundQuickLook will be removed in a future Swift version"
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/random(in:using:)-75uk1",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(_:)-u8j6",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer. The value passed as source must be representable in this type.\n\nDiscussion\n\nUse this initializer to convert from another integer type when you know the value is within the bounds of this type. Passing a value that can’t be represented in this type results in a runtime error.\n\nIn the following example, the constant y is successfully created from x, an Int instance with a value of 100. Because the Int8 type can represent 127 at maximum, the attempt to create z with a value of 1000 results in a runtime error.\n\nlet x = 100\nlet y = Int8(x)\n// y == 100\nlet z = Int8(x * 10)\n// Error: Not enough bits to represent the given value\n"
  },
  {
    "title": "init(littleEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(littleendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the little-endian representation of the new integer."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/init(integerliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false otherwise. Once predicate returns false it will not be called again."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/flatmap(_:)-7fl2l",
    "html": "Discussion\n\nUse this method to receive a single-level sequence when your transformation produces a sequence or collection for each element. Calling flatMap(_:) on a sequence s is equivalent to calling s.map(transform).joined().\n\nComplexity\n\nO(1)"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/_(_:_:)-fe5k",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/endindex",
    "html": "Discussion\n\nendIndex is always reachable from startIndex by zero or more applications of index(after:)."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/index(_:offsetby:limitedby:)-617va",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/split(separator:maxsplits:omittingemptysubsequences:)-3ls1g",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/isempty-1upms",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be nonuniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can result in an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/index(_:offsetby:)-uoy5",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/map(_:)-9kewz",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/index(_:offsetby:limitedby:)-62vws",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/index(_:offsetby:limitedby:)-l4oe",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/split(separator:maxsplits:omittingemptysubsequences:)-ki1c",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/subscript(_:)-1lzdb",
    "html": "Overview\n\nPrecondition\n\nposition is a valid position in self and position != endIndex."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/subscript(_:)-8iflg",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/subscript(_:)-9kt1v",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "predecessor() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/predecessor()",
    "html": "Return Value\n\nA pointer shifted backward from this pointer by MemoryLayout<Pointee>.stride bytes.\n\nDiscussion\n\nThe resulting pointer must be within the bounds of the same allocation as this pointer."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/opaquepointer/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/joined()-2ibvq",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/'...(_:)-9mt9j",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_=(_:_:)-1clb5",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than-or-equal-to operator (<=), even if the two instances are of different types."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_=(_:_:)-3atk2",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_(_:_:)-5phl8",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/flatmap(_:)-102bh",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_=(_:_:)-4pbv7",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false otherwise. Once predicate returns false it will not be called again."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafecurrenttask/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/'...(_:)-4mm56",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/'...(_:)-6ct52",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/_=(_:_:)-1ihk",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/_(_:_:)-24u5j",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "isMultiple(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/ismultiple(of:)",
    "html": "Parameters\nother\n\nThe value to test.\n\nDiscussion\n\nFor two integers a and b, a is a multiple of b if there exists a third integer q such that a = q*b. For example, 6 is a multiple of 3 because 6 = 2*3. Zero is a multiple of everything because 0 = 0*x for any integer x.\n\nTwo edge cases are worth particular attention:\n\nx.isMultiple(of: 0) is true if x is zero and false otherwise.\n\nT.min.isMultiple(of: -1) is true for signed integer T, even though the quotient T.min / -1 isn’t representable in type T."
  },
  {
    "title": "quotientAndRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/quotientandremainder(dividingby:)",
    "html": "Parameters\nrhs\n\nThe value to divide this value by.\n\nReturn Value\n\nA tuple containing the quotient and remainder of this value divided by rhs.\n\nDiscussion\n\nUse this method to calculate the quotient and remainder of a division at the same time.\n\nlet x = 1_000_000\nlet (q, r) = x.quotientAndRemainder(dividingBy: 933)\n// q == 1071\n// r == 757\n"
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/distance(to:)",
    "html": "Parameters\nother\n\nThe value to calculate the distance to.\n\nReturn Value\n\nThe distance from this value to other.\n\nDiscussion\n\nFor two values x and y, and a distance n = x.distance(to: y), x.advanced(by: n) == y."
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nFor a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "LazySequence.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "LazySequence.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/count-1cggd",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "LazySequence.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/compactmap(_:)-73i9g",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/distance(to:)",
    "html": "Parameters\nend\n\nThe pointer to calculate the distance to.\n\nReturn Value\n\nThe distance from this pointer to end, in strides of the pointer’s Pointee type. To access the stride, use MemoryLayout<Pointee>.stride.\n\nDiscussion\n\nWith pointers p and q, the result of p.distance(to: q) is equivalent to q - p.\n\nTyped pointers are required to be properly aligned for their Pointee type. Proper alignment ensures that the result of distance(to:) accurately measures the distance between the two pointers, counted in strides of Pointee. To find the distance in bytes between two pointers, convert them to UnsafeRawPointer instances before calling distance(to:)."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/_=(_:_:)-jie3",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address later than or the same as rhs; otherwise, false."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/==(_:_:)-6ra49",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the equality of instances of any BinaryInteger types using the equal-to operator (==). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are equal: \\(firstUTF8 == firstScalar)\")\n}\n// Prints \"First code values are equal: true\"\n"
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_(_:_:)-5hgaz",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "%(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_(_:_:)-68vrk",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nThe result of the remainder operator (%) has the same sign as lhs and has a magnitude less than rhs.magnitude.\n\nlet x = 22 % 5\n// x == 2\nlet y = 22 % -5\n// y == 2\nlet z = -22 % -5\n// z == -2\n\n\nFor any two integers a and b, their quotient q, and their remainder r, a == b * q + r."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_(_:_:)-6ykmm",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_(_:_:)-75vtz",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than operator (<), even if the two instances are of different types."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_(_:_:)-9xpv",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than operator (>), even if the two instances are of different types."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_=(_:_:)-5p2f4",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than-or-equal-to operator (>=), even if the two instances are of different types."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/__(_:_:)-7rk6f",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/__(_:_:)-83yhh",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": ">>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/__=(_:_:)-25p32",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >>= operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx >>= 2\n// x == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny >>= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na >>= -3\n// a == 240                       // 0b11110000\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb <<= 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nvar q: Int8 = -30                 // 0b11100010\nq >>= 2\n// q == -8                        // 0b11111000\n\n\nvar r: Int8 = -30                 // 0b11100010\nr >>= 11\n// r == -1                        // 0b11111111\n"
  },
  {
    "title": "<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/__=(_:_:)-7usr",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx <<= 2\n// x == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny <<= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na <<= -3\n// a == 3                         // 0b00000011\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb >>= 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/'...(_:)-6rvzw",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/'...(_:)-64ixm",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_(_:_:)-5jero",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_(_:_:)-5kh4y",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_=(_:_:)-5sy3d",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_=(_:_:)-5zp05",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_(_:_:)-6uaw2",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_=(_:_:)-938i3",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_=(_:_:)-9d45t",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "LazySequence.Elements | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/elements-swift.typealias",
    "html": "Discussion\n\nSee also: elements"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/+=(_:_:)-5brqh",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/-=(_:_:)-aern",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazysequence/filter(_:)",
    "html": "Discussion\n\nNote\n\nThe elements of the result are computed on-demand, as the result is used. No buffering storage is allocated and each traversal step invokes predicate on one or more underlying elements."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafecurrenttask/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&(_:_:)-404as",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/!=(_:_:)-67tzk",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the inequality of instances of any BinaryInteger types using the not-equal-to operator (!=). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is not equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are different: \\(firstUTF8 != firstScalar)\")\n}\n// Prints \"First code values are different: false\"\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/_=(_:_:)-8lyi4",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\n1 + 2                   // 3\n-10 + 15                // 5\n-15 + -5                // -20\n21.5 + 3.25             // 24.75\n\n\nYou cannot use + with arguments of different types. To add values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) + y              // 1000021\n\n\nThe sum of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 + 120 is greater than the maximum representable Int8 value:\n\nx + 120                 // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow addition operator (&+).\n\nx &+ 120                // -115\n"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\n2 * 3                   // 6\n100 * 21                // 2100\n-10 * 15                // -150\n3.5 * 2.25              // 7.875\n\n\nYou cannot use * with arguments of different types. To multiply values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) * y              // 21000000\n\n\nThe product of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 * 21 is greater than the maximum representable Int8 value:\n\nx * 21                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow multiplication operator (&*).\n\nx &* 21                // -115\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/&(_:_:)-3x1yh",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/_=(_:_:)-88947",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/opaquepointer/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/!=(_:_:)-48qvt",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference different memory addresses; otherwise, false."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/==(_:_:)-8ubmz",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference the same memory address; otherwise, false."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/==(_:_:)-9kt0g",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference the same memory address; otherwise, false."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/_(_:_:)-1r7fs",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than rhs; otherwise, false."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/_(_:_:)-4cbv2",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than rhs; otherwise, false."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/init(_:)-1o7o9",
    "html": "Parameters\nfrom\n\nThe opaque pointer to convert to a typed pointer."
  },
  {
    "title": "init(bitPattern:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/init(bitpattern:)-3r9sv",
    "html": "Parameters\nbitPattern\n\nA bit pattern to use for the address of the new pointer. If bitPattern is zero, the result is nil.\n\nDiscussion\n\nThe address passed as bitPattern must have the correct alignment for the pointer’s Pointee type. That is, bitPattern % MemoryLayout<Pointee>.alignment must be 0."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/'...(_:)-12nb2",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "successor() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/successor()",
    "html": "Return Value\n\nA pointer advanced from this pointer by MemoryLayout<Pointee>.stride bytes.\n\nDiscussion\n\nThe resulting pointer must be within the bounds of the same allocation as this pointer."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/_(_:_:)-7org4",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/_(_:_:)-7z083",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\n8 - 3                   // 5\n-10 - 5                 // -15\n100 - -5                // 105\n10.5 - 100.0            // -89.5\n\n\nYou cannot use - with arguments of different types. To subtract values of different types, convert one of the values to the other value’s type.\n\nlet x: UInt8 = 21\nlet y: UInt = 1000000\ny - UInt(x)             // 999979\n\n\nThe difference of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 - 50 is less than zero, the minimum representable UInt8 value:\n\nx - 50                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow subtraction operator (&-).\n\nx &- 50                // 227\n"
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_(_:_:)-1kwg2",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nFor integer types, any remainder of the division is discarded.\n\nlet x = 21 / 5\n// x == 4\n"
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/_(_:_:)-2girh",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/zero",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x."
  },
  {
    "title": "ReversedCollection.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/subscript(_:)",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nOverview\n\nThe following example accesses an element of an array through its subscript to print its value:\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nprint(streets[1])\n// Prints \"Bryant\"\n\n\nYou can subscript a collection with any valid index other than the collection’s end index. The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.\n\nComplexity\n\nO(1)"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/_=(_:_:)-6jasp",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafecurrenttask/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/startindex",
    "html": "Discussion\n\nIf the collection is empty, startIndex is equal to endIndex."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/split(separator:maxsplits:omittingemptysubsequences:)-7uzmt",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/advanced(by:)",
    "html": "Parameters\nn\n\nThe number of strides of the pointer’s Pointee type to offset this pointer. To access the stride, use MemoryLayout<Pointee>.stride. n may be positive, negative, or zero.\n\nReturn Value\n\nA pointer offset from this pointer by n instances of the Pointee type.\n\nDiscussion\n\nWith pointer p and distance n, the result of p.advanced(by: n) is equivalent to p + n.\n\nThe resulting pointer must be within the bounds of the same allocation as this pointer."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/init(_:)-7r783",
    "html": "Parameters\nother\n\nThe typed pointer to convert. If other is nil, the result is nil."
  },
  {
    "title": "init(bitPattern:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/init(bitpattern:)-84bzj",
    "html": "Parameters\nbitPattern\n\nA bit pattern to use for the address of the new pointer. If bitPattern is zero, the result is nil.\n\nDiscussion\n\nThe address passed as bitPattern must have the correct alignment for the pointer’s Pointee type. That is, bitPattern % MemoryLayout<Pointee>.alignment must be 0."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/_(_:_:)-8n81w",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address later than rhs; otherwise, false."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/_=(_:_:)-45lk8",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than or the same as rhs; otherwise, false."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/init(_:)-qu0h",
    "html": "Parameters\nfrom\n\nThe opaque pointer to convert to a typed pointer. If from is nil, the result of this initializer is nil."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/autoreleasingunsafemutablepointer/init(_:)-98q6r",
    "html": "Parameters\nother\n\nThe typed pointer to convert."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/canonicalcombiningclass/'...(_:)-6pi3",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/canonicalcombiningclass/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/canonicalcombiningclass/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/canonicalcombiningclass/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/canonicalcombiningclass/_=(_:_:)-4pgnv",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/canonicalcombiningclass/_(_:_:)-5jtn9",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/canonicalcombiningclass/_=(_:_:)-q66b",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/_=(_:_:)-5ovrh",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/_=(_:_:)-1gott",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/'...(_:)-9yax3",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "ReversedCollection.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/element",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/endindex",
    "html": "Discussion\n\nWhen you need a range that includes the last element of a collection, use the half-open range operator (..<) with endIndex. The ..< operator creates a range that doesn’t include the upper bound, so it’s always safe to use with endIndex. For example:\n\nlet numbers = [10, 20, 30, 40, 50]\nif let index = numbers.firstIndex(of: 30) {\n    print(numbers[index ..< numbers.endIndex])\n}\n// Prints \"[30, 40, 50]\"\n\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/map(_:)-80k1p",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/flatmap(_:)-4wxgx",
    "html": "Discussion\n\nUse this method to receive a single-level sequence when your transformation produces a sequence or collection for each element. Calling flatMap(_:) on a sequence s is equivalent to calling s.map(transform).joined().\n\nComplexity\n\nO(1)"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/compactmap(_:)-45kvo",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/flatmap(_:)-81zng",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "ReversedCollection.Elements | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/elements-swift.typealias",
    "html": "Discussion\n\nSee also: elements"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/_=(_:_:)-9wsxs",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/_=(_:_:)-8cq0s",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/'...(_:)-61uj4",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/_(_:_:)-38ae7",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/'...(_:)-30fi7",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/canonicalcombiningclass/'...(_:)-5seus",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "transcode(_:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/utf32/transcode(_:from:)",
    "html": "Discussion\n\nA default implementation of this method will be provided automatically for any conforming type that does not implement one."
  },
  {
    "title": "encodedReplacementCharacter | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/utf32/encodedreplacementcharacter",
    "html": "Discussion\n\nIf the Unicode replacement character U+FFFD is representable in this encoding, encodedReplacementCharacter encodes that scalar value."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/'...(_:)-7td6l",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/_(_:_:)-1oel1",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/index/_(_:_:)-4ruii",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/init(_:)-3eyf0",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector.\n\nDiscussion\n\nPrecondition\n\nscalars must have the same number of elements as the vector type."
  },
  {
    "title": "wrappedSum() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/wrappedsum()",
    "html": "Discussion\n\nEquivalent to indices.reduce(into: 0) { $0 &+= self[$1] }."
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/replacing(with:where:)-3o8ie",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other : self[i]\n}\n"
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/replacing(with:where:)-32h18",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other[i] : self[i]\n}\n"
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/replace(with:where:)-7yqkl",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other }\n}\n"
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/replace(with:where:)-7e4sy",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other[i] }\n}\n"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "encode(_:into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/utf32/encode(_:into:)",
    "html": "Parameters\ninput\n\nThe Unicode scalar value to encode.\n\nprocessCodeUnit\n\nA closure that processes one code unit argument at a time.\n\nDiscussion\n\nFor example, like every Unicode scalar, the musical fermata symbol (“𝄐”) can be represented in UTF-32 as a single code unit. The following code encodes a fermata in UTF-32:\n\nvar codeUnit: UTF32.CodeUnit = 0\nUTF32.encode(\"𝄐\", into: { codeUnit = $0 })\nprint(codeUnit)\n// Prints \"119056\"\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "decode(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/utf32/decode(_:)-swift.method",
    "html": "Parameters\ninput\n\nAn iterator of code units to be decoded. input must be the same iterator instance in repeated calls to this method. Do not advance the iterator or any copies of the iterator outside this method.\n\nReturn Value\n\nA UnicodeDecodingResult instance, representing the next Unicode scalar, an indication of an error, or an indication that the UTF sequence has been fully decoded.\n\nDiscussion\n\nTo decode a code unit sequence completely, call this method repeatedly until it returns UnicodeDecodingResult.emptyInput. Checking that the iterator was exhausted is not sufficient, because the decoder can store buffered data from the input iterator.\n\nBecause of buffering, it is impossible to find the corresponding position in the iterator for a given returned Unicode.Scalar or an error.\n\nThe following example decodes the UTF-16 encoded bytes of a string into an array of Unicode.Scalar instances. This is a demonstration only—if you need the Unicode scalar representation of a string, use its unicodeScalars view.\n\n// UTF-32 representation of \"✨Unicode✨\"\nlet codeUnits: [UTF32.CodeUnit] =\n        [10024, 85, 110, 105, 99, 111, 100, 101, 10024]\n\n\nvar codeUnitIterator = codeUnits.makeIterator()\nvar scalars: [Unicode.Scalar] = []\nvar utf32Decoder = UTF32()\nDecode: while true {\n    switch utf32Decoder.decode(&codeUnitIterator) {\n    case .scalarValue(let v): scalars.append(v)\n    case .emptyInput: break Decode\n    case .error:\n        print(\"Decoding error\")\n        break Decode\n    }\n}\nprint(scalars)\n// Prints \"[\"\\u{2728}\", \"U\", \"n\", \"i\", \"c\", \"o\", \"d\", \"e\", \"\\u{2728}\"]\"\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/_(_:_:)-8taor",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/index/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "decode(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicodecodec/decode(_:)",
    "html": "Required\n\nParameters\ninput\n\nAn iterator of code units to be decoded. input must be the same iterator instance in repeated calls to this method. Do not advance the iterator or any copies of the iterator outside this method.\n\nReturn Value\n\nA UnicodeDecodingResult instance, representing the next Unicode scalar, an indication of an error, or an indication that the UTF sequence has been fully decoded.\n\nDiscussion\n\nTo decode a code unit sequence completely, call this method repeatedly until it returns UnicodeDecodingResult.emptyInput. Checking that the iterator was exhausted is not sufficient, because the decoder can store buffered data from the input iterator.\n\nBecause of buffering, it is impossible to find the corresponding position in the iterator for a given returned Unicode.Scalar or an error.\n\nThe following example decodes the UTF-8 encoded bytes of a string into an array of Unicode.Scalar instances:\n\nlet str = \"✨Unicode✨\"\nprint(Array(str.utf8))\n// Prints \"[226, 156, 168, 85, 110, 105, 99, 111, 100, 101, 226, 156, 168]\"\n\n\nvar bytesIterator = str.utf8.makeIterator()\nvar scalars: [Unicode.Scalar] = []\nvar utf8Decoder = UTF8()\nDecode: while true {\n    switch utf8Decoder.decode(&bytesIterator) {\n    case .scalarValue(let v): scalars.append(v)\n    case .emptyInput: break Decode\n    case .error:\n        print(\"Decoding error\")\n        break Decode\n    }\n}\nprint(scalars)\n// Prints \"[\"\\u{2728}\", \"U\", \"n\", \"i\", \"c\", \"o\", \"d\", \"e\", \"\\u{2728}\"]\"\n"
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicodecodec/init()",
    "html": "Required"
  },
  {
    "title": "encode(_:into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicodecodec/encode(_:into:)",
    "html": "Required\n\nParameters\ninput\n\nThe Unicode scalar value to encode.\n\nprocessCodeUnit\n\nA closure that processes one code unit argument at a time.\n\nDiscussion\n\nFor example, the musical fermata symbol (“𝄐”) is a single Unicode scalar value (\\u{1D110}) but requires four code units for its UTF-8 representation. The following code uses the UTF8 codec to encode a fermata in UTF-8:\n\nvar bytes: [UTF8.CodeUnit] = []\nUTF8.encode(\"𝄐\", into: { bytes.append($0) })\nprint(bytes)\n// Prints \"[240, 157, 132, 144]\"\n"
  },
  {
    "title": "init(arrayLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/init(arrayliteral:)",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector. scalars must have the same number of elements as the vector type."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/*=(_:_:)-4iyd7",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/-(_:_:)-59rjl",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": ".!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/'.!=(_:_:)-70nnx",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] != b[i]\n}\n"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/localizationvalue/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "withUnsafeMutablePointerToHeader(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/managedbuffer/withunsafemutablepointertoheader(_:)",
    "html": "Discussion\n\nNote\n\nThis pointer is valid only for the duration of the call to body."
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/-(_:_:)-8vs0w",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/-=(_:_:)-5eh2w",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/-(_:_:)-5rdme",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/+(_:_:)-62rmr",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/+(_:_:)-1h7vz",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/*=(_:_:)-27n78",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": ".==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/'.==(_:_:)-862bq",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] == b[i]\n}\n"
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/*(_:_:)-4lqdj",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "localizedStandard | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/comparator/localizedstandard",
    "html": "Discussion\n\nUses a localized, numeric comparison in the current locale.\n\nThe default String.Comparator used in String comparisons."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/localizationvalue/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/'...(_:)-53ydx",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "withUnsafeMutablePointerToElements(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/managedbuffer/withunsafemutablepointertoelements(_:)",
    "html": "Discussion\n\nNote\n\nThis pointer is valid only for the duration of the call to body."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/_=(_:_:)-9z65w",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "capacity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/managedbuffer/capacity",
    "html": "Discussion\n\nThis header may be nontrivial to compute; it is usually a good idea to store this information in the “header” area when an instance is created."
  },
  {
    "title": "withUnsafeMutablePointers(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/managedbuffer/withunsafemutablepointers(_:)",
    "html": "Discussion\n\nNote\n\nThese pointers are valid only for the duration of the call to body."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/'...(_:)-26k07",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/_=(_:_:)-3zh7l",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/-=(_:_:)-8oxw3",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/+=(_:_:)-3itnf",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/+(_:_:)-842lq",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/+=(_:_:)-4kfxk",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "BidirectionalCollection Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/bidirectionalcollection-implementations",
    "html": "Topics\nStructures\nstruct Index\nA position of a character or code unit in a string.\nInstance Properties\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nvar last: Self.Element?\nThe last element of the collection.\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nInstance Methods\nfunc difference<C>(from: C) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection.\nAvailable when Element conforms to Equatable.\nfunc difference<C>(from: C, by: (C.Element, Self.Element) -> Bool) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc reversed() -> ReversedCollection<Self>\nReturns a view presenting the elements of the collection in reverse order.\nfunc suffix(Int) -> Self.SubSequence\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nSubscripts\nsubscript(Range<String.Index>) -> Substring\nAccesses a contiguous subrange of the collection’s elements.\nsubscript(String.Index) -> Character\nAccesses the character at the given position."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/!=(_:_:)-1bb05",
    "html": "See Also\nComparing Strings Using Operators\nstatic func == (String, String) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nstatic func == <RHS>(Self, RHS) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nstatic func != <RHS>(Self, RHS) -> Bool\nstatic func ~= (String, Substring) -> Bool"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "init(unicodeScalarLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/localizationvalue/init(unicodescalarliteral:)",
    "html": "Parameters\nvalue\n\nThe value of the new instance."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "~=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/~=(_:_:)",
    "html": "See Also\nComparing Strings Using Operators\nstatic func == (String, String) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nstatic func == <RHS>(Self, RHS) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nstatic func != (Self, Self) -> Bool\nstatic func != <RHS>(Self, RHS) -> Bool"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/map(_:)-qb74",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/*(_:_:)-6kum2",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/_(_:_:)-3fyv7",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd4/*(_:_:)-50g1c",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "EntityIdentifierConvertible Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/entityidentifierconvertible-implementations",
    "html": "Topics\nInstance Properties\nvar entityIdentifierString: String\nThe AppEntity’s identifier value as a String.\nType Methods\nstatic func entityIdentifier(for: String) -> String?\nIdentifiers should be able to initialize via a String format."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/index/_(_:_:)-3k5dv",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "header | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/managedbuffer/header",
    "html": "Discussion\n\nDuring instance creation, in particular during ManagedBuffer.create’s call to initialize, ManagedBuffer’s header property is as-yet uninitialized, and therefore reading the header property during ManagedBuffer.create is undefined."
  },
  {
    "title": "Hashable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/hashable-implementations",
    "html": "Topics\nInstance Properties\nvar hashValue: Int\nThe hash value.\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/removesubrange(_:)-9twng",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/'...(_:)-8ba8y",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/'...(_:)-9mz14",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/_(_:_:)-9hg6k",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/_=(_:_:)-5m6n5",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/_(_:_:)-3rwk8",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/_=(_:_:)-7wk7h",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/endindex",
    "html": "Discussion\n\nWhen you need a range that includes the last element of a collection, use the half-open range operator (..<) with endIndex. The ..< operator creates a range that doesn’t include the upper bound, so it’s always safe to use with endIndex. For example:\n\nlet numbers = [10, 20, 30, 40, 50]\nif let index = numbers.firstIndex(of: 30) {\n    print(numbers[index ..< numbers.endIndex])\n}\n// Prints \"[30, 40, 50]\"\n\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/startindex",
    "html": "Discussion\n\nIf the collection is empty, startIndex is equal to endIndex."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/map(_:)-9ae8w",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/subscript(_:)-2f48f",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/subscript(_:)-smvg",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "String.IndexDistance | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/indexdistance",
    "html": "Deprecated\n\nAll index distances are now of type Int\n\nDiscussion\n\nIn Swift, reachability refers to the ability to produce one value from the other through zero or more applications of index(after:)."
  },
  {
    "title": "decodeCString(_:as:repairingInvalidCodeUnits:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/decodecstring(_:as:repairinginvalidcodeunits:)-2l7u6",
    "html": "Deprecated\n\nUse String(_ scalar: Unicode.Scalar)"
  },
  {
    "title": "decodeCString(_:as:repairingInvalidCodeUnits:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/decodecstring(_:as:repairinginvalidcodeunits:)-9pdmv",
    "html": "Deprecated\n\nUse a copy of the String argument"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/flatmap(_:)-4cccc",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "RegexComponent Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/regexcomponent-implementations",
    "html": "Topics\nInstance Properties\nvar regex: Regex<String.Output>\nThe regular expression represented by this component.\nType Aliases\ntypealias RegexOutput\nThe output type for this regular expression."
  },
  {
    "title": "init(extendedGraphemeClusterLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/localizationvalue/init(extendedgraphemeclusterliteral:)",
    "html": "Parameters\nvalue\n\nThe value of the new instance."
  },
  {
    "title": "remove(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/remove(at:)-5g0wm",
    "html": "Parameters\nposition\n\nThe position of the element to remove. position must be a valid index of the collection that is not equal to the collection’s end index.\n\nReturn Value\n\nThe removed element.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes the middle element from an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.6]\nlet removed = measurements.remove(at: 2)\nprint(measurements)\n// Prints \"[1.2, 1.5, 1.2, 1.6]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "insert(contentsOf:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/insert(contentsof:at:)-rdu9",
    "html": "Parameters\nnewElements\n\nThe new elements to insert into the collection.\n\ni\n\nThe position at which to insert the new elements. index must be a valid index of the collection.\n\nDiscussion\n\nThe new elements are inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new elements are appended to the collection.\n\nHere’s an example of inserting a range of integers into an array of the same type:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(contentsOf: 100...103, at: 3)\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 101, 102, 103, 4, 5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If i == endIndex, this method is equivalent to append(contentsOf:).\n\nSee Also\nInserting Characters\nfunc insert(Character, at: String.Index)\nInserts a new character at the specified position.\nfunc insert(Self.Element, at: Self.Index)\nInserts a new element into the collection at the specified position.\nfunc insert<S>(contentsOf: S, at: String.Index)\nInserts a collection of characters at the specified position."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "CustomStringConvertible Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/customstringconvertible-implementations",
    "html": "Topics\nInstance Properties\nvar description: String\nThe value of this string."
  },
  {
    "title": "CodingKeyRepresentable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/codingkeyrepresentable-implementations",
    "html": "Topics\nInitializers\ninit?<T>(codingKey: T)\nInstance Properties\nvar codingKey: CodingKey"
  },
  {
    "title": "Collection Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/collection-implementations",
    "html": "Topics\nStructures\nstruct Iterator\nA type that provides the collection’s iteration interface and encapsulates its iteration state.\nInstance Properties\nvar count: Int\nThe number of characters in a string.\nvar first: Self.Element?\nThe first element of the collection.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>.\nvar isEmpty: Bool\nA Boolean value indicating whether a string has no characters.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection.\nInstance Methods\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc makeIterator() -> String.Iterator\nReturns an iterator over the elements of the collection.\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc prefix(Int) -> Self.SubSequence\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc randomElement() -> Self.Element?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> Self.Element?\nReturns a random element of the collection, using the given generator as a source for randomness.\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (Self.Element) throws -> Bool) rethrows -> [Self.SubSequence]\nReturns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.\nfunc split(separator: Self.Element, maxSplits: Int, omittingEmptySubsequences: Bool) -> [Self.SubSequence]\nReturns the longest possible subsequences of the collection, in order, around elements equal to the given element.\nAvailable when Element conforms to Equatable.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection.\nSubscripts\nsubscript((UnboundedRange_) -> ()) -> Self.SubSequence\nsubscript<R>(R) -> Self.SubSequence\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nType Aliases\ntypealias Indices\nA type that represents the indices that are valid for subscripting the collection, in ascending order.\ntypealias SubSequence\nA collection representing a contiguous subrange of this collection’s elements. The subsequence shares indices with the original collection."
  },
  {
    "title": "Comparable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/comparable-implementations",
    "html": "Topics\nOperators\nstatic func ... (Self) -> PartialRangeThrough<Self>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Self) -> PartialRangeFrom<Self>\nReturns a partial range extending upward from a lower bound.\nstatic func ... (Self, Self) -> ClosedRange<Self>\nReturns a closed range that contains both of its bounds.\nstatic func ..< (Self) -> PartialRangeUpTo<Self>\nReturns a partial range up to, but not including, its upper bound.\nstatic func ..< (Self, Self) -> Range<Self>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func < (String, String) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than that of the second argument.\nstatic func > (Self, Self) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func > <RHS>(Self, RHS) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.\nstatic func < <RHS>(Self, RHS) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than that of the second argument.\nstatic func <= (Self, Self) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func <= <RHS>(Self, RHS) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.\nstatic func >= (Self, Self) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.\nstatic func >= <RHS>(Self, RHS) -> Bool\nReturns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument."
  },
  {
    "title": "CustomReflectable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/customreflectable-implementations",
    "html": "Topics\nInstance Properties\nvar customMirror: Mirror\nA mirror that reflects the String instance."
  },
  {
    "title": "Encodable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/encodable-implementations",
    "html": "Topics\nInstance Methods\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder."
  },
  {
    "title": "ExpressibleByStringInterpolation Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/expressiblebystringinterpolation-implementations",
    "html": "Topics\nInitializers\ninit(stringInterpolation: DefaultStringInterpolation)\nCreates a new instance from an interpolated string literal.\ninit(stringInterpolation: DefaultStringInterpolation)\nCreates a new instance from an interpolated string literal.\nAvailable when StringInterpolation is DefaultStringInterpolation.\nType Aliases\ntypealias StringInterpolation\nThe type each segment of a string literal containing interpolations should be appended to."
  },
  {
    "title": "Equatable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nstatic func == <RHS>(Self, RHS) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nstatic func == (String, String) -> Bool\nReturns a Boolean value indicating whether two values are equal."
  },
  {
    "title": "ExpressibleByExtendedGraphemeClusterLiteral Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/expressiblebyextendedgraphemeclusterliteral-implementations",
    "html": "Topics\nInitializers\ninit(extendedGraphemeClusterLiteral: Self.StringLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.StringLiteralType.\nType Aliases\ntypealias ExtendedGraphemeClusterLiteralType\nA type that represents an extended grapheme cluster literal."
  },
  {
    "title": "ExpressibleByStringLiteral Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/expressiblebystringliteral-implementations",
    "html": "Topics\nInitializers\ninit(stringLiteral: String)\nCreates an instance initialized to the given string value.\nType Aliases\ntypealias StringLiteralType\nA type that represents a string literal."
  },
  {
    "title": "RangeReplaceableCollection Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/rangereplaceablecollection-implementations",
    "html": "Topics\nOperators\nstatic func + <Other>(Other, Self) -> Self\nCreates a new collection by concatenating the elements of a sequence and a collection.\nstatic func + <Other>(Self, Other) -> Self\nCreates a new collection by concatenating the elements of two collections.\nstatic func + <Other>(Self, Other) -> Self\nCreates a new collection by concatenating the elements of a collection and a sequence.\nstatic func += <Other>(inout Self, Other)\nAppends the elements of a sequence to a range-replaceable collection.\nInitializers\ninit<S>(S)\nCreates a new instance of a collection containing the elements of a sequence.\ninit<S>(S)\nCreates a new string containing the characters in the given sequence.\ninit(repeating: Character, count: Int)\nCreates a string representing the given character repeated the specified number of times.\ninit(repeating: Self.Element, count: Int)\nCreates a new collection containing the specified number of a single, repeated value.\nInstance Methods\nfunc append(Self.Element)\nAdds an element to the end of the collection.\nfunc append(Character)\nAppends the given character to the string.\nfunc append<S>(contentsOf: S)\nAppends the characters in the given sequence to the string.\nfunc append<S>(contentsOf: S)\nAdds the elements of a sequence or collection to the end of this collection.\nfunc applying(CollectionDifference<Self.Element>) -> Self?\nApplies the given difference to this collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc insert(Character, at: String.Index)\nInserts a new character at the specified position.\nfunc insert(Self.Element, at: Self.Index)\nInserts a new element into the collection at the specified position.\nfunc insert<S>(contentsOf: S, at: String.Index)\nInserts a collection of characters at the specified position.\nfunc insert<C>(contentsOf: C, at: Self.Index)\nInserts the elements of a sequence into the collection at the specified position.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nRemoves all elements from the collection.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc replaceSubrange<C>(Range<String.Index>, with: C)\nReplaces the text within the specified bounds with the given characters.\nfunc replaceSubrange<C>(Range<Self.Index>, with: C)\nReplaces the specified subrange of elements with the given collection.\nDeprecated\nfunc replaceSubrange<C, R>(R, with: C)\nReplaces the specified subrange of elements with the given collection.\nfunc reserveCapacity(Int)\nReserves enough space in the string’s underlying storage to store the specified number of ASCII characters.\nfunc reserveCapacity(Int)\nPrepares the collection to store the specified number of elements, when doing so is appropriate for the underlying type."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/==(_:_:)-8kzxf",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false.\n\nSee Also\nComparing Strings Using Operators\nstatic func == (String, String) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nstatic func != (Self, Self) -> Bool\nstatic func != <RHS>(Self, RHS) -> Bool\nstatic func ~= (String, Substring) -> Bool"
  },
  {
    "title": "ExpressibleByUnicodeScalarLiteral Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/expressiblebyunicodescalarliteral-implementations",
    "html": "Topics\nInitializers\ninit(unicodeScalarLiteral: Self.ExtendedGraphemeClusterLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.UnicodeScalarLiteralType.\nType Aliases\ntypealias UnicodeScalarLiteralType\nA type that represents a Unicode scalar literal."
  },
  {
    "title": "LosslessStringConvertible Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/losslessstringconvertible-implementations",
    "html": "Topics\nInitializers\ninit<S>(S)\nCreates a new string containing the characters in the given sequence."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/poplast()",
    "html": "Return Value\n\nThe last element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements."
  },
  {
    "title": "uppercased() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/uppercased()",
    "html": "Return Value\n\nAn uppercase copy of the string.\n\nDiscussion\n\nThe following example transforms a string to uppercase letters:\n\nlet cafe = \"Café 🍵\"\nprint(cafe.uppercased())\n// Prints \"CAFÉ 🍵\"\n\n\nComplexity\n\nO(n)\n\nSee Also\nChanging Case\nfunc lowercased() -> String\nReturns a lowercase version of the string."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/removesubrange(_:)-8y51u",
    "html": "Parameters\nbounds\n\nThe range of the elements to remove. The upper and lower bounds of bounds must be valid indices of the string and not equal to the string’s end index.\n\nbounds\n\nThe range of the elements to remove. The upper and lower bounds of bounds must be valid indices of the string.\n\nDiscussion\n\nCalling this method invalidates any existing indices for use with this string.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/removesubrange(_:)-8maxn",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned collection.\n\nReturn Value\n\nA collection of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "insert(contentsOf:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/insert(contentsof:at:)-4may",
    "html": "Parameters\nnewElements\n\nA collection of Character elements to insert into the string.\n\ni\n\nA valid index of the string. If i is equal to the string’s end index, this methods appends the contents of newElements to the string.\n\nDiscussion\n\nCalling this method invalidates any existing indices for use with this string.\n\nComplexity\n\nO(n), where n is the combined length of the string and newElements.\n\nSee Also\nInserting Characters\nfunc insert(Character, at: String.Index)\nInserts a new character at the specified position.\nfunc insert(Self.Element, at: Self.Index)\nInserts a new element into the collection at the specified position.\nfunc insert<C>(contentsOf: C, at: Self.Index)\nInserts the elements of a sequence into the collection at the specified position."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/subscript(_:)-60hc1",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nOverview\n\nThe following example accesses an element of an array through its subscript to print its value:\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nprint(streets[1])\n// Prints \"Bryant\"\n\n\nYou can subscript a collection with any valid index other than the collection’s end index. The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "AnyRegexOutput.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "AnyRegexOutput.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "AnyRegexOutput.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyhashable/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/replacesubrange(_:with:)-1wyxa",
    "html": "Parameters\nbounds\n\nThe range of text to replace. The bounds of the range must be valid indices of the string.\n\nnewElements\n\nThe new characters to add to the string.\n\nDiscussion\n\nCalling this method invalidates any existing indices for use with this string.\n\nComplexity\n\nO(m), where m is the combined length of the string and newElements. If the call to replaceSubrange(_:with:) simply removes text at the end of the string, the complexity is O(n), where n is equal to bounds.count.\n\nSee Also\nReplacing Substrings\nfunc replaceSubrange<C, R>(R, with: C)\nReplaces the specified subrange of elements with the given collection."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/replacesubrange(_:with:)-72947",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, the complexity is O(m).\n\nSee Also\nReplacing Substrings\nfunc replaceSubrange<C>(Range<String.Index>, with: C)\nReplaces the text within the specified bounds with the given characters."
  },
  {
    "title": "removeAll(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/removeall(where:)",
    "html": "Parameters\nshouldBeRemoved\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.\n\nDiscussion\n\nUse this method to remove every element in a collection that meets particular criteria. The order of the remaining elements is preserved. This example removes all the vowels from a string:\n\nvar phrase = \"The rain in Spain stays mainly in the plain.\"\n\n\nlet vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nphrase.removeAll(where: { vowels.contains($0) })\n// phrase == \"Th rn n Spn stys mnly n th pln.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "remove(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/remove(at:)-4n29z",
    "html": "Parameters\ni\n\nThe position of the character to remove. i must be a valid index of the string that is not equal to the string’s end index.\n\nReturn Value\n\nThe character that was removed.\n\nDiscussion\n\nAll the elements following i are moved to close the gap. This example removes the hyphen from the middle of a string.\n\nvar nonempty = \"non-empty\"\nif let i = nonempty.firstIndex(of: \"-\") {\n    nonempty.remove(at: i)\n}\nprint(nonempty)\n// Prints \"nonempty\"\n\n\nCalling this method invalidates any existing indices for use with this string.\n\nSee Also\nRemoving Substrings\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/split(separator:maxsplits:omittingemptysubsequences:)-rqw4",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/removelast()",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "removeAll(keepingCapacity:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/removeall(keepingcapacity:)-b1dr",
    "html": "Parameters\nkeepCapacity\n\nPass true to prevent the release of the string’s allocated storage. Retaining the storage can be a useful optimization when you’re planning to grow the string again. The default value is false.\n\nDiscussion\n\nCalling this method invalidates any existing indices for use with this string.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/removefirst()",
    "html": "Return Value\n\nThe removed element.\n\nDiscussion\n\nThe collection must not be empty.\n\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst()\nprint(bugs)\n// Prints \"[\"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/removefirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst(3)\nprint(bugs)\n// Prints \"[\"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/removelast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(k), where k is the specified number of elements.\n\nSee Also\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection."
  },
  {
    "title": "insert(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/insert(_:at:)-1uqvy",
    "html": "Parameters\nnewElement\n\nThe new character to insert into the string.\n\ni\n\nA valid index of the string. If i is equal to the string’s end index, this methods appends newElement to the string.\n\nDiscussion\n\nCalling this method invalidates any existing indices for use with this string.\n\nComplexity\n\nO(n), where n is the length of the string.\n\nSee Also\nInserting Characters\nfunc insert(Self.Element, at: Self.Index)\nInserts a new element into the collection at the specified position.\nfunc insert<C>(contentsOf: C, at: Self.Index)\nInserts the elements of a sequence into the collection at the specified position.\nfunc insert<S>(contentsOf: S, at: String.Index)\nInserts a collection of characters at the specified position."
  },
  {
    "title": "insert(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/insert(_:at:)-88yqh",
    "html": "Parameters\nnewElement\n\nThe new element to insert into the collection.\n\ni\n\nThe position at which to insert the new element. index must be a valid index into the collection.\n\nDiscussion\n\nThe new element is inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new element is appended to the collection.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(100, at: 3)\nnumbers.insert(200, at: numbers.endIndex)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 4, 5, 200]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection. If i == endIndex, this method is equivalent to append(_:).\n\nSee Also\nInserting Characters\nfunc insert(Character, at: String.Index)\nInserts a new character at the specified position.\nfunc insert<C>(contentsOf: C, at: Self.Index)\nInserts the elements of a sequence into the collection at the specified position.\nfunc insert<S>(contentsOf: S, at: String.Index)\nInserts a collection of characters at the specified position."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/+=(_:_:)-676gx",
    "html": "Parameters\nlhs\n\nThe array to append to.\n\nrhs\n\nA collection or finite sequence.\n\nDiscussion\n\nUse this operator to append the elements of a sequence to the end of range-replaceable collection with same Element type. This example appends the elements of a Range<Int> instance to an array of integers.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers += 10...15\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]\"\n\n\nComplexity\n\nO(m), where m is the length of the right-hand-side argument.\n\nSee Also\nAppending Strings and Characters\nfunc append(String)\nAppends the given string to this string.\nfunc append(Character)\nAppends the given character to the string.\nfunc append(contentsOf: String)\nfunc append(contentsOf: Substring)\nfunc append<S>(contentsOf: S)\nAppends the characters in the given sequence to the string.\nfunc append<S>(contentsOf: S)\nAdds the elements of a sequence or collection to the end of this collection.\nfunc reserveCapacity(Int)\nReserves enough space in the string’s underlying storage to store the specified number of ASCII characters.\nstatic func + (String, String) -> String\nstatic func += (inout String, String)\nstatic func + <Other>(Other, Self) -> Self\nCreates a new collection by concatenating the elements of a sequence and a collection.\nstatic func + <Other>(Self, Other) -> Self\nCreates a new collection by concatenating the elements of a collection and a sequence.\nstatic func + <Other>(Self, Other) -> Self\nCreates a new collection by concatenating the elements of two collections."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/filter(_:)",
    "html": "Discussion\n\nNote\n\nThe elements of the result are computed on-demand, as the result is used. No buffering storage is allocated and each traversal step invokes predicate on one or more underlying elements."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false otherwise. Once predicate returns false it will not be called again."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/flatmap(_:)-907vo",
    "html": "Discussion\n\nUse this method to receive a single-level sequence when your transformation produces a sequence or collection for each element. Calling flatMap(_:) on a sequence s is equivalent to calling s.map(transform).joined().\n\nComplexity\n\nO(1)"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyhashable/==(_:_:)",
    "html": "Parameters\nlhs\n\nA type-erased hashable value.\n\nrhs\n\nAnother type-erased hashable value.\n\nDiscussion\n\nAnyHashable considers bridged counterparts (such as a String and an NSString) of the same value to be equivalent when type-erased. If those compatible types use different definitions for equality, values that were originally distinct might compare as equal when they are converted to AnyHashable:\n\nlet string1 = \"café\"\nlet string2 = \"cafe\\u{301}\" // U+301 COMBINING ACUTE ACCENT\nlet nsString1 = string1 as NSString\nlet nsString2 = string2 as NSString\nlet typeErased1 = nsString1 as AnyHashable\nlet typeErased2 = nsString2 as AnyHashable\nprint(string1 == string2)         // prints \"true\"\nprint(nsString1 == nsString2)     // prints \"false\"\nprint(typeErased1 == typeErased2) // prints \"true\"\n"
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/==(_:_:)-9812z",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false.\n\nSee Also\nComparing Strings Using Operators\nstatic func == <RHS>(Self, RHS) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nstatic func != (Self, Self) -> Bool\nstatic func != <RHS>(Self, RHS) -> Bool\nstatic func ~= (String, Substring) -> Bool"
  },
  {
    "title": "lowercased() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/lowercased()",
    "html": "Return Value\n\nA lowercase copy of the string.\n\nDiscussion\n\nHere’s an example of transforming a string to all lowercase letters.\n\nlet cafe = \"BBQ Café 🍵\"\nprint(cafe.lowercased())\n// Prints \"bbq café 🍵\"\n\n\nComplexity\n\nO(n)\n\nSee Also\nChanging Case\nfunc uppercased() -> String\nReturns an uppercase version of the string."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "LazyPrefixWhileSequence.Elements | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/elements-swift.typealias",
    "html": "Discussion\n\nSee also: elements"
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false otherwise. Once predicate returns false it will not be called again."
  },
  {
    "title": "MLDataValueConvertible Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/mldatavalueconvertible-implementations",
    "html": "Topics\nInitializers\ninit?(from: MLDataValue)\nCreates an instance of the conforming type from a data value.\nInstance Properties\nvar dataValue: MLDataValue\nThe value of the conforming type’s instance wrapped in a data value.\nType Properties\nstatic var dataValueType: MLDataValue.ValueType\nThe underlying type the conforming type uses when it wraps itself in a data value."
  },
  {
    "title": "MLIdentifier Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/mlidentifier-implementations",
    "html": "Topics\nInstance Properties\nvar identifierValue: MLDataValue\nThe value of the unique identifier wrapped in a data value."
  },
  {
    "title": "CustomDebugStringConvertible Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/customdebugstringconvertible-implementations",
    "html": "Topics\nInstance Properties\nvar debugDescription: String\nA representation of the string that is suitable for debugging."
  },
  {
    "title": "Decodable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/decodable-implementations",
    "html": "Topics\nInitializers\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/fixedwidthinteger/&__(_:_:)-6o5at",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/fixedwidthinteger/&__(_:_:)-6pggx",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/fixedwidthinteger/&__(_:_:)-1dnt",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/flatmap(_:)-1qive",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/subscript(_:)-5ta1h",
    "html": "Parameters\nposition\n\nA valid index of the view. position must be less than the view’s end index.\n\nOverview\n\nThe following example uses the subscript to print the value of a string’s first UTF-16 code unit.\n\nlet greeting = \"Hello, friend!\"\nlet i = greeting.utf16.startIndex\nprint(\"First character's UTF-16 code unit: \\(greeting.utf16[i])\")\n// Prints \"First character's UTF-16 code unit: 72\"\n"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/subscript(_:)-5fneh",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyhashable/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "AnyRegexOutput.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/element",
    "html": "Topics\nInstance Properties\nvar name: String?\nThe name of this capture, if the capture is named.\nvar range: Range<String.Index>?\nThe range over which a value was captured, if there was a capture.\nvar substring: Substring?\nThe slice of the input which was captured, if there was a capture.\nvar type: Any.Type\nThe type of this capture.\nvar value: Any?\nThe captured value, if there was a capture."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/customplaygroundquicklook",
    "html": "Discussion\n\nIf this type has value semantics, the PlaygroundQuickLook instance should be unaffected by subsequent mutations."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/flatmap(_:)-8pzjy",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/compactmap(_:)-2xgdq",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "StaticString.ExtendedGraphemeClusterLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticstring/extendedgraphemeclusterliteraltype",
    "html": "Discussion\n\nValid types for ExtendedGraphemeClusterLiteralType are Character, String, and StaticString."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/endindex",
    "html": "Discussion\n\nIn an empty UTF-16 view, endIndex is equal to startIndex."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyhashable/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/'...(_:)-5e4wo",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticstring/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/_(_:_:)-1fc79",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/_(_:_:)-95v6o",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/'...(_:)-63ber",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/_=(_:_:)-divd",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "init(bigEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/fixedwidthinteger/init(bigendian:)-7m4au",
    "html": "Parameters\nvalue\n\nA value to use as the big-endian representation of the new integer."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "bigEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/fixedwidthinteger/bigendian-3he9",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a big-endian platform, for any integer x, x == x.bigEndian."
  },
  {
    "title": "&<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/fixedwidthinteger/&__=(_:_:)-5s3cx",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &<<= operator performs a masking shift, where the value used as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &<<= 2\n// x == 120                       // 0b01111000\n\n\nHowever, if you pass 19 as rhs, the method first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &<<= 19\n// y == 240                       // 0b11110000\n"
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/fixedwidthinteger/&__(_:_:)-9b5yu",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/fixedwidthinteger/&__=(_:_:)-k22q",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &>>= operator performs a masking shift, where the value passed as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &>>= 2\n// x == 7                         // 0b00000111\n\n\nHowever, if you use 19 as rhs, the operation first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &>>= 19\n// y == 3                         // 0b00000011\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/map(_:)-brz6",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16view/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdmask/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "addingProduct(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/addingproduct(_:_:)-81yl5",
    "html": "Parameters\nlhs\n\nOne of the values to multiply before adding to this value.\n\nrhs\n\nThe other value to multiply.\n\nReturn Value\n\nThe product of lhs and rhs, added to this value.\n\nDiscussion\n\nThis method is equivalent to the C fma function and implements the fusedMultiplyAdd operation defined by the IEEE 754 specification."
  },
  {
    "title": "init(stringLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticstring/init(stringliteral:)",
    "html": "Discussion\n\nDo not call this initializer directly. It may be used by the compiler when you initialize a static string using a string literal."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/joined(separator:)-9atxk",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/index/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyhashable/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyhashable/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "init(extendedGraphemeClusterLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticstring/init(extendedgraphemeclusterliteral:)-14kgw",
    "html": "Parameters\nvalue\n\nThe value of the new instance."
  },
  {
    "title": "init(extendedGraphemeClusterLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticstring/init(extendedgraphemeclusterliteral:)-1c0e7",
    "html": "Discussion\n\nDo not call this initializer directly. It may be used by the compiler when you initialize a static string using an extended grapheme cluster."
  },
  {
    "title": "ulpOfOne | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/ulpofone-3j2pj",
    "html": "Discussion\n\nThe positive difference between 1.0 and the next greater representable number. ulpOfOne corresponds to the value represented by the C macros FLT_EPSILON, DBL_EPSILON, etc, and is sometimes called epsilon or machine epsilon. Swift deliberately avoids using the term “epsilon” because:\n\nHistorically “epsilon” has been used to refer to several different concepts in different languages, leading to confusion and bugs.\n\nThe name “epsilon” suggests that this quantity is a good tolerance to choose for approximate comparisons, but it is almost always unsuitable for that purpose.\n\nSee also the ulp member property."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "radix | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/radix-322z3",
    "html": "Discussion\n\nThe magnitude of a floating-point value x of type F can be calculated by using the following formula, where ** is exponentiation:\n\nx.significand * (F.radix ** x.exponent)\n\n\nA conforming type may use any integer radix, but values other than 2 (for binary floating-point types) or 10 (for decimal floating-point types) are extraordinarily rare in practice."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/_=(_:_:)-7vu9w",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/_=(_:_:)-2htxd",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/closedrange/index/_=(_:_:)-52920",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/_(_:_:)-8kchc",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "littleEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/fixedwidthinteger/littleendian-13phi",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a little-endian platform, for any integer x, x == x.littleEndian."
  },
  {
    "title": "multipliedFullWidth(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/fixedwidthinteger/multipliedfullwidth(by:)-3n598",
    "html": "Parameters\nother\n\nThe value to multiply this value by.\n\nReturn Value\n\nA tuple containing the high and low parts of the result of multiplying this value and other.\n\nDiscussion\n\nUse this method to calculate the full result of a product that would otherwise overflow. Unlike traditional truncating multiplication, the multipliedFullWidth(by:) method returns a tuple containing both the high and low parts of the product of this value and other. The following example uses this method to multiply two Int8 values that normally overflow when multiplied:\n\nlet x: Int8 = 48\nlet y: Int8 = -40\nlet result = x.multipliedFullWidth(by: y)\n// result.high == -8\n// result.low  == 128\n\n\nThe product of x and y is -1920, which is too large to represent in an Int8 instance. The high and low components of the result value represent -1920 when concatenated to form a double-width integer; that is, using result.high as the high byte and result.low as the low byte of an Int16 instance.\n\nlet z = Int16(result.high) << 8 | Int16(result.low)\n// z == -1920\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/_(_:_:)-7sv3e",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "init(littleEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/fixedwidthinteger/init(littleendian:)-16nn4",
    "html": "Parameters\nvalue\n\nA value to use as the little-endian representation of the new integer."
  },
  {
    "title": "nextDown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/nextdown-92vef",
    "html": "Discussion\n\nFor any finite value x, x.nextDown is less than x. For nan or -infinity, x.nextDown is x itself. The following special cases also apply:\n\nIf x is infinity, then x.nextDown is greatestFiniteMagnitude.\n\nIf x is leastNonzeroMagnitude, then x.nextDown is 0.0.\n\nIf x is zero, then x.nextDown is -leastNonzeroMagnitude.\n\nIf x is -greatestFiniteMagnitude, then x.nextDown is -infinity."
  },
  {
    "title": "isTotallyOrdered(belowOrEqualTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/istotallyordered(beloworequalto:)-itx6",
    "html": "Parameters\nother\n\nA floating-point value to compare to this value.\n\nReturn Value\n\ntrue if this value is ordered below or the same as other in a total ordering of the floating-point type; otherwise, false.\n\nDiscussion\n\nThis relation is a refinement of the less-than-or-equal-to operator (<=) that provides a total order on all values of the type, including signed zeros and NaNs.\n\nThe following example uses isTotallyOrdered(belowOrEqualTo:) to sort an array of floating-point values, including some that are NaN:\n\nvar numbers = [2.5, 21.25, 3.0, .nan, -9.5]\nnumbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }\nprint(numbers)\n// Prints \"[-9.5, 2.5, 3.0, 21.25, nan]\"\n\n\nThe isTotallyOrdered(belowOrEqualTo:) method implements the total order relation as defined by the IEEE 754 specification."
  },
  {
    "title": "remainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/remainder(dividingby:)-15z1e",
    "html": "Parameters\nother\n\nThe value to use when dividing this value.\n\nReturn Value\n\nThe remainder of this value divided by other.\n\nDiscussion\n\nFor two finite values x and y, the remainder r of dividing x by y satisfies x == y * q + r, where q is the integer nearest to x / y. If x / y is exactly halfway between two integers, q is chosen to be even. Note that q is not x / y computed in floating-point arithmetic, and that q may not be representable in any available integer type.\n\nThe following example calculates the remainder of dividing 8.625 by 0.75:\n\nlet x = 8.625\nprint(x / 0.75)\n// Prints \"11.5\"\n\n\nlet q = (x / 0.75).rounded(.toNearestOrEven)\n// q == 12.0\nlet r = x.remainder(dividingBy: 0.75)\n// r == -0.375\n\n\nlet x1 = 0.75 * q + r\n// x1 == 8.625\n\n\nIf this value and other are finite numbers, the remainder is in the closed range -abs(other / 2)...abs(other / 2). The remainder(dividingBy:) method is always exact. This method implements the remainder operation defined by the IEEE 754 specification."
  },
  {
    "title": "squareRoot() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/squareroot()-7bo35",
    "html": "Return Value\n\nThe square root of the value.\n\nDiscussion\n\nThe following example declares a function that calculates the length of the hypotenuse of a right triangle given its two perpendicular sides.\n\nfunc hypotenuse(_ a: Double, _ b: Double) -> Double {\n    return (a * a + b * b).squareRoot()\n}\n\n\nlet (dx, dy) = (3.0, 4.0)\nlet distance = hypotenuse(dx, dy)\n// distance == 5.0\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryfloatingpoint/init(exactly:)-9lyid",
    "html": "Parameters\nvalue\n\nThe integer to convert to a floating-point value.\n\nDiscussion\n\nIf the given integer cannot be represented exactly, the result is nil."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryfloatingpoint/init(_:)-17tah",
    "html": "Parameters\nvalue\n\nA floating-point value to be converted.\n\nDiscussion\n\nIf two representable values are equally close, the result is the value with more trailing zeros in its significand bit pattern."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryfloatingpoint/init(exactly:)-6fobm",
    "html": "Parameters\nvalue\n\nA floating-point value to be converted.\n\nDiscussion\n\nIf the given floating-point value cannot be represented exactly, the result is nil."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryfloatingpoint/init(_:)-5p0og",
    "html": "Parameters\nvalue\n\nThe integer to convert to a floating-point value.\n\nDiscussion\n\nIf two representable values are equally close, the result is the value with more trailing zeros in its significand bit pattern."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/flatmap(_:)-37uwt",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "StaticString.UnicodeScalarLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticstring/unicodescalarliteraltype",
    "html": "Discussion\n\nValid types for UnicodeScalarLiteralType are Unicode.Scalar, Character, String, and StaticString."
  },
  {
    "title": "init(unicodeScalarLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticstring/init(unicodescalarliteral:)-6dd2p",
    "html": "Discussion\n\nDo not call this initializer directly. It may be used by the compiler when you initialize a static string with a Unicode scalar."
  },
  {
    "title": "init(unicodeScalarLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticstring/init(unicodescalarliteral:)-7ic1r",
    "html": "Parameters\nvalue\n\nThe value of the new instance."
  },
  {
    "title": "maximum(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/maximum(_:_:)-1dfa",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nThe greater of x and y, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the maximum of two values, preserving order and eliminating NaN when possible. For two values x and y, the result of maximum(x, y) is x if x > y, y if x <= y, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.maximum(10.0, -25.0)\n// 10.0\nDouble.maximum(10.0, .nan)\n// 10.0\nDouble.maximum(.nan, -25.0)\n// -25.0\nDouble.maximum(.nan, .nan)\n// nan\n\n\nThe maximum method implements the maxNum operation defined by the IEEE 754 specification."
  },
  {
    "title": "maximumMagnitude(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/maximummagnitude(_:_:)-1e1x7",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nWhichever of x or y has greater magnitude, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the value with greater magnitude of the two given values, preserving order and eliminating NaN when possible. For two values x and y, the result of maximumMagnitude(x, y) is x if x.magnitude > y.magnitude, y if x.magnitude <= y.magnitude, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.maximumMagnitude(10.0, -25.0)\n// -25.0\nDouble.maximumMagnitude(10.0, .nan)\n// 10.0\nDouble.maximumMagnitude(.nan, -25.0)\n// -25.0\nDouble.maximumMagnitude(.nan, .nan)\n// nan\n\n\nThe maximumMagnitude method implements the maxNumMag operation defined by the IEEE 754 specification."
  },
  {
    "title": "minimumMagnitude(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/minimummagnitude(_:_:)-8oqx4",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nWhichever of x or y has lesser magnitude, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the value with lesser magnitude of the two given values, preserving order and eliminating NaN when possible. For two values x and y, the result of minimumMagnitude(x, y) is x if x.magnitude <= y.magnitude, y if y.magnitude < x.magnitude, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.minimumMagnitude(10.0, -25.0)\n// 10.0\nDouble.minimumMagnitude(10.0, .nan)\n// 10.0\nDouble.minimumMagnitude(.nan, -25.0)\n// -25.0\nDouble.minimumMagnitude(.nan, .nan)\n// nan\n\n\nThe minimumMagnitude method implements the minNumMag operation defined by the IEEE 754 specification."
  },
  {
    "title": "minimum(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/minimum(_:_:)-cb9c",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nThe minimum of x and y, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the minimum of two values, preserving order and eliminating NaN when possible. For two values x and y, the result of minimum(x, y) is x if x <= y, y if y < x, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.minimum(10.0, -25.0)\n// -25.0\nDouble.minimum(10.0, .nan)\n// 10.0\nDouble.minimum(.nan, -25.0)\n// -25.0\nDouble.minimum(.nan, .nan)\n// nan\n\n\nThe minimum method implements the minNum operation defined by the IEEE 754 specification."
  },
  {
    "title": "&>>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&__=(_:_:)-9dar0",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &>>= operator performs a masking shift, where the value passed as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &>>= 2\n// x == 7                         // 0b00000111\n\n\nHowever, if you use 19 as rhs, the operation first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &>>= 19\n// y == 3                         // 0b00000011\n"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_=(_:_:)-10tl1",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than-or-equal-to operator (<=), even if the two instances are of different types."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/__(_:_:)-moua",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nFor integer types, any remainder of the division is discarded.\n\nlet x = 21 / 5\n// x == 4\n"
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/!=(_:_:)-5cims",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the inequality of instances of any BinaryInteger types using the not-equal-to operator (!=). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is not equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are different: \\(firstUTF8 != firstScalar)\")\n}\n// Prints \"First code values are different: false\"\n"
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_(_:_:)-662qp",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_=(_:_:)-41bgc",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than-or-equal-to operator (>=), even if the two instances are of different types."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdmask/init(_:)",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector.\n\nDiscussion\n\nPrecondition\n\nscalars must have the same number of elements as the vector type."
  },
  {
    "title": ".==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdmask/'.==(_:_:)-8vdyh",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] == b[i]\n}\n"
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/map(_:)-2kp3b",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "truncatingRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/truncatingremainder(dividingby:)-6ay9c",
    "html": "Parameters\nother\n\nThe value to use when dividing this value.\n\nReturn Value\n\nThe remainder of this value divided by other using truncating division.\n\nDiscussion\n\nPerforming truncating division with floating-point values results in a truncated integer quotient and a remainder. For values x and y and their truncated integer quotient q, the remainder r satisfies x == y * q + r.\n\nThe following example calculates the truncating remainder of dividing 8.625 by 0.75:\n\nlet x = 8.625\nprint(x / 0.75)\n// Prints \"11.5\"\n\n\nlet q = (x / 0.75).rounded(.towardZero)\n// q == 11.0\nlet r = x.truncatingRemainder(dividingBy: 0.75)\n// r == 0.375\n\n\nlet x1 = 0.75 * q + r\n// x1 == 8.625\n\n\nIf this value and other are both finite numbers, the truncating remainder has the same sign as this value and is strictly smaller in magnitude than other. The truncatingRemainder(dividingBy:) method is always exact."
  },
  {
    "title": "init(signOf:magnitudeOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/init(signof:magnitudeof:)-9n676",
    "html": "Parameters\nsignOf\n\nA value from which to use the sign. The result of the initializer has the same sign as signOf.\n\nmagnitudeOf\n\nA value from which to use the magnitude. The result of the initializer has the same magnitude as magnitudeOf.\n\nDiscussion\n\nThe following example uses this initializer to create a new Double instance with the sign of a and the magnitude of b:\n\nlet a = -21.5\nlet b = 305.15\nlet c = Double(signOf: a, magnitudeOf: b)\nprint(c)\n// Prints \"-305.15\"\n\n\nThis initializer implements the IEEE 754 copysign operation."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "rounded(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/rounded(_:)-rkwb",
    "html": "Parameters\nrule\n\nThe rounding rule to use.\n\nReturn Value\n\nThe integral value found by rounding using rule.\n\nDiscussion\n\nThe following example rounds a value using four different rounding rules:\n\nlet x = 6.5\n\n\n// Equivalent to the C 'round' function:\nprint(x.rounded(.toNearestOrAwayFromZero))\n// Prints \"7.0\"\n\n\n// Equivalent to the C 'trunc' function:\nprint(x.rounded(.towardZero))\n// Prints \"6.0\"\n\n\n// Equivalent to the C 'ceil' function:\nprint(x.rounded(.up))\n// Prints \"7.0\"\n\n\n// Equivalent to the C 'floor' function:\nprint(x.rounded(.down))\n// Prints \"6.0\"\n\n\nFor more information about the available rounding rules, see the FloatingPointRoundingRule enumeration. To round a value using the default “schoolbook rounding”, you can use the shorter rounded() method instead.\n\nprint(x.rounded())\n// Prints \"7.0\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "StaticString.StringLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticstring/stringliteraltype",
    "html": "Discussion\n\nValid types for StringLiteralType are String and StaticString."
  },
  {
    "title": "floatingPointClass | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpoint/floatingpointclass-2cj4n",
    "html": "Discussion\n\nA value’s floatingPointClass property describes its “class” as described by the IEEE 754 specification."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/map(_:)-6slu4",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": ".!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdmask/'.!=(_:_:)-5cnom",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] != b[i]\n}\n"
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/random(in:using:)-1n6up",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n\n\nNote\n\nThe algorithm used to create random values may change in a future version of Swift. If you’re passing a generator that results in the same sequence of integer values each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/random(in:)-5kgo1",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling random(in:using:), passing in the system’s default random generator."
  },
  {
    "title": "isSigned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/issigned",
    "html": "Discussion\n\nThis property is always true for signed integer types."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/-=(_:_:)-21yov",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/zero",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/+=(_:_:)-2acub",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "~=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangefrom/~=(_:_:)",
    "html": "Parameters\npattern\n\nA range.\n\nbound\n\nA value to match against pattern.\n\nDiscussion\n\nYou can use the pattern-matching operator (~=) to test whether a value is included in a range. The pattern-matching operator is used internally in case statements for pattern matching. The following example uses the ~= operator to test whether an integer is included in a range of single-digit numbers:\n\nlet chosenNumber = 3\nif 0..<10 ~= chosenNumber {\n    print(\"\\(chosenNumber) is a single digit.\")\n}\n// Prints \"3 is a single digit.\"\n"
  },
  {
    "title": "relative(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangefrom/relative(to:)",
    "html": "Parameters\ncollection\n\nThe collection to evaluate this range expression in relation to.\n\nReturn Value\n\nA range suitable for slicing collection. The returned range is not guaranteed to be inside the bounds of collection. Callers should apply the same preconditions to the return value as they would to a range provided directly by the user.\n\nDiscussion\n\nYou can use the relative(to:) method to convert a range expression, which could be missing one or both of its endpoints, into a concrete range that is bounded on both sides. The following example uses this method to convert a partial range up to 4 into a half-open range, using an array instance to add the range’s lower bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nlet upToFour = ..<4\n\n\nlet r1 = upToFour.relative(to: numbers)\n// r1 == 0..<4\n\n\nThe r1 range is bounded on the lower end by 0 because that is the starting index of the numbers array. When the collection passed to relative(to:) starts with a different index, that index is used as the lower bound instead. The next example creates a slice of numbers starting at index 2, and then uses the slice with relative(to:) to convert upToFour to a concrete range.\n\nlet numbersSuffix = numbers[2...]\n// numbersSuffix == [30, 40, 50, 60, 70]\n\n\nlet r2 = upToFour.relative(to: numbersSuffix)\n// r2 == 2..<4\n\n\nUse this method only if you need the concrete range it produces. To access a slice of a collection using a range expression, use the collection’s generic subscript that uses a range expression as its parameter.\n\nlet numbersPrefix = numbers[upToFour]\n// numbersPrefix == [10, 20, 30, 40]\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangefrom/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to check for containment.\n\nReturn Value\n\ntrue if element is contained in the range expression; otherwise, false."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangefrom/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangefrom/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\n2 * 3                   // 6\n100 * 21                // 2100\n-10 * 15                // -150\n3.5 * 2.25              // 7.875\n\n\nYou cannot use * with arguments of different types. To multiply values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) * y              // 21000000\n\n\nThe product of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 * 21 is greater than the maximum representable Int8 value:\n\nx * 21                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow multiplication operator (&*).\n\nx &* 21                // -115\n"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\n1 + 2                   // 3\n-10 + 15                // 5\n-15 + -5                // -20\n21.5 + 3.25             // 24.75\n\n\nYou cannot use + with arguments of different types. To add values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) + y              // 1000021\n\n\nThe sum of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 + 120 is greater than the maximum representable Int8 value:\n\nx + 120                 // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow addition operator (&+).\n\nx &+ 120                // -115\n"
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_(_:_:)-346io",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\n8 - 3                   // 5\n-10 - 5                 // -15\n100 - -5                // 105\n10.5 - 100.0            // -89.5\n\n\nYou cannot use - with arguments of different types. To subtract values of different types, convert one of the values to the other value’s type.\n\nlet x: UInt8 = 21\nlet y: UInt = 1000000\ny - UInt(x)             // 999979\n\n\nThe difference of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 - 50 is less than zero, the minimum representable UInt8 value:\n\nx - 50                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow subtraction operator (&-).\n\nx &- 50                // 227\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/==(_:_:)-exky",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the equality of instances of any BinaryInteger types using the equal-to operator (==). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are equal: \\(firstUTF8 == firstScalar)\")\n}\n// Prints \"First code values are equal: true\"\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_(_:_:)-53qq",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than operator (>), even if the two instances are of different types."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_(_:_:)-5p6eu",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_(_:_:)-615a6",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than operator (<), even if the two instances are of different types."
  },
  {
    "title": "%(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_(_:_:)-6tefc",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nThe result of the remainder operator (%) has the same sign as lhs and has a magnitude less than rhs.magnitude.\n\nlet x = 22 % 5\n// x == 2\nlet y = 22 % -5\n// y == 2\nlet z = -22 % -5\n// z == -2\n\n\nFor any two integers a and b, their quotient q, and their remainder r, a == b * q + r."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/__(_:_:)-9i518",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": ">>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/__=(_:_:)-40egk",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >>= operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx >>= 2\n// x == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny >>= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na >>= -3\n// a == 240                       // 0b11110000\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb <<= 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nvar q: Int8 = -30                 // 0b11100010\nq >>= 2\n// q == -8                        // 0b11111000\n\n\nvar r: Int8 = -30                 // 0b11100010\nr >>= 11\n// r == -1                        // 0b11111111\n"
  },
  {
    "title": "<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/__=(_:_:)-53mkr",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx <<= 2\n// x == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny <<= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na <<= -3\n// a == 3                         // 0b00000011\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb >>= 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "init(arrayLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdmask/init(arrayliteral:)",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector. scalars must have the same number of elements as the vector type."
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdmask/replacing(with:where:)-2gka4",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other[i] : self[i]\n}\n"
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdmask/replace(with:where:)-6wonx",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other }\n}\n"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdmask/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdmask/replacing(with:where:)-3lyjl",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other : self[i]\n}\n"
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdmask/replace(with:where:)-7bhx",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other[i] }\n}\n"
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/words-swift.struct/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "isMultiple(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/ismultiple(of:)",
    "html": "Parameters\nother\n\nThe value to test.\n\nDiscussion\n\nFor two integers a and b, a is a multiple of b if there exists a third integer q such that a = q*b. For example, 6 is a multiple of 3 because 6 = 2*3. Zero is a multiple of everything because 0 = 0*x for any integer x.\n\nTwo edge cases are worth particular attention:\n\nx.isMultiple(of: 0) is true if x is zero and false otherwise.\n\nT.min.isMultiple(of: -1) is true for signed integer T, even though the quotient T.min / -1 isn’t representable in type T."
  },
  {
    "title": "&+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe masking addition assignment operator (&+=) silently wraps any overflow that occurs during the operation. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &+= 21\n// x == 31\nvar y: Int8 = 100\ny &+= 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&-(_:_:)-2drgj",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe overflow subtraction operator (&-) discards any bits that overflow the fixed width of the integer type. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: UInt8 = 21 &- 10\n// x == 11\nlet y: UInt8 = 10 &- 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&-=(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe masking subtraction assignment operator (&-=) silently wraps any overflow that occurs during the operation. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 21\nx &-= 10\n// x == 11\nvar y: UInt8 = 10\ny &-= 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&+(_:_:)-8saky",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe overflow addition operator (&+) discards any bits that overflow the fixed width of the integer type. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &+ 21\n// x == 31\nlet y: Int8 = 100 &+ 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&__(_:_:)-1v821",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&__(_:_:)-9x51j",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&__=(_:_:)-6g9h1",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &<<= operator performs a masking shift, where the value used as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &<<= 2\n// x == 120                       // 0b01111000\n\n\nHowever, if you pass 19 as rhs, the method first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &<<= 19\n// y == 240                       // 0b11110000\n"
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&__(_:_:)-4szuk",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&__(_:_:)-2a90q",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/__(_:_:)-7wosz",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "init(littleEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(littleendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the little-endian representation of the new integer."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/__(_:_:)-3z21o",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(exactly:)-16mcu",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 21.0, while the attempt to initialize the constant y from 21.5 fails:\n\nlet x = Int(exactly: 21.0)\n// x == Optional(21)\nlet y = Int(exactly: 21.5)\n// y == nil\n"
  },
  {
    "title": "~(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/~(_:)",
    "html": "Discussion\n\nThe bitwise NOT operator (~) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are 1 in the argument are 0 in the result, and bits that are 0 in the argument are 1 in the result. This is equivalent to the inverse of a set. For example:\n\nlet x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010\n\n\nPerforming a bitwise NOT operation on 0 returns a value with every bit set to 1.\n\nlet allOnes = ~UInt8.min   // 0b11111111\n\n\nComplexity\n\nO(1)."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/random(in:using:)-8ennz",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(exactly:)-9vj4n",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 100, while the attempt to initialize the constant y from 1_000 fails because the Int8 type can represent 127 at maximum:\n\nlet x = Int8(exactly: 100)\n// x == Optional(100)\nlet y = Int8(exactly: 1_000)\n// y == nil\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&(_:_:)-6jf06",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&(_:_:)-9i61c",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_(_:_:)-a3sx",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_=(_:_:)-5bita",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_=(_:_:)-2nsgl",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_=(_:_:)-3nz2d",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_=(_:_:)-7pwh6",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_=(_:_:)-qbgp",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_=(_:_:)-863du",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/distance(to:)",
    "html": "Parameters\nother\n\nThe value to calculate the distance to.\n\nReturn Value\n\nThe distance from this value to other.\n\nDiscussion\n\nFor two values x and y, and a distance n = x.distance(to: y), x.advanced(by: n) == y."
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nFor a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n."
  },
  {
    "title": "&*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe overflow multiplication operator (&*) discards any bits that overflow the fixed width of the integer type. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &* 5\n// x == 50\nlet y: Int8 = 10 &* 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&__(_:_:)-24uqw",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&__(_:_:)-7028d",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "init(_:radix:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(_:radix:)",
    "html": "Parameters\ntext\n\nThe ASCII representation of a number in the radix passed as radix.\n\nradix\n\nThe radix, or base, to use for converting text to an integer value. radix must be in the range 2...36. The default is 10.\n\nDiscussion\n\nThe string passed as text may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9) or letters (a-z or A-Z). Parsing of the string is case insensitive.\n\nlet x = Int(\"123\")\n// x == 123\n\n\nlet y = Int(\"-123\", radix: 8)\n// y == -83\nlet y = Int(\"+123\", radix: 8)\n// y == +83\n\n\nlet z = Int(\"07b\", radix: 16)\n// z == 123\n\n\nIf text is in an invalid format or contains characters that are out of bounds for the given radix, or if the value it denotes in the given radix is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"zzzzzzzzzzzzz\", radix: 36)   // Out of range\n"
  },
  {
    "title": "init(bigEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(bigendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the big-endian representation of the new integer."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(_:)-89uu",
    "html": "Parameters\ndescription\n\nThe ASCII representation of a number.\n\nDiscussion\n\nThe string passed as description may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9).\n\nlet x = Int(\"123\")\n// x == 123\n\n\nIf description is in an invalid format, or if the value it denotes in base 10 is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"10000000000000000000000000\") // Out of range\n"
  },
  {
    "title": "init(clamping:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(clamping:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nIf the value passed as source is greater than the maximum representable value in this type, the result is the type’s max value. If source is less than the smallest representable value in this type, the result is the type’s min value.\n\nIn this example, x is initialized as an Int8 instance by clamping 500 to the range -128...127, and y is initialized as a UInt instance by clamping -500 to the range 0...UInt.max.\n\nlet x = Int8(clamping: 500)\n// x == 127\n// x == Int8.max\n\n\nlet y = UInt(clamping: -500)\n// y == 0\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(_:)-7lqol",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer. source must be representable in this type after rounding toward zero.\n\nDiscussion\nlet x = Int(21.5)\n// x == 21\nlet y = Int(-21.5)\n// y == -21\n\n\nIf source is outside the bounds of this type after rounding toward zero, a runtime error may occur.\n\nlet z = UInt(-21.5)\n// Error: ...outside the representable range\n"
  },
  {
    "title": "&*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/&*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe masking multiplication assignment operator (&*=) silently wraps any overflow that occurs during the operation. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &*= 5\n// x == 50\nvar y: Int8 = 10\ny &*= 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "quotientAndRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/quotientandremainder(dividingby:)",
    "html": "Parameters\nrhs\n\nThe value to divide this value by.\n\nReturn Value\n\nA tuple containing the quotient and remainder of this value divided by rhs.\n\nDiscussion\n\nUse this method to calculate the quotient and remainder of a division at the same time.\n\nlet x = 1_000_000\nlet (q, r) = x.quotientAndRemainder(dividingBy: 933)\n// q == 1071\n// r == 757\n"
  },
  {
    "title": "init(truncatingIfNeeded:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(truncatingifneeded:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nWhen the bit width of T (the type of source) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of source. For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of source are used.\n\nlet p: Int16 = -500\n// 'p' has a binary representation of 11111110_00001100\nlet q = Int8(truncatingIfNeeded: p)\n// q == 12\n// 'q' has a binary representation of 00001100\n\n\nWhen the bit width of T is less than this type’s bit width, the result is sign-extended to fill the remaining bits. That is, if source is negative, the result is padded with ones; otherwise, the result is padded with zeros.\n\nlet u: Int8 = 21\n// 'u' has a binary representation of 00010101\nlet v = Int16(truncatingIfNeeded: u)\n// v == 21\n// 'v' has a binary representation of 00000000_00010101\n\n\nlet w: Int8 = -21\n// 'w' has a binary representation of 11101011\nlet x = Int16(truncatingIfNeeded: w)\n// x == -21\n// 'x' has a binary representation of 11111111_11101011\nlet y = UInt16(truncatingIfNeeded: w)\n// y == 65515\n// 'y' has a binary representation of 11111111_11101011\n"
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/random(in:)-2fyvz",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling the version that takes a generator, passing in the system’s default random generator."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(_:)-5sm6h",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer. The value passed as source must be representable in this type.\n\nDiscussion\n\nUse this initializer to convert from another integer type when you know the value is within the bounds of this type. Passing a value that can’t be represented in this type results in a runtime error.\n\nIn the following example, the constant y is successfully created from x, an Int instance with a value of 100. Because the Int8 type can represent 127 at maximum, the attempt to create z with a value of 1000 results in a runtime error.\n\nlet x = 100\nlet y = Int8(x)\n// y == 100\nlet z = Int8(x * 10)\n// Error: Not enough bits to represent the given value\n"
  },
  {
    "title": "bigEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/bigendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a big-endian platform, for any integer x, x == x.bigEndian."
  },
  {
    "title": "littleEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/littleendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a little-endian platform, for any integer x, x == x.littleEndian."
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/replace(with:where:)-99fgt",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other }\n}\n"
  },
  {
    "title": "negate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/negate()",
    "html": "Discussion\n\nThe following example uses the negate() method to negate the value of an integer x:\n\nvar x = 21\nx.negate()\n// x == -21\n\n\nThe resulting value must be representable within the value’s type. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nvar y = Int8.min\ny.negate()\n// Overflow error\n"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/init(integerliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/==(_:_:)-1h8wx",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/'...(_:)-4f0gs",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_(_:_:)-1r3uj",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_(_:_:)-1jlfi",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_(_:_:)-14f22",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/'...(_:)-4tgui",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/_(_:_:)-59kbk",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "max | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/max",
    "html": "Discussion\n\nFor signed integer types, this value is (2 ** (bitWidth - 1)) - 1, where ** is exponentiation."
  },
  {
    "title": "min | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/min",
    "html": "Discussion\n\nFor signed integer types, this value is -(2 ** (bitWidth - 1)), where ** is exponentiation."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "wrappedSum() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/wrappedsum()",
    "html": "Discussion\n\nEquivalent to indices.reduce(into: 0) { $0 &+= self[$1] }."
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/replacing(with:where:)-xwqn",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other : self[i]\n}\n"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "-(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/-(_:)",
    "html": "Return Value\n\nThe additive inverse of the argument.\n\nDiscussion\n\nThe negation operator (prefix -) returns the additive inverse of its argument.\n\nlet x = 21\nlet y = -x\n// y == -21\n\n\nThe resulting value must be representable in the same type as the argument. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nlet z = -Int8.min\n// Overflow error\n"
  },
  {
    "title": "init(arrayLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/init(arrayliteral:)",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector. scalars must have the same number of elements as the vector type."
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/replace(with:where:)-7685a",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other[i] }\n}\n"
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/replacing(with:where:)-3ecx2",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other[i] : self[i]\n}\n"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/+=(_:_:)-2kbw8",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": ".==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/'.==(_:_:)-68z13",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] == b[i]\n}\n"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/-=(_:_:)-7bdez",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/-=(_:_:)-20ca5",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": ".!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/'.!=(_:_:)-8woo1",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] != b[i]\n}\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/init(_:)-6l6bn",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector.\n\nDiscussion\n\nPrecondition\n\nscalars must have the same number of elements as the vector type."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/+=(_:_:)-5sues",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/*(_:_:)-80pyw",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/-(_:_:)-tcjo",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/-(_:_:)-fbas",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/+(_:_:)-3wpa7",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/*(_:_:)-7agrf",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/*(_:_:)-3kbvd",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/-(_:_:)-7ar0m",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "hasSuffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stringprotocol/hassuffix(_:)-13eus",
    "html": "Parameters\nsuffix\n\nA possible suffix to test against this string.\n\nReturn Value\n\ntrue if the string ends with suffix; otherwise, false.\n\nDiscussion\n\nThe comparison is both case sensitive and Unicode safe. The case-sensitive comparison will only match strings whose corresponding characters have the same case.\n\nlet plans = \"Let's meet at the café\"\n\n\n// Case sensitive\nprint(plans.hasSuffix(\"Café\"))\n// Prints \"false\"\n\n\nThe Unicode-safe comparison matches Unicode extended grapheme clusters rather than the code points used to compose them. The example below uses two strings with different forms of the \"é\" character—the first uses the composed form and the second uses the decomposed form.\n\n// Unicode safe\nlet composedCafe = \"café\"\nlet decomposedCafe = \"cafe\\u{0301}\"\n\n\nprint(plans.hasSuffix(composedCafe))\n// Prints \"true\"\nprint(plans.hasSuffix(decomposedCafe))\n// Prints \"true\"\n"
  },
  {
    "title": "wrappedSum() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/wrappedsum()",
    "html": "Discussion\n\nEquivalent to indices.reduce(into: 0) { $0 &+= self[$1] }."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/+(_:_:)-5r8e2",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/customplaygroundquicklook",
    "html": "Deprecated\n\nInt8.customPlaygroundQuickLook will be removed in a future Swift version"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/+(_:_:)-69rpi",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stringprotocol/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "hasPrefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stringprotocol/hasprefix(_:)-9c8b6",
    "html": "Parameters\nprefix\n\nA possible prefix to test against this string.\n\nReturn Value\n\ntrue if the string begins with prefix; otherwise, false.\n\nDiscussion\n\nThe comparison is both case sensitive and Unicode safe. The case-sensitive comparison will only match strings whose corresponding characters have the same case.\n\nlet cafe = \"Café du Monde\"\n\n\n// Case sensitive\nprint(cafe.hasPrefix(\"café\"))\n// Prints \"false\"\n\n\nThe Unicode-safe comparison matches Unicode extended grapheme clusters rather than the code points used to compose them. The example below uses two strings with different forms of the \"é\" character—the first uses the composed form and the second uses the decomposed form.\n\n// Unicode safe\nlet composedCafe = \"Café\"\nlet decomposedCafe = \"Cafe\\u{0301}\"\n\n\nprint(cafe.hasPrefix(composedCafe))\n// Prints \"true\"\nprint(cafe.hasPrefix(decomposedCafe))\n// Prints \"true\"\n"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/*=(_:_:)-3vpxk",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/*=(_:_:)-3ntoe",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd64/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/encoding/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/encoding/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/encoding/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/encoding/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/replace(with:where:)-7e5tu",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other[i] }\n}\n"
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/replacing(with:where:)-32kt0",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other[i] : self[i]\n}\n"
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/replace(with:where:)-7ys4t",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other }\n}\n"
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/replacing(with:where:)-3o9r2",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other : self[i]\n}\n"
  },
  {
    "title": "init(arrayLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/init(arrayliteral:)",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector. scalars must have the same number of elements as the vector type."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/init(_:)-3ewxg",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector.\n\nDiscussion\n\nPrecondition\n\nscalars must have the same number of elements as the vector type."
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/*(_:_:)-6kqtm",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": ".!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/'.!=(_:_:)-70jxh",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] != b[i]\n}\n"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/-=(_:_:)-8p1mb",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/-=(_:_:)-5efu0",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/-(_:_:)-8vqls",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/+(_:_:)-62o3n",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/+(_:_:)-841fq",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/*=(_:_:)-4j1xn",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/*=(_:_:)-27m64",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/*(_:_:)-4lmnj",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/*(_:_:)-50hhc",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": ".==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/'.==(_:_:)-85ylq",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] == b[i]\n}\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/endindex",
    "html": "Discussion\n\nIn an empty UTF-8 view, endIndex is equal to startIndex."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(integerliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "String.UTF8View.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/+=(_:_:)-4kc6w",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/-(_:_:)-59qe9",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/+=(_:_:)-3iuqz",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/-(_:_:)-5retq",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_=(_:_:)-9dxms",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd8/+(_:_:)-1h94n",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/index(after:)",
    "html": "Discussion\n\nPrecondition\n\nThe next position is representable."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/map(_:)-5mzud",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/subscript(_:)-3gfsv",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/flatmap(_:)-3i8lk",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/map(_:)-57edm",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unownedjob/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/startindex",
    "html": "Discussion\n\nIf the UTF-8 view is empty, startIndex is equal to endIndex."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "String.UTF8View.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_=(_:_:)-573ra",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_(_:_:)-67i4z",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&__(_:_:)-5qjx7",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&__(_:_:)-6boh2",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/withcontiguousstorageifavailable(_:)-2kyu1",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/withcontiguousstorageifavailable(_:)-3fk9a",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/_=(_:_:)-3yi5q",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/_=(_:_:)-1inkc",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/_(_:_:)-7pn1h",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/_(_:_:)-2bswy",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/'...(_:)-6i99j",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/subscript(_:)-3wo7k",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nFor example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2..<5]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")!    // 4\nprint(streets[index])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/subscript(_:)-6nubh",
    "html": "Parameters\nposition\n\nA valid index of the view. position must be less than the view’s end index.\n\nOverview\n\nThe following example uses the subscript to print the value of a string’s first UTF-8 code unit.\n\nlet greeting = \"Hello, friend!\"\nlet i = greeting.utf8.startIndex\nprint(\"First character's UTF-8 code unit: \\(greeting.utf8[i])\")\n// Prints \"First character's UTF-8 code unit: 72\"\n"
  },
  {
    "title": "String.UTF8View.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/character/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/customplaygroundquicklook",
    "html": "Deprecated\n\nUInt32.customPlaygroundQuickLook will be removed in a future Swift version"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_=(_:_:)-apxe",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_=(_:_:)-69qui",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/'...(_:)-1sif9",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_=(_:_:)-3rq79",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_(_:_:)-9eky4",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/__(_:_:)-2fuku",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_(_:_:)-5v5ah",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/'...(_:)-6hglj",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/'...(_:)-5u2el",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/random(in:using:)-91wzi",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n\n\nNote\n\nThe algorithm used to create random values may change in a future version of Swift. If you’re passing a generator that results in the same sequence of integer values each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/random(in:)-58bdl",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling random(in:using:), passing in the system’s default random generator."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/random(in:using:)-7gifu",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n"
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/random(in:)-5r5dt",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling the version that takes a generator, passing in the system’s default random generator."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(_:)-5tue7",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer. source must be representable in this type after rounding toward zero.\n\nDiscussion\nlet x = Int(21.5)\n// x == 21\nlet y = Int(-21.5)\n// y == -21\n\n\nIf source is outside the bounds of this type after rounding toward zero, a runtime error may occur.\n\nlet z = UInt(-21.5)\n// Error: ...outside the representable range\n"
  },
  {
    "title": "init(littleEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(littleendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the little-endian representation of the new integer."
  },
  {
    "title": "littleEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/littleendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a little-endian platform, for any integer x, x == x.littleEndian."
  },
  {
    "title": "init(truncatingIfNeeded:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(truncatingifneeded:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nWhen the bit width of T (the type of source) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of source. For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of source are used.\n\nlet p: Int16 = -500\n// 'p' has a binary representation of 11111110_00001100\nlet q = Int8(truncatingIfNeeded: p)\n// q == 12\n// 'q' has a binary representation of 00001100\n\n\nWhen the bit width of T is less than this type’s bit width, the result is sign-extended to fill the remaining bits. That is, if source is negative, the result is padded with ones; otherwise, the result is padded with zeros.\n\nlet u: Int8 = 21\n// 'u' has a binary representation of 00010101\nlet v = Int16(truncatingIfNeeded: u)\n// v == 21\n// 'v' has a binary representation of 00000000_00010101\n\n\nlet w: Int8 = -21\n// 'w' has a binary representation of 11101011\nlet x = Int16(truncatingIfNeeded: w)\n// x == -21\n// 'x' has a binary representation of 11111111_11101011\nlet y = UInt16(truncatingIfNeeded: w)\n// y == 65515\n// 'y' has a binary representation of 11111111_11101011\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(exactly:)-8348l",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 21.0, while the attempt to initialize the constant y from 21.5 fails:\n\nlet x = Int(exactly: 21.0)\n// x == Optional(21)\nlet y = Int(exactly: 21.5)\n// y == nil\n"
  },
  {
    "title": "init(clamping:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(clamping:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nIf the value passed as source is greater than the maximum representable value in this type, the result is the type’s max value. If source is less than the smallest representable value in this type, the result is the type’s min value.\n\nIn this example, x is initialized as an Int8 instance by clamping 500 to the range -128...127, and y is initialized as a UInt instance by clamping -500 to the range 0...UInt.max.\n\nlet x = Int8(clamping: 500)\n// x == 127\n// x == Int8.max\n\n\nlet y = UInt(clamping: -500)\n// y == 0\n"
  },
  {
    "title": "init(bigEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(bigendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the big-endian representation of the new integer."
  },
  {
    "title": "&<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&__=(_:_:)-4p3qm",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &<<= operator performs a masking shift, where the value used as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &<<= 2\n// x == 120                       // 0b01111000\n\n\nHowever, if you pass 19 as rhs, the method first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &<<= 19\n// y == 240                       // 0b11110000\n"
  },
  {
    "title": "&>>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&__=(_:_:)-477ef",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &>>= operator performs a masking shift, where the value passed as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &>>= 2\n// x == 7                         // 0b00000111\n\n\nHowever, if you use 19 as rhs, the operation first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &>>= 19\n// y == 3                         // 0b00000011\n"
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&__(_:_:)-bol",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&-=(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe masking subtraction assignment operator (&-=) silently wraps any overflow that occurs during the operation. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 21\nx &-= 10\n// x == 11\nvar y: UInt8 = 10\ny &-= 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe overflow subtraction operator (&-) discards any bits that overflow the fixed width of the integer type. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: UInt8 = 21 &- 10\n// x == 11\nlet y: UInt8 = 10 &- 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&__(_:_:)-4icck",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&__(_:_:)-6cy2r",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&__(_:_:)-2b50j",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "init(littleEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(littleendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the little-endian representation of the new integer."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/continuousclock/instant/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/__(_:_:)-8ecom",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/==(_:_:)-46ijp",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "&*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe masking multiplication assignment operator (&*=) silently wraps any overflow that occurs during the operation. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &*= 5\n// x == 50\nvar y: Int8 = 10\ny &*= 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "magnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/magnitude-swift.property",
    "html": "Discussion\n\nEvery unsigned integer is its own magnitude, so for any value x, x == x.magnitude.\n\nThe global abs(_:) function provides more familiar syntax when you need to find an absolute value. In addition, because abs(_:) always returns a value of the same type, even in a generic context, using the function instead of the magnitude property is encouraged."
  },
  {
    "title": "max | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/max",
    "html": "Discussion\n\nFor unsigned integer types, this value is (2 ** bitWidth) - 1, where ** is exponentiation."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/==(_:_:)-4aoew",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8view/customplaygroundquicklook",
    "html": "Discussion\n\nIf this type has value semantics, the PlaygroundQuickLook instance should be unaffected by subsequent mutations."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "Character.RegexOutput | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/character/regexoutput",
    "html": "Discussion\n\nA Regex instance’s output type depends on whether the Regex has captures and how it is created.\n\nA Regex created from a string using the init(_:) initializer has an output type of AnyRegexOutput, whether it has captures or not.\n\nA Regex without captures created from a regex literal, the init(_:as:) initializer, or a RegexBuilder closure has a Substring output type, where the substring is the portion of the string that was matched.\n\nA Regex with captures created from a regex literal or the init(_:as:) initializer has a tuple of substrings as its output type. The first component of the tuple is the full portion of the string that was matched, with the remaining components holding the captures."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/!=(_:_:)-6i9jj",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the inequality of instances of any BinaryInteger types using the not-equal-to operator (!=). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is not equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are different: \\(firstUTF8 != firstScalar)\")\n}\n// Prints \"First code values are different: false\"\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&(_:_:)-3g9c6",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\n2 * 3                   // 6\n100 * 21                // 2100\n-10 * 15                // -150\n3.5 * 2.25              // 7.875\n\n\nYou cannot use * with arguments of different types. To multiply values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) * y              // 21000000\n\n\nThe product of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 * 21 is greater than the maximum representable Int8 value:\n\nx * 21                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow multiplication operator (&*).\n\nx &* 21                // -115\n"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\n8 - 3                   // 5\n-10 - 5                 // -15\n100 - -5                // 105\n10.5 - 100.0            // -89.5\n\n\nYou cannot use - with arguments of different types. To subtract values of different types, convert one of the values to the other value’s type.\n\nlet x: UInt8 = 21\nlet y: UInt = 1000000\ny - UInt(x)             // 999979\n\n\nThe difference of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 - 50 is less than zero, the minimum representable UInt8 value:\n\nx - 50                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow subtraction operator (&-).\n\nx &- 50                // 227\n"
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nFor integer types, any remainder of the division is discarded.\n\nlet x = 21 / 5\n// x == 4\n"
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nFor integer types, any remainder of the division is discarded.\n\nlet x = 21 / 5\n// x == 4\n"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_=(_:_:)-4zprc",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_(_:_:)-60hif",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "~(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/~(_:)",
    "html": "Discussion\n\nThe bitwise NOT operator (~) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are 1 in the argument are 0 in the result, and bits that are 0 in the argument are 1 in the result. This is equivalent to the inverse of a set. For example:\n\nlet x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010\n\n\nPerforming a bitwise NOT operation on 0 returns a value with every bit set to 1.\n\nlet allOnes = ~UInt8.min   // 0b11111111\n\n\nComplexity\n\nO(1)."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/__(_:_:)-63byq",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "init(_:radix:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(_:radix:)",
    "html": "Parameters\ntext\n\nThe ASCII representation of a number in the radix passed as radix.\n\nradix\n\nThe radix, or base, to use for converting text to an integer value. radix must be in the range 2...36. The default is 10.\n\nDiscussion\n\nThe string passed as text may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9) or letters (a-z or A-Z). Parsing of the string is case insensitive.\n\nlet x = Int(\"123\")\n// x == 123\n\n\nlet y = Int(\"-123\", radix: 8)\n// y == -83\nlet y = Int(\"+123\", radix: 8)\n// y == +83\n\n\nlet z = Int(\"07b\", radix: 16)\n// z == 123\n\n\nIf text is in an invalid format or contains characters that are out of bounds for the given radix, or if the value it denotes in the given radix is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"zzzzzzzzzzzzz\", radix: 36)   // Out of range\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(_:)-6w6ag",
    "html": "Parameters\ndescription\n\nThe ASCII representation of a number.\n\nDiscussion\n\nThe string passed as description may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9).\n\nlet x = Int(\"123\")\n// x == 123\n\n\nIf description is in an invalid format, or if the value it denotes in base 10 is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"10000000000000000000000000\") // Out of range\n"
  },
  {
    "title": "bigEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/bigendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a big-endian platform, for any integer x, x == x.bigEndian."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/__(_:_:)-7yxgh",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "&<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&__=(_:_:)-60dw2",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &<<= operator performs a masking shift, where the value used as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &<<= 2\n// x == 120                       // 0b01111000\n\n\nHowever, if you pass 19 as rhs, the method first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &<<= 19\n// y == 240                       // 0b11110000\n"
  },
  {
    "title": "&>>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&__=(_:_:)-16yhm",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &>>= operator performs a masking shift, where the value passed as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &>>= 2\n// x == 7                         // 0b00000111\n\n\nHowever, if you use 19 as rhs, the operation first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &>>= 19\n// y == 3                         // 0b00000011\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/==(_:_:)-6gtla",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the equality of instances of any BinaryInteger types using the equal-to operator (==). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are equal: \\(firstUTF8 == firstScalar)\")\n}\n// Prints \"First code values are equal: true\"\n"
  },
  {
    "title": "%(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_(_:_:)-6ovdh",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nThe result of the remainder operator (%) has the same sign as lhs and has a magnitude less than rhs.magnitude.\n\nlet x = 22 % 5\n// x == 2\nlet y = 22 % -5\n// y == 2\nlet z = -22 % -5\n// z == -2\n\n\nFor any two integers a and b, their quotient q, and their remainder r, a == b * q + r."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_(_:_:)-7gl7s",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than operator (<), even if the two instances are of different types."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_(_:_:)-5p6yw",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_(_:_:)-ru4w",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than operator (>), even if the two instances are of different types."
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_(_:_:)-9mox3",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_=(_:_:)-6655v",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than-or-equal-to operator (>=), even if the two instances are of different types."
  },
  {
    "title": "<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/__=(_:_:)-9xth9",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx <<= 2\n// x == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny <<= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na <<= -3\n// a == 3                         // 0b00000011\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb >>= 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_=(_:_:)-vr4i",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than-or-equal-to operator (<=), even if the two instances are of different types."
  },
  {
    "title": ">>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/__=(_:_:)-2nln1",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >>= operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx >>= 2\n// x == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny >>= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na >>= -3\n// a == 240                       // 0b11110000\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb <<= 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nvar q: Int8 = -30                 // 0b11100010\nq >>= 2\n// q == -8                        // 0b11111000\n\n\nvar r: Int8 = -30                 // 0b11100010\nr >>= 11\n// r == -1                        // 0b11111111\n"
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/__(_:_:)-8299k",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nFor a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n."
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/distance(to:)",
    "html": "Parameters\nother\n\nThe value to calculate the distance to.\n\nReturn Value\n\nThe distance from this value to other.\n\nDiscussion\n\nFor two values x and y, and a distance n = x.distance(to: y), x.advanced(by: n) == y."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/random(in:using:)-6l2z5",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/+=(_:_:)-511b2",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/-=(_:_:)-9sxd7",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/zero",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x."
  },
  {
    "title": "&*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe overflow multiplication operator (&*) discards any bits that overflow the fixed width of the integer type. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &* 5\n// x == 50\nlet y: Int8 = 10 &* 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe overflow addition operator (&+) discards any bits that overflow the fixed width of the integer type. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &+ 21\n// x == 31\nlet y: Int8 = 100 &+ 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(_:)-c1wd",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer. The value passed as source must be representable in this type.\n\nDiscussion\n\nUse this initializer to convert from another integer type when you know the value is within the bounds of this type. Passing a value that can’t be represented in this type results in a runtime error.\n\nIn the following example, the constant y is successfully created from x, an Int instance with a value of 100. Because the Int8 type can represent 127 at maximum, the attempt to create z with a value of 1000 results in a runtime error.\n\nlet x = 100\nlet y = Int8(x)\n// y == 100\nlet z = Int8(x * 10)\n// Error: Not enough bits to represent the given value\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/init(exactly:)-8t3ac",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 100, while the attempt to initialize the constant y from 1_000 fails because the Int8 type can represent 127 at maximum:\n\nlet x = Int8(exactly: 100)\n// x == Optional(100)\nlet y = Int8(exactly: 1_000)\n// y == nil\n"
  },
  {
    "title": "&+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe masking addition assignment operator (&+=) silently wraps any overflow that occurs during the operation. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &+= 21\n// x == 31\nvar y: Int8 = 100\ny &+= 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "isSigned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/issigned",
    "html": "Discussion\n\nThis property is always false for unsigned integer types."
  },
  {
    "title": "Character.UnicodeScalarLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/character/unicodescalarliteraltype",
    "html": "Discussion\n\nValid types for UnicodeScalarLiteralType are Unicode.Scalar, Character, String, and StaticString."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\n1 + 2                   // 3\n-10 + 15                // 5\n-15 + -5                // -20\n21.5 + 3.25             // 24.75\n\n\nYou cannot use + with arguments of different types. To add values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) + y              // 1000021\n\n\nThe sum of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 + 120 is greater than the maximum representable Int8 value:\n\nx + 120                 // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow addition operator (&+).\n\nx &+ 120                // -115\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/&(_:_:)-3m6z0",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\n8 - 3                   // 5\n-10 - 5                 // -15\n100 - -5                // 105\n10.5 - 100.0            // -89.5\n\n\nYou cannot use - with arguments of different types. To subtract values of different types, convert one of the values to the other value’s type.\n\nlet x: UInt8 = 21\nlet y: UInt = 1000000\ny - UInt(x)             // 999979\n\n\nThe difference of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 - 50 is less than zero, the minimum representable UInt8 value:\n\nx - 50                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow subtraction operator (&-).\n\nx &- 50                // 227\n"
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_(_:_:)-297tf",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_(_:_:)-7mpvu",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than operator (<), even if the two instances are of different types."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/==(_:_:)-69b04",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the equality of instances of any BinaryInteger types using the equal-to operator (==). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are equal: \\(firstUTF8 == firstScalar)\")\n}\n// Prints \"First code values are equal: true\"\n"
  },
  {
    "title": "<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/__=(_:_:)-9qkzb",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx <<= 2\n// x == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny <<= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na <<= -3\n// a == 3                         // 0b00000011\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb >>= 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nFor a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/random(in:)-6wnz5",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling the version that takes a generator, passing in the system’s default random generator."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/random(in:)-85h4o",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling random(in:using:), passing in the system’s default random generator."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/random(in:using:)-3zjsj",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n\n\nNote\n\nThe algorithm used to create random values may change in a future version of Swift. If you’re passing a generator that results in the same sequence of integer values each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "littleEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/littleendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a little-endian platform, for any integer x, x == x.littleEndian."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(exactly:)-8szg6",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 21.0, while the attempt to initialize the constant y from 21.5 fails:\n\nlet x = Int(exactly: 21.0)\n// x == Optional(21)\nlet y = Int(exactly: 21.5)\n// y == nil\n"
  },
  {
    "title": "init(truncatingIfNeeded:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(truncatingifneeded:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nWhen the bit width of T (the type of source) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of source. For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of source are used.\n\nlet p: Int16 = -500\n// 'p' has a binary representation of 11111110_00001100\nlet q = Int8(truncatingIfNeeded: p)\n// q == 12\n// 'q' has a binary representation of 00001100\n\n\nWhen the bit width of T is less than this type’s bit width, the result is sign-extended to fill the remaining bits. That is, if source is negative, the result is padded with ones; otherwise, the result is padded with zeros.\n\nlet u: Int8 = 21\n// 'u' has a binary representation of 00010101\nlet v = Int16(truncatingIfNeeded: u)\n// v == 21\n// 'v' has a binary representation of 00000000_00010101\n\n\nlet w: Int8 = -21\n// 'w' has a binary representation of 11101011\nlet x = Int16(truncatingIfNeeded: w)\n// x == -21\n// 'x' has a binary representation of 11111111_11101011\nlet y = UInt16(truncatingIfNeeded: w)\n// y == 65515\n// 'y' has a binary representation of 11111111_11101011\n"
  },
  {
    "title": "init(_:radix:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(_:radix:)",
    "html": "Parameters\ntext\n\nThe ASCII representation of a number in the radix passed as radix.\n\nradix\n\nThe radix, or base, to use for converting text to an integer value. radix must be in the range 2...36. The default is 10.\n\nDiscussion\n\nThe string passed as text may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9) or letters (a-z or A-Z). Parsing of the string is case insensitive.\n\nlet x = Int(\"123\")\n// x == 123\n\n\nlet y = Int(\"-123\", radix: 8)\n// y == -83\nlet y = Int(\"+123\", radix: 8)\n// y == +83\n\n\nlet z = Int(\"07b\", radix: 16)\n// z == 123\n\n\nIf text is in an invalid format or contains characters that are out of bounds for the given radix, or if the value it denotes in the given radix is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"zzzzzzzzzzzzz\", radix: 36)   // Out of range\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(_:)-1iroc",
    "html": "Parameters\ndescription\n\nThe ASCII representation of a number.\n\nDiscussion\n\nThe string passed as description may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9).\n\nlet x = Int(\"123\")\n// x == 123\n\n\nIf description is in an invalid format, or if the value it denotes in base 10 is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"10000000000000000000000000\") // Out of range\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(_:)-5e02",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer. source must be representable in this type after rounding toward zero.\n\nDiscussion\nlet x = Int(21.5)\n// x == 21\nlet y = Int(-21.5)\n// y == -21\n\n\nIf source is outside the bounds of this type after rounding toward zero, a runtime error may occur.\n\nlet z = UInt(-21.5)\n// Error: ...outside the representable range\n"
  },
  {
    "title": "~(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/~(_:)",
    "html": "Discussion\n\nThe bitwise NOT operator (~) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are 1 in the argument are 0 in the result, and bits that are 0 in the argument are 1 in the result. This is equivalent to the inverse of a set. For example:\n\nlet x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010\n\n\nPerforming a bitwise NOT operation on 0 returns a value with every bit set to 1.\n\nlet allOnes = ~UInt8.min   // 0b11111111\n\n\nComplexity\n\nO(1)."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/__(_:_:)-2qqlb",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&__(_:_:)-7gp0b",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&__(_:_:)-5m6yb",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&__(_:_:)-6jqbr",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&__(_:_:)-60i6u",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "init(clamping:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(clamping:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nIf the value passed as source is greater than the maximum representable value in this type, the result is the type’s max value. If source is less than the smallest representable value in this type, the result is the type’s min value.\n\nIn this example, x is initialized as an Int8 instance by clamping 500 to the range -128...127, and y is initialized as a UInt instance by clamping -500 to the range 0...UInt.max.\n\nlet x = Int8(clamping: 500)\n// x == 127\n// x == Int8.max\n\n\nlet y = UInt(clamping: -500)\n// y == 0\n"
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&__(_:_:)-1fquv",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&__(_:_:)-3qwyl",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "quotientAndRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/quotientandremainder(dividingby:)",
    "html": "Parameters\nrhs\n\nThe value to divide this value by.\n\nReturn Value\n\nA tuple containing the quotient and remainder of this value divided by rhs.\n\nDiscussion\n\nUse this method to calculate the quotient and remainder of a division at the same time.\n\nlet x = 1_000_000\nlet (q, r) = x.quotientAndRemainder(dividingBy: 933)\n// q == 1071\n// r == 757\n"
  },
  {
    "title": "&*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe masking multiplication assignment operator (&*=) silently wraps any overflow that occurs during the operation. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &*= 5\n// x == 50\nvar y: Int8 = 10\ny &*= 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe overflow multiplication operator (&*) discards any bits that overflow the fixed width of the integer type. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &* 5\n// x == 50\nlet y: Int8 = 10 &* 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "Character.ExtendedGraphemeClusterLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/character/extendedgraphemeclusterliteraltype",
    "html": "Discussion\n\nValid types for ExtendedGraphemeClusterLiteralType are Character, String, and StaticString."
  },
  {
    "title": "isSigned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/issigned",
    "html": "Discussion\n\nThis property is always false for unsigned integer types."
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/zero",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x."
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_(_:_:)-21za9",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "isMultiple(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/ismultiple(of:)",
    "html": "Parameters\nother\n\nThe value to test.\n\nDiscussion\n\nFor two integers a and b, a is a multiple of b if there exists a third integer q such that a = q*b. For example, 6 is a multiple of 3 because 6 = 2*3. Zero is a multiple of everything because 0 = 0*x for any integer x.\n\nTwo edge cases are worth particular attention:\n\nx.isMultiple(of: 0) is true if x is zero and false otherwise.\n\nT.min.isMultiple(of: -1) is true for signed integer T, even though the quotient T.min / -1 isn’t representable in type T."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/_(_:_:)-1zok6",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/_(_:_:)-4eiav",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/random(in:using:)-7a3q0",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/character/_(_:_:)-24u5o",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&(_:_:)-3mlmk",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/character/_=(_:_:)-8lyhz",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\n2 * 3                   // 6\n100 * 21                // 2100\n-10 * 15                // -150\n3.5 * 2.25              // 7.875\n\n\nYou cannot use * with arguments of different types. To multiply values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) * y              // 21000000\n\n\nThe product of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 * 21 is greater than the maximum representable Int8 value:\n\nx * 21                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow multiplication operator (&*).\n\nx &* 21                // -115\n"
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nFor a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/character/_(_:_:)-3jyg1",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&(_:_:)-60vz9",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\n1 + 2                   // 3\n-10 + 15                // 5\n-15 + -5                // -20\n21.5 + 3.25             // 24.75\n\n\nYou cannot use + with arguments of different types. To add values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) + y              // 1000021\n\n\nThe sum of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 + 120 is greater than the maximum representable Int8 value:\n\nx + 120                 // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow addition operator (&+).\n\nx &+ 120                // -115\n"
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_(_:_:)-1s8m4",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": ">>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/__=(_:_:)-2u0d3",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >>= operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx >>= 2\n// x == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny >>= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na >>= -3\n// a == 240                       // 0b11110000\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb <<= 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nvar q: Int8 = -30                 // 0b11100010\nq >>= 2\n// q == -8                        // 0b11111000\n\n\nvar r: Int8 = -30                 // 0b11100010\nr >>= 11\n// r == -1                        // 0b11111111\n"
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/distance(to:)",
    "html": "Parameters\nother\n\nThe value to calculate the distance to.\n\nReturn Value\n\nThe distance from this value to other.\n\nDiscussion\n\nFor two values x and y, and a distance n = x.distance(to: y), x.advanced(by: n) == y."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/!=(_:_:)-99bok",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the inequality of instances of any BinaryInteger types using the not-equal-to operator (!=). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is not equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are different: \\(firstUTF8 != firstScalar)\")\n}\n// Prints \"First code values are different: false\"\n"
  },
  {
    "title": "quotientAndRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/quotientandremainder(dividingby:)",
    "html": "Parameters\nrhs\n\nThe value to divide this value by.\n\nReturn Value\n\nA tuple containing the quotient and remainder of this value divided by rhs.\n\nDiscussion\n\nUse this method to calculate the quotient and remainder of a division at the same time.\n\nlet x = 1_000_000\nlet (q, r) = x.quotientAndRemainder(dividingBy: 933)\n// q == 1071\n// r == 757\n"
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "bigEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/bigendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a big-endian platform, for any integer x, x == x.bigEndian."
  },
  {
    "title": "&+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe overflow addition operator (&+) discards any bits that overflow the fixed width of the integer type. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &+ 21\n// x == 31\nlet y: Int8 = 100 &+ 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe masking addition assignment operator (&+=) silently wraps any overflow that occurs during the operation. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &+= 21\n// x == 31\nvar y: Int8 = 100\ny &+= 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&-=(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe masking subtraction assignment operator (&-=) silently wraps any overflow that occurs during the operation. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 21\nx &-= 10\n// x == 11\nvar y: UInt8 = 10\ny &-= 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe overflow subtraction operator (&-) discards any bits that overflow the fixed width of the integer type. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: UInt8 = 21 &- 10\n// x == 11\nlet y: UInt8 = 10 &- 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "init(bigEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(bigendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the big-endian representation of the new integer."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/character/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/-=(_:_:)-45l1",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(_:)-5kvfz",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer. The value passed as source must be representable in this type.\n\nDiscussion\n\nUse this initializer to convert from another integer type when you know the value is within the bounds of this type. Passing a value that can’t be represented in this type results in a runtime error.\n\nIn the following example, the constant y is successfully created from x, an Int instance with a value of 100. Because the Int8 type can represent 127 at maximum, the attempt to create z with a value of 1000 results in a runtime error.\n\nlet x = 100\nlet y = Int8(x)\n// y == 100\nlet z = Int8(x * 10)\n// Error: Not enough bits to represent the given value\n"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_(_:_:)-5oqcr",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_(_:_:)-3unk9",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/_(_:_:)-5kmc9",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than operator (<), even if the two instances are of different types."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/_(_:_:)-7nbqc",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than operator (>), even if the two instances are of different types."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/_(_:_:)-865lu",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "%(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/_(_:_:)-9tmal",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nThe result of the remainder operator (%) has the same sign as lhs and has a magnitude less than rhs.magnitude.\n\nlet x = 22 % 5\n// x == 2\nlet y = 22 % -5\n// y == 2\nlet z = -22 % -5\n// z == -2\n\n\nFor any two integers a and b, their quotient q, and their remainder r, a == b * q + r."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/_=(_:_:)-6b690",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than-or-equal-to operator (<=), even if the two instances are of different types."
  },
  {
    "title": ">>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/__=(_:_:)-8pj4c",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >>= operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx >>= 2\n// x == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny >>= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na >>= -3\n// a == 240                       // 0b11110000\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb <<= 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nvar q: Int8 = -30                 // 0b11100010\nq >>= 2\n// q == -8                        // 0b11111000\n\n\nvar r: Int8 = -30                 // 0b11100010\nr >>= 11\n// r == -1                        // 0b11111111\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/_=(_:_:)-9rm29",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than-or-equal-to operator (>=), even if the two instances are of different types."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/__(_:_:)-jtqk",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/__(_:_:)-56eg9",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/__=(_:_:)-1p711",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx <<= 2\n// x == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny <<= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na <<= -3\n// a == 3                         // 0b00000011\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb >>= 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/distance(to:)",
    "html": "Parameters\nother\n\nThe value to calculate the distance to.\n\nReturn Value\n\nThe distance from this value to other.\n\nDiscussion\n\nFor two values x and y, and a distance n = x.distance(to: y), x.advanced(by: n) == y."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "quotientAndRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/quotientandremainder(dividingby:)",
    "html": "Parameters\nrhs\n\nThe value to divide this value by.\n\nReturn Value\n\nA tuple containing the quotient and remainder of this value divided by rhs.\n\nDiscussion\n\nUse this method to calculate the quotient and remainder of a division at the same time.\n\nlet x = 1_000_000\nlet (q, r) = x.quotientAndRemainder(dividingBy: 933)\n// q == 1071\n// r == 757\n"
  },
  {
    "title": "isMultiple(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/ismultiple(of:)",
    "html": "Parameters\nother\n\nThe value to test.\n\nDiscussion\n\nFor two integers a and b, a is a multiple of b if there exists a third integer q such that a = q*b. For example, 6 is a multiple of 3 because 6 = 2*3. Zero is a multiple of everything because 0 = 0*x for any integer x.\n\nTwo edge cases are worth particular attention:\n\nx.isMultiple(of: 0) is true if x is zero and false otherwise.\n\nT.min.isMultiple(of: -1) is true for signed integer T, even though the quotient T.min / -1 isn’t representable in type T."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/character/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/!=(_:_:)-6oo9x",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the inequality of instances of any BinaryInteger types using the not-equal-to operator (!=). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is not equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are different: \\(firstUTF8 != firstScalar)\")\n}\n// Prints \"First code values are different: false\"\n"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/character/_=(_:_:)-1ihf",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/__(_:_:)-89hsa",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_(_:_:)-50tep",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_(_:_:)-y91e",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than operator (>), even if the two instances are of different types."
  },
  {
    "title": "%(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_(_:_:)-6nw45",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nThe result of the remainder operator (%) has the same sign as lhs and has a magnitude less than rhs.magnitude.\n\nlet x = 22 % 5\n// x == 2\nlet y = 22 % -5\n// y == 2\nlet z = -22 % -5\n// z == -2\n\n\nFor any two integers a and b, their quotient q, and their remainder r, a == b * q + r."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/__(_:_:)-8745o",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_=(_:_:)-ob5s",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than-or-equal-to operator (<=), even if the two instances are of different types."
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_(_:_:)-drxc",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_=(_:_:)-6ddld",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than-or-equal-to operator (>=), even if the two instances are of different types."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(integerliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/__(_:_:)-5wx7k",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "bigEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/bigendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a big-endian platform, for any integer x, x == x.bigEndian."
  },
  {
    "title": "isMultiple(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/ismultiple(of:)",
    "html": "Parameters\nother\n\nThe value to test.\n\nDiscussion\n\nFor two integers a and b, a is a multiple of b if there exists a third integer q such that a = q*b. For example, 6 is a multiple of 3 because 6 = 2*3. Zero is a multiple of everything because 0 = 0*x for any integer x.\n\nTwo edge cases are worth particular attention:\n\nx.isMultiple(of: 0) is true if x is zero and false otherwise.\n\nT.min.isMultiple(of: -1) is true for signed integer T, even though the quotient T.min / -1 isn’t representable in type T."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/_=(_:_:)-17ymu",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/_=(_:_:)-6xec7",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/_(_:_:)-14u28",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/_(_:_:)-1lk58",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/init(exactly:)-41wk8",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 100, while the attempt to initialize the constant y from 1_000 fails because the Int8 type can represent 127 at maximum:\n\nlet x = Int8(exactly: 100)\n// x == Optional(100)\nlet y = Int8(exactly: 1_000)\n// y == nil\n"
  },
  {
    "title": "min | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/min",
    "html": "Discussion\n\nFor unsigned integer types, this value is always 0."
  },
  {
    "title": "magnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/magnitude-swift.property",
    "html": "Discussion\n\nEvery unsigned integer is its own magnitude, so for any value x, x == x.magnitude.\n\nThe global abs(_:) function provides more familiar syntax when you need to find an absolute value. In addition, because abs(_:) always returns a value of the same type, even in a generic context, using the function instead of the magnitude property is encouraged."
  },
  {
    "title": "max | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/max",
    "html": "Discussion\n\nFor unsigned integer types, this value is (2 ** bitWidth) - 1, where ** is exponentiation."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/'...(_:)-6ornx",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/'...(_:)-5nnpz",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_=(_:_:)-3l8yn",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/+=(_:_:)-4tslw",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_=(_:_:)-4shca",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_=(_:_:)-6slvy",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/random(in:using:)-8uepg",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n\n\nNote\n\nThe algorithm used to create random values may change in a future version of Swift. If you’re passing a generator that results in the same sequence of integer values each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(integerliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/-=(_:_:)-9z9m1",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/zero",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x."
  },
  {
    "title": "&*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe overflow multiplication operator (&*) discards any bits that overflow the fixed width of the integer type. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &* 5\n// x == 50\nlet y: Int8 = 10 &* 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/random(in:)-5jx03",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling the version that takes a generator, passing in the system’s default random generator."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/random(in:)-512t7",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling random(in:using:), passing in the system’s default random generator."
  },
  {
    "title": "&*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe masking multiplication assignment operator (&*=) silently wraps any overflow that occurs during the operation. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &*= 5\n// x == 50\nvar y: Int8 = 10\ny &*= 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/_=(_:_:)-8ut2h",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&(_:_:)-8rmb8",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/_(_:_:)-17p9c",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\n1 + 2                   // 3\n-10 + 15                // 5\n-15 + -5                // -20\n21.5 + 3.25             // 24.75\n\n\nYou cannot use + with arguments of different types. To add values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) + y              // 1000021\n\n\nThe sum of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 + 120 is greater than the maximum representable Int8 value:\n\nx + 120                 // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow addition operator (&+).\n\nx &+ 120                // -115\n"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\n2 * 3                   // 6\n100 * 21                // 2100\n-10 * 15                // -150\n3.5 * 2.25              // 7.875\n\n\nYou cannot use * with arguments of different types. To multiply values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) * y              // 21000000\n\n\nThe product of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 * 21 is greater than the maximum representable Int8 value:\n\nx * 21                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow multiplication operator (&*).\n\nx &* 21                // -115\n"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\n8 - 3                   // 5\n-10 - 5                 // -15\n100 - -5                // 105\n10.5 - 100.0            // -89.5\n\n\nYou cannot use - with arguments of different types. To subtract values of different types, convert one of the values to the other value’s type.\n\nlet x: UInt8 = 21\nlet y: UInt = 1000000\ny - UInt(x)             // 999979\n\n\nThe difference of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 - 50 is less than zero, the minimum representable UInt8 value:\n\nx - 50                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow subtraction operator (&-).\n\nx &- 50                // 227\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/&(_:_:)-4psmt",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/==(_:_:)-156b9",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the equality of instances of any BinaryInteger types using the equal-to operator (==). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are equal: \\(firstUTF8 == firstScalar)\")\n}\n// Prints \"First code values are equal: true\"\n"
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nFor integer types, any remainder of the division is discarded.\n\nlet x = 21 / 5\n// x == 4\n"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/+=(_:_:)-4vs0u",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/'...(_:)-9qpet",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "init(clamping:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(clamping:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nIf the value passed as source is greater than the maximum representable value in this type, the result is the type’s max value. If source is less than the smallest representable value in this type, the result is the type’s min value.\n\nIn this example, x is initialized as an Int8 instance by clamping 500 to the range -128...127, and y is initialized as a UInt instance by clamping -500 to the range 0...UInt.max.\n\nlet x = Int8(clamping: 500)\n// x == 127\n// x == Int8.max\n\n\nlet y = UInt(clamping: -500)\n// y == 0\n"
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&__(_:_:)-23wlt",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe masking addition assignment operator (&+=) silently wraps any overflow that occurs during the operation. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &+= 21\n// x == 31\nvar y: Int8 = 100\ny &+= 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&__(_:_:)-1s44o",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe overflow subtraction operator (&-) discards any bits that overflow the fixed width of the integer type. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: UInt8 = 21 &- 10\n// x == 11\nlet y: UInt8 = 10 &- 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&__(_:_:)-4pl2m",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "init(_:radix:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(_:radix:)",
    "html": "Parameters\ntext\n\nThe ASCII representation of a number in the radix passed as radix.\n\nradix\n\nThe radix, or base, to use for converting text to an integer value. radix must be in the range 2...36. The default is 10.\n\nDiscussion\n\nThe string passed as text may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9) or letters (a-z or A-Z). Parsing of the string is case insensitive.\n\nlet x = Int(\"123\")\n// x == 123\n\n\nlet y = Int(\"-123\", radix: 8)\n// y == -83\nlet y = Int(\"+123\", radix: 8)\n// y == +83\n\n\nlet z = Int(\"07b\", radix: 16)\n// z == 123\n\n\nIf text is in an invalid format or contains characters that are out of bounds for the given radix, or if the value it denotes in the given radix is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"zzzzzzzzzzzzz\", radix: 36)   // Out of range\n"
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&__(_:_:)-5j3zt",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "~(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/~(_:)",
    "html": "Discussion\n\nThe bitwise NOT operator (~) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are 1 in the argument are 0 in the result, and bits that are 0 in the argument are 1 in the result. This is equivalent to the inverse of a set. For example:\n\nlet x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010\n\n\nPerforming a bitwise NOT operation on 0 returns a value with every bit set to 1.\n\nlet allOnes = ~UInt8.min   // 0b11111111\n\n\nComplexity\n\nO(1)."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&__(_:_:)-6qf3",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&__(_:_:)-u6vr",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/__(_:_:)-2m9b8",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(_:)-5nfkl",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer. source must be representable in this type after rounding toward zero.\n\nDiscussion\nlet x = Int(21.5)\n// x == 21\nlet y = Int(-21.5)\n// y == -21\n\n\nIf source is outside the bounds of this type after rounding toward zero, a runtime error may occur.\n\nlet z = UInt(-21.5)\n// Error: ...outside the representable range\n"
  },
  {
    "title": "init(bigEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(bigendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the big-endian representation of the new integer."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(exactly:)-8acu7",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 21.0, while the attempt to initialize the constant y from 21.5 fails:\n\nlet x = Int(exactly: 21.0)\n// x == Optional(21)\nlet y = Int(exactly: 21.5)\n// y == nil\n"
  },
  {
    "title": "init(truncatingIfNeeded:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(truncatingifneeded:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nWhen the bit width of T (the type of source) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of source. For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of source are used.\n\nlet p: Int16 = -500\n// 'p' has a binary representation of 11111110_00001100\nlet q = Int8(truncatingIfNeeded: p)\n// q == 12\n// 'q' has a binary representation of 00001100\n\n\nWhen the bit width of T is less than this type’s bit width, the result is sign-extended to fill the remaining bits. That is, if source is negative, the result is padded with ones; otherwise, the result is padded with zeros.\n\nlet u: Int8 = 21\n// 'u' has a binary representation of 00010101\nlet v = Int16(truncatingIfNeeded: u)\n// v == 21\n// 'v' has a binary representation of 00000000_00010101\n\n\nlet w: Int8 = -21\n// 'w' has a binary representation of 11101011\nlet x = Int16(truncatingIfNeeded: w)\n// x == -21\n// 'x' has a binary representation of 11111111_11101011\nlet y = UInt16(truncatingIfNeeded: w)\n// y == 65515\n// 'y' has a binary representation of 11111111_11101011\n"
  },
  {
    "title": "init(littleEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(littleendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the little-endian representation of the new integer."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(_:)-jhtz",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer. The value passed as source must be representable in this type.\n\nDiscussion\n\nUse this initializer to convert from another integer type when you know the value is within the bounds of this type. Passing a value that can’t be represented in this type results in a runtime error.\n\nIn the following example, the constant y is successfully created from x, an Int instance with a value of 100. Because the Int8 type can represent 127 at maximum, the attempt to create z with a value of 1000 results in a runtime error.\n\nlet x = 100\nlet y = Int8(x)\n// y == 100\nlet z = Int8(x * 10)\n// Error: Not enough bits to represent the given value\n"
  },
  {
    "title": "min | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/min",
    "html": "Discussion\n\nFor unsigned integer types, this value is always 0."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/'...(_:)-49lx1",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/'...(_:)-79mxl",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/_(_:_:)-9yifb",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/_=(_:_:)-3pf1e",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/customplaygroundquicklook",
    "html": "Deprecated\n\nUInt16.customPlaygroundQuickLook will be removed in a future Swift version"
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/customplaygroundquicklook",
    "html": "Deprecated\n\nUInt8.customPlaygroundQuickLook will be removed in a future Swift version"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_=(_:_:)-5wxfd",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_=(_:_:)-6h9fs",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_(_:_:)-606yp",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "littleEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/littleendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a little-endian platform, for any integer x, x == x.littleEndian."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_(_:_:)-67pzh",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/_=(_:_:)-9k2em",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/_=(_:_:)-4o9y7",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/_(_:_:)-877n2",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/_=(_:_:)-897gt",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/_(_:_:)-5bc9w",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "&>>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&__=(_:_:)-4eicd",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &>>= operator performs a masking shift, where the value passed as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &>>= 2\n// x == 7                         // 0b00000111\n\n\nHowever, if you use 19 as rhs, the operation first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &>>= 19\n// y == 3                         // 0b00000011\n"
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "&<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&__=(_:_:)-4iwdg",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &<<= operator performs a masking shift, where the value used as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &<<= 2\n// x == 120                       // 0b01111000\n\n\nHowever, if you pass 19 as rhs, the method first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &<<= 19\n// y == 240                       // 0b11110000\n"
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpointroundingrule/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/floatingpointroundingrule/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/formindex(before:)-1ghfa",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "&-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&-=(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe masking subtraction assignment operator (&-=) silently wraps any overflow that occurs during the operation. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 21\nx &-= 10\n// x == 11\nvar y: UInt8 = 10\ny &-= 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/&+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe overflow addition operator (&+) discards any bits that overflow the fixed width of the integer type. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &+ 21\n// x == 31\nlet y: Int8 = 100 &+ 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "magnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/magnitude-swift.property",
    "html": "Discussion\n\nEvery unsigned integer is its own magnitude, so for any value x, x == x.magnitude.\n\nThe global abs(_:) function provides more familiar syntax when you need to find an absolute value. In addition, because abs(_:) always returns a value of the same type, even in a generic context, using the function instead of the magnitude property is encouraged."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(_:)-6powq",
    "html": "Parameters\ndescription\n\nThe ASCII representation of a number.\n\nDiscussion\n\nThe string passed as description may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9).\n\nlet x = Int(\"123\")\n// x == 123\n\n\nIf description is in an invalid format, or if the value it denotes in base 10 is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"10000000000000000000000000\") // Out of range\n"
  },
  {
    "title": "max | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/max",
    "html": "Discussion\n\nFor unsigned integer types, this value is (2 ** bitWidth) - 1, where ** is exponentiation."
  },
  {
    "title": "isSigned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/issigned",
    "html": "Discussion\n\nThis property is always false for unsigned integer types."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/init(exactly:)-8ls1a",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 100, while the attempt to initialize the constant y from 1_000 fails because the Int8 type can represent 127 at maximum:\n\nlet x = Int8(exactly: 100)\n// x == Optional(100)\nlet y = Int8(exactly: 1_000)\n// y == nil\n"
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/formindex(before:)-6uf5x",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/_=(_:_:)-1va76",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/_(_:_:)-5jxjs",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/'...(_:)-8yc3u",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "Mirror.AncestorRepresentation.generated | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation/generated",
    "html": "Discussion\n\nThis case is the default when initializing a Mirror instance.\n\nWhen you use this option, a subclass’s mirror generates default mirrors even for ancestor classes that conform to the CustomReflectable protocol. To avoid dropping the customization provided by ancestor classes, an override of customMirror should pass .customized({ super.customMirror }) as ancestorRepresentation when initializing its mirror."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/_=(_:_:)-7pich",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/==(_:_:)-4cq0f",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "Mirror.AncestorRepresentation.suppressed | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation/suppressed",
    "html": "Discussion\n\nIn a mirror created with this ancestor representation, the superclassMirror property is nil."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/mirror/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskpriority/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/'...(_:)-79vop",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "-(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/signednumeric/-(_:)-2q7oc",
    "html": "Return Value\n\nThe additive inverse of the argument.\n\nDiscussion\n\nThe negation operator (prefix -) returns the additive inverse of its argument.\n\nlet x = 21\nlet y = -x\n// y == -21\n\n\nThe resulting value must be representable in the same type as the argument. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nlet z = -Int8.min\n// Overflow error\n"
  },
  {
    "title": "negate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/signednumeric/negate()-4f1ov",
    "html": "Discussion\n\nThe following example uses the negate() method to negate the value of an integer x:\n\nvar x = 21\nx.negate()\n// x == -21\n\n\nThe resulting value must be representable within the value’s type. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nvar y = Int8.min\ny.negate()\n// Overflow error\n"
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/suspendingclock/instant/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/init(_:)-6afuc",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector.\n\nDiscussion\n\nPrecondition\n\nscalars must have the same number of elements as the vector type."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/mirror/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/joined(separator:)-9kr1e",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/'...(_:)-1suah",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "Mirror.AncestorRepresentation.customized(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation/customized(_:)",
    "html": "Discussion\n\nOther classes derived from such an ancestor are given a default mirror. The payload for this option should always be { super.customMirror }:\n\nvar customMirror: Mirror {\n    return Mirror(\n        self,\n        children: [\"someProperty\": self.someProperty],\n        ancestorRepresentation: .customized({ super.customMirror })) // <==\n}\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/index/_(_:_:)-9lk2",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/replacing(with:where:)-h40g",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other : self[i]\n}\n"
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/replacing(with:where:)-3v5ph",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other[i] : self[i]\n}\n"
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/replace(with:where:)-7o8hd",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other[i] }\n}\n"
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/replace(with:where:)-9jte6",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other }\n}\n"
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "init(arrayLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/init(arrayliteral:)",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector. scalars must have the same number of elements as the vector type."
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/*=(_:_:)-46f5z",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "wrappedSum() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/wrappedsum()",
    "html": "Discussion\n\nEquivalent to indices.reduce(into: 0) { $0 &+= self[$1] }."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/+(_:_:)-5rl9l",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": ".==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/'.==(_:_:)-5y9oc",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] == b[i]\n}\n"
  },
  {
    "title": ".!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/'.!=(_:_:)-968x6",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] != b[i]\n}\n"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/-=(_:_:)-6ujbc",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/-=(_:_:)-2aro2",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/-(_:_:)-ily3",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/-(_:_:)-7rtph",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/+=(_:_:)-6aukb",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/+=(_:_:)-318n3",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/*=(_:_:)-36zit",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/*(_:_:)-7shb0",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/_=(_:_:)-1ihi",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/+(_:_:)-473a4",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/-(_:_:)-4vvz",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/+(_:_:)-59ak9",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/*(_:_:)-7q0sz",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/*(_:_:)-418m6",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/_(_:_:)-24u5l",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/_(_:_:)-smlq",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/'...(_:)-4mm50",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/'...(_:)-6ct54",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd32/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/split(separator:maxsplits:omittingemptysubsequences:)-9yjf5",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/subscript(_:)-1cq56",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/subscript(_:)-1eq7u",
    "html": "Overview\n\nPrecondition\n\nposition is a valid position in self and position != endIndex."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/subscript(_:)-cutv",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/subscript(_:)-3w5sk",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nFor example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2..<5]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")!    // 4\nprint(streets[index])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "FlattenSequence.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/replace(with:where:)-7e48m",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other[i] }\n}\n"
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/replacing(with:where:)-3o6pm",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other : self[i]\n}\n"
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/replacing(with:where:)-32hlo",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other[i] : self[i]\n}\n"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/objectidentifier/_=(_:_:)-8lyhu",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "wrappedSum() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/wrappedsum()",
    "html": "Discussion\n\nEquivalent to indices.reduce(into: 0) { $0 &+= self[$1] }."
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/replace(with:where:)-7yq25",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other }\n}\n"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/+=(_:_:)-3it33",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/+=(_:_:)-4kf28",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "init(arrayLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/init(arrayliteral:)",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector. scalars must have the same number of elements as the vector type."
  },
  {
    "title": ".==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/'.==(_:_:)-860hm",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] == b[i]\n}\n"
  },
  {
    "title": ".!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/'.!=(_:_:)-70n1x",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] != b[i]\n}\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/init(_:)-3f03w",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector.\n\nDiscussion\n\nPrecondition\n\nscalars must have the same number of elements as the vector type."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/-=(_:_:)-5eiqo",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/-=(_:_:)-8oyin",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/-(_:_:)-5rbq2",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/-(_:_:)-59t7d",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/-(_:_:)-8vsnc",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/+(_:_:)-844oq",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/*(_:_:)-50ffc",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/+(_:_:)-1h79f",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/*=(_:_:)-4j02f",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/*=(_:_:)-27nt8",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "wrappedSum() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/wrappedsum()",
    "html": "Discussion\n\nEquivalent to indices.reduce(into: 0) { $0 &+= self[$1] }."
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/replace(with:where:)-7yqk1",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other }\n}\n"
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/replacing(with:where:)-3o6zs",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other : self[i]\n}\n"
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/replacing(with:where:)-32h3i",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other[i] : self[i]\n}\n"
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/replace(with:where:)-7e3ns",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other[i] }\n}\n"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/*(_:_:)-4lojf",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/*(_:_:)-6ktum",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "init(arrayLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/init(arrayliteral:)",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector. scalars must have the same number of elements as the vector type."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd2/+(_:_:)-62pyv",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": ".==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/'.==(_:_:)-8605k",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] == b[i]\n}\n"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/-=(_:_:)-8oysv",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/-=(_:_:)-5ej92",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/-(_:_:)-8vs62",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/init(_:)-3f00q",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector.\n\nDiscussion\n\nPrecondition\n\nscalars must have the same number of elements as the vector type."
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/-(_:_:)-5rbfs",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/*=(_:_:)-27oce",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/-(_:_:)-59t4d",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/+=(_:_:)-4kezy",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": ".!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/'.!=(_:_:)-70ndl",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] != b[i]\n}\n"
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/replacing(with:where:)-ng2a",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other : self[i]\n}\n"
  },
  {
    "title": "replacing(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/replacing(with:where:)-42oan",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = Self()\nfor i in indices {\n  result[i] = mask[i] ? other[i] : self[i]\n}\n"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/*(_:_:)-6ktkg",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/*(_:_:)-50fba",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/+=(_:_:)-3islb",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/+(_:_:)-1h7rv",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/*=(_:_:)-4j0iv",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/+(_:_:)-844rw",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/+(_:_:)-62q9z",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd3/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/replace(with:where:)-9cks4",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other }\n}\n"
  },
  {
    "title": "replace(with:where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/replace(with:where:)-7gncz",
    "html": "Discussion\n\nEquivalent to:\n\nfor i in indices {\n  if mask[i] { self[i] = other[i] }\n}\n"
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "wrappedSum() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/wrappedsum()",
    "html": "Discussion\n\nEquivalent to indices.reduce(into: 0) { $0 &+= self[$1] }."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/init(_:)-64awu",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector.\n\nDiscussion\n\nPrecondition\n\nscalars must have the same number of elements as the vector type."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/-=(_:_:)-6n3d6",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/+=(_:_:)-2urad",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "init(arrayLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/init(arrayliteral:)",
    "html": "Parameters\nscalars\n\nThe elements to use in the vector. scalars must have the same number of elements as the vector type."
  },
  {
    "title": ".!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/'.!=(_:_:)-8zu6g",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] != b[i]\n}\n"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/-=(_:_:)-2iaa8",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-=' instead"
  },
  {
    "title": ".==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/'.==(_:_:)-64qzq",
    "html": "Discussion\n\nEquivalent to:\n\nvar result = SIMDMask<MaskStorage>()\nfor i in result.indices {\n  result[i] = a[i] == b[i]\n}\n"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/+=(_:_:)-63jfd",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+=' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/+(_:_:)-5z1ez",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/+(_:_:)-52yaj",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/+(_:_:)-40yo6",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&+' instead"
  },
  {
    "title": "~=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangeupto/~=(_:_:)",
    "html": "Parameters\npattern\n\nA range.\n\nbound\n\nA value to match against pattern.\n\nDiscussion\n\nYou can use the pattern-matching operator (~=) to test whether a value is included in a range. The pattern-matching operator is used internally in case statements for pattern matching. The following example uses the ~= operator to test whether an integer is included in a range of single-digit numbers:\n\nlet chosenNumber = 3\nif 0..<10 ~= chosenNumber {\n    print(\"\\(chosenNumber) is a single digit.\")\n}\n// Prints \"3 is a single digit.\"\n"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangethrough/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "visibility(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/visibility(_:)",
    "html": "Parameters\nvisibility\n\nThe visibility level."
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/*(_:_:)-7whvl",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/*(_:_:)-7l65y",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/-(_:_:)-bdg9",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/-(_:_:)-7z2dr",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/-(_:_:)-c6qt",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&-' instead"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/_(_:_:)-26oxe",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "Float.IntegerLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/integerliteraltype",
    "html": "Discussion\n\nThe standard library integer and floating-point types are all valid types for IntegerLiteralType."
  },
  {
    "title": "dataValueType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/datavaluetype",
    "html": "Discussion\n\nSee MLDataValue/ValueType for a list of available options."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "Scalar | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdstorage/scalar",
    "html": "Required"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangethrough/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to check for containment.\n\nReturn Value\n\ntrue if element is contained in the range expression; otherwise, false."
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdstorage/init()",
    "html": "Required"
  },
  {
    "title": "relative(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangethrough/relative(to:)",
    "html": "Parameters\ncollection\n\nThe collection to evaluate this range expression in relation to.\n\nReturn Value\n\nA range suitable for slicing collection. The returned range is not guaranteed to be inside the bounds of collection. Callers should apply the same preconditions to the return value as they would to a range provided directly by the user.\n\nDiscussion\n\nYou can use the relative(to:) method to convert a range expression, which could be missing one or both of its endpoints, into a concrete range that is bounded on both sides. The following example uses this method to convert a partial range up to 4 into a half-open range, using an array instance to add the range’s lower bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nlet upToFour = ..<4\n\n\nlet r1 = upToFour.relative(to: numbers)\n// r1 == 0..<4\n\n\nThe r1 range is bounded on the lower end by 0 because that is the starting index of the numbers array. When the collection passed to relative(to:) starts with a different index, that index is used as the lower bound instead. The next example creates a slice of numbers starting at index 2, and then uses the slice with relative(to:) to convert upToFour to a concrete range.\n\nlet numbersSuffix = numbers[2...]\n// numbersSuffix == [30, 40, 50, 60, 70]\n\n\nlet r2 = upToFour.relative(to: numbersSuffix)\n// r2 == 2..<4\n\n\nUse this method only if you need the concrete range it produces. To access a slice of a collection using a range expression, use the collection’s generic subscript that uses a range expression as its parameter.\n\nlet numbersPrefix = numbers[upToFour]\n// numbersPrefix == [10, 20, 30, 40]\n"
  },
  {
    "title": "~=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangethrough/~=(_:_:)",
    "html": "Parameters\npattern\n\nA range.\n\nbound\n\nA value to match against pattern.\n\nDiscussion\n\nYou can use the pattern-matching operator (~=) to test whether a value is included in a range. The pattern-matching operator is used internally in case statements for pattern matching. The following example uses the ~= operator to test whether an integer is included in a range of single-digit numbers:\n\nlet chosenNumber = 3\nif 0..<10 ~= chosenNumber {\n    print(\"\\(chosenNumber) is a single digit.\")\n}\n// Prints \"3 is a single digit.\"\n"
  },
  {
    "title": "compare(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/compare(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nA value to compare.\n\nDiscussion\n\nThe result of comparisons should be flipped if the current order is reverse.\n\nIf compare(lhs, rhs) is .orderedAscending, then compare(rhs, lhs) must be .orderedDescending. If compare(lhs, rhs) is .orderedDescending, then compare(rhs, lhs) must be .orderedAscending."
  },
  {
    "title": "scalarCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdstorage/scalarcount-swift.property",
    "html": "Required Default implementation provided.\n\nDefault Implementations\nSIMDStorage Implementations\nstatic var scalarCount: Int\nThe number of scalars, or elements, in a vector of this type."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangeupto/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to check for containment.\n\nReturn Value\n\ntrue if element is contained in the range expression; otherwise, false."
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/*(_:_:)-3ur7o",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*' instead"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/*=(_:_:)-4dnsd",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/*=(_:_:)-2zjkv",
    "html": "Deprecated\n\ninteger vector types do not support checked arithmetic; use the wrapping operator '&*=' instead"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_(_:_:)-5fkgf",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_(_:_:)-9l49m",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_=(_:_:)-1jjgk",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_(_:_:)-2j2vz",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "quotientAndRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/quotientandremainder(dividingby:)",
    "html": "Parameters\nrhs\n\nThe value to divide this value by.\n\nReturn Value\n\nA tuple containing the quotient and remainder of this value divided by rhs.\n\nDiscussion\n\nUse this method to calculate the quotient and remainder of a division at the same time.\n\nlet x = 1_000_000\nlet (q, r) = x.quotientAndRemainder(dividingBy: 933)\n// q == 1071\n// r == 757\n"
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "body | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/body-8li6s",
    "html": "Discussion\n\nCombine multiple existing transfer representations to compose a single transfer representation that describes how to transfer an item in multiple scenarios.\n\nstruct CombinedRepresentation: TransferRepresentation {\n   var body: some TransferRepresentation {\n       DataRepresentation(...)\n       FileRepresentation(...)\n   }\n}\n"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/_=(_:_:)-8zp5u",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/_(_:_:)-4z5nl",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/init(exactly:)-7vjwc",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 100, while the attempt to initialize the constant y from 1_000 fails because the Int8 type can represent 127 at maximum:\n\nlet x = Int8(exactly: 100)\n// x == Optional(100)\nlet y = Int8(exactly: 1_000)\n// y == nil\n"
  },
  {
    "title": "isSigned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/issigned",
    "html": "Discussion\n\nThis property is always true for signed integer types."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/init(_:)-4i8wx",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer. The value passed as source must be representable in this type.\n\nDiscussion\n\nUse this initializer to convert from another integer type when you know the value is within the bounds of this type. Passing a value that can’t be represented in this type results in a runtime error.\n\nIn the following example, the constant y is successfully created from x, an Int instance with a value of 100. Because the Int8 type can represent 127 at maximum, the attempt to create z with a value of 1000 results in a runtime error.\n\nlet x = 100\nlet y = Int8(x)\n// y == 100\nlet z = Int8(x * 10)\n// Error: Not enough bits to represent the given value\n"
  },
  {
    "title": "min | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/min",
    "html": "Discussion\n\nFor signed integer types, this value is -(2 ** (bitWidth - 1)), where ** is exponentiation."
  },
  {
    "title": "max | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/max",
    "html": "Discussion\n\nFor signed integer types, this value is (2 ** (bitWidth - 1)) - 1, where ** is exponentiation."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/customplaygroundquicklook",
    "html": "Deprecated\n\nInt64.customPlaygroundQuickLook will be removed in a future Swift version"
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/init(integerliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_=(_:_:)-6mb7g",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_=(_:_:)-561mj",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdstorage/subscript(_:)-82o6b",
    "html": "Required Default implementations provided.\n\nParameters\nindex\n\nThe index of the element to access. index must be in the range 0..<scalarCount.\n\nDefault Implementations\nSIMDStorage Implementations\nsubscript<Index>(SIMD2<Index>) -> SIMD2<Self.Scalar>\nExtracts the scalars at specified indices to form a SIMD2.\nsubscript<Index>(SIMD3<Index>) -> SIMD3<Self.Scalar>\nExtracts the scalars at specified indices to form a SIMD3.\nsubscript<Index>(SIMD32<Index>) -> SIMD32<Self.Scalar>\nExtracts the scalars at specified indices to form a SIMD32.\nsubscript<Index>(SIMD16<Index>) -> SIMD16<Self.Scalar>\nExtracts the scalars at specified indices to form a SIMD16.\nsubscript<Index>(SIMD64<Index>) -> SIMD64<Self.Scalar>\nExtracts the scalars at specified indices to form a SIMD64.\nsubscript<Index>(SIMD4<Index>) -> SIMD4<Self.Scalar>\nExtracts the scalars at specified indices to form a SIMD4.\nsubscript<Index>(SIMD8<Index>) -> SIMD8<Self.Scalar>\nExtracts the scalars at specified indices to form a SIMD8."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangethrough/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simd16/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangeupto/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "relative(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangeupto/relative(to:)",
    "html": "Parameters\ncollection\n\nThe collection to evaluate this range expression in relation to.\n\nReturn Value\n\nA range suitable for slicing collection. The returned range is not guaranteed to be inside the bounds of collection. Callers should apply the same preconditions to the return value as they would to a range provided directly by the user.\n\nDiscussion\n\nYou can use the relative(to:) method to convert a range expression, which could be missing one or both of its endpoints, into a concrete range that is bounded on both sides. The following example uses this method to convert a partial range up to 4 into a half-open range, using an array instance to add the range’s lower bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nlet upToFour = ..<4\n\n\nlet r1 = upToFour.relative(to: numbers)\n// r1 == 0..<4\n\n\nThe r1 range is bounded on the lower end by 0 because that is the starting index of the numbers array. When the collection passed to relative(to:) starts with a different index, that index is used as the lower bound instead. The next example creates a slice of numbers starting at index 2, and then uses the slice with relative(to:) to convert upToFour to a concrete range.\n\nlet numbersSuffix = numbers[2...]\n// numbersSuffix == [30, 40, 50, 60, 70]\n\n\nlet r2 = upToFour.relative(to: numbersSuffix)\n// r2 == 2..<4\n\n\nUse this method only if you need the concrete range it produces. To access a slice of a collection using a range expression, use the collection’s generic subscript that uses a range expression as its parameter.\n\nlet numbersPrefix = numbers[upToFour]\n// numbersPrefix == [10, 20, 30, 40]\n"
  },
  {
    "title": "exportingCondition(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/exportingcondition(_:)",
    "html": "Parameters\ncondition\n\nA closure that determines whether the item is exportable. Don’t perform long-running work in this closure. It shouldn’t contain network requests, file operations, or other potentially time-consuming tasks as they can cause delays during operations with Transferable items.\n\nDiscussion\n\nSome instances of a model type may have state-dependent conditions that make them unsuitable for export. For example, an Archive structure that supports a comma-separated text representation only when it has compatible content:\n\nstruct Archive {\n    var supportsCSV: Bool\n    func csvData() -> Data\n    init(csvData: Data)\n}\n\n\nextension Archive: Transferable {\n    static var transferRepresentation: some TransferRepresentation {\n        DataRepresentation(contentType: .commaSeparatedText) { archive in\n            archive.csvData()\n        } importing: { data in Archive(csvData: data) }\n            .exportingCondition { archive in archive.supportsCSV }\n    }\n}\n"
  },
  {
    "title": "suggestedFileName(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/suggestedfilename(_:)-940ze",
    "html": "Parameters\nfileName\n\nThe suggested filename including the filename extension. If several suggested file names are specified on an item, only the last one will be used.\n\nDiscussion\n\nAny transfer representation can be written to disk.\n\n extension ImageDocumentLayer: Transferable {\n     static var transferRepresentation: some TransferRepresentation {\n         DataRepresentation(contentType: .layer) { layer in\n             layer.data()\n             } importing: { data in\n                 try ImageDocumentLayer(data: data)\n             }\n             .suggestedFileName(\"Layer.exampleLayer\")\n         DataRepresentation(exportedContentType: .png) { layer in\n             layer.pngData()\n         }\n         .suggestedFileName(\"Layer.png\")\n     }\n }\n\n\nThe .exampleLayer filename extension above should match the extension for the layer content type, which you declare in your app’s Info.plist file."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/partialrangeupto/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "suggestedFileName(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/suggestedfilename(_:)-3oljg",
    "html": "Parameters\nfileName\n\nThe optional closure that returns the suggested filename including the filename extension. If several suggested file names are specified on an item, only the last one will be used.\n\nDiscussion\n\nAny transfer representation can be written to disk.\n\nstruct Note: Transferable {\n    var title: String\n    var body: String\n    static var transferRepresentation: some TransferRepresentation {\n        ProxyRepresentation(exporting: \\.body)\n            .suggestedFileName { $0.title + \".txt\" }\n     }\n }\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_=(_:_:)-2dl1k",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_=(_:_:)-3tzj9",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_=(_:_:)-4500l",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_(_:_:)-4twvv",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/'...(_:)-6hr1s",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/'...(_:)-2lfk5",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "%(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_(_:_:)-2xs3w",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nThe result of the remainder operator (%) has the same sign as lhs and has a magnitude less than rhs.magnitude.\n\nlet x = 22 % 5\n// x == 2\nlet y = 22 % -5\n// y == 2\nlet z = -22 % -5\n// z == -2\n\n\nFor any two integers a and b, their quotient q, and their remainder r, a == b * q + r."
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_(_:_:)-340al",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_(_:_:)-5oz05",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_(_:_:)-4u3sc",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than operator (>), even if the two instances are of different types."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_(_:_:)-65vvy",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_(_:_:)-6otcp",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than operator (<), even if the two instances are of different types."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_=(_:_:)-1d6gy",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than-or-equal-to operator (<=), even if the two instances are of different types."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/__(_:_:)-364qh",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_=(_:_:)-8h42b",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than-or-equal-to operator (>=), even if the two instances are of different types."
  },
  {
    "title": ">>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/__=(_:_:)-1yiba",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >>= operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx >>= 2\n// x == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny >>= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na >>= -3\n// a == 240                       // 0b11110000\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb <<= 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nvar q: Int8 = -30                 // 0b11100010\nq >>= 2\n// q == -8                        // 0b11111000\n\n\nvar r: Int8 = -30                 // 0b11100010\nr >>= 11\n// r == -1                        // 0b11111111\n"
  },
  {
    "title": "<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/__=(_:_:)-8bomq",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx <<= 2\n// x == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny <<= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na <<= -3\n// a == 3                         // 0b00000011\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb >>= 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/__(_:_:)-7p8tu",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/_=(_:_:)-999en",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "-(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/-(_:)",
    "html": "Return Value\n\nThe additive inverse of the argument.\n\nDiscussion\n\nThe negation operator (prefix -) returns the additive inverse of its argument.\n\nlet x = 21\nlet y = -x\n// y == -21\n\n\nThe resulting value must be representable in the same type as the argument. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nlet z = -Int8.min\n// Overflow error\n"
  },
  {
    "title": "negate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/negate()",
    "html": "Discussion\n\nThe following example uses the negate() method to negate the value of an integer x:\n\nvar x = 21\nx.negate()\n// x == -21\n\n\nThe resulting value must be representable within the value’s type. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nvar y = Int8.min\ny.negate()\n// Overflow error\n"
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/'...(_:)-8j8j6",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/'...(_:)-45ng",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "init(signOf:magnitudeOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/init(signof:magnitudeof:)-6i9uw",
    "html": "Parameters\nsignOf\n\nA value from which to use the sign. The result of the initializer has the same sign as signOf.\n\nmagnitudeOf\n\nA value from which to use the magnitude. The result of the initializer has the same magnitude as magnitudeOf.\n\nDiscussion\n\nThe following example uses this initializer to create a new Double instance with the sign of a and the magnitude of b:\n\nlet a = -21.5\nlet b = 305.15\nlet c = Double(signOf: a, magnitudeOf: b)\nprint(c)\n// Prints \"-305.15\"\n\n\nThis initializer implements the IEEE 754 copysign operation."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/-=(_:_:)-67mm8",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by.\n\nDiscussion\n\nThe division operator (/) calculates the quotient of the division if rhs is nonzero. If rhs is zero, the result of the division is infinity, with the sign of the result matching the sign of lhs.\n\nlet x = 16.875\nlet y = x / 2.25\n// y == 7.5\n\n\nlet z = x / 0\n// z.isInfinite == true\n\n\nThe / operator implements the division operation defined by the IEEE 754 specification."
  },
  {
    "title": "-(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/-(_:)-44ygc",
    "html": "Parameters\noperand\n\nThe value to negate.\n\nDiscussion\n\nThe unary minus operator (prefix -) calculates the negation of its operand. The result is always exact.\n\nlet x = 21.5\nlet y = -x\n// y == -21.5\n"
  },
  {
    "title": "isDiscoverable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/isdiscoverable",
    "html": "Discussion\n\nApp Intents must be discoverable to support App Shortcuts. If you an app intend isn’t discoverable, people can use it only when it’s directly connected by a button in a SwiftUI app or a widget.\n\nThis property is true by default."
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/distance(to:)",
    "html": "Parameters\nother\n\nThe value to calculate the distance to.\n\nReturn Value\n\nThe distance from this value to other.\n\nDiscussion\n\nFor two values x and y, and a distance n = x.distance(to: y), x.advanced(by: n) == y."
  },
  {
    "title": "littleEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/littleendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a little-endian platform, for any integer x, x == x.littleEndian."
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nFor a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n."
  },
  {
    "title": "negate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/negate()",
    "html": "Discussion\n\nThe following example uses the negate() method to negate the value of an integer x:\n\nvar x = 21\nx.negate()\n// x == -21\n\n\nThe resulting value must be representable within the value’s type. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nvar y = Int8.min\ny.negate()\n// Overflow error\n"
  },
  {
    "title": "transferRepresentation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/transferrepresentation",
    "html": "Discussion\n\nA transferRepresentation can contain multiple representations for different content types."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "Never.Representation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/representation",
    "html": "Discussion\n\nSwift infers this type from the return value of the transferRepresentation property."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&(_:_:)-jsun",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&(_:_:)-5w3in",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/!=(_:_:)-3fzrz",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the inequality of instances of any BinaryInteger types using the not-equal-to operator (!=). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is not equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are different: \\(firstUTF8 != firstScalar)\")\n}\n// Prints \"First code values are different: false\"\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/==(_:_:)-1qxpp",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the equality of instances of any BinaryInteger types using the equal-to operator (==). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are equal: \\(firstUTF8 == firstScalar)\")\n}\n// Prints \"First code values are equal: true\"\n"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\n2 * 3                   // 6\n100 * 21                // 2100\n-10 * 15                // -150\n3.5 * 2.25              // 7.875\n\n\nYou cannot use * with arguments of different types. To multiply values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) * y              // 21000000\n\n\nThe product of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 * 21 is greater than the maximum representable Int8 value:\n\nx * 21                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow multiplication operator (&*).\n\nx &* 21                // -115\n"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\n1 + 2                   // 3\n-10 + 15                // 5\n-15 + -5                // -20\n21.5 + 3.25             // 24.75\n\n\nYou cannot use + with arguments of different types. To add values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) + y              // 1000021\n\n\nThe sum of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 + 120 is greater than the maximum representable Int8 value:\n\nx + 120                 // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow addition operator (&+).\n\nx &+ 120                // -115\n"
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nFor integer types, any remainder of the division is discarded.\n\nlet x = 21 / 5\n// x == 4\n"
  },
  {
    "title": "isMultiple(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/ismultiple(of:)",
    "html": "Parameters\nother\n\nThe value to test.\n\nDiscussion\n\nFor two integers a and b, a is a multiple of b if there exists a third integer q such that a = q*b. For example, 6 is a multiple of 3 because 6 = 2*3. Zero is a multiple of everything because 0 = 0*x for any integer x.\n\nTwo edge cases are worth particular attention:\n\nx.isMultiple(of: 0) is true if x is zero and false otherwise.\n\nT.min.isMultiple(of: -1) is true for signed integer T, even though the quotient T.min / -1 isn’t representable in type T."
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\n8 - 3                   // 5\n-10 - 5                 // -15\n100 - -5                // 105\n10.5 - 100.0            // -89.5\n\n\nYou cannot use - with arguments of different types. To subtract values of different types, convert one of the values to the other value’s type.\n\nlet x: UInt8 = 21\nlet y: UInt = 1000000\ny - UInt(x)             // 999979\n\n\nThe difference of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 - 50 is less than zero, the minimum representable UInt8 value:\n\nx - 50                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow subtraction operator (&-).\n\nx &- 50                // 227\n"
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/_(_:_:)-1pc7e",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "init(bigEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/init(bigendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the big-endian representation of the new integer."
  },
  {
    "title": "ulpOfOne | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/ulpofone-1s81z",
    "html": "Discussion\n\nThe positive difference between 1.0 and the next greater representable number. ulpOfOne corresponds to the value represented by the C macros FLT_EPSILON, DBL_EPSILON, etc, and is sometimes called epsilon or machine epsilon. Swift deliberately avoids using the term “epsilon” because:\n\nHistorically “epsilon” has been used to refer to several different concepts in different languages, leading to confusion and bugs.\n\nThe name “epsilon” suggests that this quantity is a good tolerance to choose for approximate comparisons, but it is almost always unsuitable for that purpose.\n\nSee also the ulp member property."
  },
  {
    "title": "init(_:radix:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/init(_:radix:)",
    "html": "Parameters\ntext\n\nThe ASCII representation of a number in the radix passed as radix.\n\nradix\n\nThe radix, or base, to use for converting text to an integer value. radix must be in the range 2...36. The default is 10.\n\nDiscussion\n\nThe string passed as text may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9) or letters (a-z or A-Z). Parsing of the string is case insensitive.\n\nlet x = Int(\"123\")\n// x == 123\n\n\nlet y = Int(\"-123\", radix: 8)\n// y == -83\nlet y = Int(\"+123\", radix: 8)\n// y == +83\n\n\nlet z = Int(\"07b\", radix: 16)\n// z == 123\n\n\nIf text is in an invalid format or contains characters that are out of bounds for the given radix, or if the value it denotes in the given radix is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"zzzzzzzzzzzzz\", radix: 36)   // Out of range\n"
  },
  {
    "title": "-(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/-(_:)",
    "html": "Return Value\n\nThe additive inverse of the argument.\n\nDiscussion\n\nThe negation operator (prefix -) returns the additive inverse of its argument.\n\nlet x = 21\nlet y = -x\n// y == -21\n\n\nThe resulting value must be representable in the same type as the argument. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nlet z = -Int8.min\n// Overflow error\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/init(exactly:)-uz92",
    "html": "Parameters\nvalue\n\nThe integer to convert to a floating-point value.\n\nDiscussion\n\nIf the given integer cannot be represented exactly, the result is nil."
  },
  {
    "title": "/=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float//=(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by."
  },
  {
    "title": "Never.SummaryContent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/summarycontent",
    "html": "Discussion\n\nWhen you create an intent, Swift infers this type from your implementation of the parameterSummary property."
  },
  {
    "title": "donate(result:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/donate(result:)-rsyn",
    "html": "Discussion\n\nThis synchronous function is available to applications that haven’t adopted Swift async concurrency. The system ignores any exceptions encountered when donating this intent."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/random(in:using:)-1ac76",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n"
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/random(in:using:)-2tzae",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n\n\nNote\n\nThe algorithm used to create random values may change in a future version of Swift. If you’re passing a generator that results in the same sequence of integer values each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "donate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/donate()",
    "html": "Discussion\n\nThis synchronous function is available to applications that haven’t adopted Swift async concurrency. The system ignores any exceptions encountered when donating this intent."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/random(in:)-5f9pk",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling random(in:using:), passing in the system’s default random generator."
  },
  {
    "title": "systemContext | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/systemcontext",
    "html": "Discussion\n\nThis includes information such as a precise timestamp in cases where the AppIntent is being executed as a result of the user pressing the Apple Watch Ultra’s Action button."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/random(in:)-4o9ko",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling the version that takes a generator, passing in the system’s default random generator."
  },
  {
    "title": "&+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe masking addition assignment operator (&+=) silently wraps any overflow that occurs during the operation. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &+= 21\n// x == 31\nvar y: Int8 = 100\ny &+= 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "multipliedFullWidth(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/multipliedfullwidth(by:)-9ozhd",
    "html": "Parameters\nother\n\nThe value to multiply this value by.\n\nReturn Value\n\nA tuple containing the high and low parts of the result of multiplying this value and other.\n\nDiscussion\n\nUse this method to calculate the full result of a product that would otherwise overflow. Unlike traditional truncating multiplication, the multipliedFullWidth(by:) method returns a tuple containing both the high and low parts of the product of this value and other. The following example uses this method to multiply two Int8 values that normally overflow when multiplied:\n\nlet x: Int8 = 48\nlet y: Int8 = -40\nlet result = x.multipliedFullWidth(by: y)\n// result.high == -8\n// result.low  == 128\n\n\nThe product of x and y is -1920, which is too large to represent in an Int8 instance. The high and low components of the result value represent -1920 when concatenated to form a double-width integer; that is, using result.high as the high byte and result.low as the low byte of an Int16 instance.\n\nlet z = Int16(result.high) << 8 | Int16(result.low)\n// z == -1920\n"
  },
  {
    "title": "&*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe overflow multiplication operator (&*) discards any bits that overflow the fixed width of the integer type. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &* 5\n// x == 50\nlet y: Int8 = 10 &* 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&+(_:_:)-4tylx",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe overflow addition operator (&+) discards any bits that overflow the fixed width of the integer type. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &+ 21\n// x == 31\nlet y: Int8 = 100 &+ 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe masking multiplication assignment operator (&*=) silently wraps any overflow that occurs during the operation. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &*= 5\n// x == 50\nvar y: Int8 = 10\ny &*= 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&-(_:_:)-18b07",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe overflow subtraction operator (&-) discards any bits that overflow the fixed width of the integer type. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: UInt8 = 21 &- 10\n// x == 11\nlet y: UInt8 = 10 &- 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_=(_:_:)-3c0fc",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_(_:_:)-45mu2",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/__(_:_:)-64bg6",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_(_:_:)-2n4zk",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&__(_:_:)-35gqp",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&-=(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe masking subtraction assignment operator (&-=) silently wraps any overflow that occurs during the operation. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 21\nx &-= 10\n// x == 11\nvar y: UInt8 = 10\ny &-= 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&__(_:_:)-1vhcm",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&__(_:_:)-3uykh",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&__=(_:_:)-7fhnz",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &>>= operator performs a masking shift, where the value passed as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &>>= 2\n// x == 7                         // 0b00000111\n\n\nHowever, if you use 19 as rhs, the operation first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &>>= 19\n// y == 3                         // 0b00000011\n"
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/__(_:_:)-2o6oi",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/__(_:_:)-6es2r",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "&<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&__=(_:_:)-o7l7",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &<<= operator performs a masking shift, where the value used as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &<<= 2\n// x == 120                       // 0b01111000\n\n\nHowever, if you pass 19 as rhs, the method first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &<<= 19\n// y == 240                       // 0b11110000\n"
  },
  {
    "title": "init(clamping:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/init(clamping:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nIf the value passed as source is greater than the maximum representable value in this type, the result is the type’s max value. If source is less than the smallest representable value in this type, the result is the type’s min value.\n\nIn this example, x is initialized as an Int8 instance by clamping 500 to the range -128...127, and y is initialized as a UInt instance by clamping -500 to the range 0...UInt.max.\n\nlet x = Int8(clamping: 500)\n// x == 127\n// x == Int8.max\n\n\nlet y = UInt(clamping: -500)\n// y == 0\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/init(exactly:)-7ihf2",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 21.0, while the attempt to initialize the constant y from 21.5 fails:\n\nlet x = Int(exactly: 21.0)\n// x == Optional(21)\nlet y = Int(exactly: 21.5)\n// y == nil\n"
  },
  {
    "title": "init(littleEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/init(littleendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the little-endian representation of the new integer."
  },
  {
    "title": "bigEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/bigendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a big-endian platform, for any integer x, x == x.bigEndian."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/-=(_:_:)-88vzw",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_=(_:_:)-6bkn5",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/zero",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "requestConfirmation(output:confirmationActionName:showPrompt:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/requestconfirmation(output:confirmationactionname:showprompt:)",
    "html": "Deprecated\n\nPlease use requestConfirmation(result:confirmationActionName:showPrompt:)"
  },
  {
    "title": "perform() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/perform()",
    "html": "Discussion\n\nIn the body of this function, validate your parameters and provide the system with information about needed parameter values or user clarification."
  },
  {
    "title": "Float.FloatLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/floatliteraltype",
    "html": "Discussion\n\nValid types for FloatLiteralType are Float, Double, and Float80 where available."
  },
  {
    "title": "&*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe masking multiplication assignment operator (&*=) silently wraps any overflow that occurs during the operation. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &*= 5\n// x == 50\nvar y: Int8 = 10\ny &*= 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/customplaygroundquicklook",
    "html": "Deprecated\n\nInt16.customPlaygroundQuickLook will be removed in a future Swift version"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_=(_:_:)-4rhds",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "quotientAndRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/quotientandremainder(dividingby:)",
    "html": "Parameters\nrhs\n\nThe value to divide this value by.\n\nReturn Value\n\nA tuple containing the quotient and remainder of this value divided by rhs.\n\nDiscussion\n\nUse this method to calculate the quotient and remainder of a division at the same time.\n\nlet x = 1_000_000\nlet (q, r) = x.quotientAndRemainder(dividingBy: 933)\n// q == 1071\n// r == 757\n"
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "&+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe masking addition assignment operator (&+=) silently wraps any overflow that occurs during the operation. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &+= 21\n// x == 31\nvar y: Int8 = 100\ny &+= 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_(_:_:)-2bfow",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_=(_:_:)-4tbcs",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/'...(_:)-6emvd",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/'...(_:)-2vv5k",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "isMultiple(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/ismultiple(of:)",
    "html": "Parameters\nother\n\nThe value to test.\n\nDiscussion\n\nFor two integers a and b, a is a multiple of b if there exists a third integer q such that a = q*b. For example, 6 is a multiple of 3 because 6 = 2*3. Zero is a multiple of everything because 0 = 0*x for any integer x.\n\nTwo edge cases are worth particular attention:\n\nx.isMultiple(of: 0) is true if x is zero and false otherwise.\n\nT.min.isMultiple(of: -1) is true for signed integer T, even though the quotient T.min / -1 isn’t representable in type T."
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/distance(to:)",
    "html": "Parameters\nother\n\nThe value to calculate the distance to.\n\nReturn Value\n\nThe distance from this value to other.\n\nDiscussion\n\nFor two values x and y, and a distance n = x.distance(to: y), x.advanced(by: n) == y."
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nFor a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/!=(_:_:)-35jaq",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the inequality of instances of any BinaryInteger types using the not-equal-to operator (!=). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is not equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are different: \\(firstUTF8 != firstScalar)\")\n}\n// Prints \"First code values are different: false\"\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&(_:_:)-11qqq",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\n1 + 2                   // 3\n-10 + 15                // 5\n-15 + -5                // -20\n21.5 + 3.25             // 24.75\n\n\nYou cannot use + with arguments of different types. To add values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) + y              // 1000021\n\n\nThe sum of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 + 120 is greater than the maximum representable Int8 value:\n\nx + 120                 // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow addition operator (&+).\n\nx &+ 120                // -115\n"
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nFor integer types, any remainder of the division is discarded.\n\nlet x = 21 / 5\n// x == 4\n"
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/__(_:_:)-1zwhf",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/==(_:_:)-1ntek",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the equality of instances of any BinaryInteger types using the equal-to operator (==). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are equal: \\(firstUTF8 == firstScalar)\")\n}\n// Prints \"First code values are equal: true\"\n"
  },
  {
    "title": ">>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/__=(_:_:)-1hmwr",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >>= operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx >>= 2\n// x == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny >>= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na >>= -3\n// a == 240                       // 0b11110000\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb <<= 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nvar q: Int8 = -30                 // 0b11100010\nq >>= 2\n// q == -8                        // 0b11111000\n\n\nvar r: Int8 = -30                 // 0b11100010\nr >>= 11\n// r == -1                        // 0b11111111\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_(_:_:)-4d8dd",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than operator (>), even if the two instances are of different types."
  },
  {
    "title": "remainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/remainder(dividingby:)",
    "html": "Parameters\nother\n\nThe value to use when dividing this value.\n\nReturn Value\n\nThe remainder of this value divided by other.\n\nDiscussion\n\nFor two finite values x and y, the remainder r of dividing x by y satisfies x == y * q + r, where q is the integer nearest to x / y. If x / y is exactly halfway between two integers, q is chosen to be even. Note that q is not x / y computed in floating-point arithmetic, and that q may not be representable in any available integer type.\n\nThe following example calculates the remainder of dividing 8.625 by 0.75:\n\nlet x = 8.625\nprint(x / 0.75)\n// Prints \"11.5\"\n\n\nlet q = (x / 0.75).rounded(.toNearestOrEven)\n// q == 12.0\nlet r = x.remainder(dividingBy: 0.75)\n// r == -0.375\n\n\nlet x1 = 0.75 * q + r\n// x1 == 8.625\n\n\nIf this value and other are finite numbers, the remainder is in the closed range -abs(other / 2)...abs(other / 2). The remainder(dividingBy:) method is always exact. This method implements the remainder operation defined by the IEEE 754 specification."
  },
  {
    "title": "infinity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/infinity",
    "html": "Discussion\n\nInfinity compares greater than all finite numbers and equal to other infinite values.\n\nlet x = Double.greatestFiniteMagnitude\nlet y = x * 2\n// y == Double.infinity\n// y > x\n"
  },
  {
    "title": "%(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_(_:_:)-412im",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nThe result of the remainder operator (%) has the same sign as lhs and has a magnitude less than rhs.magnitude.\n\nlet x = 22 % 5\n// x == 2\nlet y = 22 % -5\n// y == 2\nlet z = -22 % -5\n// z == -2\n\n\nFor any two integers a and b, their quotient q, and their remainder r, a == b * q + r."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/_(_:_:)-fe4v",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_(_:_:)-5s4nw",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_(_:_:)-6e2wc",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than operator (<), even if the two instances are of different types."
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_(_:_:)-5yszf",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_(_:_:)-6tyn",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/__(_:_:)-70yoj",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&__(_:_:)-gclw",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/init(_:)-6esec",
    "html": "Parameters\ndescription\n\nThe ASCII representation of a number.\n\nDiscussion\n\nThe string passed as description may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9).\n\nlet x = Int(\"123\")\n// x == 123\n\n\nIf description is in an invalid format, or if the value it denotes in base 10 is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"10000000000000000000000000\") // Out of range\n"
  },
  {
    "title": "~(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/~(_:)",
    "html": "Discussion\n\nThe bitwise NOT operator (~) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are 1 in the argument are 0 in the result, and bits that are 0 in the argument are 1 in the result. This is equivalent to the inverse of a set. For example:\n\nlet x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010\n\n\nPerforming a bitwise NOT operation on 0 returns a value with every bit set to 1.\n\nlet allOnes = ~UInt8.min   // 0b11111111\n\n\nComplexity\n\nO(1)."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&__(_:_:)-61wzt",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/&__(_:_:)-5vfka",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/init(_:)-9oso5",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer. source must be representable in this type after rounding toward zero.\n\nDiscussion\nlet x = Int(21.5)\n// x == 21\nlet y = Int(-21.5)\n// y == -21\n\n\nIf source is outside the bounds of this type after rounding toward zero, a runtime error may occur.\n\nlet z = UInt(-21.5)\n// Error: ...outside the representable range\n"
  },
  {
    "title": "init(truncatingIfNeeded:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/init(truncatingifneeded:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nWhen the bit width of T (the type of source) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of source. For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of source are used.\n\nlet p: Int16 = -500\n// 'p' has a binary representation of 11111110_00001100\nlet q = Int8(truncatingIfNeeded: p)\n// q == 12\n// 'q' has a binary representation of 00001100\n\n\nWhen the bit width of T is less than this type’s bit width, the result is sign-extended to fill the remaining bits. That is, if source is negative, the result is padded with ones; otherwise, the result is padded with zeros.\n\nlet u: Int8 = 21\n// 'u' has a binary representation of 00010101\nlet v = Int16(truncatingIfNeeded: u)\n// v == 21\n// 'v' has a binary representation of 00000000_00010101\n\n\nlet w: Int8 = -21\n// 'w' has a binary representation of 11101011\nlet x = Int16(truncatingIfNeeded: w)\n// x == -21\n// 'x' has a binary representation of 11111111_11101011\nlet y = UInt16(truncatingIfNeeded: w)\n// y == 65515\n// 'y' has a binary representation of 11111111_11101011\n"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/+=(_:_:)-6n9bz",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_=(_:_:)-7wokl",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "init(truncatingIfNeeded:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(truncatingifneeded:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nWhen the bit width of T (the type of source) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of source. For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of source are used.\n\nlet p: Int16 = -500\n// 'p' has a binary representation of 11111110_00001100\nlet q = Int8(truncatingIfNeeded: p)\n// q == 12\n// 'q' has a binary representation of 00001100\n\n\nWhen the bit width of T is less than this type’s bit width, the result is sign-extended to fill the remaining bits. That is, if source is negative, the result is padded with ones; otherwise, the result is padded with zeros.\n\nlet u: Int8 = 21\n// 'u' has a binary representation of 00010101\nlet v = Int16(truncatingIfNeeded: u)\n// v == 21\n// 'v' has a binary representation of 00000000_00010101\n\n\nlet w: Int8 = -21\n// 'w' has a binary representation of 11101011\nlet x = Int16(truncatingIfNeeded: w)\n// x == -21\n// 'x' has a binary representation of 11111111_11101011\nlet y = UInt16(truncatingIfNeeded: w)\n// y == 65515\n// 'y' has a binary representation of 11111111_11101011\n"
  },
  {
    "title": "entityIdentifierString | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/entityidentifierstring",
    "html": "Discussion\n\nNote: Due to system-imposed limitations, the length of this value can not exceed 512 characters!"
  },
  {
    "title": "isSubnormal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/issubnormal",
    "html": "Discussion\n\nA subnormal value is a nonzero number that has a lesser magnitude than the smallest normal number. Subnormal values don’t use the full precision available to values of a type.\n\nZero is neither a normal nor a subnormal number. Subnormal numbers are often called denormal or denormalized—these are different names for the same concept."
  },
  {
    "title": "result(value:actionButtonIntent:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/result(value:actionbuttonintent:)",
    "html": "Parameters\nvalue\n\nThe value produced by the AppIntent\n\nnextIntent\n\nthe AppIntent used perform next"
  },
  {
    "title": "result(value:opensIntent:dialog:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/result(value:opensintent:dialog:)",
    "html": "Parameters\nvalue\n\nThe value produced by the AppIntent\n\nopensIntent\n\nAn AppIntent to shows the result of current intent\n\ndialog\n\nA custom success dialog"
  },
  {
    "title": "result(value:opensIntent:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/result(value:opensintent:)",
    "html": "Parameters\nvalue\n\nThe value produced by the AppIntent\n\nopensIntent\n\nAn AppIntent to shows the result of current intent"
  },
  {
    "title": "result(value:actionButtonIntent:dialog:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/result(value:actionbuttonintent:dialog:)",
    "html": "Parameters\nvalue\n\nThe value produced by the AppIntent\n\nnextIntent\n\nthe AppIntent used perform next\n\ndialog\n\nA custom success dialog"
  },
  {
    "title": "result(value:dialog:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/result(value:dialog:)",
    "html": "Parameters\nvalue\n\nThe value produced by the AppIntent\n\ndialog\n\nA custom success dialog"
  },
  {
    "title": "result(actionButtonIntent:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/result(actionbuttonintent:)",
    "html": "Parameters\nnextIntent\n\nthe AppIntent used perform next"
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/random(in:)-4qzm1",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling random(in:using:), passing in the system’s default random generator."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/random(in:using:)-25p6v",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n\n\nNote\n\nThe algorithm used to create random values may change in a future version of Swift. If you’re passing a generator that results in the same sequence of integer values each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_=(_:_:)-4hrh6",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "&*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe overflow multiplication operator (&*) discards any bits that overflow the fixed width of the integer type. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &* 5\n// x == 50\nlet y: Int8 = 10 &* 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/random(in:)-3zzix",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling the version that takes a generator, passing in the system’s default random generator."
  },
  {
    "title": "leastNormalMagnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/leastnormalmagnitude",
    "html": "Discussion\n\nThis value compares less than or equal to all positive normal numbers. There may be smaller positive numbers, but they are subnormal, meaning that they are represented with less precision than normal numbers.\n\nThis value corresponds to type-specific C macros such as FLT_MIN and DBL_MIN. The naming of those macros is slightly misleading, because subnormals, zeros, and negative numbers are smaller than this value."
  },
  {
    "title": "&+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&+(_:_:)-4bzi0",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe overflow addition operator (&+) discards any bits that overflow the fixed width of the integer type. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &+ 21\n// x == 31\nlet y: Int8 = 100 &+ 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_(_:_:)-93553",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_(_:_:)-37egm",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\n8 - 3                   // 5\n-10 - 5                 // -15\n100 - -5                // 105\n10.5 - 100.0            // -89.5\n\n\nYou cannot use - with arguments of different types. To subtract values of different types, convert one of the values to the other value’s type.\n\nlet x: UInt8 = 21\nlet y: UInt = 1000000\ny - UInt(x)             // 999979\n\n\nThe difference of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 - 50 is less than zero, the minimum representable UInt8 value:\n\nx - 50                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow subtraction operator (&-).\n\nx &- 50                // 227\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&(_:_:)-9nwor",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/__(_:_:)-2ve4s",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/__=(_:_:)-88k9n",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx <<= 2\n// x == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny <<= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na <<= -3\n// a == 3                         // 0b00000011\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb >>= 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\n2 * 3                   // 6\n100 * 21                // 2100\n-10 * 15                // -150\n3.5 * 2.25              // 7.875\n\n\nYou cannot use * with arguments of different types. To multiply values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) * y              // 21000000\n\n\nThe product of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 * 21 is greater than the maximum representable Int8 value:\n\nx * 21                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow multiplication operator (&*).\n\nx &* 21                // -115\n"
  },
  {
    "title": "leastNonzeroMagnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/leastnonzeromagnitude",
    "html": "Discussion\n\nThis value compares less than or equal to all positive numbers, but greater than zero. If the type supports subnormal values, leastNonzeroMagnitude is smaller than leastNormalMagnitude; otherwise they are equal."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&__(_:_:)-5kz3z",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "ulpOfOne | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/ulpofone-4g2do",
    "html": "Discussion\n\nThe positive difference between 1.0 and the next greater representable number. The ulpOfOne constant corresponds to the C macros FLT_EPSILON, DBL_EPSILON, and others with a similar purpose."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_=(_:_:)-808tq",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than-or-equal-to operator (>=), even if the two instances are of different types."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/_=(_:_:)-1iin",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/_=(_:_:)-1hfy3",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than-or-equal-to operator (<=), even if the two instances are of different types."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(_:)-733m5",
    "html": "Parameters\ndescription\n\nThe ASCII representation of a number.\n\nDiscussion\n\nThe string passed as description may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9).\n\nlet x = Int(\"123\")\n// x == 123\n\n\nIf description is in an invalid format, or if the value it denotes in base 10 is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"10000000000000000000000000\") // Out of range\n"
  },
  {
    "title": "~(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/~(_:)",
    "html": "Discussion\n\nThe bitwise NOT operator (~) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are 1 in the argument are 0 in the result, and bits that are 0 in the argument are 1 in the result. This is equivalent to the inverse of a set. For example:\n\nlet x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010\n\n\nPerforming a bitwise NOT operation on 0 returns a value with every bit set to 1.\n\nlet allOnes = ~UInt8.min   // 0b11111111\n\n\nComplexity\n\nO(1)."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(_:)-90imc",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer. source must be representable in this type after rounding toward zero.\n\nDiscussion\nlet x = Int(21.5)\n// x == 21\nlet y = Int(-21.5)\n// y == -21\n\n\nIf source is outside the bounds of this type after rounding toward zero, a runtime error may occur.\n\nlet z = UInt(-21.5)\n// Error: ...outside the representable range\n"
  },
  {
    "title": "init(_:radix:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(_:radix:)",
    "html": "Parameters\ntext\n\nThe ASCII representation of a number in the radix passed as radix.\n\nradix\n\nThe radix, or base, to use for converting text to an integer value. radix must be in the range 2...36. The default is 10.\n\nDiscussion\n\nThe string passed as text may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9) or letters (a-z or A-Z). Parsing of the string is case insensitive.\n\nlet x = Int(\"123\")\n// x == 123\n\n\nlet y = Int(\"-123\", radix: 8)\n// y == -83\nlet y = Int(\"+123\", radix: 8)\n// y == +83\n\n\nlet z = Int(\"07b\", radix: 16)\n// z == 123\n\n\nIf text is in an invalid format or contains characters that are out of bounds for the given radix, or if the value it denotes in the given radix is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"zzzzzzzzzzzzz\", radix: 36)   // Out of range\n"
  },
  {
    "title": "init(bigEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(bigendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the big-endian representation of the new integer."
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "init(clamping:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(clamping:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nIf the value passed as source is greater than the maximum representable value in this type, the result is the type’s max value. If source is less than the smallest representable value in this type, the result is the type’s min value.\n\nIn this example, x is initialized as an Int8 instance by clamping 500 to the range -128...127, and y is initialized as a UInt instance by clamping -500 to the range 0...UInt.max.\n\nlet x = Int8(clamping: 500)\n// x == 127\n// x == Int8.max\n\n\nlet y = UInt(clamping: -500)\n// y == 0\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(exactly:)-71m8j",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 21.0, while the attempt to initialize the constant y from 21.5 fails:\n\nlet x = Int(exactly: 21.0)\n// x == Optional(21)\nlet y = Int(exactly: 21.5)\n// y == nil\n"
  },
  {
    "title": "bigEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/bigendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a big-endian platform, for any integer x, x == x.bigEndian."
  },
  {
    "title": "max | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/max",
    "html": "Discussion\n\nFor signed integer types, this value is (2 ** (bitWidth - 1)) - 1, where ** is exponentiation."
  },
  {
    "title": "isSigned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/issigned",
    "html": "Discussion\n\nThis property is always true for signed integer types."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(exactly:)-7l3f5",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 100, while the attempt to initialize the constant y from 1_000 fails because the Int8 type can represent 127 at maximum:\n\nlet x = Int8(exactly: 100)\n// x == Optional(100)\nlet y = Int8(exactly: 1_000)\n// y == nil\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(_:)-409to",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer. The value passed as source must be representable in this type.\n\nDiscussion\n\nUse this initializer to convert from another integer type when you know the value is within the bounds of this type. Passing a value that can’t be represented in this type results in a runtime error.\n\nIn the following example, the constant y is successfully created from x, an Int instance with a value of 100. Because the Int8 type can represent 127 at maximum, the attempt to create z with a value of 1000 results in a runtime error.\n\nlet x = 100\nlet y = Int8(x)\n// y == 100\nlet z = Int8(x * 10)\n// Error: Not enough bits to represent the given value\n"
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/==(_:_:)-811lg",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(integerliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/_(_:_:)-24u4g",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/_=(_:_:)-8lyh7",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/==(_:_:)-4wfu9",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "result(actionButtonIntent:dialog:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/result(actionbuttonintent:dialog:)",
    "html": "Parameters\nnextIntent\n\nthe AppIntent used perform next\n\ndialog\n\nA custom success dialog"
  },
  {
    "title": "result(dialog:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/result(dialog:)",
    "html": "Parameters\ndialog\n\nA custom success dialog"
  },
  {
    "title": "result(opensIntent:dialog:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/result(opensintent:dialog:)",
    "html": "Parameters\nopensIntent\n\nAn AppIntent to shows the result of current intent\n\ndialog\n\nA custom success dialog"
  },
  {
    "title": "result(value:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/result(value:)",
    "html": "Parameters\nvalue\n\nThe value produced by the AppIntent"
  },
  {
    "title": "result(opensIntent:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/never/result(opensintent:)",
    "html": "Parameters\nopensIntent\n\nAn AppIntent to shows the result of current intent"
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/random(in:using:)-m203",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n"
  },
  {
    "title": "littleEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/littleendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a little-endian platform, for any integer x, x == x.littleEndian."
  },
  {
    "title": "nextDown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/nextdown",
    "html": "Discussion\n\nFor any finite value x, x.nextDown is less than x. For nan or -infinity, x.nextDown is x itself. The following special cases also apply:\n\nIf x is infinity, then x.nextDown is greatestFiniteMagnitude.\n\nIf x is leastNonzeroMagnitude, then x.nextDown is 0.0.\n\nIf x is zero, then x.nextDown is -leastNonzeroMagnitude.\n\nIf x is -greatestFiniteMagnitude, then x.nextDown is -infinity."
  },
  {
    "title": "floatingPointClass | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/floatingpointclass",
    "html": "Discussion\n\nA value’s floatingPointClass property describes its “class” as described by the IEEE 754 specification."
  },
  {
    "title": "isSignalingNaN | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/issignalingnan",
    "html": "Discussion\n\nSignaling NaNs typically raise the Invalid flag when used in general computing operations."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/_(_:_:)-7cnm4",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "minimum(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/minimum(_:_:)",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nThe minimum of x and y, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the minimum of two values, preserving order and eliminating NaN when possible. For two values x and y, the result of minimum(x, y) is x if x <= y, y if y < x, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.minimum(10.0, -25.0)\n// -25.0\nDouble.minimum(10.0, .nan)\n// 10.0\nDouble.minimum(.nan, -25.0)\n// -25.0\nDouble.minimum(.nan, .nan)\n// nan\n\n\nThe minimum method implements the minNum operation defined by the IEEE 754 specification."
  },
  {
    "title": "maximum(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/maximum(_:_:)",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nThe greater of x and y, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the maximum of two values, preserving order and eliminating NaN when possible. For two values x and y, the result of maximum(x, y) is x if x > y, y if x <= y, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.maximum(10.0, -25.0)\n// 10.0\nDouble.maximum(10.0, .nan)\n// 10.0\nDouble.maximum(.nan, -25.0)\n// -25.0\nDouble.maximum(.nan, .nan)\n// nan\n\n\nThe maximum method implements the maxNum operation defined by the IEEE 754 specification."
  },
  {
    "title": "minimumMagnitude(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/minimummagnitude(_:_:)",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nWhichever of x or y has lesser magnitude, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the value with lesser magnitude of the two given values, preserving order and eliminating NaN when possible. For two values x and y, the result of minimumMagnitude(x, y) is x if x.magnitude <= y.magnitude, y if y.magnitude < x.magnitude, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.minimumMagnitude(10.0, -25.0)\n// 10.0\nDouble.minimumMagnitude(10.0, .nan)\n// 10.0\nDouble.minimumMagnitude(.nan, -25.0)\n// -25.0\nDouble.minimumMagnitude(.nan, .nan)\n// nan\n\n\nThe minimumMagnitude method implements the minNumMag operation defined by the IEEE 754 specification."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/-=(_:_:)-2aqso",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "maximumMagnitude(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/maximummagnitude(_:_:)",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nWhichever of x or y has greater magnitude, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the value with greater magnitude of the two given values, preserving order and eliminating NaN when possible. For two values x and y, the result of maximumMagnitude(x, y) is x if x.magnitude > y.magnitude, y if x.magnitude <= y.magnitude, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.maximumMagnitude(10.0, -25.0)\n// -25.0\nDouble.maximumMagnitude(10.0, .nan)\n// 10.0\nDouble.maximumMagnitude(.nan, -25.0)\n// -25.0\nDouble.maximumMagnitude(.nan, .nan)\n// nan\n\n\nThe maximumMagnitude method implements the maxNumMag operation defined by the IEEE 754 specification."
  },
  {
    "title": "ulpOfOne | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/ulpofone-8wr95",
    "html": "Discussion\n\nThe positive difference between 1.0 and the next greater representable number. ulpOfOne corresponds to the value represented by the C macros FLT_EPSILON, DBL_EPSILON, etc, and is sometimes called epsilon or machine epsilon. Swift deliberately avoids using the term “epsilon” because:\n\nHistorically “epsilon” has been used to refer to several different concepts in different languages, leading to confusion and bugs.\n\nThe name “epsilon” suggests that this quantity is a good tolerance to choose for approximate comparisons, but it is almost always unsuitable for that purpose.\n\nSee also the ulp member property."
  },
  {
    "title": "pi | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/pi",
    "html": "Discussion\n\nWhen measuring an angle in radians, π is equivalent to a half-turn.\n\nThis value is rounded toward zero to keep user computations with angles from inadvertently ending up in the wrong quadrant. A type that conforms to the FloatingPoint protocol provides the value for pi at its best possible precision.\n\nprint(Double.pi)\n// Prints \"3.14159265358979\"\n"
  },
  {
    "title": "radix | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/radix",
    "html": "Discussion\n\nThe magnitude of a floating-point value x of type F can be calculated by using the following formula, where ** is exponentiation:\n\nx.significand * (F.radix ** x.exponent)\n\n\nA conforming type may use any integer radix, but values other than 2 (for binary floating-point types) or 10 (for decimal floating-point types) are extraordinarily rare in practice."
  },
  {
    "title": "signalingNaN | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/signalingnan",
    "html": "Discussion\n\nThe default IEEE 754 behavior of operations involving a signaling NaN is to raise the Invalid flag in the floating-point environment and return a quiet NaN.\n\nOperations on types conforming to the FloatingPoint protocol should support this behavior, but they might also support other options. For example, it would be reasonable to implement alternative operations in which operating on a signaling NaN triggers a runtime error or results in a diagnostic for debugging purposes. Types that implement alternative behaviors for a signaling NaN must document the departure.\n\nOther than these signaling operations, a signaling NaN behaves in the same manner as a quiet NaN."
  },
  {
    "title": "truncatingRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/truncatingremainder(dividingby:)",
    "html": "Parameters\nother\n\nThe value to use when dividing this value.\n\nReturn Value\n\nThe remainder of this value divided by other using truncating division.\n\nDiscussion\n\nPerforming truncating division with floating-point values results in a truncated integer quotient and a remainder. For values x and y and their truncated integer quotient q, the remainder r satisfies x == y * q + r.\n\nThe following example calculates the truncating remainder of dividing 8.625 by 0.75:\n\nlet x = 8.625\nprint(x / 0.75)\n// Prints \"11.5\"\n\n\nlet q = (x / 0.75).rounded(.towardZero)\n// q == 11.0\nlet r = x.truncatingRemainder(dividingBy: 0.75)\n// r == 0.375\n\n\nlet x1 = 0.75 * q + r\n// x1 == 8.625\n\n\nIf this value and other are both finite numbers, the truncating remainder has the same sign as this value and is strictly smaller in magnitude than other. The truncatingRemainder(dividingBy:) method is always exact."
  },
  {
    "title": "nan | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/nan",
    "html": "Discussion\n\nA NaN compares not equal, not greater than, and not less than every value, including itself. Passing a NaN to an operation generally results in NaN.\n\nlet x = 1.21\n// x > Double.nan == false\n// x < Double.nan == false\n// x == Double.nan == false\n\n\nBecause a NaN always compares not equal to itself, to test whether a floating-point value is NaN, use its isNaN property instead of the equal-to operator (==). In the following example, y is NaN.\n\nlet y = x + Double.nan\nprint(y == Double.nan)\n// Prints \"false\"\nprint(y.isNaN)\n// Prints \"true\"\n"
  },
  {
    "title": "greatestFiniteMagnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/greatestfinitemagnitude",
    "html": "Discussion\n\nThis value compares greater than or equal to all finite numbers, but less than infinity.\n\nThis value corresponds to type-specific C macros such as FLT_MAX and DBL_MAX. The naming of those macros is slightly misleading, because infinity is greater than this value."
  },
  {
    "title": "squareRoot() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/squareroot()",
    "html": "Return Value\n\nThe square root of the value.\n\nDiscussion\n\nThe following example declares a function that calculates the length of the hypotenuse of a right triangle given its two perpendicular sides.\n\nfunc hypotenuse(_ a: Double, _ b: Double) -> Double {\n    return (a * a + b * b).squareRoot()\n}\n\n\nlet (dx, dy) = (3.0, 4.0)\nlet distance = hypotenuse(dx, dy)\n// distance == 5.0\n"
  },
  {
    "title": "rounded(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/rounded(_:)",
    "html": "Parameters\nrule\n\nThe rounding rule to use.\n\nReturn Value\n\nThe integral value found by rounding using rule.\n\nDiscussion\n\nThe following example rounds a value using four different rounding rules:\n\nlet x = 6.5\n\n\n// Equivalent to the C 'round' function:\nprint(x.rounded(.toNearestOrAwayFromZero))\n// Prints \"7.0\"\n\n\n// Equivalent to the C 'trunc' function:\nprint(x.rounded(.towardZero))\n// Prints \"6.0\"\n\n\n// Equivalent to the C 'ceil' function:\nprint(x.rounded(.up))\n// Prints \"7.0\"\n\n\n// Equivalent to the C 'floor' function:\nprint(x.rounded(.down))\n// Prints \"6.0\"\n\n\nFor more information about the available rounding rules, see the FloatingPointRoundingRule enumeration. To round a value using the default “schoolbook rounding”, you can use the shorter rounded() method instead.\n\nprint(x.rounded())\n// Prints \"7.0\"\n"
  },
  {
    "title": "negate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/negate()-746a7",
    "html": "Discussion\n\nThe following example uses the negate() method to negate the value of an integer x:\n\nvar x = 21\nx.negate()\n// x == -21\n\n\nThe resulting value must be representable within the value’s type. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nvar y = Int8.min\ny.negate()\n// Overflow error\n"
  },
  {
    "title": "&>>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&__=(_:_:)-7px1u",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &>>= operator performs a masking shift, where the value passed as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &>>= 2\n// x == 7                         // 0b00000111\n\n\nHowever, if you use 19 as rhs, the operation first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &>>= 19\n// y == 3                         // 0b00000011\n"
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&__(_:_:)-6669c",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&-(_:_:)-k0ye",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe overflow subtraction operator (&-) discards any bits that overflow the fixed width of the integer type. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: UInt8 = 21 &- 10\n// x == 11\nlet y: UInt8 = 10 &- 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&__(_:_:)-8zhel",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&__(_:_:)-177cn",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&-=(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe masking subtraction assignment operator (&-=) silently wraps any overflow that occurs during the operation. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 21\nx &-= 10\n// x == 11\nvar y: UInt8 = 10\ny &-= 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&__(_:_:)-2vu0k",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&__(_:_:)-11whl",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/&__=(_:_:)-1cj5m",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &<<= operator performs a masking shift, where the value used as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &<<= 2\n// x == 120                       // 0b01111000\n\n\nHowever, if you pass 19 as rhs, the method first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &<<= 19\n// y == 240                       // 0b11110000\n"
  },
  {
    "title": "init(littleEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/init(littleendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the little-endian representation of the new integer."
  },
  {
    "title": "-(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/-(_:)-41os2",
    "html": "Return Value\n\nThe additive inverse of the argument.\n\nDiscussion\n\nThe negation operator (prefix -) returns the additive inverse of its argument.\n\nlet x = 21\nlet y = -x\n// y == -21\n\n\nThe resulting value must be representable in the same type as the argument. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nlet z = -Int8.min\n// Overflow error\n"
  },
  {
    "title": "negate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/negate()-jfhp",
    "html": "Discussion\n\nThe following example uses the negate() method to negate the value of an integer x:\n\nvar x = 21\nx.negate()\n// x == -21\n\n\nThe resulting value must be representable within the value’s type. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nvar y = Int8.min\ny.negate()\n// Overflow error\n"
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/zero",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "magnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/magnitude-swift.property",
    "html": "Discussion\n\nFor any numeric value x, x.magnitude is the absolute value of x. You can use the magnitude property in operations that are simpler to implement in terms of unsigned values, such as printing the value of an integer, which is just printing a ‘-’ character in front of an absolute value.\n\nlet x = -200\n// x.magnitude == 200\n\n\nThe global abs(_:) function provides more familiar syntax when you need to find an absolute value. In addition, because abs(_:) always returns a value of the same type, even in a generic context, using the function instead of the magnitude property is encouraged."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/-=(_:_:)-8ppup",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/+=(_:_:)-6k4zy",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "min | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/min",
    "html": "Discussion\n\nFor signed integer types, this value is -(2 ** (bitWidth - 1)), where ** is exponentiation."
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by.\n\nDiscussion\n\nThe division operator (/) calculates the quotient of the division if rhs is nonzero. If rhs is zero, the result of the division is infinity, with the sign of the result matching the sign of lhs.\n\nlet x = 16.875\nlet y = x / 2.25\n// y == 7.5\n\n\nlet z = x / 0\n// z.isInfinite == true\n\n\nThe / operator implements the division operation defined by the IEEE 754 specification."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "isEqual(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/isequal(to:)",
    "html": "Parameters\nother\n\nThe value to compare with this value.\n\nReturn Value\n\ntrue if other has the same value as this instance; otherwise, false. If either this value or other is NaN, the result of this method is false.\n\nDiscussion\n\nThis method serves as the basis for the equal-to operator (==) for floating-point values. When comparing two values with this method, -0 is equal to +0. NaN is not equal to any value, including itself. For example:\n\nlet x = 15.0\nx.isEqual(to: 15.0)\n// true\nx.isEqual(to: .nan)\n// false\nDouble.nan.isEqual(to: .nan)\n// false\n\n\nThe isEqual(to:) method implements the equality predicate defined by the IEEE 754 specification."
  },
  {
    "title": "negate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/negate()-80pzu",
    "html": "Discussion\n\nThe result is always exact. This example uses the negate() method to negate the value of the variable x:\n\nvar x = 21.5\nx.negate()\n// x == -21.5\n"
  },
  {
    "title": "isTotallyOrdered(belowOrEqualTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/istotallyordered(beloworequalto:)",
    "html": "Parameters\nother\n\nA floating-point value to compare to this value.\n\nReturn Value\n\ntrue if this value is ordered below or the same as other in a total ordering of the floating-point type; otherwise, false.\n\nDiscussion\n\nThis relation is a refinement of the less-than-or-equal-to operator (<=) that provides a total order on all values of the type, including signed zeros and NaNs.\n\nThe following example uses isTotallyOrdered(belowOrEqualTo:) to sort an array of floating-point values, including some that are NaN:\n\nvar numbers = [2.5, 21.25, 3.0, .nan, -9.5]\nnumbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }\nprint(numbers)\n// Prints \"[-9.5, 2.5, 3.0, 21.25, nan]\"\n\n\nThe isTotallyOrdered(belowOrEqualTo:) method implements the total order relation as defined by the IEEE 754 specification."
  },
  {
    "title": "isLess(than:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/isless(than:)",
    "html": "Parameters\nother\n\nThe value to compare with this value.\n\nReturn Value\n\ntrue if this value is less than other; otherwise, false. If either this value or other is NaN, the result of this method is false.\n\nDiscussion\n\nThis method serves as the basis for the less-than operator (<) for floating-point values. Some special cases apply:\n\nBecause NaN compares not less than nor greater than any value, this method returns false when called on NaN or when NaN is passed as other.\n\n-infinity compares less than all values except for itself and NaN.\n\nEvery value except for NaN and +infinity compares less than +infinity.\n\nlet x = 15.0 x.isLess(than: 20.0) // true x.isLess(than: .nan) // false Double.nan.isLess(than: x) // false\n\nThe isLess(than:) method implements the less-than predicate defined by the IEEE 754 specification."
  },
  {
    "title": "isLessThanOrEqualTo(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/islessthanorequalto(_:)",
    "html": "Parameters\nother\n\nThe value to compare with this value.\n\nReturn Value\n\ntrue if other is greater than this value; otherwise, false. If either this value or other is NaN, the result of this method is false.\n\nDiscussion\n\nThis method serves as the basis for the less-than-or-equal-to operator (<=) for floating-point values. Some special cases apply:\n\nBecause NaN is incomparable with any value, this method returns false when called on NaN or when NaN is passed as other.\n\n-infinity compares less than or equal to all values except NaN.\n\nEvery value except NaN compares less than or equal to +infinity.\n\nlet x = 15.0 x.isLessThanOrEqualTo(20.0) // true x.isLessThanOrEqualTo(.nan) // false Double.nan.isLessThanOrEqualTo(x) // false\n\nThe isLessThanOrEqualTo(_:) method implements the less-than-or-equal predicate defined by the IEEE 754 specification."
  },
  {
    "title": "formTruncatingRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/formtruncatingremainder(dividingby:)",
    "html": "Parameters\nother\n\nThe value to use when dividing this value.\n\nDiscussion\n\nPerforming truncating division with floating-point values results in a truncated integer quotient and a remainder. For values x and y and their truncated integer quotient q, the remainder r satisfies x == y * q + r.\n\nThe following example calculates the truncating remainder of dividing 8.625 by 0.75:\n\nvar x = 8.625\nprint(x / 0.75)\n// Prints \"11.5\"\n\n\nlet q = (x / 0.75).rounded(.towardZero)\n// q == 11.0\nx.formTruncatingRemainder(dividingBy: 0.75)\n// x == 0.375\n\n\nlet x1 = 0.75 * q + x\n// x1 == 8.625\n\n\nIf this value and other are both finite numbers, the truncating remainder has the same sign as this value and is strictly smaller in magnitude than other. The formTruncatingRemainder(dividingBy:) method is always exact."
  },
  {
    "title": "addingProduct(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/addingproduct(_:_:)",
    "html": "Parameters\nlhs\n\nOne of the values to multiply before adding to this value.\n\nrhs\n\nThe other value to multiply.\n\nReturn Value\n\nThe product of lhs and rhs, added to this value.\n\nDiscussion\n\nThis method is equivalent to the C fma function and implements the fusedMultiplyAdd operation defined by the IEEE 754 specification."
  },
  {
    "title": "formRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/formremainder(dividingby:)",
    "html": "Parameters\nother\n\nThe value to use when dividing this value.\n\nDiscussion\n\nFor two finite values x and y, the remainder r of dividing x by y satisfies x == y * q + r, where q is the integer nearest to x / y. If x / y is exactly halfway between two integers, q is chosen to be even. Note that q is not x / y computed in floating-point arithmetic, and that q may not be representable in any available integer type.\n\nThe following example calculates the remainder of dividing 8.625 by 0.75:\n\nvar x = 8.625\nprint(x / 0.75)\n// Prints \"11.5\"\n\n\nlet q = (x / 0.75).rounded(.toNearestOrEven)\n// q == 12.0\nx.formRemainder(dividingBy: 0.75)\n// x == -0.375\n\n\nlet x1 = 0.75 * q + x\n// x1 == 8.625\n\n\nIf this value and other are finite numbers, the remainder is in the closed range -abs(other / 2)...abs(other / 2). The formRemainder(dividingBy:) method is always exact."
  },
  {
    "title": "addProduct(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/addproduct(_:_:)",
    "html": "Parameters\nlhs\n\nOne of the values to multiply before adding to this value.\n\nrhs\n\nThe other value to multiply."
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\nlet x = 7.5\nlet y = x * 2.25\n// y == 16.875\n\n\nThe * operator implements the multiplication operation defined by the IEEE 754 specification."
  },
  {
    "title": "init(signOf:magnitudeOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(signof:magnitudeof:)-6xxbh",
    "html": "Parameters\nsignOf\n\nA value from which to use the sign. The result of the initializer has the same sign as signOf.\n\nmagnitudeOf\n\nA value from which to use the magnitude. The result of the initializer has the same magnitude as magnitudeOf.\n\nDiscussion\n\nThe following example uses this initializer to create a new Double instance with the sign of a and the magnitude of b:\n\nlet a = -21.5\nlet b = 305.15\nlet c = Double(signOf: a, magnitudeOf: b)\nprint(c)\n// Prints \"-305.15\"\n\n\nThis initializer implements the IEEE 754 copysign operation."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\nlet x = 1.5\nlet y = x + 2.25\n// y == 3.75\n\n\nThe + operator implements the addition operation defined by the IEEE 754 specification."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/+=(_:_:)-27qw5",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "-(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/-(_:)-7kn98",
    "html": "Parameters\noperand\n\nThe value to negate.\n\nDiscussion\n\nThe unary minus operator (prefix -) calculates the negation of its operand. The result is always exact.\n\nlet x = 21.5\nlet y = -x\n// y == -21.5\n"
  },
  {
    "title": "/=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16//=(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by."
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply."
  },
  {
    "title": "isInfinite | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/isinfinite",
    "html": "Discussion\n\nFor NaN, both isFinite and isInfinite are false."
  },
  {
    "title": "init(signOf:magnitudeOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(signof:magnitudeof:)-1oylh",
    "html": "Parameters\nsignOf\n\nA value from which to use the sign. The result of the initializer has the same sign as signOf.\n\nmagnitudeOf\n\nA value from which to use the magnitude. The result of the initializer has the same magnitude as magnitudeOf.\n\nDiscussion\n\nThe following example uses this initializer to create a new Double instance with the sign of a and the magnitude of b:\n\nlet a = -21.5\nlet b = 305.15\nlet c = Double(signOf: a, magnitudeOf: b)\nprint(c)\n// Prints \"-305.15\"\n\n\nThis initializer implements the IEEE 754 copysign operation."
  },
  {
    "title": "isNaN | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/isnan",
    "html": "Discussion\n\nBecause NaN is not equal to any value, including NaN, use this property instead of the equal-to operator (==) or not-equal-to operator (!=) to test whether a value is or is not NaN. For example:\n\nlet x = 0.0\nlet y = x * .infinity\n// y is a NaN\n\n\n// Comparing with the equal-to operator never returns 'true'\nprint(x == Double.nan)\n// Prints \"false\"\nprint(y == Double.nan)\n// Prints \"false\"\n\n\n// Test with the 'isNaN' property instead\nprint(x.isNaN)\n// Prints \"false\"\nprint(y.isNaN)\n// Prints \"true\"\n\n\nThis property is true for both quiet and signaling NaNs."
  },
  {
    "title": "sign | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/sign",
    "html": "Discussion\n\nThe sign property is .minus if the value’s signbit is set, and .plus otherwise. For example:\n\nlet x = -33.375\n// x.sign == .minus\n\n\nDon’t use this property to check whether a floating point value is negative. For a value x, the comparison x.sign == .minus is not necessarily the same as x < 0. In particular, x.sign == .minus if x is -0, and while x < 0 is always false if x is NaN, x.sign could be either .plus or .minus."
  },
  {
    "title": "exponent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/exponent-swift.property",
    "html": "Discussion\n\nThe exponent of a floating-point value is the integer part of the logarithm of the value’s magnitude. For a value x of a floating-point type F, the magnitude can be calculated as the following, where ** is exponentiation:\n\nx.significand * (F.radix ** x.exponent)\n\n\nIn the next example, y has a value of 21.5, which is encoded as 1.34375 * 2 ** 4. The significand of y is therefore 1.34375.\n\nlet y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2\n\n\nThe exponent property has the following edge cases:\n\nIf x is zero, then x.exponent is Int.min.\n\nIf x is +/-infinity or NaN, then x.exponent is Int.max\n\nThis property implements the logB operation defined by the IEEE 754 specification."
  },
  {
    "title": "isCanonical | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/iscanonical",
    "html": "Discussion\n\nThe IEEE 754 specification defines a canonical, or preferred, encoding of a floating-point value. On platforms that fully support IEEE 754, every Float or Double value is canonical, but non-canonical values can exist on other platforms or for other types. Some examples:\n\nOn platforms that flush subnormal numbers to zero (such as armv7 with the default floating-point environment), Swift interprets subnormal Float and Double values as non-canonical zeros. (In Swift 5.1 and earlier, isCanonical is true for these values, which is the incorrect value.)\n\nOn i386 and x86_64, Float80 has a number of non-canonical encodings. “Pseudo-NaNs”, “pseudo-infinities”, and “unnormals” are interpreted as non-canonical NaN encodings. “Pseudo-denormals” are interpreted as non-canonical encodings of subnormal values.\n\nDecimal floating-point types admit a large number of non-canonical encodings. Consult the IEEE 754 standard for additional details."
  },
  {
    "title": "significand | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/significand",
    "html": "Discussion\n\nThe magnitude of a floating-point value x of type F can be calculated by using the following formula, where ** is exponentiation:\n\nx.significand * (F.radix ** x.exponent)\n\n\nIn the next example, y has a value of 21.5, which is encoded as 1.34375 * 2 ** 4. The significand of y is therefore 1.34375.\n\nlet y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2\n\n\nIf a type’s radix is 2, then for finite nonzero numbers, the significand is in the range 1.0 ..< 2.0. For other values of x, x.significand is defined as follows:\n\nIf x is zero, then x.significand is 0.0.\n\nIf x is infinite, then x.significand is infinity.\n\nIf x is NaN, then x.significand is NaN.\n\nNote\n\nThe significand is frequently also called the mantissa, but significand is the preferred terminology in the IEEE 754 specification, to allay confusion with the use of mantissa for the fractional part of a logarithm."
  },
  {
    "title": "ulp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/ulp",
    "html": "Discussion\n\nThis is the unit of the least significant digit in this value’s significand. For most numbers x, this is the difference between x and the next greater (in magnitude) representable number. There are some edge cases to be aware of:\n\nIf x is not a finite number, then x.ulp is NaN.\n\nIf x is very small in magnitude, then x.ulp may be a subnormal number. If a type does not support subnormals, x.ulp may be rounded to zero.\n\ngreatestFiniteMagnitude.ulp is a finite number, even though the next greater representable value is infinity.\n\nSee also the ulpOfOne static property."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/'...(_:)-3pk0v",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/'...(_:)-5cxb4",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/_(_:_:)-4g8ih",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/_(_:_:)-31fi",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/_=(_:_:)-1s8n2",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/_=(_:_:)-3ah1i",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/_(_:_:)-9d93b",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/_=(_:_:)-3uvqe",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/+=(_:_:)-5g9j2",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "round(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/round(_:)",
    "html": "Parameters\nrule\n\nThe rounding rule to use.\n\nDiscussion\n\nThe following example rounds a value using four different rounding rules:\n\n// Equivalent to the C 'round' function:\nvar w = 6.5\nw.round(.toNearestOrAwayFromZero)\n// w == 7.0\n\n\n// Equivalent to the C 'trunc' function:\nvar x = 6.5\nx.round(.towardZero)\n// x == 6.0\n\n\n// Equivalent to the C 'ceil' function:\nvar y = 6.5\ny.round(.up)\n// y == 7.0\n\n\n// Equivalent to the C 'floor' function:\nvar z = 6.5\nz.round(.down)\n// z == 6.0\n\n\nFor more information about the available rounding rules, see the FloatingPointRoundingRule enumeration. To round a value using the default “schoolbook rounding”, you can use the shorter round() method instead.\n\nvar w1 = 6.5\nw1.round()\n// w1 == 7.0\n"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/_=(_:_:)-5yoz5",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/change/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/change/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "init(sign:exponentBitPattern:significandBitPattern:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(sign:exponentbitpattern:significandbitpattern:)",
    "html": "Parameters\nsign\n\nThe sign of the new value.\n\nexponentBitPattern\n\nThe bit pattern to use for the exponent field of the new value.\n\nsignificandBitPattern\n\nThe bit pattern to use for the significand field of the new value.\n\nDiscussion\n\nThe values passed as exponentBitPattern and significandBitPattern are interpreted in the binary interchange format defined by the IEEE 754 specification."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "-(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/-(_:)-3w54g",
    "html": "Return Value\n\nThe additive inverse of the argument.\n\nDiscussion\n\nThe negation operator (prefix -) returns the additive inverse of its argument.\n\nlet x = 21\nlet y = -x\n// y == -21\n\n\nThe resulting value must be representable in the same type as the argument. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nlet z = -Int8.min\n// Overflow error\n"
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/split(separator:maxsplits:omittingemptysubsequences:)-897oj",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nfunc addOne<T: Strideable>(to x: T) -> T\n    where T.Stride: ExpressibleByIntegerLiteral\n{\n    return x.advanced(by: 1)\n}\n\n\nlet x = addOne(to: 5)\n// x == 6\nlet y = addOne(to: 3.5)\n// y = 4.5\n\n\nIf this type’s Stride type conforms to BinaryInteger, then for a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n. Using this method with types that have a noninteger Stride may result in an approximation. If the result of advancing by n is not representable as a value of this type, then a runtime error may occur.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/distance(to:)",
    "html": "Parameters\nother\n\nThe value to calculate the distance to.\n\nReturn Value\n\nThe distance from this value to other.\n\nDiscussion\n\nIf this type’s Stride type conforms to BinaryInteger, then for two values x and y, and a distance n = x.distance(to: y), x.advanced(by: n) == y. Using this method with types that have a noninteger Stride may result in an approximation.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(_:)-67cee",
    "html": "Parameters\nvalue\n\nThe integer to convert to a floating-point value.\n\nDiscussion\n\nIf two representable values are equally close, the result is the value with more trailing zeros in its significand bit pattern."
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\nlet x = 7.5\nlet y = x - 2.25\n// y == 5.25\n\n\nThe - operator implements the subtraction operation defined by the IEEE 754 specification."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(_:)-4iaoz",
    "html": "Parameters\nvalue\n\nThe integer to convert to a floating-point value.\n\nDiscussion\n\nIf two representable values are equally close, the result is the value with more trailing zeros in its significand bit pattern."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/-=(_:_:)-sfza",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(exactly:)-2qxl0",
    "html": "Parameters\nvalue\n\nThe integer to convert to a floating-point value.\n\nDiscussion\n\nIf the given integer cannot be represented exactly, the result is nil."
  },
  {
    "title": "init(sign:exponent:significand:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(sign:exponent:significand:)",
    "html": "Parameters\nsign\n\nThe sign to use for the new value.\n\nexponent\n\nThe new value’s exponent.\n\nsignificand\n\nThe new value’s significand.\n\nDiscussion\n\nThe following example uses this initializer to create a new Double instance. Double is a binary floating-point type that has a radix of 2.\n\nlet x = Double(sign: .plus, exponent: -2, significand: 1.5)\n// x == 0.375\n\n\nThis initializer is equivalent to the following calculation, where ** is exponentiation, computed as if by a single, correctly rounded, floating-point operation:\n\nlet sign: FloatingPointSign = .plus\nlet exponent = -2\nlet significand = 1.5\nlet y = (sign == .minus ? -1 : 1) * significand * Double.radix ** exponent\n// y == 0.375\n\n\nAs with any basic operation, if this value is outside the representable range of the type, overflow or underflow occurs, and zero, a subnormal value, or infinity may result. In addition, there are two other edge cases:\n\nIf the value you pass to significand is zero or infinite, the result is zero or infinite, regardless of the value of exponent.\n\nIf the value you pass to significand is NaN, the result is NaN.\n\nFor any floating-point value x of type F, the result of the following is equal to x, with the distinction that the result is canonicalized if x is in a noncanonical encoding:\n\nlet x0 = F(sign: x.sign, exponent: x.exponent, significand: x.significand)\n\n\nThis initializer implements the scaleB operation defined by the IEEE 754 specification."
  },
  {
    "title": "isZero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/iszero",
    "html": "Discussion\n\nThe isZero property of a value x is true when x represents either -0.0 or +0.0. x.isZero is equivalent to the following comparison: x == 0.0.\n\nlet x = -0.0\nx.isZero        // true\nx == 0.0        // true\n"
  },
  {
    "title": "nextUp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/nextup",
    "html": "Discussion\n\nFor any finite value x, x.nextUp is greater than x. For nan or infinity, x.nextUp is x itself. The following special cases also apply:\n\nIf x is -infinity, then x.nextUp is -greatestFiniteMagnitude.\n\nIf x is -leastNonzeroMagnitude, then x.nextUp is -0.0.\n\nIf x is zero, then x.nextUp is leastNonzeroMagnitude.\n\nIf x is greatestFiniteMagnitude, then x.nextUp is infinity."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/description",
    "html": "Discussion\n\nFor any finite value, this property provides a string that can be converted back to an instance of Float16 without rounding errors. That is, if x is an instance of Float16, then Float16(x.description) == x is always true. For any NaN value, the property’s value is “nan”, and for positive and negative infinity its value is “inf” and “-inf”."
  },
  {
    "title": "isNormal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/isnormal",
    "html": "Discussion\n\nA normal value is a finite number that uses the full precision available to values of a type. Zero is neither a normal nor a subnormal number."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/_=(_:_:)-4bq0a",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "isFinite | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/isfinite",
    "html": "Discussion\n\nAll values other than NaN and infinity are considered finite, whether normal or subnormal. For NaN, both isFinite and isInfinite are false."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/==(_:_:)-12hdt",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "significandBitCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/significandbitcount",
    "html": "Discussion\n\nFor fixed-width floating-point types, this is the actual number of fractional significand bits.\n\nFor extensible floating-point types, significandBitCount should be the maximum allowed significand width (without counting any leading integral bit of the significand). If there is no upper limit, then significandBitCount should be Int.max.\n\nNote that Float80.significandBitCount is 63, even though 64 bits are used to store the significand in the memory representation of a Float80 (unlike other floating-point types, Float80 explicitly stores the leading integral significand bit, but the BinaryFloatingPoint APIs provide an abstraction so that users don’t need to be aware of this detail)."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/+=(_:_:)-9dl40",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/==(_:_:)-3rkkw",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/_=(_:_:)-9o6ha",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/zero",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/change/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(_:)-7x3fq",
    "html": "Parameters\nother\n\nThe value to use for the new instance.\n\nDiscussion\n\nThe value of other is rounded to a representable value, if necessary. A NaN passed as other results in another NaN, with a signaling NaN value converted to quiet NaN.\n\nlet x: Double = 21.25\nlet y = Float16(x)\n// y == 21.25\n\n\nlet z = Float16(Double.nan)\n// z.isNaN == true\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(_:)-6u8fq",
    "html": "Parameters\nvalue\n\nA floating-point value to be converted.\n\nDiscussion\n\nIf two representable values are equally close, the result is the value with more trailing zeros in its significand bit pattern."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/flatmap(_:)-89rmu",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "significandBitPattern | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/significandbitpattern",
    "html": "Discussion\n\nThe significandBitPattern property does not include the leading integral bit of the significand, even for types like Float80 that store it explicitly."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/map(_:)-27fi",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "Float16.FloatLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/floatliteraltype",
    "html": "Discussion\n\nValid types for FloatLiteralType are Float, Double, and Float80 where available."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/customplaygroundquicklook",
    "html": "Discussion\n\nIf this type has value semantics, the PlaygroundQuickLook instance should be unaffected by subsequent mutations."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\nlet x = 1.5\nlet y = x + 2.25\n// y == 3.75\n\n\nThe + operator implements the addition operation defined by the IEEE 754 specification."
  },
  {
    "title": "exponentBitCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/exponentbitcount",
    "html": "Discussion\n\nA binary floating-point type’s exponentBitCount imposes a limit on the range of the exponent for normal, finite values. The exponent bias of a type F can be calculated as the following, where ** is exponentiation:\n\nlet bias = 2 ** (F.exponentBitCount - 1) - 1\n\n\nThe least normal exponent for values of the type F is 1 - bias, and the largest finite exponent is bias. An all-zeros exponent is reserved for subnormals and zeros, and an all-ones exponent is reserved for infinity and NaN.\n\nFor example, the Float type has an exponentBitCount of 8, which gives an exponent bias of 127 by the calculation above.\n\nlet bias = 2 ** (Float.exponentBitCount - 1) - 1\n// bias == 127\nprint(Float.greatestFiniteMagnitude.exponent)\n// Prints \"127\"\nprint(Float.leastNormalMagnitude.exponent)\n// Prints \"-126\"\n"
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/change/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "significandWidth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/significandwidth",
    "html": "Discussion\n\nIf this value is a finite nonzero number, significandWidth is the number of fractional bits required to represent the value of significand; otherwise, significandWidth is -1. The value of significandWidth is always -1 or between zero and significandBitCount. For example:\n\nFor any representable power of two, significandWidth is zero, because significand is 1.0.\n\nIf x is 10, x.significand is 1.01 in binary, so x.significandWidth is 2.\n\nIf x is Float.pi, x.significand is 1.10010010000111111011011 in binary, and x.significandWidth is 23."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/random(in:)-4blql",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must be finite and non-empty.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate a floating-point value within a specific range. This example creates three new values in the range 10.0 ..< 20.0.\n\nfor _ in 1...3 {\n    print(Double.random(in: 10.0 ..< 20.0))\n}\n// Prints \"18.1900709259179\"\n// Prints \"14.2286325689993\"\n// Prints \"13.1485686260762\"\n\n\nThe random() static method chooses a random value from a continuous uniform distribution in range, and then converts that value to the nearest representable value in this type. Depending on the size and span of range, some concrete values may be represented more frequently than others.\n\nThis method is equivalent to calling random(in:using:), passing in the system’s default random generator."
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/random(in:)-6nryy",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. Must be finite.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate a floating-point value within a specific range. This example creates three new values in the range 10.0 ... 20.0.\n\nfor _ in 1...3 {\n    print(Double.random(in: 10.0 ... 20.0))\n}\n// Prints \"18.1900709259179\"\n// Prints \"14.2286325689993\"\n// Prints \"13.1485686260762\"\n\n\nThe random() static method chooses a random value from a continuous uniform distribution in range, and then converts that value to the nearest representable value in this type. Depending on the size and span of range, some concrete values may be represented more frequently than others.\n\nThis method is equivalent to calling random(in:using:), passing in the system’s default random generator."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/random(in:using:)-1prt0",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. Must be finite.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate a floating-point value within a specific range when you are using a custom random number generator. This example creates three new values in the range 10.0 ... 20.0.\n\nfor _ in 1...3 {\n    print(Double.random(in: 10.0 ... 20.0, using: &myGenerator))\n}\n// Prints \"18.1900709259179\"\n// Prints \"14.2286325689993\"\n// Prints \"13.1485686260762\"\n\n\nThe random(in:using:) static method chooses a random value from a continuous uniform distribution in range, and then converts that value to the nearest representable value in this type. Depending on the size and span of range, some concrete values may be represented more frequently than others.\n\nNote\n\nThe algorithm used to create random values may change in a future version of Swift. If you’re passing a generator that results in the same sequence of floating-point values each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/random(in:using:)-9qt91",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must be finite and non-empty.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate a floating-point value within a specific range when you are using a custom random number generator. This example creates three new values in the range 10.0 ..< 20.0.\n\nfor _ in 1...3 {\n    print(Double.random(in: 10.0 ..< 20.0, using: &myGenerator))\n}\n// Prints \"18.1900709259179\"\n// Prints \"14.2286325689993\"\n// Prints \"13.1485686260762\"\n\n\nThe random(in:using:) static method chooses a random value from a continuous uniform distribution in range, and then converts that value to the nearest representable value in this type. Depending on the size and span of range, some concrete values may be represented more frequently than others.\n\nNote\n\nThe algorithm used to create random values may change in a future version of Swift. If you’re passing a generator that results in the same sequence of floating-point values each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/_(_:_:)-552jr",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(_:)-9qp1z",
    "html": "Parameters\ntext\n\nAn input string to convert to a Float16? instance.\n\nDiscussion\n\nThe string passed as text can represent a real number in decimal or hexadecimal format or can be in a special format representing infinity or NaN (“not a number”). If text is not in a recognized format, the optional initializer will fail and return nil.\n\nThe text string consists of an optional plus or minus sign character (+ or -) followed by one of the following:\n\nA decimal string contains a significand consisting of one or more decimal digits that may include a decimal point:\n\nlet c = Float16(\"-1.0\")\n// c == -1.0\n\n\nlet d = Float16(\"28.375\")\n// d == 28.375\n\n\nA decimal string may also include an exponent following the significand, indicating the power of 10 by which the significand should be multiplied. If included, the exponent is separated by a single character, e or E, and consists of an optional plus or minus sign character and a sequence of decimal digits.\n\nlet e = Float16(\"2837.5e-2\")\n// e == 28.375\n\n\nA hexadecimal string contains a significand consisting of 0X or 0x followed by one or more hexadecimal digits that may include a decimal point.\n\nlet f = Float16(\"0x1c.6\")\n// f == 28.375\n\n\nA hexadecimal string may also include an exponent indicating the power of 2 by which the significand should be multiplied. If included, the exponent is separated by a single character, p or P, and consists of an optional plus or minus sign character and a sequence of decimal digits.\n\nlet g = Float16(\"0x1.c6p4\")\n// g == 28.375\n\n\nThe input strings \"inf\" or \"infinity\" (case insensitive) are converted to an infinite result:\n\nlet i = Float16(\"inf\")\n// i == Float16.infinity\n\n\nlet j = Float16(\"-Infinity\")\n// j == -Float16.infinity\n\n\nAn input string of \"nan\" (case insensitive) is converted into a NaN value:\n\nlet n = Float16(\"-nan\")\n// n?.isNaN == true\n// n?.sign == .minus\n\n\nA NaN string may also include a payload in parentheses following the \"nan\" keyword. The payload consists of a sequence of decimal digits, or the characters 0X or 0x followed by a sequence of hexadecimal digits. If the payload contains any other characters, it is ignored. If the value of the payload is larger than can be stored as the payload of a Float16.nan, the least significant bits are used.\n\nlet p = Float16(\"nan(0x10)\")\n// p?.isNaN == true\n// String(p!) == \"nan(0x10)\"\n\n\nA string in any other format than those described above or containing additional characters results in a nil value. For example, the following conversions result in nil:\n\n  Float16(\" 5.0\")      // Includes whitespace\n  Float16(\"±2.0\")      // Invalid character\n  Float16(\"0x1.25e4\")  // Incorrect exponent format\n\n\nA decimal or hexadecimal string is converted to a Float16 instance using the IEEE 754 roundTiesToEven (default) rounding attribute. Values with absolute value smaller than Float16.leastNonzeroMagnitude are rounded to plus or minus zero. Values with absolute value larger than Float16.greatestFiniteMagnitude are rounded to plus or minus infinity.\n\n  let y = Float16(\"1.23e-9999\")\n  // y == 0.0\n  // y?.sign == .plus\n\n\n  let z = Float16(\"-7.89e-7206\")\n  // z == -0.0\n  // z?.sign == .minus\n\n\n  let r = Float16(\"1.23e17802\")\n  // r == Float16.infinity\n\n\n  let s = Float16(\"-7.89e7206\")\n  // s == Float16.-infinity\n\n\nNote\n\nPrior to Swift 5.4, a decimal or hexadecimal input string whose value was too large to represent as a finite Float16 instance returned nil instead of Float16.infinity."
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\nlet x = 7.5\nlet y = x * 2.25\n// y == 16.875\n\n\nThe * operator implements the multiplication operation defined by the IEEE 754 specification."
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/_(_:_:)-7lwp7",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/-=(_:_:)-4m9c5",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "binade | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/binade",
    "html": "Discussion\n\nA binade is a set of binary floating-point values that all have the same sign and exponent. The binade property is a member of the same binade as this value, but with a unit significand.\n\nIn this example, x has a value of 21.5, which is stored as 1.34375 * 2**4, where ** is exponentiation. Therefore, x.binade is equal to 1.0 * 2**4, or 16.0.\n\nlet x = 21.5\n// x.significand == 1.34375\n// x.exponent == 4\n\n\nlet y = x.binade\n// y == 16.0\n// y.significand == 1.0\n// y.exponent == 4\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(_:)-7teyd",
    "html": "Parameters\nvalue\n\nThe integer to convert to a floating-point value.\n\nDiscussion\n\nIf two representable values are equally close, the result is the value with more trailing zeros in its significand bit pattern."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(_:)-469bw",
    "html": "Parameters\nother\n\nThe value to use for the new instance.\n\nDiscussion\n\nThe value of other is rounded to a representable value, if necessary. A NaN passed as other results in another NaN, with a signaling NaN value converted to quiet NaN.\n\nlet x: Float = 21.25\nlet y = Float16(x)\n// y == 21.25\n\n\nlet z = Float16(Float.nan)\n// z.isNaN == true\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(exactly:)-d42j",
    "html": "Parameters\nvalue\n\nA floating-point value to be converted.\n\nDiscussion\n\nIf the given floating-point value cannot be represented exactly, the result is nil."
  },
  {
    "title": "exponentBitPattern | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/exponentbitpattern",
    "html": "Discussion\n\nThis value is unadjusted by the type’s exponent bias."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(exactly:)-6c0t5",
    "html": "Parameters\nvalue\n\nThe integer to convert to a floating-point value.\n\nDiscussion\n\nIf the given integer cannot be represented exactly, the result is nil."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/debugdescription",
    "html": "Discussion\n\nThis property has the same value as the description property, except that NaN values are printed in an extended format."
  },
  {
    "title": "encodeConditional(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unkeyedencodingcontainer/encodeconditional(_:)-4trvc",
    "html": "Parameters\nobject\n\nThe object to encode.\n\nDiscussion\n\nFor encoders which don’t support this feature, the default implementation encodes the given object unconditionally.\n\nFor formats which don’t support this feature, the default implementation encodes the given object unconditionally.\n\nThrows\n\nEncodingError.invalidValue if the given value is invalid in the current context for this format."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/'...(_:)-6ct6c",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/'...(_:)-4mm5k",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/_(_:_:)-24u51",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/_(_:_:)-6o7pz",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/_=(_:_:)-1ii2",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/_=(_:_:)-5y23r",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/_=(_:_:)-8lyhq",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/==(_:_:)-ngi4",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/+=(_:_:)-17hzy",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\nlet x = 7.5\nlet y = x - 2.25\n// y == 5.25\n\n\nThe - operator implements the subtraction operation defined by the IEEE 754 specification."
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/'...(_:)-4mm65",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float/'...(_:)-6ct5t",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectiondifference/change/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removelast()-2gcne",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty. To remove the last element of a collection that might be empty, use the popLast() method instead.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/subscript(_:)-6e3qj",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removelast(_:)-8r1d9",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to remove."
  },
  {
    "title": "Float16.IntegerLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/integerliteraltype",
    "html": "Discussion\n\nThe standard library integer and floating-point types are all valid types for IntegerLiteralType."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(integerliteral:)-5nuto",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": "init(floatLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(floatliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using a floating-point literal. For example:\n\nlet x = 21.5\n\n\nIn this example, the assignment to the x constant calls this floating-point literal initializer behind the scenes."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/float16/init(integerliteral:)-1mjyo",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/_=(_:_:)-nd7a",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "encodeConditional(_:forKey:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyedencodingcontainer/encodeconditional(_:forkey:)-2sxc0",
    "html": "Parameters\nobject\n\nThe object to encode.\n\nkey\n\nThe key to associate the object with.\n\nDiscussion\n\nFor encoders which don’t support this feature, the default implementation encodes the given object unconditionally.\n\nThrows\n\nEncodingError.invalidValue if the given value is invalid in the current context for this format."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/+(_:_:)-9fm63",
    "html": "Parameters\nlhs\n\nA range-replaceable collection.\n\nrhs\n\nAnother range-replaceable collection.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of two integer arrays.\n\nlet lowerNumbers = [1, 2, 3, 4]\nlet higherNumbers: ContiguousArray = [5, 6, 7, 8, 9, 10]\nlet allNumbers = lowerNumbers + higherNumbers\nprint(allNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of the argument on the left-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/init(_:)-1ip9z",
    "html": "Parameters\nelements\n\nThe sequence of elements for the new collection."
  },
  {
    "title": "append(contentsOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/append(contentsof:)-3ccoe",
    "html": "Parameters\nnewElements\n\nThe elements to append to the collection.\n\nDiscussion\n\nThe collection being appended to allocates any additional necessary storage to hold the new elements.\n\nThe following example appends the elements of a Range<Int> instance to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(contentsOf: 10...15)\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]\"\n\n\nComplexity\n\nO(m), where m is the length of newElements."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/+(_:_:)-n335",
    "html": "Parameters\nlhs\n\nA range-replaceable collection.\n\nrhs\n\nA collection or finite sequence.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of an integer array and a Range<Int> instance.\n\nlet numbers = [1, 2, 3, 4]\nlet moreNumbers = numbers + (5...10)\nprint(moreNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of the argument on the left-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removelast()-5b56p",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/map(_:)-9dpvt",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/flatmap(_:)-i3n5",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/_(_:_:)-8n837",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address later than rhs; otherwise, false."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/poplast()-7k3s0",
    "html": "Return Value\n\nThe last element of the collection if the collection has one or more elements; otherwise, nil.\n\nDiscussion\n\nYou can use popLast() to remove the last element of a collection that might be empty. The removeLast() method must be used only on a nonempty collection.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removelast(_:)-1xrzw",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(k), where k is the specified number of elements."
  },
  {
    "title": "removeAll(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removeall(where:)",
    "html": "Parameters\nshouldBeRemoved\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.\n\nDiscussion\n\nUse this method to remove every element in a collection that meets particular criteria. The order of the remaining elements is preserved. This example removes all the vowels from a string:\n\nvar phrase = \"The rain in Spain stays mainly in the plain.\"\n\n\nlet vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nphrase.removeAll(where: { vowels.contains($0) })\n// phrase == \"Th rn n Spn stys mnly n th pln.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dataValueType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/datavaluetype",
    "html": "Discussion\n\nSee MLDataValue/ValueType for a list of available options.\n\nSee Also\nUsing a String as a Data Value\ninit?(from: MLDataValue)\nCreates an instance of the conforming type from a data value.\nvar dataValue: MLDataValue\nThe value of the conforming type’s instance wrapped in a data value.\nvar identifierValue: MLDataValue\nThe value of the unique identifier wrapped in a data value."
  },
  {
    "title": "init(stringInterpolation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(stringinterpolation:)-1jjv",
    "html": "Discussion\n\nDo not call this initializer directly. It is used by the compiler when you create a string using string interpolation. Instead, use string interpolation to create a new string by including values, literals, variables, or expressions enclosed in parentheses, prefixed by a backslash (\\(…)).\n\nlet price = 2\nlet number = 3\nlet message = \"\"\"\n              If one cookie costs \\(price) dollars, \\\n              \\(number) cookies cost \\(price * number) dollars.\n              \"\"\"\nprint(message)\n// Prints \"If one cookie costs 2 dollars, 3 cookies cost 6 dollars.\"\n\nSee Also\nInfrequently Used Functionality\nfunc index(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\ninit(NSString)\ninit(stringLiteral: String)\nCreates an instance initialized to the given string value.\ninit(unicodeScalarLiteral: Self.ExtendedGraphemeClusterLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.UnicodeScalarLiteralType.\ninit(extendedGraphemeClusterLiteral: Self.StringLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.StringLiteralType.\nvar customPlaygroundQuickLook: _PlaygroundQuickLook\nA custom playground Quick Look for the String instance.\nDeprecated\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?\nExecutes a closure on the sequence’s contiguous storage."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe array to append to.\n\nrhs\n\nA collection or finite sequence.\n\nDiscussion\n\nUse this operator to append the elements of a sequence to the end of range-replaceable collection with same Element type. This example appends the elements of a Range<Int> instance to an array of integers.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers += 10...15\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]\"\n\n\nComplexity\n\nO(m), where m is the length of the right-hand-side argument."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/+(_:_:)-6h592",
    "html": "Parameters\nlhs\n\nA collection or finite sequence.\n\nrhs\n\nA range-replaceable collection.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of a Range<Int> instance and an integer array.\n\nlet numbers = [7, 8, 9, 10]\nlet moreNumbers = (1...6) + numbers\nprint(moreNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of argument on the right-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": "append(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/append(_:)",
    "html": "Parameters\nnewElement\n\nThe element to append to the collection.\n\nDiscussion\n\nIf the collection does not have sufficient capacity for another element, additional storage is allocated before appending newElement. The following example adds a new number to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(100)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 100]\"\n\n\nComplexity\n\nO(1) on average, over many calls to append(_:) on the same collection."
  },
  {
    "title": "init(extendedGraphemeClusterLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/init(extendedgraphemeclusterliteral:)-3gyj6",
    "html": "Parameters\nvalue\n\nThe value of the new instance."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "init(repeating:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/init(repeating:count:)",
    "html": "Parameters\nrepeatedValue\n\nThe element to repeat.\n\ncount\n\nThe number of times to repeat the value passed in the repeating parameter. count must be zero or greater.\n\nDiscussion\n\nHere’s an example of creating an array initialized with five strings containing the letter Z.\n\nlet fiveZs = Array(repeating: \"Z\", count: 5)\nprint(fiveZs)\n// Prints \"[\"Z\", \"Z\", \"Z\", \"Z\", \"Z\"]\"\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/init(_:)-6lxbv",
    "html": "Parameters\nelements\n\nThe sequence of elements for the new collection. elements must be finite."
  },
  {
    "title": "applying(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/applying(_:)",
    "html": "Parameters\ndifference\n\nThe difference to be applied.\n\nReturn Value\n\nAn instance representing the state of the receiver with the difference applied, or nil if the difference is incompatible with the receiver’s state.\n\nDiscussion\n\nComplexity\n\nO(n + c), where n is self.count and c is the number of changes contained by the parameter."
  },
  {
    "title": "insert(contentsOf:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/insert(contentsof:at:)",
    "html": "Parameters\nnewElements\n\nThe new elements to insert into the collection.\n\ni\n\nThe position at which to insert the new elements. index must be a valid index of the collection.\n\nDiscussion\n\nThe new elements are inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new elements are appended to the collection.\n\nHere’s an example of inserting a range of integers into an array of the same type:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(contentsOf: 100...103, at: 3)\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 101, 102, 103, 4, 5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If i == endIndex, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "insert(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/insert(_:at:)",
    "html": "Parameters\nnewElement\n\nThe new element to insert into the collection.\n\ni\n\nThe position at which to insert the new element. index must be a valid index into the collection.\n\nDiscussion\n\nThe new element is inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new element is appended to the collection.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(100, at: 3)\nnumbers.insert(200, at: numbers.endIndex)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 4, 5, 200]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection. If i == endIndex, this method is equivalent to append(_:)."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/poplast()-70a2x",
    "html": "Return Value\n\nThe last element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/'...(_:)-4mm5p",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/!=(_:_:)-48qw8",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference different memory addresses; otherwise, false."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/_=(_:_:)-1ii7",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removelast()-4kq76",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removefirst()-2cpd8",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/_=(_:_:)-8lyhn",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/==(_:_:)-4wftt",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/!=(_:_:)-48qwe",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference different memory addresses; otherwise, false."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/poplast()-nrp9",
    "html": "Return Value\n\nThe last element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removefirst(_:)-5s82s",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst(3)\nprint(bugs)\n// Prints \"[\"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeAll(keepingCapacity:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removeall(keepingcapacity:)",
    "html": "Parameters\nkeepCapacity\n\nPass true to request that the collection avoid releasing its storage. Retaining the collection’s storage can be a useful optimization when you’re planning to grow the collection again. The default value is false.\n\nDiscussion\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removefirst()-39om1",
    "html": "Return Value\n\nThe removed element.\n\nDiscussion\n\nThe collection must not be empty.\n\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst()\nprint(bugs)\n// Prints \"[\"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removefirst(_:)-43evo",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removesubrange(_:)-9twoc",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/replacesubrange(_:with:)-5g58l",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/replacesubrange(_:with:)-3hke2",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/replacesubrange(_:with:)-7293b",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, the complexity is O(m)."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removesubrange(_:)-8mayj",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removelast(_:)-5ulmx",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(k), where k is the specified number of elements."
  },
  {
    "title": "init(unicodeScalarLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/init(unicodescalarliteral:)-92ft4",
    "html": "Parameters\nvalue\n\nThe value of the new instance."
  },
  {
    "title": "init(unicodeScalarLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/init(unicodescalarliteral:)-53rjt",
    "html": "Parameters\nvalue\n\nThe value of the new instance."
  },
  {
    "title": "Substring.StringLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/stringliteraltype",
    "html": "Discussion\n\nValid types for StringLiteralType are String and StaticString."
  },
  {
    "title": "init(stringLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/init(stringliteral:)",
    "html": "Parameters\nvalue\n\nThe value of the new instance."
  },
  {
    "title": "identifierValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/identifiervalue",
    "html": "See Also\nUsing a String as a Data Value\ninit?(from: MLDataValue)\nCreates an instance of the conforming type from a data value.\nvar dataValue: MLDataValue\nThe value of the conforming type’s instance wrapped in a data value.\nstatic var dataValueType: MLDataValue.ValueType\nThe underlying type the conforming type uses when it wraps itself in a data value."
  },
  {
    "title": "Substring.RegexOutput | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/regexoutput",
    "html": "Discussion\n\nA Regex instance’s output type depends on whether the Regex has captures and how it is created.\n\nA Regex created from a string using the init(_:) initializer has an output type of AnyRegexOutput, whether it has captures or not.\n\nA Regex without captures created from a regex literal, the init(_:as:) initializer, or a RegexBuilder closure has a Substring output type, where the substring is the portion of the string that was matched.\n\nA Regex with captures created from a regex literal or the init(_:as:) initializer has a tuple of substrings as its output type. The first component of the tuple is the full portion of the string that was matched, with the remaining components holding the captures."
  },
  {
    "title": "init(stringLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(stringliteral:)",
    "html": "Discussion\n\nDo not call this initializer directly. It is used by the compiler when you initialize a string using a string literal. For example:\n\nlet nextStop = \"Clark & Lake\"\n\n\nThis assignment to the nextStop constant calls this string literal initializer behind the scenes.\n\nSee Also\nInfrequently Used Functionality\nfunc index(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\ninit(NSString)\ninit(stringInterpolation: DefaultStringInterpolation)\nCreates a new instance from an interpolated string literal.\ninit(unicodeScalarLiteral: Self.ExtendedGraphemeClusterLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.UnicodeScalarLiteralType.\ninit(extendedGraphemeClusterLiteral: Self.StringLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.StringLiteralType.\nvar customPlaygroundQuickLook: _PlaygroundQuickLook\nA custom playground Quick Look for the String instance.\nDeprecated\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?\nExecutes a closure on the sequence’s contiguous storage."
  },
  {
    "title": "predecessor() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/predecessor()",
    "html": "Return Value\n\nA pointer shifted backward from this pointer by MemoryLayout<Pointee>.stride bytes.\n\nDiscussion\n\nThe resulting pointer must be within the bounds of the same allocation as this pointer."
  },
  {
    "title": "index(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index(of:)",
    "html": "See Also\nInfrequently Used Functionality\ninit(NSString)\ninit(stringInterpolation: DefaultStringInterpolation)\nCreates a new instance from an interpolated string literal.\ninit(stringLiteral: String)\nCreates an instance initialized to the given string value.\ninit(unicodeScalarLiteral: Self.ExtendedGraphemeClusterLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.UnicodeScalarLiteralType.\ninit(extendedGraphemeClusterLiteral: Self.StringLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.StringLiteralType.\nvar customPlaygroundQuickLook: _PlaygroundQuickLook\nA custom playground Quick Look for the String instance.\nDeprecated\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?\nExecutes a closure on the sequence’s contiguous storage."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(_:)-5a5lw",
    "html": "See Also\nInfrequently Used Functionality\nfunc index(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\ninit(stringInterpolation: DefaultStringInterpolation)\nCreates a new instance from an interpolated string literal.\ninit(stringLiteral: String)\nCreates an instance initialized to the given string value.\ninit(unicodeScalarLiteral: Self.ExtendedGraphemeClusterLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.UnicodeScalarLiteralType.\ninit(extendedGraphemeClusterLiteral: Self.StringLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.StringLiteralType.\nvar customPlaygroundQuickLook: _PlaygroundQuickLook\nA custom playground Quick Look for the String instance.\nDeprecated\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?\nExecutes a closure on the sequence’s contiguous storage."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dataValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/datavalue",
    "html": "See Also\nUsing a String as a Data Value\ninit?(from: MLDataValue)\nCreates an instance of the conforming type from a data value.\nvar identifierValue: MLDataValue\nThe value of the unique identifier wrapped in a data value.\nstatic var dataValueType: MLDataValue.ValueType\nThe underlying type the conforming type uses when it wraps itself in a data value."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/init(_:)-1o7ou",
    "html": "Parameters\nfrom\n\nThe opaque pointer to convert to a typed pointer."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "append(contentsOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/append(contentsof:)-9folw",
    "html": "Parameters\nnewElements\n\nThe elements to append to the collection.\n\nDiscussion\n\nThe collection being appended to allocates any additional necessary storage to hold the new elements.\n\nThe following example appends the elements of a Range<Int> instance to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(contentsOf: 10...15)\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]\"\n\n\nComplexity\n\nO(m), where m is the length of newElements."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/'...(_:)-6ct69",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/_(_:_:)-4cbw9",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than rhs; otherwise, false."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/_=(_:_:)-45ljz",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than or the same as rhs; otherwise, false."
  },
  {
    "title": "Unicode.Scalar.UnicodeScalarLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/unicodescalarliteraltype",
    "html": "Discussion\n\nValid types for UnicodeScalarLiteralType are Unicode.Scalar, Character, String, and StaticString."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/_=(_:_:)-jiek",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address later than or the same as rhs; otherwise, false."
  },
  {
    "title": "remove(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/remove(at:)",
    "html": "Parameters\nposition\n\nThe position of the element to remove. position must be a valid index of the collection that is not equal to the collection’s end index.\n\nReturn Value\n\nThe removed element.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes the middle element from an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.6]\nlet removed = measurements.remove(at: 2)\nprint(measurements)\n// Prints \"[1.2, 1.5, 1.2, 1.6]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reserveCapacity(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/reservecapacity(_:)",
    "html": "Parameters\nn\n\nThe requested number of elements to store.\n\nDiscussion\n\nIf you will be adding a known number of elements to a collection, use this method to avoid multiple reallocations. A type that conforms to RangeReplaceableCollection can choose how to respond when this method is called. Depending on the type, it may make sense to allocate more or less storage than requested or to take no action at all."
  },
  {
    "title": "Substring.UnicodeScalarLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarliteraltype",
    "html": "Discussion\n\nValid types for UnicodeScalarLiteralType are Unicode.Scalar, Character, String, and StaticString."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/init(_:)-7r78k",
    "html": "Parameters\nother\n\nThe typed pointer to convert. If other is nil, the result is nil."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/init(_:)-98q78",
    "html": "Parameters\nother\n\nThe typed pointer to convert."
  },
  {
    "title": "init(bitPattern:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/init(bitpattern:)-3r9t4",
    "html": "Parameters\nbitPattern\n\nA bit pattern to use for the address of the new pointer. If bitPattern is zero, the result is nil.\n\nDiscussion\n\nThe address passed as bitPattern must have the correct alignment for the pointer’s Pointee type. That is, bitPattern % MemoryLayout<Pointee>.alignment must be 0."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/init(_:)-qtza",
    "html": "Parameters\nfrom\n\nThe opaque pointer to convert to a typed pointer. If from is nil, the result of this initializer is nil."
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/advanced(by:)",
    "html": "Parameters\nn\n\nThe number of strides of the pointer’s Pointee type to offset this pointer. To access the stride, use MemoryLayout<Pointee>.stride. n may be positive, negative, or zero.\n\nReturn Value\n\nA pointer offset from this pointer by n instances of the Pointee type.\n\nDiscussion\n\nWith pointer p and distance n, the result of p.advanced(by: n) is equivalent to p + n.\n\nThe resulting pointer must be within the bounds of the same allocation as this pointer."
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(exactly:)-7er6b",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 100, while the attempt to initialize the constant y from 1_000 fails because the Int8 type can represent 127 at maximum:\n\nlet x = Int8(exactly: 100)\n// x == Optional(100)\nlet y = Int8(exactly: 1_000)\n// y == nil\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(_:)-47iba",
    "html": "Parameters\nsource\n\nA value to convert to this type of integer. The value passed as source must be representable in this type.\n\nDiscussion\n\nUse this initializer to convert from another integer type when you know the value is within the bounds of this type. Passing a value that can’t be represented in this type results in a runtime error.\n\nIn the following example, the constant y is successfully created from x, an Int instance with a value of 100. Because the Int8 type can represent 127 at maximum, the attempt to create z with a value of 1000 results in a runtime error.\n\nlet x = 100\nlet y = Int8(x)\n// y == 100\nlet z = Int8(x * 10)\n// Error: Not enough bits to represent the given value\n"
  },
  {
    "title": "SIMD64Storage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdscalar/simd64storage",
    "html": "Required"
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/distance(to:)",
    "html": "Parameters\nend\n\nThe pointer to calculate the distance to.\n\nReturn Value\n\nThe distance from this pointer to end, in strides of the pointer’s Pointee type. To access the stride, use MemoryLayout<Pointee>.stride.\n\nDiscussion\n\nWith pointers p and q, the result of p.distance(to: q) is equivalent to q - p.\n\nTyped pointers are required to be properly aligned for their Pointee type. Proper alignment ensures that the result of distance(to:) accurately measures the distance between the two pointers, counted in strides of Pointee. To find the distance in bytes between two pointers, convert them to UnsafeRawPointer instances before calling distance(to:)."
  },
  {
    "title": "isSigned | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/issigned",
    "html": "Discussion\n\nThis property is always true for signed integer types."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "successor() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/successor()",
    "html": "Return Value\n\nA pointer advanced from this pointer by MemoryLayout<Pointee>.stride bytes.\n\nDiscussion\n\nThe resulting pointer must be within the bounds of the same allocation as this pointer."
  },
  {
    "title": "min | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/min",
    "html": "Discussion\n\nFor signed integer types, this value is -(2 ** (bitWidth - 1)), where ** is exponentiation."
  },
  {
    "title": "max | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/max",
    "html": "Discussion\n\nFor signed integer types, this value is (2 ** (bitWidth - 1)) - 1, where ** is exponentiation."
  },
  {
    "title": "init(stringInterpolation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/init(stringinterpolation:)-99wcz",
    "html": "Discussion\n\nDo not call this initializer directly. It is used by the compiler when you create a string using string interpolation. Instead, use string interpolation to create a new string by including values, literals, variables, or expressions enclosed in parentheses, prefixed by a backslash (\\(…)).\n\nlet price = 2\nlet number = 3\nlet message = \"\"\"\n              If one cookie costs \\(price) dollars, \\\n              \\(number) cookies cost \\(price * number) dollars.\n              \"\"\"\nprint(message)\n// Prints \"If one cookie costs 2 dollars, 3 cookies cost 6 dollars.\"\n"
  },
  {
    "title": "Substring.StringInterpolation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/stringinterpolation",
    "html": "Discussion\n\nThe StringLiteralType of an interpolation type must match the StringLiteralType of the conforming type."
  },
  {
    "title": "init(stringInterpolation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/init(stringinterpolation:)-62cd",
    "html": "Discussion\n\nDon’t call this initializer directly. It’s used by the compiler when you create a string using string interpolation. Instead, use string interpolation to create a new string by including values, literals, variables, or expressions enclosed in parentheses, prefixed by a backslash (\\(…)).\n\nlet price = 2\nlet number = 3\nlet message = \"\"\"\n              If one cookie costs \\(price) dollars, \\\n              \\(number) cookies cost \\(price * number) dollars.\n              \"\"\"\n// message == \"If one cookie costs 2 dollars, 3 cookies cost 6 dollars.\"\n"
  },
  {
    "title": "Substring.ExtendedGraphemeClusterLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/extendedgraphemeclusterliteraltype",
    "html": "Discussion\n\nValid types for ExtendedGraphemeClusterLiteralType are Character, String, and StaticString."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/==(_:_:)-8ubmi",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference the same memory address; otherwise, false."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/customplaygroundquicklook",
    "html": "Discussion\n\nIf this type has value semantics, the PlaygroundQuickLook instance should be unaffected by subsequent mutations."
  },
  {
    "title": "init(_:radix:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(_:radix:)",
    "html": "Parameters\ntext\n\nThe ASCII representation of a number in the radix passed as radix.\n\nradix\n\nThe radix, or base, to use for converting text to an integer value. radix must be in the range 2...36. The default is 10.\n\nDiscussion\n\nThe string passed as text may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9) or letters (a-z or A-Z). Parsing of the string is case insensitive.\n\nlet x = Int(\"123\")\n// x == 123\n\n\nlet y = Int(\"-123\", radix: 8)\n// y == -83\nlet y = Int(\"+123\", radix: 8)\n// y == +83\n\n\nlet z = Int(\"07b\", radix: 16)\n// z == 123\n\n\nIf text is in an invalid format or contains characters that are out of bounds for the given radix, or if the value it denotes in the given radix is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"zzzzzzzzzzzzz\", radix: 36)   // Out of range\n"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/_=(_:_:)-45ljt",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than or the same as rhs; otherwise, false."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/init(_:)-7r78i",
    "html": "Parameters\nother\n\nThe typed pointer to convert. If other is nil, the result is nil."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "Unicode.Scalar.RegexOutput | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/regexoutput",
    "html": "Discussion\n\nA Regex instance’s output type depends on whether the Regex has captures and how it is created.\n\nA Regex created from a string using the init(_:) initializer has an output type of AnyRegexOutput, whether it has captures or not.\n\nA Regex without captures created from a regex literal, the init(_:as:) initializer, or a RegexBuilder closure has a Substring output type, where the substring is the portion of the string that was matched.\n\nA Regex with captures created from a regex literal or the init(_:as:) initializer has a tuple of substrings as its output type. The first component of the tuple is the full portion of the string that was matched, with the remaining components holding the captures."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "init(extendedGraphemeClusterLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/init(extendedgraphemeclusterliteral:)-8o1te",
    "html": "Parameters\nvalue\n\nThe value of the new instance."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/_(_:_:)-fe5b",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/_(_:_:)-24u4w",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/_(_:_:)-1r7fj",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than rhs; otherwise, false."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/==(_:_:)-9kt07",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference the same memory address; otherwise, false."
  },
  {
    "title": "&*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe overflow multiplication operator (&*) discards any bits that overflow the fixed width of the integer type. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &* 5\n// x == 50\nlet y: Int8 = 10 &* 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/==(_:_:)-8ubmk",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference the same memory address; otherwise, false."
  },
  {
    "title": "&<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&__=(_:_:)-1642g",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &<<= operator performs a masking shift, where the value used as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &<<= 2\n// x == 120                       // 0b01111000\n\n\nHowever, if you pass 19 as rhs, the method first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &<<= 19\n// y == 240                       // 0b11110000\n"
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&__(_:_:)-98mep",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe masking multiplication assignment operator (&*=) silently wraps any overflow that occurs during the operation. In the following example, the product of 10 and 50 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &*= 5\n// x == 50\nvar y: Int8 = 10\ny &*= 50\n// y == -12 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&-(_:_:)-qd7g",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe overflow subtraction operator (&-) discards any bits that overflow the fixed width of the integer type. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: UInt8 = 21 &- 10\n// x == 11\nlet y: UInt8 = 10 &- 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "init(littleEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(littleendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the little-endian representation of the new integer."
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\n8 - 3                   // 5\n-10 - 5                 // -15\n100 - -5                // 105\n10.5 - 100.0            // -89.5\n\n\nYou cannot use - with arguments of different types. To subtract values of different types, convert one of the values to the other value’s type.\n\nlet x: UInt8 = 21\nlet y: UInt = 1000000\ny - UInt(x)             // 999979\n\n\nThe difference of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 - 50 is less than zero, the minimum representable UInt8 value:\n\nx - 50                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow subtraction operator (&-).\n\nx &- 50                // 227\n"
  },
  {
    "title": "successor() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/successor()",
    "html": "Return Value\n\nA pointer advanced from this pointer by MemoryLayout<Pointee>.stride bytes.\n\nDiscussion\n\nThe resulting pointer must be within the bounds of the same allocation as this pointer."
  },
  {
    "title": "-(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/-(_:)",
    "html": "Return Value\n\nThe additive inverse of the argument.\n\nDiscussion\n\nThe negation operator (prefix -) returns the additive inverse of its argument.\n\nlet x = 21\nlet y = -x\n// y == -21\n\n\nThe resulting value must be representable in the same type as the argument. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nlet z = -Int8.min\n// Overflow error\n"
  },
  {
    "title": "SIMD4Storage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdscalar/simd4storage",
    "html": "Required"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/==(_:_:)-1giba",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the equality of instances of any BinaryInteger types using the equal-to operator (==). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are equal: \\(firstUTF8 == firstScalar)\")\n}\n// Prints \"First code values are equal: true\"\n"
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nfunc addOne<T: Strideable>(to x: T) -> T\n    where T.Stride: ExpressibleByIntegerLiteral\n{\n    return x.advanced(by: 1)\n}\n\n\nlet x = addOne(to: 5)\n// x == 6\nlet y = addOne(to: 3.5)\n// y = 4.5\n\n\nIf this type’s Stride type conforms to BinaryInteger, then for a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n. Using this method with types that have a noninteger Stride may result in an approximation. If the result of advancing by n is not representable as a value of this type, then a runtime error may occur.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/_(_:_:)-1r7fd",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than rhs; otherwise, false."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawpointer/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/_(_:_:)-4cbwf",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than rhs; otherwise, false."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/==(_:_:)-9kt01",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference the same memory address; otherwise, false."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/_(_:_:)-8n839",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address later than rhs; otherwise, false."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/init(_:)-98q76",
    "html": "Parameters\nother\n\nThe typed pointer to convert."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/_=(_:_:)-jiei",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address later than or the same as rhs; otherwise, false."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/init(_:)-1o7oo",
    "html": "Parameters\nfrom\n\nThe opaque pointer to convert to a typed pointer."
  },
  {
    "title": "init(bitPattern:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/init(bitpattern:)-3r9ta",
    "html": "Parameters\nbitPattern\n\nA bit pattern to use for the address of the new pointer. If bitPattern is zero, the result is nil.\n\nDiscussion\n\nThe address passed as bitPattern must have the correct alignment for the pointer’s Pointee type. That is, bitPattern % MemoryLayout<Pointee>.alignment must be 0."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/init(_:)-qtz4",
    "html": "Parameters\nfrom\n\nThe opaque pointer to convert to a typed pointer. If from is nil, the result of this initializer is nil."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/'...(_:)-33g6y",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "littleEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/littleendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a little-endian platform, for any integer x, x == x.littleEndian."
  },
  {
    "title": "init(truncatingIfNeeded:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(truncatingifneeded:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nWhen the bit width of T (the type of source) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of source. For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of source are used.\n\nlet p: Int16 = -500\n// 'p' has a binary representation of 11111110_00001100\nlet q = Int8(truncatingIfNeeded: p)\n// q == 12\n// 'q' has a binary representation of 00001100\n\n\nWhen the bit width of T is less than this type’s bit width, the result is sign-extended to fill the remaining bits. That is, if source is negative, the result is padded with ones; otherwise, the result is padded with zeros.\n\nlet u: Int8 = 21\n// 'u' has a binary representation of 00010101\nlet v = Int16(truncatingIfNeeded: u)\n// v == 21\n// 'v' has a binary representation of 00000000_00010101\n\n\nlet w: Int8 = -21\n// 'w' has a binary representation of 11101011\nlet x = Int16(truncatingIfNeeded: w)\n// x == -21\n// 'x' has a binary representation of 11111111_11101011\nlet y = UInt16(truncatingIfNeeded: w)\n// y == 65515\n// 'y' has a binary representation of 11111111_11101011\n"
  },
  {
    "title": "init(clamping:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(clamping:)",
    "html": "Parameters\nsource\n\nAn integer to convert to this type.\n\nDiscussion\n\nIf the value passed as source is greater than the maximum representable value in this type, the result is the type’s max value. If source is less than the smallest representable value in this type, the result is the type’s min value.\n\nIn this example, x is initialized as an Int8 instance by clamping 500 to the range -128...127, and y is initialized as a UInt instance by clamping -500 to the range 0...UInt.max.\n\nlet x = Int8(clamping: 500)\n// x == 127\n// x == Int8.max\n\n\nlet y = UInt(clamping: -500)\n// y == 0\n"
  },
  {
    "title": "~(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/~(_:)",
    "html": "Discussion\n\nThe bitwise NOT operator (~) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are 1 in the argument are 0 in the result, and bits that are 0 in the argument are 1 in the result. This is equivalent to the inverse of a set. For example:\n\nlet x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010\n\n\nPerforming a bitwise NOT operation on 0 returns a value with every bit set to 1.\n\nlet allOnes = ~UInt8.min   // 0b11111111\n\n\nComplexity\n\nO(1)."
  },
  {
    "title": "init(bigEndian:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(bigendian:)",
    "html": "Parameters\nvalue\n\nA value to use as the big-endian representation of the new integer."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/!=(_:_:)-2y35c",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can check the inequality of instances of any BinaryInteger types using the not-equal-to operator (!=). For example, you can test whether the first UInt8 value in a string’s UTF-8 encoding is not equal to the first UInt32 value in its Unicode scalar view:\n\nlet gameName = \"Red Light, Green Light\"\nif let firstUTF8 = gameName.utf8.first,\n    let firstScalar = gameName.unicodeScalars.first?.value {\n    print(\"First code values are different: \\(firstUTF8 != firstScalar)\")\n}\n// Prints \"First code values are different: false\"\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&(_:_:)-40fb6",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "isMultiple(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/ismultiple(of:)",
    "html": "Parameters\nother\n\nThe value to test.\n\nDiscussion\n\nFor two integers a and b, a is a multiple of b if there exists a third integer q such that a = q*b. For example, 6 is a multiple of 3 because 6 = 2*3. Zero is a multiple of everything because 0 = 0*x for any integer x.\n\nTwo edge cases are worth particular attention:\n\nx.isMultiple(of: 0) is true if x is zero and false otherwise.\n\nT.min.isMultiple(of: -1) is true for signed integer T, even though the quotient T.min / -1 isn’t representable in type T."
  },
  {
    "title": "quotientAndRemainder(dividingBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/quotientandremainder(dividingby:)",
    "html": "Parameters\nrhs\n\nThe value to divide this value by.\n\nReturn Value\n\nA tuple containing the quotient and remainder of this value divided by rhs.\n\nDiscussion\n\nUse this method to calculate the quotient and remainder of a division at the same time.\n\nlet x = 1_000_000\nlet (q, r) = x.quotientAndRemainder(dividingBy: 933)\n// q == 1071\n// r == 757\n"
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/__(_:_:)-27cld",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&(_:_:)-ui0w",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/_=(_:_:)-8lyhp",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\n2 * 3                   // 6\n100 * 21                // 2100\n-10 * 15                // -150\n3.5 * 2.25              // 7.875\n\n\nYou cannot use * with arguments of different types. To multiply values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) * y              // 21000000\n\n\nThe product of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 * 21 is greater than the maximum representable Int8 value:\n\nx * 21                  // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow multiplication operator (&*).\n\nx &* 21                // -115\n"
  },
  {
    "title": "init(bitPattern:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/init(bitpattern:)-84bz2",
    "html": "Parameters\nbitPattern\n\nA bit pattern to use for the address of the new pointer. If bitPattern is zero, the result is nil.\n\nDiscussion\n\nThe address passed as bitPattern must have the correct alignment for the pointer’s Pointee type. That is, bitPattern % MemoryLayout<Pointee>.alignment must be 0."
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/distance(to:)",
    "html": "Parameters\nend\n\nThe pointer to calculate the distance to.\n\nReturn Value\n\nThe distance from this pointer to end, in strides of the pointer’s Pointee type. To access the stride, use MemoryLayout<Pointee>.stride.\n\nDiscussion\n\nWith pointers p and q, the result of p.distance(to: q) is equivalent to q - p.\n\nTyped pointers are required to be properly aligned for their Pointee type. Proper alignment ensures that the result of distance(to:) accurately measures the distance between the two pointers, counted in strides of Pointee. To find the distance in bytes between two pointers, convert them to UnsafeRawPointer instances before calling distance(to:)."
  },
  {
    "title": "predecessor() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/predecessor()",
    "html": "Return Value\n\nA pointer shifted backward from this pointer by MemoryLayout<Pointee>.stride bytes.\n\nDiscussion\n\nThe resulting pointer must be within the bounds of the same allocation as this pointer."
  },
  {
    "title": "SIMD32Storage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdscalar/simd32storage",
    "html": "Required"
  },
  {
    "title": "SIMDMaskScalar | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdscalar/simdmaskscalar",
    "html": "Required"
  },
  {
    "title": "SIMD16Storage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdscalar/simd16storage",
    "html": "Required"
  },
  {
    "title": "SIMD2Storage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdscalar/simd2storage",
    "html": "Required"
  },
  {
    "title": "negate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/negate()",
    "html": "Discussion\n\nThe following example uses the negate() method to negate the value of an integer x:\n\nvar x = 21\nx.negate()\n// x == -21\n\n\nThe resulting value must be representable within the value’s type. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nvar y = Int8.min\ny.negate()\n// Overflow error\n"
  },
  {
    "title": "SIMD8Storage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdscalar/simd8storage",
    "html": "Required"
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/customplaygroundquicklook",
    "html": "Deprecated\n\nInt32.customPlaygroundQuickLook will be removed in a future Swift version"
  },
  {
    "title": "&+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe masking addition assignment operator (&+=) silently wraps any overflow that occurs during the operation. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 10\nx &+= 21\n// x == 31\nvar y: Int8 = 100\ny &+= 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&-=(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe masking subtraction assignment operator (&-=) silently wraps any overflow that occurs during the operation. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the result is the partial value after discarding the overflowing bits.\n\nvar x: Int8 = 21\nx &-= 10\n// x == 11\nvar y: UInt8 = 10\ny &-= 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&__(_:_:)-2odv2",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&__=(_:_:)-7weao",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &>>= operator performs a masking shift, where the value passed as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &>>= 2\n// x == 7                         // 0b00000111\n\n\nHowever, if you use 19 as rhs, the operation first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &>>= 19\n// y == 3                         // 0b00000011\n"
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&__(_:_:)-5dixx",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&__(_:_:)-6cb7m",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&+(_:_:)-4jhwa",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe overflow addition operator (&+) discards any bits that overflow the fixed width of the integer type. In the following example, the sum of 100 and 121 is greater than the maximum representable Int8 value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: Int8 = 10 &+ 21\n// x == 31\nlet y: Int8 = 100 &+ 121\n// y == -35 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&__(_:_:)-1djlp",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/&__(_:_:)-7sh72",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "%(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_(_:_:)-41rsu",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nThe result of the remainder operator (%) has the same sign as lhs and has a magnitude less than rhs.magnitude.\n\nlet x = 22 % 5\n// x == 2\nlet y = 22 % -5\n// y == 2\nlet z = -22 % -5\n// z == -2\n\n\nFor any two integers a and b, their quotient q, and their remainder r, a == b * q + r."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_=(_:_:)-1nkpl",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than-or-equal-to operator (<=), even if the two instances are of different types."
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nFor a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n."
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/distance(to:)",
    "html": "Parameters\nother\n\nThe value to calculate the distance to.\n\nReturn Value\n\nThe distance from this value to other.\n\nDiscussion\n\nFor two values x and y, and a distance n = x.distance(to: y), x.advanced(by: n) == y."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/'...(_:)-67bt7",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_(_:_:)-30znw",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_(_:_:)-9adkd",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_(_:_:)-4d2t4",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_=(_:_:)-1ukxu",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_=(_:_:)-3jitm",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_=(_:_:)-658lf",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_=(_:_:)-4p7mg",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(integerliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/__(_:_:)-5xz7g",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(_:)-6wz3b",
    "html": "Parameters\ndescription\n\nThe ASCII representation of a number.\n\nDiscussion\n\nThe string passed as description may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9).\n\nlet x = Int(\"123\")\n// x == 123\n\n\nIf description is in an invalid format, or if the value it denotes in base 10 is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"10000000000000000000000000\") // Out of range\n"
  },
  {
    "title": "init(exactly:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(exactly:)-77qpt",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer.\n\nDiscussion\n\nIf the value passed as source is not representable exactly, the result is nil. In the following example, the constant x is successfully created from a value of 21.0, while the attempt to initialize the constant y from 21.5 fails:\n\nlet x = Int(exactly: 21.0)\n// x == Optional(21)\nlet y = Int(exactly: 21.5)\n// y == nil\n"
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/random(in:)-47fh7",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling the version that takes a generator, passing in the system’s default random generator."
  },
  {
    "title": "bigEndian | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/bigendian",
    "html": "Discussion\n\nIf necessary, the byte order of this value is reversed from the typical byte order of this integer type. On a big-endian platform, for any integer x, x == x.bigEndian."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(_:)-97yta",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer. source must be representable in this type after rounding toward zero.\n\nDiscussion\nlet x = Int(21.5)\n// x == 21\nlet y = Int(-21.5)\n// y == -21\n\n\nIf source is outside the bounds of this type after rounding toward zero, a runtime error may occur.\n\nlet z = UInt(-21.5)\n// Error: ...outside the representable range\n"
  },
  {
    "title": "random(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/random(in:)-4xbuz",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100))\n}\n// Prints \"53\"\n// Prints \"64\"\n// Prints \"5\"\n\n\nThis method is equivalent to calling random(in:using:), passing in the system’s default random generator."
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/random(in:using:)-thxt",
    "html": "Parameters\nrange\n\nThe range in which to create a random value.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1...100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1...100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n"
  },
  {
    "title": "random(in:using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/random(in:using:)-2c18d",
    "html": "Parameters\nrange\n\nThe range in which to create a random value. range must not be empty.\n\ngenerator\n\nThe random number generator to use when creating the new random value.\n\nReturn Value\n\nA random value within the bounds of range.\n\nDiscussion\n\nUse this method to generate an integer within a specific range when you are using a custom random number generator. This example creates three new values in the range 1..<100.\n\nfor _ in 1...3 {\n    print(Int.random(in: 1..<100, using: &myGenerator))\n}\n// Prints \"7\"\n// Prints \"44\"\n// Prints \"21\"\n\n\nNote\n\nThe algorithm used to create random values may change in a future version of Swift. If you’re passing a generator that results in the same sequence of integer values each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/==(_:_:)-88moe",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/+=(_:_:)-6ck44",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/_(_:_:)-fe55",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/_(_:_:)-24u52",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_(_:_:)-5i6yu",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/__(_:_:)-2ny6e",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": ">>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/__=(_:_:)-1o1y1",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >>= operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx >>= 2\n// x == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny >>= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na >>= -3\n// a == 240                       // 0b11110000\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb <<= 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nvar q: Int8 = -30                 // 0b11100010\nq >>= 2\n// q == -8                        // 0b11111000\n\n\nvar r: Int8 = -30                 // 0b11100010\nr >>= 11\n// r == -1                        // 0b11111111\n"
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_(_:_:)-1xb80",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/__(_:_:)-78esh",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\n1 + 2                   // 3\n-10 + 15                // 5\n-15 + -5                // -20\n21.5 + 3.25             // 24.75\n\n\nYou cannot use + with arguments of different types. To add values of different types, convert one of the values to the other value’s type.\n\nlet x: Int8 = 21\nlet y: Int = 1000000\nInt(x) + y              // 1000021\n\n\nThe sum of the two arguments must be representable in the arguments’ type. In the following example, the result of 21 + 120 is greater than the maximum representable Int8 value:\n\nx + 120                 // Overflow error\n\n\nNote\n\nOverflow checking is not performed in -Ounchecked builds.\n\nIf you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow addition operator (&+).\n\nx &+ 120                // -115\n"
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nFor integer types, any remainder of the division is discarded.\n\nlet x = 21 / 5\n// x == 4\n"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_(_:_:)-67qna",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than operator (<), even if the two instances are of different types."
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_(_:_:)-2t9oy",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_(_:_:)-4jn4j",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than operator (>), even if the two instances are of different types."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_(_:_:)-5zn2u",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_=(_:_:)-86dc4",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than-or-equal-to operator (>=), even if the two instances are of different types."
  },
  {
    "title": "<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/__=(_:_:)-80z6h",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx <<= 2\n// x == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny <<= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na <<= -3\n// a == 3                         // 0b00000011\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb >>= 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/customplaygroundquicklook",
    "html": "Discussion\n\nIf this type has value semantics, the PlaygroundQuickLook instance should be unaffected by subsequent mutations."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_(_:_:)-5p8ms",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_=(_:_:)-4n6ly",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/_=(_:_:)-5corj",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/==(_:_:)-4wftz",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/removefirst()-9kzay",
    "html": "Return Value\n\nThe removed element.\n\nDiscussion\n\nThe collection must not be empty.\n\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst()\nprint(bugs)\n// Prints \"[\"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/replacesubrange(_:with:)-9qrl3",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, the complexity is O(m)."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/endindex",
    "html": "Discussion\n\nWhen you need a range that includes the last element of a collection, use the half-open range operator (..<) with endIndex. The ..< operator creates a range that doesn’t include the upper bound, so it’s always safe to use with endIndex. For example:\n\nlet numbers = [10, 20, 30, 40, 50]\nif let index = numbers.firstIndex(of: 30) {\n    print(numbers[index ..< numbers.endIndex])\n}\n// Prints \"[30, 40, 50]\"\n\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/-=(_:_:)-8jb43",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/_=(_:_:)-1ii1",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/zero",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/'...(_:)-6ct6f",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablepointer/'...(_:)-4mm5n",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/__(_:_:)-635pg",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeAll(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/removeall(where:)-7wiss",
    "html": "Parameters\nshouldBeRemoved\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.\n\nDiscussion\n\nUse this method to remove every element in a collection that meets particular criteria. The order of the remaining elements is preserved. This example removes all the odd values from an array of numbers:\n\nvar numbers = [5, 6, 7, 8, 9, 10, 11]\nnumbers.removeAll(where: { $0 % 2 != 0 })\n// numbers == [6, 8, 10]\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "init(literalCapacity:interpolationCount:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/localizationvalue/stringinterpolation/init(literalcapacity:interpolationcount:)",
    "html": "Parameters\nliteralCapacity\n\nThe approximate size of all literal segments combined. This is meant to be passed to String.reserveCapacity(_:); it may be slightly larger or smaller than the sum of the counts of each literal segment.\n\ninterpolationCount\n\nThe number of interpolations which will be appended. Use this value to estimate how much additional capacity will be needed for the interpolated segments.\n\nDiscussion\n\nDon’t call this initializer directly. Instead, initialize a variable or constant using a string literal with interpolated expressions.\n\nSwift passes this initializer a pair of arguments specifying the size of the literal segments and the number of interpolated segments. Use this information to estimate the amount of storage you will need."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/startindex",
    "html": "Discussion\n\nIf the collection is empty, startIndex is equal to endIndex."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off the specified number of elements at the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/removefirst()",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/__(_:_:)-2xfjq",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/removefirst()-6z962",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "insert(contentsOf:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/insert(contentsof:at:)-3h5sa",
    "html": "Parameters\nnewElements\n\nThe new elements to insert into the collection.\n\ni\n\nThe position at which to insert the new elements. index must be a valid index of the collection.\n\nDiscussion\n\nThe new elements are inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new elements are appended to the collection.\n\nHere’s an example of inserting a range of integers into an array of the same type:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(contentsOf: 100...103, at: 3)\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 101, 102, 103, 4, 5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If i == endIndex, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_=(_:_:)-8lyh0",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_=(_:_:)-7v58y",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than-or-equal-to operator (>=), even if the two instances are of different types."
  },
  {
    "title": "reserveCapacity(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/reservecapacity(_:)-1ewcj",
    "html": "Parameters\nn\n\nThe requested number of elements to store.\n\nDiscussion\n\nIf you will be adding a known number of elements to a collection, use this method to avoid multiple reallocations. A type that conforms to RangeReplaceableCollection can choose how to respond when this method is called. Depending on the type, it may make sense to allocate more or less storage than requested or to take no action at all."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_(_:_:)-4e53i",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/partition(by:)-1s0cl",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_(_:_:)-1e0ee",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nFor integer types, any remainder of the division is discarded.\n\nlet x = 21 / 5\n// x == 4\n"
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/&(_:_:)-1gv8r",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "|(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_(_:_:)-26x3w",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise OR operation results in a value that has each bit set to 1 where one or both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x | y             // 0b00001111\n// z == 15\n"
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_(_:_:)-591r5",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_(_:_:)-7d57p",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the greater-than operator (>), even if the two instances are of different types."
  },
  {
    "title": "sort(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/sort(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false. If areInIncreasingOrder throws an error during the sort, the elements may be in a different order, but none will be lost.\n\nDiscussion\n\nWhen you want to sort a collection of elements that don’t conform to the Comparable protocol, pass a closure to this method that returns true when the first element should be ordered before the second.\n\nIn the following example, the closure provides an ordering for an array of a custom enumeration that describes an HTTP response. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nvar responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nresponses.sort {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(responses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nAlternatively, use this method to sort a collection of elements that do conform to Comparable when you want the sort to be descending instead of ascending. Pass the greater-than operator (>) operator as the predicate.\n\nvar students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nstudents.sort(by: >)\nprint(students)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nareInIncreasingOrder must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the collection."
  },
  {
    "title": "removeAll(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/removeall(where:)-zdk8",
    "html": "Parameters\nshouldBeRemoved\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.\n\nDiscussion\n\nUse this method to remove every element in a collection that meets particular criteria. The order of the remaining elements is preserved. This example removes all the vowels from a string:\n\nvar phrase = \"The rain in Spain stays mainly in the plain.\"\n\n\nlet vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nphrase.removeAll(where: { vowels.contains($0) })\n// phrase == \"Th rn n Spn stys mnly n th pln.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "insert(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/insert(_:at:)-2i3ee",
    "html": "Parameters\nnewElement\n\nThe new element to insert into the collection.\n\ni\n\nThe position at which to insert the new element. index must be a valid index into the collection.\n\nDiscussion\n\nThe new element is inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new element is appended to the collection.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(100, at: 3)\nnumbers.insert(200, at: numbers.endIndex)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 4, 5, 200]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection. If i == endIndex, this method is equivalent to append(_:)."
  },
  {
    "title": "withContiguousMutableStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/withcontiguousmutablestorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an in-out UnsafeMutableBufferPointer to the collection’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the collection doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer provides access to the contiguous mutable storage of the entire collection. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in the form of contiguous mutable storage, this method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nAlways perform any necessary cleanup in the closure, because the method makes no guarantees about the state of the collection if the closure throws an error. Your changes to the collection may be absent from the collection after throwing the error, because the closure could receive a temporary copy rather than direct access to the collection’s storage.\n\nWarning\n\nYour body closure must not replace buffer. This leads to a crash in all implementations of this method within the standard library.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/subscript(_:)-1grsk",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nOverview\n\nThe following example accesses an element of an array through its subscript to print its value:\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nprint(streets[1])\n// Prints \"Bryant\"\n\n\nYou can subscript a collection with any valid index other than the collection’s end index. The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "DefaultIndices.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "DefaultIndices.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "DefaultIndices.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "removeAll(keepingCapacity:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/removeall(keepingcapacity:)-9axpj",
    "html": "Parameters\nkeepCapacity\n\nPass true to request that the collection avoid releasing its storage. Retaining the collection’s storage can be a useful optimization when you’re planning to grow the collection again. The default value is false.\n\nDiscussion\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/&__(_:_:)-2kxph",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/&-(_:_:)-3tqmb",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe overflow subtraction operator (&-) discards any bits that overflow the fixed width of the integer type. In the following example, the difference of 10 and 21 is less than zero, the minimum representable UInt value, so the result is the partial value after discarding the overflowing bits.\n\nlet x: UInt8 = 21 &- 10\n// x == 11\nlet y: UInt8 = 10 &- 21\n// y == 245 (after overflow)\n\n\nFor more about arithmetic with overflow operators, see Overflow Operators in The Swift Programming Language."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/losslessstringconvertible/init(_:)-62cdc",
    "html": "Parameters\nsource\n\nA floating-point value to convert to an integer. source must be representable in this type after rounding toward zero.\n\nDiscussion\nlet x = Int(21.5)\n// x == 21\nlet y = Int(-21.5)\n// y == -21\n\n\nIf source is outside the bounds of this type after rounding toward zero, a runtime error may occur.\n\nlet z = UInt(-21.5)\n// Error: ...outside the representable range\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/==(_:_:)-4wfum",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be nonuniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can result in an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "popFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/popfirst()",
    "html": "Return Value\n\nThe first element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/map(_:)-87c51",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/removefirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "entityIdentifierString | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/entityidentifierstring",
    "html": "Discussion\n\nNote: Due to system-imposed limitations, the length of this value can not exceed 512 characters!"
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_(_:_:)-24u4v",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_=(_:_:)-yera",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than-or-equal-to operator (<=), even if the two instances are of different types."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_=(_:_:)-7tmrx",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/__(_:_:)-60q97",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x << 2\n// y == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x << 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nlet a = x << -3\n// a == 3                         // 0b00000011\nlet b = x >> 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_=(_:_:)-443dp",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_(_:_:)-fe4g",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_(_:_:)-9cdiy",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_=(_:_:)-6cfca",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/&__(_:_:)-voti",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/map(_:)-4gmui",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/&__(_:_:)-76ndv",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/partition(by:)-2ouy4",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "^(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_(_:_:)-2yuui",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to 1 where one or the other but not both of its arguments had that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x ^ y             // 0b00001011\n// z == 11\n"
  },
  {
    "title": "%(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_(_:_:)-6lyj3",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by. rhs must not be zero.\n\nDiscussion\n\nThe result of the remainder operator (%) has the same sign as lhs and has a magnitude less than rhs.magnitude.\n\nlet x = 22 % 5\n// x == 2\nlet y = 22 % -5\n// y == 2\nlet z = -22 % -5\n// z == -2\n\n\nFor any two integers a and b, their quotient q, and their remainder r, a == b * q + r."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/subscript(_:)-82bqh",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "remove(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/remove(at:)-98ice",
    "html": "Parameters\nposition\n\nThe position of the element to remove. position must be a valid index of the collection that is not equal to the collection’s end index.\n\nReturn Value\n\nThe removed element.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes the middle element from an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.6]\nlet removed = measurements.remove(at: 2)\nprint(measurements)\n// Prints \"[1.2, 1.5, 1.2, 1.6]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/subscript(_:)-8buws",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/subscript(_:)-4h7sp",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/subscript(_:)-8o3ct",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nFor example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2..<5]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")!    // 4\nprint(streets[index])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/+=(_:_:)-5g9ip",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/-=(_:_:)-2aqsn",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/randomnumbergenerator/next()-6auxg",
    "html": "Return Value\n\nA random value of T. Bits are randomly distributed so that every value of T is equally likely to be returned.\n\nDiscussion\n\nUse this method when you need random binary data to generate another value. If you need an integer value within a specific range, use the static random(in:using:) method on that integer type instead of this method."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/&__(_:_:)-35o0c",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "appendLiteral(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/localizationvalue/stringinterpolation/appendliteral(_:)",
    "html": "Parameters\nliteral\n\nA string literal containing the characters that appear next in the string literal.\n\nDiscussion\n\nDon’t call this method directly. Instead, initialize a variable or constant using a string literal with interpolated expressions.\n\nInterpolated expressions don’t pass through this method; instead, Swift selects an overload of appendInterpolation. For more information, see the top-level StringInterpolationProtocol documentation."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_=(_:_:)-1ii8",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_=(_:_:)-28qlv",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/losslessstringconvertible/init(_:)-3cx61",
    "html": "Parameters\ndescription\n\nThe ASCII representation of a number.\n\nDiscussion\n\nThe string passed as description may begin with a plus or minus sign character (+ or -), followed by one or more numeric digits (0-9).\n\nlet x = Int(\"123\")\n// x == 123\n\n\nIf description is in an invalid format, or if the value it denotes in base 10 is not representable, the result is nil. For example, the following conversions result in nil:\n\nInt(\" 100\")                       // Includes whitespace\nInt(\"21-50\")                      // Invalid format\nInt(\"ff6600\")                     // Characters out of bounds\nInt(\"10000000000000000000000000\") // Out of range\n"
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "&<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/&__=(_:_:)-13miv",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &<<= operator performs a masking shift, where the value used as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &<<= 2\n// x == 120                       // 0b01111000\n\n\nHowever, if you pass 19 as rhs, the method first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &<<= 19\n// y == 240                       // 0b11110000\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "&>>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/&__(_:_:)-5zh5j",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking right shift operator (&>>) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking right shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &>> 2\n// y == 7                         // 0b00000111\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &>> 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "&<<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/&__(_:_:)-3euzz",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nUse the masking left shift operator (&<<) when you need to perform a shift and are sure that the shift amount is in the range 0..<lhs.bitWidth. Before shifting, the masking left shift operator masks the shift to this range. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x &<< 2\n// y == 120                       // 0b01111000\n\n\nHowever, if you use 8 as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.\n\nlet z = x &<< 8\n// z == 30                        // 0b00011110\n\n\nIf the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "&>>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/&__=(_:_:)-704vj",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right. If rhs is outside the range 0..<lhs.bitWidth, it is masked to produce a value within that range.\n\nDiscussion\n\nThe &>>= operator performs a masking shift, where the value passed as rhs is masked to produce a value in the range 0..<lhs.bitWidth. The shift is performed using this masked value.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the shift amount requires no masking.\n\nvar x: UInt8 = 30                 // 0b00011110\nx &>>= 2\n// x == 7                         // 0b00000111\n\n\nHowever, if you use 19 as rhs, the operation first bitmasks rhs to 3, and then uses that masked value as the number of bits to shift lhs.\n\nvar y: UInt8 = 30                 // 0b00011110\ny &>>= 19\n// y == 3                         // 0b00000011\n"
  },
  {
    "title": ">>=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/__=(_:_:)-9p0ct",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >>= operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx >>= 2\n// x == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny >>= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na >>= -3\n// a == 240                       // 0b11110000\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb <<= 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nvar q: Int8 = -30                 // 0b11100010\nq >>= 2\n// q == -8                        // 0b11111000\n\n\nvar r: Int8 = -30                 // 0b11100010\nr >>= 11\n// r == -1                        // 0b11111111\n"
  },
  {
    "title": "<<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/__=(_:_:)-66xgb",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the left.\n\nDiscussion\n\nThe << operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a right shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift, resulting in zero.\n\nUsing any other value for rhs performs a left shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted left by two bits.\n\nvar x: UInt8 = 30                 // 0b00011110\nx <<= 2\n// x == 120                       // 0b01111000\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nvar y: UInt8 = 30                 // 0b00011110\ny <<= 11\n// y == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a right shift with abs(rhs).\n\nvar a: UInt8 = 30                 // 0b00011110\na <<= -3\n// a == 3                         // 0b00000011\n\n\nvar b: UInt8 = 30                 // 0b00011110\nb >>= 3\n// b == 3                         // 0b00000011\n"
  },
  {
    "title": ">>(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/__(_:_:)-97tkh",
    "html": "Parameters\nlhs\n\nThe value to shift.\n\nrhs\n\nThe number of bits to shift lhs to the right.\n\nDiscussion\n\nThe >> operator performs a smart shift, which defines a result for a shift of any value.\n\nUsing a negative value for rhs performs a left shift using abs(rhs).\n\nUsing a value for rhs that is greater than or equal to the bit width of lhs is an overshift. An overshift results in -1 for a negative value of lhs or 0 for a nonnegative value.\n\nUsing any other value for rhs performs a right shift on lhs by that amount.\n\nThe following example defines x as an instance of UInt8, an 8-bit, unsigned integer type. If you use 2 as the right-hand-side value in an operation on x, the value is shifted right by two bits.\n\nlet x: UInt8 = 30                 // 0b00011110\nlet y = x >> 2\n// y == 7                         // 0b00000111\n\n\nIf you use 11 as rhs, x is overshifted such that all of its bits are set to zero.\n\nlet z = x >> 11\n// z == 0                         // 0b00000000\n\n\nUsing a negative value as rhs is the same as performing a left shift using abs(rhs).\n\nlet a = x >> -3\n// a == 240                       // 0b11110000\nlet b = x << 3\n// b == 240                       // 0b11110000\n\n\nRight shift operations on negative values “fill in” the high bits with ones instead of zeros.\n\nlet q: Int8 = -30                 // 0b11100010\nlet r = q >> 2\n// r == -8                        // 0b11111000\n\n\nlet s = q >> 11\n// s == -1                        // 0b11111111\n"
  },
  {
    "title": "sort() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/sort()",
    "html": "Discussion\n\nYou can sort any mutable collection of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nvar students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nstudents.sort()\nprint(students)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your collection in descending order, pass the greater-than operator (>) to the sort(by:) method.\n\nstudents.sort(by: >)\nprint(students)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the collection."
  },
  {
    "title": "shuffle(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/shuffle(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the collection.\n\nDiscussion\n\nYou use this method to randomize the elements of a collection when you are using a custom random number generator. For example, you can use the shuffle(using:) method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle(using: &myGenerator)\n// names == [\"Sofía\", \"Alejandro\", \"Camila\", \"Luis\", \"Diego\", \"Luciana\"]\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to shuffle a collection may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "reverse() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/reverse()",
    "html": "Discussion\n\nThe following example reverses the elements of an array of characters:\n\nvar characters: [Character] = [\"C\", \"a\", \"f\", \"é\"]\ncharacters.reverse()\nprint(characters)\n// Prints \"[\"é\", \"f\", \"a\", \"C\"]\"\n\n\nComplexity\n\nO(n), where n is the number of elements in the collection."
  },
  {
    "title": "shuffle() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/shuffle()",
    "html": "Discussion\n\nUse the shuffle() method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle()\n// names == [\"Luis\", \"Camila\", \"Luciana\", \"Sofía\", \"Alejandro\", \"Diego\"]\n\n\nThis method is equivalent to calling shuffle(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int/_(_:_:)-3r70c",
    "html": "Parameters\nlhs\n\nAn integer to compare.\n\nrhs\n\nAnother integer to compare.\n\nDiscussion\n\nYou can compare instances of any BinaryInteger types using the less-than operator (<), even if the two instances are of different types."
  },
  {
    "title": "firstRange(of:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/firstrange(of:in:)",
    "html": "Discussion\n\nA default implementation is given in terms of self.regions."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/flatmap(_:)-i3m3",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/joined(separator:)-1ckn9",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "KeyValuePairs.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/split(separator:maxsplits:omittingemptysubsequences:)-4y9zq",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "regions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/regions-swift.property",
    "html": "Discussion\n\nThe sum of the lengths of the associated regions must equal self.count (such that iterating regions and iterating self produces the same sequence of indices in the same number of index advancements)."
  },
  {
    "title": "KeyValuePairs.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "KeyValuePairs.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/removefirst(_:)-6lekf",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "shuffle(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/shuffle(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the collection.\n\nDiscussion\n\nYou use this method to randomize the elements of a collection when you are using a custom random number generator. For example, you can use the shuffle(using:) method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle(using: &myGenerator)\n// names == [\"Sofía\", \"Alejandro\", \"Camila\", \"Luis\", \"Diego\", \"Luciana\"]\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to shuffle a collection may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/comparable/_(_:_:)-uq3f",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "withUnsafeBytes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/withunsafebytes(_:)",
    "html": "Discussion\n\nNote\n\nCalling withUnsafeBytes multiple times does not guarantee that the same buffer pointer will be passed in every time.\n\nWarning\n\nThe buffer argument to the body should not be stored or used outside of the lifetime of the call to the closure."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be 1.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/endindex",
    "html": "Discussion\n\nIn a CollectionOfOne instance, endIndex is always 1."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/startindex",
    "html": "Discussion\n\nIn a CollectionOfOne instance, startIndex is always 0."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be 0.\n\nReturn Value\n\nThe index value immediately after i."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/subscript(_:)-876qi",
    "html": "Parameters\nposition\n\nThe position of the element to access. The only valid position in a CollectionOfOne instance is 0."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/subscript(_:)-16mfr",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/split(separator:maxsplits:omittingemptysubsequences:)-4mogv",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "EmptyCollection.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/removefirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/map(_:)-9dpwz",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "init(repeating:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/init(repeating:count:)-7exog",
    "html": "Parameters\nrepeatedValue\n\nThe element to repeat.\n\ncount\n\nThe number of times to repeat the value passed in the repeating parameter. count must be zero or greater.\n\nDiscussion\n\nHere’s an example of creating an array initialized with five strings containing the letter Z.\n\nlet fiveZs = Array(repeating: \"Z\", count: 5)\nprint(fiveZs)\n// Prints \"[\"Z\", \"Z\", \"Z\", \"Z\", \"Z\"]\"\n"
  },
  {
    "title": "append(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/append(_:)-3fp44",
    "html": "Parameters\nnewElement\n\nThe element to append to the collection.\n\nDiscussion\n\nIf the collection does not have sufficient capacity for another element, additional storage is allocated before appending newElement. The following example adds a new number to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(100)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 100]\"\n\n\nComplexity\n\nO(1) on average, over many calls to append(_:) on the same collection."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/comparable/_(_:_:)-91z6r",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/removesubrange(_:)-4820q",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/removesubrange(_:)-3s5pl",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/removefirst(_:)-6mezs",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst(3)\nprint(bugs)\n// Prints \"[\"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lastRange(of:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/lastrange(of:in:)",
    "html": "Discussion\n\nA default implementation is given in terms of self.regions."
  },
  {
    "title": "sort() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/sort()",
    "html": "Discussion\n\nYou can sort any mutable collection of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nvar students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nstudents.sort()\nprint(students)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your collection in descending order, pass the greater-than operator (>) to the sort(by:) method.\n\nstudents.sort(by: >)\nprint(students)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/subscript(_:)-1atow",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/partition(by:)-37csa",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "swapAt(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/swapat(_:_:)",
    "html": "Parameters\ni\n\nThe index of the first value to swap.\n\nj\n\nThe index of the second value to swap.\n\nDiscussion\n\nBoth parameters must be valid indices of the collection that are not equal to endIndex. Calling swapAt(_:_:) with the same index as both i and j has no effect.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "sort(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/sort(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false. If areInIncreasingOrder throws an error during the sort, the elements may be in a different order, but none will be lost.\n\nDiscussion\n\nWhen you want to sort a collection of elements that don’t conform to the Comparable protocol, pass a closure to this method that returns true when the first element should be ordered before the second.\n\nIn the following example, the closure provides an ordering for an array of a custom enumeration that describes an HTTP response. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nvar responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nresponses.sort {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(responses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nAlternatively, use this method to sort a collection of elements that do conform to Comparable when you want the sort to be descending instead of ascending. Pass the greater-than operator (>) operator as the predicate.\n\nvar students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nstudents.sort(by: >)\nprint(students)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nareInIncreasingOrder must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the collection."
  },
  {
    "title": "withContiguousMutableStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/withcontiguousmutablestorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an in-out UnsafeMutableBufferPointer to the collection’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the collection doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer provides access to the contiguous mutable storage of the entire collection. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in the form of contiguous mutable storage, this method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nAlways perform any necessary cleanup in the closure, because the method makes no guarantees about the state of the collection if the closure throws an error. Your changes to the collection may be absent from the collection after throwing the error, because the closure could receive a temporary copy rather than direct access to the collection’s storage.\n\nWarning\n\nYour body closure must not replace buffer. This leads to a crash in all implementations of this method within the standard library.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/partition(by:)-4cd8k",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reverse() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/reverse()",
    "html": "Discussion\n\nThe following example reverses the elements of an array of characters:\n\nvar characters: [Character] = [\"C\", \"a\", \"f\", \"é\"]\ncharacters.reverse()\nprint(characters)\n// Prints \"[\"é\", \"f\", \"a\", \"C\"]\"\n\n\nComplexity\n\nO(n), where n is the number of elements in the collection."
  },
  {
    "title": "shuffle() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/shuffle()",
    "html": "Discussion\n\nUse the shuffle() method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle()\n// names == [\"Luis\", \"Camila\", \"Luciana\", \"Sofía\", \"Alejandro\", \"Diego\"]\n\n\nThis method is equivalent to calling shuffle(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/subscript(_:)-5fxf8",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/subscript(_:)-1wkfh",
    "html": "Overview\n\nMust never be called, since this collection is always empty."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/subscript(_:)-2eo9o",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/index(before:)",
    "html": "Discussion\n\nEmptyCollection does not have any element indices, so it is not possible to advance indices."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/index(after:)",
    "html": "Discussion\n\nEmptyCollection does not have any element indices, so it is not possible to advance indices."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/removefirst()",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/joined(separator:)-7ubfv",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "advanced(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/advanced(by:)",
    "html": "Parameters\nn\n\nThe distance to advance this value.\n\nReturn Value\n\nA value that is offset from this value by n.\n\nDiscussion\n\nUse the advanced(by:) method in generic code to offset a value by a specified distance. If you’re working directly with numeric values, use the addition operator (+) instead of this method.\n\nfunc addOne<T: Strideable>(to x: T) -> T\n    where T.Stride: ExpressibleByIntegerLiteral\n{\n    return x.advanced(by: 1)\n}\n\n\nlet x = addOne(to: 5)\n// x == 6\nlet y = addOne(to: 3.5)\n// y = 4.5\n\n\nIf this type’s Stride type conforms to BinaryInteger, then for a value x, a distance n, and a value y = x.advanced(by: n), x.distance(to: y) == n. Using this method with types that have a noninteger Stride may result in an approximation. If the result of advancing by n is not representable as a value of this type, then a runtime error may occur.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "CollectionOfOne.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/defaultindices/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "append(contentsOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/append(contentsof:)-15j8g",
    "html": "Parameters\nnewElements\n\nThe elements to append to the collection.\n\nDiscussion\n\nThe collection being appended to allocates any additional necessary storage to hold the new elements.\n\nThe following example appends the elements of a Range<Int> instance to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(contentsOf: 10...15)\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]\"\n\n\nComplexity\n\nO(m), where m is the length of newElements."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/rangereplaceablecollection/init(_:)-2c3y1",
    "html": "Parameters\nelements\n\nThe sequence of elements for the new collection."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticbigint/init(integerliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticbigint/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/staticbigint/debugdescription",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(reflecting:) initializer. This initializer works with any type, and uses the custom debugDescription property for types that conform to CustomDebugStringConvertible:\n\nstruct Point: CustomDebugStringConvertible {\n    let x: Int, y: Int\n\n\n    var debugDescription: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(reflecting: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s debugDescription property."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/comparable/_(_:_:)-2qz41",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/customplaygroundquicklook",
    "html": "Discussion\n\nIf this type has value semantics, the PlaygroundQuickLook instance should be unaffected by subsequent mutations."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sort() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/sort()",
    "html": "Discussion\n\nYou can sort any mutable collection of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nvar students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nstudents.sort()\nprint(students)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your collection in descending order, pass the greater-than operator (>) to the sort(by:) method.\n\nstudents.sort(by: >)\nprint(students)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the collection."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/joined(separator:)-7kra3",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/map(_:)-7s13l",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "popFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/popfirst()",
    "html": "Return Value\n\nThe first element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/split(separator:maxsplits:omittingemptysubsequences:)-628bu",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/flatmap(_:)-36s4w",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/withcontiguousstorageifavailable(_:)-1ynsq",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/withcontiguousstorageifavailable(_:)-38tvz",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/comparable/_(_:_:)-8ogs5",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/flatmap(_:)-41jts",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousMutableStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/withcontiguousmutablestorageifavailable(_:)-73994",
    "html": "Parameters\nbody\n\nA closure that receives an in-out UnsafeMutableBufferPointer to the collection’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the collection doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer provides access to the contiguous mutable storage of the entire collection. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in the form of contiguous mutable storage, this method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nAlways perform any necessary cleanup in the closure, because the method makes no guarantees about the state of the collection if the closure throws an error. Your changes to the collection may be absent from the collection after throwing the error, because the closure could receive a temporary copy rather than direct access to the collection’s storage.\n\nWarning\n\nYour body closure must not replace buffer. This leads to a crash in all implementations of this method within the standard library.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/flatmap(_:)-i3n9",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/subscript(_:)-3i1v",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/map(_:)-9dpvx",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "withUnsafeBytes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/withunsafebytes(_:)",
    "html": "Discussion\n\nNote\n\nCalling withUnsafeBytes multiple times does not guarantee that the same buffer pointer will be passed in every time.\n\nWarning\n\nThe buffer argument to the body should not be stored or used outside of the lifetime of the call to the closure."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/joined(separator:)-7gggv",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/joined(separator:)-7ryk5",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/map(_:)-pk75",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/startindex",
    "html": "Discussion\n\nIf the KeyValuePairs instance is empty, startIndex is equal to endIndex."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/==(_:_:)-4wfsx",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/subscript(_:)-5iy5s",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/endindex",
    "html": "Discussion\n\nIf the KeyValuePairs instance is empty, endIndex is equal to startIndex."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/removelast()",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty. To remove the last element of a collection that might be empty, use the popLast() method instead.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/removelast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to remove."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/partition(by:)-90pnv",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/partition(by:)-33su1",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reverse() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/reverse()",
    "html": "Discussion\n\nThe following example reverses the elements of an array of characters:\n\nvar characters: [Character] = [\"C\", \"a\", \"f\", \"é\"]\ncharacters.reverse()\nprint(characters)\n// Prints \"[\"é\", \"f\", \"a\", \"C\"]\"\n\n\nComplexity\n\nO(n), where n is the number of elements in the collection."
  },
  {
    "title": "shuffle() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/shuffle()",
    "html": "Discussion\n\nUse the shuffle() method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle()\n// names == [\"Luis\", \"Camila\", \"Luciana\", \"Sofía\", \"Alejandro\", \"Diego\"]\n\n\nThis method is equivalent to calling shuffle(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "shuffle(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/shuffle(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the collection.\n\nDiscussion\n\nYou use this method to randomize the elements of a collection when you are using a custom random number generator. For example, you can use the shuffle(using:) method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle(using: &myGenerator)\n// names == [\"Sofía\", \"Alejandro\", \"Camila\", \"Luis\", \"Diego\", \"Luciana\"]\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to shuffle a collection may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/map(_:)-2s57z",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/_(_:_:)-4cbvd",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than rhs; otherwise, false."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "init(bitPattern:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/init(bitpattern:)-84bzs",
    "html": "Parameters\nbitPattern\n\nA bit pattern to use for the address of the new pointer. If bitPattern is zero, the result is nil.\n\nDiscussion\n\nThe address passed as bitPattern must have the correct alignment for the pointer’s Pointee type. That is, bitPattern % MemoryLayout<Pointee>.alignment must be 0."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/withcontiguousstorageifavailable(_:)-1ynsv",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousMutableStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/withcontiguousmutablestorageifavailable(_:)-3okf",
    "html": "Parameters\nbody\n\nA closure that receives an in-out UnsafeMutableBufferPointer to the collection’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the collection doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer provides access to the contiguous mutable storage of the entire collection. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in the form of contiguous mutable storage, this method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nAlways perform any necessary cleanup in the closure, because the method makes no guarantees about the state of the collection if the closure throws an error. Your changes to the collection may be absent from the collection after throwing the error, because the closure could receive a temporary copy rather than direct access to the collection’s storage.\n\nWarning\n\nYour body closure must not replace buffer. This leads to a crash in all implementations of this method within the standard library.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "withContiguousMutableStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/withcontiguousmutablestorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an in-out UnsafeMutableBufferPointer to the collection’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the collection doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer provides access to the contiguous mutable storage of the entire collection. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in the form of contiguous mutable storage, this method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nAlways perform any necessary cleanup in the closure, because the method makes no guarantees about the state of the collection if the closure throws an error. Your changes to the collection may be absent from the collection after throwing the error, because the closure could receive a temporary copy rather than direct access to the collection’s storage.\n\nWarning\n\nYour body closure must not replace buffer. This leads to a crash in all implementations of this method within the standard library.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/subscript(_:)-13u1d",
    "html": "Parameters\nbounds\n\nA range of the buffer’s indices. The bounds of the range must be valid indices of the buffer.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original buffer uses. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice from a buffer of strings, finding the index of one of the strings in the slice, and then using that index in the original buffer.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nstreets.withUnsafeMutableBufferPointer { buffer in\n    let streetSlice = buffer[2..<buffer.endIndex]\n    print(Array(streetSlice))\n    // Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n    let index = streetSlice.firstIndex(of: \"Evarts\")    // 4\n    buffer[index!] = \"Eustace\"\n}\nprint(streets.last!)\n// Prints \"Eustace\"\n\n\nNote\n\nBounds checks for bounds are performed only in debug mode."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/subscript(_:)-3g47",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/subscript(_:)-3g42",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "swapAt(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/swapat(_:_:)",
    "html": "Parameters\ni\n\nThe index of the first byte to swap.\n\nj\n\nThe index of the second byte to swap.\n\nDiscussion\n\nBoth parameters must be valid indices of the buffer, and not equal to endIndex. Passing the same index as both i and j has no effect."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/subscript(_:)-3i1y",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/'...(_:)-4mm4t",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/subscript(_:)-u791",
    "html": "Parameters\ni\n\nThe offset of the byte to access. i must be in the range 0..<count."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/subscript(_:)-znv7",
    "html": "Parameters\nbounds\n\nThe range of byte offsets to access. The upper and lower bounds of the range must be in the range 0...count."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/'...(_:)-6ct5d",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/_(_:_:)-fe67",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/_(_:_:)-24u5s",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/_=(_:_:)-1ihb",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/_=(_:_:)-8lyij",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/keyvaluepairs/subscript(_:)",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nThe key-value pair at position position."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/joined(separator:)-rq8f",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/poplast()",
    "html": "Return Value\n\nThe last element of the collection if the collection has one or more elements; otherwise, nil.\n\nDiscussion\n\nYou can use popLast() to remove the last element of a collection that might be empty. The removeLast() method must be used only on a nonempty collection.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/==(_:_:)-8ubng",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference the same memory address; otherwise, false."
  },
  {
    "title": "!=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/!=(_:_:)-48qvi",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference different memory addresses; otherwise, false."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/endindex",
    "html": "Discussion\n\nThe endIndex property of an UnsafeMutableBufferPointer instance is always identical to count."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/==(_:_:)-9kt13",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs and rhs reference the same memory address; otherwise, false."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/_(_:_:)-8n82b",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address later than rhs; otherwise, false."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/_=(_:_:)-45lkv",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than or the same as rhs; otherwise, false."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/_(_:_:)-1r7gf",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address earlier than rhs; otherwise, false."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/init(_:)-98q6c",
    "html": "Parameters\nother\n\nThe typed pointer to convert."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/withcontiguousstorageifavailable(_:)-7zpis",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/init(_:)-qu06",
    "html": "Parameters\nfrom\n\nThe opaque pointer to convert to a typed pointer. If from is nil, the result of this initializer is nil."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/comparable/_=(_:_:)-2nvou",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/_=(_:_:)-jido",
    "html": "Parameters\nlhs\n\nA pointer.\n\nrhs\n\nAnother pointer.\n\nReturn Value\n\ntrue if lhs references a memory address later than or the same as rhs; otherwise, false."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/init(_:)-1o7ny",
    "html": "Parameters\nfrom\n\nThe opaque pointer to convert to a typed pointer."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/==(_:_:)-4wft3",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/split(separator:maxsplits:omittingemptysubsequences:)-9bdx3",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "swapAt(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/swapat(_:_:)",
    "html": "Parameters\ni\n\nThe index of the first value to swap.\n\nj\n\nThe index of the second value to swap.\n\nDiscussion\n\nBoth parameters must be valid indices of the buffer, and not equal to endIndex. Passing the same index as both i and j has no effect."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/subscript(_:)-9t9gq",
    "html": "Parameters\ni\n\nThe position of the element to access. i must be in the range 0..<count.\n\nOverview\n\nThe following example uses the buffer pointer’s subscript to access and modify the elements of a mutable buffer pointing to the contiguous contents of an array:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.withUnsafeMutableBufferPointer { buffer in\n    for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {\n        let x = buffer[i]\n        buffer[i + 1] = buffer[i]\n        buffer[i] = x\n    }\n}\nprint(numbers)\n// Prints \"[2, 1, 4, 3, 5]\"\n\n\nUninitialized memory cannot be initialized to a nontrivial type\nusing this subscript. Instead, use an initializing method, such as\n`initializeElement(at:to:)`\n\n\nNote\n\nBounds checks for i are performed only in debug mode."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "shuffle(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/shuffle(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the collection.\n\nDiscussion\n\nYou use this method to randomize the elements of a collection when you are using a custom random number generator. For example, you can use the shuffle(using:) method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle(using: &myGenerator)\n// names == [\"Sofía\", \"Alejandro\", \"Camila\", \"Luis\", \"Diego\", \"Luciana\"]\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to shuffle a collection may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/partition(by:)-90pny",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "shuffle() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/shuffle()",
    "html": "Discussion\n\nUse the shuffle() method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle()\n// names == [\"Luis\", \"Camila\", \"Luciana\", \"Sofía\", \"Alejandro\", \"Diego\"]\n\n\nThis method is equivalent to calling shuffle(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/partition(by:)-33su4",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "sort(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/sort(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false. If areInIncreasingOrder throws an error during the sort, the elements may be in a different order, but none will be lost.\n\nDiscussion\n\nWhen you want to sort a collection of elements that don’t conform to the Comparable protocol, pass a closure to this method that returns true when the first element should be ordered before the second.\n\nIn the following example, the closure provides an ordering for an array of a custom enumeration that describes an HTTP response. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nvar responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nresponses.sort {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(responses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nAlternatively, use this method to sort a collection of elements that do conform to Comparable when you want the sort to be descending instead of ascending. Pass the greater-than operator (>) operator as the predicate.\n\nvar students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nstudents.sort(by: >)\nprint(students)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nareInIncreasingOrder must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the collection."
  },
  {
    "title": "reverse() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/reverse()",
    "html": "Discussion\n\nThe following example reverses the elements of an array of characters:\n\nvar characters: [Character] = [\"C\", \"a\", \"f\", \"é\"]\ncharacters.reverse()\nprint(characters)\n// Prints \"[\"é\", \"f\", \"a\", \"C\"]\"\n\n\nComplexity\n\nO(n), where n is the number of elements in the collection."
  },
  {
    "title": "sort() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/sort()",
    "html": "Discussion\n\nYou can sort any mutable collection of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nvar students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nstudents.sort()\nprint(students)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your collection in descending order, pass the greater-than operator (>) to the sort(by:) method.\n\nstudents.sort(by: >)\nprint(students)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "init(extendedGraphemeClusterLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/expressiblebyextendedgraphemeclusterliteral/init(extendedgraphemeclusterliteral:)-6bx13",
    "html": "Parameters\nvalue\n\nThe value of the new instance."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/map(_:)-9dpvs",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/startindex",
    "html": "Discussion\n\nThe startIndex property of an UnsafeMutableBufferPointer instance is always zero."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be nonuniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can result in an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "UnsafeRawBufferPointer.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/init(_:)-7r77o",
    "html": "Parameters\nother\n\nThe typed pointer to convert. If other is nil, the result is nil."
  },
  {
    "title": "distance(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/distance(to:)",
    "html": "Parameters\nend\n\nThe pointer to calculate the distance to.\n\nReturn Value\n\nThe distance from this pointer to end, in strides of the pointer’s Pointee type. To access the stride, use MemoryLayout<Pointee>.stride.\n\nDiscussion\n\nWith pointers p and q, the result of p.distance(to: q) is equivalent to q - p.\n\nTyped pointers are required to be properly aligned for their Pointee type. Proper alignment ensures that the result of distance(to:) accurately measures the distance between the two pointers, counted in strides of Pointee. To find the distance in bytes between two pointers, convert them to UnsafeRawPointer instances before calling distance(to:)."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/comparable/_=(_:_:)-8wgjd",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/comparable/_=(_:_:)-1eln1",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/comparable/_=(_:_:)-7yw8z",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "predecessor() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/predecessor()",
    "html": "Return Value\n\nA pointer shifted backward from this pointer by MemoryLayout<Pointee>.stride bytes.\n\nDiscussion\n\nThe resulting pointer must be within the bounds of the same allocation as this pointer."
  },
  {
    "title": "successor() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/successor()",
    "html": "Return Value\n\nA pointer advanced from this pointer by MemoryLayout<Pointee>.stride bytes.\n\nDiscussion\n\nThe resulting pointer must be within the bounds of the same allocation as this pointer."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "init(bitPattern:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/init(bitpattern:)-3r9s8",
    "html": "Parameters\nbitPattern\n\nA bit pattern to use for the address of the new pointer. If bitPattern is zero, the result is nil.\n\nDiscussion\n\nThe address passed as bitPattern must have the correct alignment for the pointer’s Pointee type. That is, bitPattern % MemoryLayout<Pointee>.alignment must be 0."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "withUnsafeBytes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/withunsafebytes(_:)",
    "html": "Discussion\n\nNote\n\nCalling withUnsafeBytes multiple times does not guarantee that the same buffer pointer will be passed in every time.\n\nWarning\n\nThe buffer argument to the body should not be stored or used outside of the lifetime of the call to the closure."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/map(_:)-87c3y",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/split(separator:maxsplits:omittingemptysubsequences:)-3dgmc",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/subscript(_:)-4h7r6",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "UnsafeMutableBufferPointer.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/flatmap(_:)-i3n4",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/joined(separator:)-7ubf4",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/joined(separator:)-1ckou",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "makeIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/makeiterator()",
    "html": "Return Value\n\nAn iterator over the elements of this buffer."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/endindex",
    "html": "Discussion\n\nThe endIndex property of an UnsafeMutableRawBufferPointer instance is always identical to count."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/count",
    "html": "Discussion\n\nIf the baseAddress of this buffer is nil, the count is zero. However, a buffer can have a count of zero even with a non-nil base address."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be nonuniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can result in an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/map(_:)-87c3v",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/subscript(_:)-2nyb9",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/subscript(_:)-4h7rb",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "withUnsafeBytes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/withunsafebytes(_:)",
    "html": "Discussion\n\nNote\n\nCalling withUnsafeBytes multiple times does not guarantee that the same buffer pointer will be passed in every time.\n\nWarning\n\nThe buffer argument to the body should not be stored or used outside of the lifetime of the call to the closure."
  },
  {
    "title": "UnsafeMutableRawBufferPointer.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawpointer/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/subscript(_:)-2nyb4",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/joined(separator:)-5do07",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/withcontiguousstorageifavailable(_:)-9dsx3",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/withcontiguousstorageifavailable(_:)-1ynrz",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "regions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/regions-swift.property",
    "html": "Discussion\n\nThe sum of the lengths of the associated regions must equal self.count (such that iterating regions and iterating self produces the same sequence of indices in the same number of index advancements)."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "firstRange(of:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/firstrange(of:in:)",
    "html": "Discussion\n\nA default implementation is given in terms of self.regions."
  },
  {
    "title": "lastRange(of:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/lastrange(of:in:)",
    "html": "Discussion\n\nA default implementation is given in terms of self.regions."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/_(_:_:)-24u5y",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/'...(_:)-6ct5j",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/_(_:_:)-fe61",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/_=(_:_:)-8lyil",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "customPlaygroundQuickLook | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/customplaygroundquicklook",
    "html": "Discussion\n\nIf this type has value semantics, the PlaygroundQuickLook instance should be unaffected by subsequent mutations."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/joined(separator:)-5do13",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablebufferpointer/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "UnsafeMutableRawBufferPointer.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafemutablerawbufferpointer/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/count",
    "html": "Discussion\n\nIf the baseAddress of this buffer is nil, the count is zero. However, a buffer can have a count of zero even with a non-nil base address."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be nonuniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can result in an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/map(_:)-87c4r",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/subscript(_:)-4dk2n",
    "html": "Parameters\ni\n\nThe offset of the byte to access. i must be in the range 0..<count."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/subscript(_:)-2nyad",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "regions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/regions-swift.property",
    "html": "Discussion\n\nThe sum of the lengths of the associated regions must equal self.count (such that iterating regions and iterating self produces the same sequence of indices in the same number of index advancements)."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/'...(_:)-4mm4r",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/_=(_:_:)-1ih5",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastRange(of:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/lastrange(of:in:)",
    "html": "Discussion\n\nA default implementation is given in terms of self.regions."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/map(_:)-5zklv",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "firstRange(of:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/firstrange(of:in:)",
    "html": "Discussion\n\nA default implementation is given in terms of self.regions."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/flatmap(_:)-i3md",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/map(_:)-9dpwt",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/endindex",
    "html": "Discussion\n\nThe endIndex property of an UnsafeRawBufferPointer instance is always identical to count."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "UnsafeRawBufferPointer.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/subscript(_:)-4h7s7",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/subscript(_:)-58r3z",
    "html": "Parameters\nbounds\n\nThe range of byte offsets to access. The upper and lower bounds of the range must be in the range 0...count."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafepointer/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "withContiguousMutableStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/mutablecollection/withcontiguousmutablestorageifavailable(_:)-83khw",
    "html": "Parameters\nbody\n\nA closure that receives an in-out UnsafeMutableBufferPointer to the collection’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the collection doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer provides access to the contiguous mutable storage of the entire collection. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in the form of contiguous mutable storage, this method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nAlways perform any necessary cleanup in the closure, because the method makes no guarantees about the state of the collection if the closure throws an error. Your changes to the collection may be absent from the collection after throwing the error, because the closure could receive a temporary copy rather than direct access to the collection’s storage.\n\nWarning\n\nYour body closure must not replace buffer. This leads to a crash in all implementations of this method within the standard library.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/withcontiguousstorageifavailable(_:)-57vwd",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "withUnsafeBytes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/withunsafebytes(_:)",
    "html": "Discussion\n\nNote\n\nCalling withUnsafeBytes multiple times does not guarantee that the same buffer pointer will be passed in every time.\n\nWarning\n\nThe buffer argument to the body should not be stored or used outside of the lifetime of the call to the closure."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/withcontiguousstorageifavailable(_:)-1ynru",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "ArraySlice.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "popFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/popfirst()",
    "html": "Return Value\n\nThe first element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsaferawbufferpointer/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/joined(separator:)-4dlb8",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/removefirst()-m0co",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/split(separator:maxsplits:omittingemptysubsequences:)-c3jd",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/subscript(_:)-4bx21",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "regions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/regions-swift.property",
    "html": "Discussion\n\nThe sum of the lengths of the associated regions must equal self.count (such that iterating regions and iterating self produces the same sequence of indices in the same number of index advancements)."
  },
  {
    "title": "lastRange(of:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/arrayslice/lastrange(of:in:)",
    "html": "Discussion\n\nA default implementation is given in terms of self.regions."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/bidirectionalcollection/index(_:offsetby:limitedby:)-8jlcd",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/bidirectionalcollection/index(after:)-4zlq6",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/bidirectionalcollection/formindex(before:)-5chhp",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  }
]
