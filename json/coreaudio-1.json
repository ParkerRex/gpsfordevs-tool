[
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375691-subscript",
    "html": "Relationships\nFrom Protocol\nBidirectionalCollection\nCollection\nMutableCollection\nRandomAccessCollection"
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375709-withcontiguousstorageifavailable",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively.\n\nNote\n\nThis documentation comment was inherited from Sequence."
  },
  {
    "title": "withContiguousMutableStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375708-withcontiguousmutablestorageifav",
    "html": "Parameters\nbody\n\nA closure that receives an in-out UnsafeMutableBufferPointer to the collection’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the collection doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer provides access to the contiguous mutable storage of the entire collection. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in the form of contiguous mutable storage, this method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nAlways perform any necessary cleanup in the closure, because the method makes no guarantees about the state of the collection if the closure throws an error. Your changes to the collection may be absent from the collection after throwing the error, because the closure could receive a temporary copy rather than direct access to the collection’s storage.\n\nWarning\n\nYour body closure must not replace buffer. This leads to a crash in all implementations of this method within the standard library.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively.\n\nNote\n\nThis documentation comment was inherited from MutableCollection."
  },
  {
    "title": "swapAt(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375706-swapat",
    "html": "Parameters\ni\n\nThe index of the first value to swap.\n\nj\n\nThe index of the second value to swap.\n\nDiscussion\n\nBoth parameters must be valid indices of the collection that are not equal to endIndex. Calling swapAt(_:_:) with the same index as both i and j has no effect.\n\nComplexity: O(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375659-randomelement",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375685-split",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375702-suffix",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375641-min",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375696-subscript",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity: O(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375694-subscript",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375700-suffix",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375690-starts",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of possiblePrefix.\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)"
  },
  {
    "title": "reverse() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375665-reverse",
    "html": "Discussion\n\nThe following example reverses the elements of an array of characters:\n\nvar characters: [Character] = [\"C\", \"a\", \"f\", \"é\"]\ncharacters.reverse()\nprint(characters)\n// Prints \"[\"é\", \"f\", \"a\", \"C\"]\"\n\n\nComplexity: O(n), where n is the number of elements in the collection."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375667-reversed",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375663-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375661-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375648-prefix",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375655-prefix",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375657-randomelement",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375651-prefix",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375646-prefix",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375639-max",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375643-partition",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375637-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375635-lexicographicallyprecedes",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of other.\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)"
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375620-index",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity: O(1)"
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375632-lastindex",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375617-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nDiscussion\n\nNote\n\nThis documentation comment was inherited from BidirectionalCollection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375615-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375616-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375614-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375580-allsatisfy",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375628-last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375689-startindex",
    "html": "Relationships\nFrom Protocol\nBidirectionalCollection\nCollection\nRandomAccessCollection"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375582-compactmap",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity: O(n), where n is the length of this sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375584-contains",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375593-droplast",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375588-difference",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity: Worst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375601-filter",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375597-enumerated",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375595-elementsequal",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of other.\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)"
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375674-shuffled",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "sort(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375678-sort",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false. If areInIncreasingOrder throws an error during the sort, the elements may be in a different order, but none will be lost.\n\nDiscussion\n\nWhen you want to sort a collection of elements that don’t conform to the Comparable protocol, pass a closure to this method that returns true when the first element should be ordered before the second.\n\nIn the following example, the closure provides an ordering for an array of a custom enumeration that describes an HTTP response. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nvar responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nresponses.sort {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(responses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nAlternatively, use this method to sort a collection of elements that do conform to Comparable when you want the sort to be descending instead of ascending. Pass the greater-than operator (>) operator as the predicate.\n\nvar students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nstudents.sort(by: >)\nprint(students)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nareInIncreasingOrder must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity: O(n log n), where n is the length of the collection."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375681-sorted",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity: O(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffle(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375672-shuffle",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the collection.\n\nDiscussion\n\nYou use this method to randomize the elements of a collection when you are using a custom random number generator. For example, you can use the shuffle(using:) method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle(using: &myGenerator)\n// names == [\"Sofía\", \"Alejandro\", \"Camila\", \"Luis\", \"Diego\", \"Luciana\"]\n\n\nComplexity: O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to shuffle a collection may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375676-shuffled",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "shuffle() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375670-shuffle",
    "html": "Discussion\n\nUse the shuffle() method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle()\n// names == [\"Luis\", \"Camila\", \"Luciana\", \"Sofía\", \"Alejandro\", \"Diego\"]\n\n\nThis method is equivalent to calling shuffle(using:), passing in the system’s default random generator.\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375630-last",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375612-foreach",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375609-flatmap",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity: O(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375607-firstindex",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375590-drop",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375707-underestimatedcount",
    "html": "Discussion\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375591-dropfirst",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375605-first",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375587-count",
    "html": "Relationships\nFrom Protocol\nCollection"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375596-endindex",
    "html": "Relationships\nFrom Protocol\nBidirectionalCollection\nCollection\nRandomAccessCollection"
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375603-first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions/3375626-isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity: O(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/3017330-map",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/3126522-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882823-max",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2994389-randomelement",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882822-prefix",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882838-lexicographicallyprecedes",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of other.\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)"
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2994397-shuffled",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity: O(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sort(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882820-sort",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false. If areInIncreasingOrder throws an error during the sort, the elements may be in a different order, but none will be lost.\n\nDiscussion\n\nWhen you want to sort a collection of elements that don’t conform to the Comparable protocol, pass a closure to this method that returns true when the first element should be ordered before the second.\n\nIn the following example, the closure provides an ordering for an array of a custom enumeration that describes an HTTP response. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nvar responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nresponses.sort {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(responses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nAlternatively, use this method to sort a collection of elements that do conform to Comparable when you want the sort to be descending instead of ascending. Pass the greater-than operator (>) operator as the predicate.\n\nvar students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nstudents.sort(by: >)\nprint(students)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nareInIncreasingOrder must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity: O(n log n), where n is the length of the collection."
  },
  {
    "title": "reverse() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2947104-reverse",
    "html": "Discussion\n\nThe following example reverses the elements of an array of characters:\n\nvar characters: [Character] = [\"C\", \"a\", \"f\", \"é\"]\ncharacters.reverse()\nprint(characters)\n// Prints \"[\"é\", \"f\", \"a\", \"C\"]\"\n\n\nComplexity: O(n), where n is the number of elements in the collection."
  },
  {
    "title": "shuffle(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2994393-shuffle",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the collection.\n\nDiscussion\n\nYou use this method to randomize the elements of a collection when you are using a custom random number generator. For example, you can use the shuffle(using:) method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle(using: &myGenerator)\n// names == [\"Sofía\", \"Alejandro\", \"Camila\", \"Luis\", \"Diego\", \"Luciana\"]\n\n\nComplexity: O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to shuffle a collection may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2994395-shuffled",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/3017332-partition",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882865-reduce",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882817-prefix",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882843-prefix",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882846-prefix",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2994387-randomelement",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2990409-last",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882831-min",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2947121-index",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity: O(1)"
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2947117-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/3017343-subscript",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity: O(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/3017341-subscript",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/1422107-subscript",
    "html": "Relationships\nFrom Protocol\nBidirectionalCollection\nCollection\nMutableCollection\nRandomAccessCollection"
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/3126525-withcontiguousstorageifavailable",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively.\n\nNote\n\nThis documentation comment was inherited from Sequence."
  },
  {
    "title": "withContiguousMutableStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/3126524-withcontiguousmutablestorageifav",
    "html": "Parameters\nbody\n\nA closure that receives an in-out UnsafeMutableBufferPointer to the collection’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the collection doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer provides access to the contiguous mutable storage of the entire collection. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in the form of contiguous mutable storage, this method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nAlways perform any necessary cleanup in the closure, because the method makes no guarantees about the state of the collection if the closure throws an error. Your changes to the collection may be absent from the collection after throwing the error, because the closure could receive a temporary copy rather than direct access to the collection’s storage.\n\nWarning\n\nYour body closure must not replace buffer. This leads to a crash in all implementations of this method within the standard library.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively.\n\nNote\n\nThis documentation comment was inherited from MutableCollection."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882825-suffix",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2983227-starts",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of possiblePrefix.\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)"
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882847-split",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "swapAt(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2892481-swapat",
    "html": "Parameters\ni\n\nThe index of the first value to swap.\n\nj\n\nThe index of the second value to swap.\n\nDiscussion\n\nBoth parameters must be valid indices of the collection that are not equal to endIndex. Calling swapAt(_:_:) with the same index as both i and j has no effect.\n\nComplexity: O(1)"
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882819-suffix",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882850-sorted",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity: O(n log n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882856-reversed",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "shuffle() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2994391-shuffle",
    "html": "Discussion\n\nUse the shuffle() method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle()\n// names == [\"Luis\", \"Camila\", \"Luciana\", \"Sofía\", \"Alejandro\", \"Diego\"]\n\n\nThis method is equivalent to calling shuffle(using:), passing in the system’s default random generator.\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882862-first",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2990408-firstindex",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882861-filter",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2947110-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2990410-lastindex",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2947119-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2947116-formindex",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nDiscussion\n\nNote\n\nThis documentation comment was inherited from BidirectionalCollection."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882818-foreach",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2949179-elementsequal",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nComplexity: O(m), where m is the lesser of the length of the sequence and the length of other.\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882863-dropfirst",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882815-droplast",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882816-drop",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity: O(n), where n is the length of the collection."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/3200243-difference",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity: Worst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2957833-compactmap",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity: O(n), where n is the length of this sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882821-contains",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/3017351-underestimatedcount",
    "html": "Discussion\n\nComplexity: O(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2994372-allsatisfy",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity: O(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/3126518-flatmap",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity: O(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882829-enumerated",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882814-first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2947118-count",
    "html": "Relationships\nFrom Protocol\nCollection"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/1422153-endindex",
    "html": "Relationships\nFrom Protocol\nBidirectionalCollection\nCollection\nRandomAccessCollection"
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/1422658-startindex",
    "html": "Relationships\nFrom Protocol\nBidirectionalCollection\nCollection\nRandomAccessCollection"
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882826-isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity: O(1)"
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer/2882837-last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity: O(1)"
  },
  {
    "title": "CATapMuteBehavior | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/catapmutebehavior",
    "html": "Topics\nEnumeration Cases\ncase muted\ncase mutedWhenTapped\ncase unmuted\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1646515-anonymous",
    "html": "Topics\nConstants\nvar kAudioClockDeviceClassID: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494512-anonymous",
    "html": "Topics\nConstants\nvar kAudioBooleanControlClassID: AudioClassID\nvar kAudioClipLightControlClassID: AudioClassID\nvar kAudioJackControlClassID: AudioClassID\nvar kAudioLFEMuteControlClassID: AudioClassID\nvar kAudioListenbackControlClassID: AudioClassID\nvar kAudioMuteControlClassID: AudioClassID\nvar kAudioPhantomPowerControlClassID: AudioClassID\nvar kAudioPhaseInvertControlClassID: AudioClassID\nvar kAudioSoloControlClassID: AudioClassID\nvar kAudioTalkbackControlClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494571-anonymous",
    "html": "Topics\nConstants\nvar kAudioControlPropertyElement: AudioObjectPropertySelector\nvar kAudioControlPropertyScope: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494430-anonymous",
    "html": "Topics\nConstants\nvar kAudioEndPointDevicePropertyComposition: AudioObjectPropertySelector\nvar kAudioEndPointDevicePropertyEndPointList: AudioObjectPropertySelector\nvar kAudioEndPointDevicePropertyIsPrivate: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494541-anonymous",
    "html": "Topics\nConstants\nvar kAudioStreamPropertyAvailablePhysicalFormats: AudioObjectPropertySelector\nvar kAudioStreamPropertyAvailableVirtualFormats: AudioObjectPropertySelector\nvar kAudioStreamPropertyDirection: AudioObjectPropertySelector\nvar kAudioStreamPropertyIsActive: AudioObjectPropertySelector\nvar kAudioStreamPropertyLatency: AudioObjectPropertySelector\nvar kAudioStreamPropertyPhysicalFormat: AudioObjectPropertySelector\nvar kAudioStreamPropertyStartingChannel: AudioObjectPropertySelector\nvar kAudioStreamPropertyTerminalType: AudioObjectPropertySelector\nvar kAudioStreamPropertyVirtualFormat: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494594-anonymous",
    "html": "Topics\nConstants\nvar kAudioSelectorControlPropertyAvailableItems: AudioObjectPropertySelector\nvar kAudioSelectorControlPropertyCurrentItem: AudioObjectPropertySelector\nvar kAudioSelectorControlPropertyItemKind: AudioObjectPropertySelector\nvar kAudioSelectorControlPropertyItemName: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494531-anonymous",
    "html": "Topics\nConstants\nvar kAudioDevicePermissionsError: OSStatus\nvar kAudioDeviceUnsupportedFormatError: OSStatus\nvar kAudioHardwareBadDeviceError: OSStatus\nvar kAudioHardwareBadObjectError: OSStatus\nvar kAudioHardwareBadPropertySizeError: OSStatus\nvar kAudioHardwareBadStreamError: OSStatus\nvar kAudioHardwareIllegalOperationError: OSStatus\nvar kAudioHardwareNoError: OSStatus\nvar kAudioHardwareNotRunningError: OSStatus\nvar kAudioHardwareUnknownPropertyError: OSStatus\nvar kAudioHardwareUnspecifiedError: OSStatus\nvar kAudioHardwareUnsupportedOperationError: OSStatus"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494587-anonymous",
    "html": "Topics\nConstants\nvar kAudioEndPointClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494522-anonymous",
    "html": "Topics\nConstants\nvar kAudioBoxPropertyAcquired: AudioObjectPropertySelector\nvar kAudioBoxPropertyAcquisitionFailed: AudioObjectPropertySelector\nvar kAudioBoxPropertyBoxUID: AudioObjectPropertySelector\nvar kAudioBoxPropertyDeviceList: AudioObjectPropertySelector\nvar kAudioBoxPropertyHasAudio: AudioObjectPropertySelector\nvar kAudioBoxPropertyHasMIDI: AudioObjectPropertySelector\nvar kAudioBoxPropertyHasVideo: AudioObjectPropertySelector\nvar kAudioBoxPropertyIsProtected: AudioObjectPropertySelector\nvar kAudioBoxPropertyTransportType: AudioObjectPropertySelector\nvar kAudioBoxPropertyClockDeviceList: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494437-anonymous",
    "html": "Topics\nConstants\nvar kAudioObjectPropertyElementWildcard: AudioObjectPropertyElement"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494526-anonymous",
    "html": "Topics\nConstants\nvar kAudioBoxClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494461-anonymous",
    "html": "Topics\nConstants\nvar kAudioObjectUnknown: AudioObjectID"
  },
  {
    "title": "ManagedAudioChannelLayout.ChannelDescriptions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout/channeldescriptions",
    "html": "Topics\nType Aliases\ntypealias ManagedAudioChannelLayout.ChannelDescriptions.Element\ntypealias ManagedAudioChannelLayout.ChannelDescriptions.Index\ntypealias ManagedAudioChannelLayout.ChannelDescriptions.Indices\ntypealias ManagedAudioChannelLayout.ChannelDescriptions.Iterator\ntypealias ManagedAudioChannelLayout.ChannelDescriptions.SubSequence\nInstance Properties\nvar count: Int\nvar endIndex: Int\nvar first: AudioChannelDescription?\nThe first element of the collection.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar last: AudioChannelDescription?\nThe last element of the collection.\nvar lazy: LazySequence<ManagedAudioChannelLayout.ChannelDescriptions>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.\nvar publisher: Publishers.Sequence<ManagedAudioChannelLayout.ChannelDescriptions, Never>\nvar startIndex: Int\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection.\nInstance Methods\nfunc allSatisfy((AudioChannelDescription) -> Bool) -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc compactMap<ElementOfResult>((AudioChannelDescription) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc compare<Comparator>(Comparator.Compared, Comparator.Compared) -> ComparisonResult\nfunc contains(where: (AudioChannelDescription) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc difference<C>(from: C, by: (C.Element, AudioChannelDescription) -> Bool) -> CollectionDifference<AudioChannelDescription>\nReturns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test.\nfunc drop(while: (AudioChannelDescription) -> Bool) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns a subsequence containing all but the specified number of final elements.\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (AudioChannelDescription, OtherSequence.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc enumerated() -> EnumeratedSequence<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc filter((AudioChannelDescription) -> Bool) -> [AudioChannelDescription]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc filter(Predicate<AudioChannelDescription>) -> [AudioChannelDescription]\nfunc first(where: (AudioChannelDescription) -> Bool) -> AudioChannelDescription?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(where: (AudioChannelDescription) -> Bool) -> Int?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((AudioChannelDescription) -> SegmentOfResult) -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((AudioChannelDescription) -> ElementOfResult?) -> [ElementOfResult]\nDeprecated\nfunc forEach((AudioChannelDescription) -> Void)\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc formIndex(inout Int, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Int, offsetBy: Int, limitedBy: Int) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Int)\nReplaces the given index with its successor.\nfunc formIndex(before: inout Int)\nReplaces the given index with its predecessor.\nfunc formatted<S>(S) -> S.FormatOutput\nfunc index(Int, offsetBy: Int, limitedBy: Int) -> Int?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc last(where: (AudioChannelDescription) -> Bool) -> AudioChannelDescription?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(where: (AudioChannelDescription) -> Bool) -> Int?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (AudioChannelDescription, AudioChannelDescription) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.\nfunc makeIterator() -> IndexingIterator<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns an iterator over the elements of the collection.\nfunc map<T>((AudioChannelDescription) -> T) -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc max(by: (AudioChannelDescription, AudioChannelDescription) -> Bool) -> AudioChannelDescription?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min(by: (AudioChannelDescription, AudioChannelDescription) -> Bool) -> AudioChannelDescription?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements.\nfunc partition(by: (AudioChannelDescription) -> Bool) -> Int\nReorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don’t match.\nfunc prefix(Int) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Int) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Int) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (AudioChannelDescription) -> Bool) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc randomElement() -> AudioChannelDescription?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> AudioChannelDescription?\nReturns a random element of the collection, using the given generator as a source for randomness.\nfunc reduce<Result>(Result, (Result, AudioChannelDescription) -> Result) -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, AudioChannelDescription) -> ()) -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reverse()\nReverses the elements of the collection in place.\nfunc reversed() -> ReversedCollection<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffle()\nShuffles the collection in place.\nfunc shuffle<T>(using: inout T)\nShuffles the collection in place, using the given generator as a source for randomness.\nfunc shuffled() -> [AudioChannelDescription]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [AudioChannelDescription]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness.\nfunc sort(by: (AudioChannelDescription, AudioChannelDescription) -> Bool)\nSorts the collection in place, using the given predicate as the comparison between elements.\nfunc sort<Comparator>(using: Comparator)\nfunc sort<S, Comparator>(using: S)\nfunc sorted(by: (AudioChannelDescription, AudioChannelDescription) -> Bool) -> [AudioChannelDescription]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [AudioChannelDescription]\nfunc sorted<S, Comparator>(using: S) -> [AudioChannelDescription]\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (AudioChannelDescription) -> Bool) -> [Slice<ManagedAudioChannelLayout.ChannelDescriptions>]\nReturns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (AudioChannelDescription, PossiblePrefix.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc suffix(Int) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Int) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nReturns a subsequence from the specified position to the end of the collection.\nfunc swapAt(Int, Int)\nExchanges the values at the specified indices of the collection.\nfunc trimmingPrefix(while: (AudioChannelDescription) -> Bool) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nfunc withContiguousMutableStorageIfAvailable<R>((inout UnsafeMutableBufferPointer<AudioChannelDescription>) -> R) -> R?\nExecutes a closure on the collection’s contiguous storage.\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<AudioChannelDescription>) -> R) -> R?\nExecutes a closure on the sequence’s contiguous storage.\nSubscripts\nsubscript(ManagedAudioChannelLayout.ChannelDescriptions.Index) -> ManagedAudioChannelLayout.ChannelDescriptions.Element\nsubscript<R>(R) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nsubscript((UnboundedRange_) -> ()) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nsubscript(Range<Int>) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nAccesses a contiguous subrange of the collection’s elements.\nsubscript<R>(R) -> Slice<ManagedAudioChannelLayout.ChannelDescriptions>\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nOperator Functions\nstatic func != (ManagedAudioChannelLayout.ChannelDescriptions, ManagedAudioChannelLayout.ChannelDescriptions) -> Bool\nstatic func == (ManagedAudioChannelLayout.ChannelDescriptions, ManagedAudioChannelLayout.ChannelDescriptions) -> Bool\nRelationships\nConforms To\nMutableCollection\nRandomAccessCollection"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494557-anonymous",
    "html": "Topics\nConstants\nvar kAudioStereoPanControlPropertyPanningChannels: AudioObjectPropertySelector\nvar kAudioStereoPanControlPropertyValue: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494454-anonymous",
    "html": "Topics\nConstants\nvar kAudioDevicePropertyAvailableNominalSampleRates: AudioObjectPropertySelector\nvar kAudioDevicePropertyClockDomain: AudioObjectPropertySelector\nvar kAudioDevicePropertyConfigurationApplication: AudioObjectPropertySelector\nvar kAudioDevicePropertyDeviceCanBeDefaultDevice: AudioObjectPropertySelector\nvar kAudioDevicePropertyDeviceCanBeDefaultSystemDevice: AudioObjectPropertySelector\nvar kAudioDevicePropertyDeviceIsAlive: AudioObjectPropertySelector\nvar kAudioDevicePropertyDeviceIsRunning: AudioObjectPropertySelector\nvar kAudioDevicePropertyDeviceUID: AudioObjectPropertySelector\nvar kAudioDevicePropertyIcon: AudioObjectPropertySelector\nvar kAudioDevicePropertyIsHidden: AudioObjectPropertySelector\nvar kAudioDevicePropertyLatency: AudioObjectPropertySelector\nvar kAudioDevicePropertyModelUID: AudioObjectPropertySelector\nvar kAudioDevicePropertyNominalSampleRate: AudioObjectPropertySelector\nvar kAudioDevicePropertyPreferredChannelLayout: AudioObjectPropertySelector\nvar kAudioDevicePropertyPreferredChannelsForStereo: AudioObjectPropertySelector\nvar kAudioDevicePropertyRelatedDevices: AudioObjectPropertySelector\nvar kAudioDevicePropertySafetyOffset: AudioObjectPropertySelector\nvar kAudioDevicePropertyStreams: AudioObjectPropertySelector\nvar kAudioDevicePropertyTransportType: AudioObjectPropertySelector\nvar kAudioObjectPropertyControlList: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494445-anonymous",
    "html": "Topics\nConstants\nvar kAudioStereoPanControlClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494472-anonymous",
    "html": "Topics\nConstants\nvar kAudioTransportManagerClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494528-anonymous",
    "html": "Topics\nConstants\nvar kAudioClockSourceItemKindInternal: UInt32"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494576-anonymous",
    "html": "Topics\nConstants\nvar kAudioObjectPropertyScopeWildcard: AudioObjectPropertyScope"
  },
  {
    "title": "AudioLevelControlTransferFunction | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/audiolevelcontroltransferfunction",
    "html": "Topics\nEnumeration Cases\ncase tranferFunction10Over1\ncase tranferFunction11Over1\ncase tranferFunction12Over1\ncase tranferFunction1Over2\ncase tranferFunction1Over3\ncase tranferFunction2Over1\ncase tranferFunction3Over1\ncase tranferFunction3Over2\ncase tranferFunction3Over4\ncase tranferFunction4Over1\ncase tranferFunction5Over1\ncase tranferFunction6Over1\ncase tranferFunction7Over1\ncase tranferFunction8Over1\ncase tranferFunction9Over1\ncase tranferFunctionLinear\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494543-anonymous",
    "html": "Topics\nConstants\nvar kAudioStreamTerminalTypeDigitalAudioInterface: UInt32\nvar kAudioStreamTerminalTypeDisplayPort: UInt32\nvar kAudioStreamTerminalTypeHDMI: UInt32\nvar kAudioStreamTerminalTypeHeadphones: UInt32\nvar kAudioStreamTerminalTypeHeadsetMicrophone: UInt32\nvar kAudioStreamTerminalTypeLFESpeaker: UInt32\nvar kAudioStreamTerminalTypeLine: UInt32\nvar kAudioStreamTerminalTypeMicrophone: UInt32\nvar kAudioStreamTerminalTypeReceiverMicrophone: UInt32\nvar kAudioStreamTerminalTypeReceiverSpeaker: UInt32\nvar kAudioStreamTerminalTypeSpeaker: UInt32\nvar kAudioStreamTerminalTypeTTY: UInt32\nvar kAudioStreamTerminalTypeUnknown: UInt32"
  },
  {
    "title": "AudioHardwarePowerHint | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/audiohardwarepowerhint",
    "html": "Topics\nEnumeration Cases\ncase favorSavingPower\ncase none\nRelationships\nConforms To\nSendable"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494449-anonymous",
    "html": "Topics\nConstants\nvar kAudioObjectPropertyBaseClass: AudioObjectPropertySelector\nvar kAudioObjectPropertyClass: AudioObjectPropertySelector\nvar kAudioObjectPropertyElementCategoryName: AudioObjectPropertySelector\nvar kAudioObjectPropertyElementName: AudioObjectPropertySelector\nvar kAudioObjectPropertyElementNumberName: AudioObjectPropertySelector\nvar kAudioObjectPropertyFirmwareVersion: AudioObjectPropertySelector\nvar kAudioObjectPropertyIdentify: AudioObjectPropertySelector\nvar kAudioObjectPropertyManufacturer: AudioObjectPropertySelector\nvar kAudioObjectPropertyModelName: AudioObjectPropertySelector\nvar kAudioObjectPropertyName: AudioObjectPropertySelector\nvar kAudioObjectPropertyOwnedObjects: AudioObjectPropertySelector\nvar kAudioObjectPropertyOwner: AudioObjectPropertySelector\nvar kAudioObjectPropertySerialNumber: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494483-anonymous",
    "html": "Topics\nConstants\nvar kAudioDeviceClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494536-anonymous",
    "html": "Topics\nConstants\nvar kAudioLevelControlPropertyConvertDecibelsToScalar: AudioObjectPropertySelector\nvar kAudioLevelControlPropertyConvertScalarToDecibels: AudioObjectPropertySelector\nvar kAudioLevelControlPropertyDecibelRange: AudioObjectPropertySelector\nvar kAudioLevelControlPropertyDecibelValue: AudioObjectPropertySelector\nvar kAudioLevelControlPropertyScalarValue: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494470-anonymous",
    "html": "Topics\nConstants\nvar kAudioSelectorControlItemKindSpacer: UInt32"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494464-anonymous",
    "html": "Topics\nConstants\nvar kAudioObjectPropertyElementMaster: AudioObjectPropertyScope\nDeprecated\nvar kAudioObjectPropertyScopeGlobal: AudioObjectPropertyScope\nvar kAudioObjectPropertyScopeInput: AudioObjectPropertyScope\nvar kAudioObjectPropertyScopeOutput: AudioObjectPropertyScope\nvar kAudioObjectPropertyScopePlayThrough: AudioObjectPropertyScope"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494503-anonymous",
    "html": "Topics\nConstants\nvar kAudioLFEVolumeControlClassID: AudioClassID\nvar kAudioLevelControlClassID: AudioClassID\nvar kAudioVolumeControlClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545865-anonymous",
    "html": "Topics\nConstants\nvar kAudioSystemObjectClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494510-anonymous",
    "html": "Topics\nConstants\nvar kAudioSliderControlPropertyRange: AudioObjectPropertySelector\nvar kAudioSliderControlPropertyValue: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545867-anonymous",
    "html": "Topics\nConstants\nvar kAudioSubDeviceClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494551-anonymous",
    "html": "Topics\nConstants\nvar kAudioBooleanControlPropertyValue: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545884-anonymous",
    "html": "Topics\nConstants\nvar kAudioAggregateDeviceClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545873-anonymous",
    "html": "Topics\nConstants\nvar kAudioObjectSystemObject: Int32"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545880-anonymous",
    "html": "Topics\nConstants\nvar kAudioSubDevicePropertyDriftCompensation: AudioObjectPropertySelector\nvar kAudioSubDevicePropertyDriftCompensationQuality: AudioObjectPropertySelector\nvar kAudioSubDevicePropertyExtraLatency: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545866-anonymous",
    "html": "Topics\nConstants\nvar kAudioDeviceProcessorOverload: AudioObjectPropertySelector\nvar kAudioDevicePropertyActualSampleRate: AudioObjectPropertySelector\nvar kAudioDevicePropertyBufferFrameSize: AudioObjectPropertySelector\nvar kAudioDevicePropertyBufferFrameSizeRange: AudioObjectPropertySelector\nvar kAudioDevicePropertyDeviceHasChanged: AudioObjectPropertySelector\nvar kAudioDevicePropertyDeviceIsRunningSomewhere: AudioObjectPropertySelector\nvar kAudioDevicePropertyHogMode: AudioObjectPropertySelector\nvar kAudioDevicePropertyIOCycleUsage: AudioObjectPropertySelector\nvar kAudioDevicePropertyIOProcStreamUsage: AudioObjectPropertySelector\nvar kAudioDevicePropertyIOStoppedAbnormally: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlugIn: AudioObjectPropertySelector\nvar kAudioDevicePropertyStreamConfiguration: AudioObjectPropertySelector\nvar kAudioDevicePropertyUsesVariableBufferFrameSizes: AudioObjectPropertySelector\nvar kAudioDevicePropertyClockDevice: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545881-anonymous",
    "html": "Topics\nConstants\nvar kAudioDevicePropertyChannelNominalLineLevel: AudioObjectPropertySelector\nvar kAudioDevicePropertyChannelNominalLineLevelNameForIDCFString: AudioObjectPropertySelector\nvar kAudioDevicePropertyChannelNominalLineLevels: AudioObjectPropertySelector\nvar kAudioDevicePropertyClipLight: AudioObjectPropertySelector\nvar kAudioDevicePropertyClockSource: AudioObjectPropertySelector\nvar kAudioDevicePropertyClockSourceKindForID: AudioObjectPropertySelector\nvar kAudioDevicePropertyClockSourceNameForIDCFString: AudioObjectPropertySelector\nvar kAudioDevicePropertyClockSources: AudioObjectPropertySelector\nvar kAudioDevicePropertyDataSource: AudioObjectPropertySelector\nvar kAudioDevicePropertyDataSourceKindForID: AudioObjectPropertySelector\nvar kAudioDevicePropertyDataSourceNameForIDCFString: AudioObjectPropertySelector\nvar kAudioDevicePropertyDataSources: AudioObjectPropertySelector\nvar kAudioDevicePropertyHighPassFilterSetting: AudioObjectPropertySelector\nvar kAudioDevicePropertyHighPassFilterSettingNameForIDCFString: AudioObjectPropertySelector\nvar kAudioDevicePropertyHighPassFilterSettings: AudioObjectPropertySelector\nvar kAudioDevicePropertyJackIsConnected: AudioObjectPropertySelector\nvar kAudioDevicePropertyListenback: AudioObjectPropertySelector\nvar kAudioDevicePropertyMute: AudioObjectPropertySelector\nvar kAudioDevicePropertyPhantomPower: AudioObjectPropertySelector\nvar kAudioDevicePropertyPhaseInvert: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThru: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruDestination: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruDestinationNameForIDCFString: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruDestinations: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruSolo: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruStereoPan: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruStereoPanChannels: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruVolumeDecibels: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruVolumeDecibelsToScalar: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruVolumeRangeDecibels: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruVolumeScalar: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruVolumeScalarToDecibels: AudioObjectPropertySelector\nvar kAudioDevicePropertySolo: AudioObjectPropertySelector\nvar kAudioDevicePropertyStereoPan: AudioObjectPropertySelector\nvar kAudioDevicePropertyStereoPanChannels: AudioObjectPropertySelector\nvar kAudioDevicePropertySubMute: AudioObjectPropertySelector\nvar kAudioDevicePropertySubVolumeDecibels: AudioObjectPropertySelector\nvar kAudioDevicePropertySubVolumeDecibelsToScalar: AudioObjectPropertySelector\nvar kAudioDevicePropertySubVolumeRangeDecibels: AudioObjectPropertySelector\nvar kAudioDevicePropertySubVolumeScalar: AudioObjectPropertySelector\nvar kAudioDevicePropertySubVolumeScalarToDecibels: AudioObjectPropertySelector\nvar kAudioDevicePropertyTalkback: AudioObjectPropertySelector\nvar kAudioDevicePropertyVolumeDecibels: AudioObjectPropertySelector\nvar kAudioDevicePropertyVolumeDecibelsToScalar: AudioObjectPropertySelector\nvar kAudioDevicePropertyVolumeRangeDecibels: AudioObjectPropertySelector\nvar kAudioDevicePropertyVolumeScalar: AudioObjectPropertySelector\nvar kAudioDevicePropertyVolumeScalarToDecibels: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545849-anonymous",
    "html": "Topics\nConstants\nvar kAudioPlugInCreateAggregateDevice: AudioObjectPropertySelector\nvar kAudioPlugInDestroyAggregateDevice: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545857-anonymous",
    "html": "Topics\nConstants\nvar kAudioTransportManagerCreateEndPointDevice: AudioObjectPropertySelector\nvar kAudioTransportManagerDestroyEndPointDevice: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494466-anonymous",
    "html": "Topics\nConstants\nvar kAudioTransportManagerPropertyEndPointList: AudioObjectPropertySelector\nvar kAudioTransportManagerPropertyTranslateUIDToEndPoint: AudioObjectPropertySelector\nvar kAudioTransportManagerPropertyTransportType: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494580-anonymous",
    "html": "Topics\nConstants\nvar kAudioDeviceTransportTypeAVB: UInt32\nvar kAudioDeviceTransportTypeAggregate: UInt32\nvar kAudioDeviceTransportTypeAirPlay: UInt32\nvar kAudioDeviceTransportTypeBluetooth: UInt32\nvar kAudioDeviceTransportTypeBluetoothLE: UInt32\nvar kAudioDeviceTransportTypeBuiltIn: UInt32\nvar kAudioDeviceTransportTypeDisplayPort: UInt32\nvar kAudioDeviceTransportTypeFireWire: UInt32\nvar kAudioDeviceTransportTypeHDMI: UInt32\nvar kAudioDeviceTransportTypePCI: UInt32\nvar kAudioDeviceTransportTypeThunderbolt: UInt32\nvar kAudioDeviceTransportTypeUSB: UInt32\nvar kAudioDeviceTransportTypeUnknown: UInt32\nvar kAudioDeviceTransportTypeVirtual: UInt32"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494474-anonymous",
    "html": "Topics\nConstants\nvar kAudioControlClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494489-anonymous",
    "html": "Topics\nConstants\nvar kAudioPlugInPropertyBoxList: AudioObjectPropertySelector\nvar kAudioPlugInPropertyBundleID: AudioObjectPropertySelector\nvar kAudioPlugInPropertyDeviceList: AudioObjectPropertySelector\nvar kAudioPlugInPropertyTranslateUIDToBox: AudioObjectPropertySelector\nvar kAudioPlugInPropertyTranslateUIDToDevice: AudioObjectPropertySelector\nvar kAudioPlugInPropertyClockDeviceList: AudioObjectPropertySelector\nvar kAudioPlugInPropertyTranslateUIDToClockDevice: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494441-anonymous",
    "html": "Topics\nConstants\nvar kAudioEndPointDeviceClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580749-anonymous",
    "html": "Topics\nConstants\nvar kAudioStreamUnknown: AudioObjectID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580736-anonymous",
    "html": "Topics\nConstants\nvar kAudioClockSourceControlPropertyItemKind: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580737-anonymous",
    "html": "Topics\nConstants\nvar kAudioPropertyWildcardSection: UInt8"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494591-anonymous",
    "html": "Topics\nConstants\nvar kAudioObjectPropertySelectorWildcard: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1646514-anonymous",
    "html": "Topics\nConstants\nvar kAudioClockDevicePropertyAvailableNominalSampleRates: AudioObjectPropertySelector\nvar kAudioClockDevicePropertyClockDomain: AudioObjectPropertySelector\nvar kAudioClockDevicePropertyControlList: AudioObjectPropertySelector\nvar kAudioClockDevicePropertyDeviceIsAlive: AudioObjectPropertySelector\nvar kAudioClockDevicePropertyDeviceIsRunning: AudioObjectPropertySelector\nvar kAudioClockDevicePropertyDeviceUID: AudioObjectPropertySelector\nvar kAudioClockDevicePropertyLatency: AudioObjectPropertySelector\nvar kAudioClockDevicePropertyNominalSampleRate: AudioObjectPropertySelector\nvar kAudioClockDevicePropertyTransportType: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494554-anonymous",
    "html": "Topics\nConstants\nvar kAudioClockSourceControlClassID: AudioClassID\nvar kAudioDataDestinationControlClassID: AudioClassID\nvar kAudioDataSourceControlClassID: AudioClassID\nvar kAudioHighPassFilterControlClassID: AudioClassID\nvar kAudioLineLevelControlClassID: AudioClassID\nvar kAudioSelectorControlClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494533-anonymous",
    "html": "Topics\nConstants\nvar kAudioSliderControlClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494569-anonymous",
    "html": "Topics\nConstants\nvar kAudioObjectClassIDWildcard: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1494595-anonymous",
    "html": "Topics\nConstants\nvar kAudioPlugInClassID: AudioClassID"
  },
  {
    "title": "UnsafeMutableAudioBufferListPointer | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/unsafemutableaudiobufferlistpointer",
    "html": "Topics\nType Aliases\ntypealias UnsafeMutableAudioBufferListPointer.Element\ntypealias UnsafeMutableAudioBufferListPointer.Index\ntypealias UnsafeMutableAudioBufferListPointer.Indices\ntypealias UnsafeMutableAudioBufferListPointer.Iterator\ntypealias UnsafeMutableAudioBufferListPointer.SubSequence\nInitializers\ninit(UnsafeMutablePointer<AudioBufferList>)\ninit?(UnsafeMutablePointer<AudioBufferList>?)\nInstance Properties\nvar count: Int\nvar endIndex: Int\nvar first: AudioBuffer?\nThe first element of the collection.\nvar isEmpty: Bool\nA Boolean value indicating whether the collection is empty.\nvar last: AudioBuffer?\nThe last element of the collection.\nvar lazy: LazySequence<UnsafeMutableAudioBufferListPointer>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.\nvar publisher: Publishers.Sequence<UnsafeMutableAudioBufferListPointer, Never>\nvar startIndex: Int\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection.\nvar unsafeMutablePointer: UnsafeMutablePointer<AudioBufferList>\nvar unsafePointer: UnsafePointer<AudioBufferList>\nInstance Methods\nfunc allSatisfy((AudioBuffer) -> Bool) -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc compactMap<ElementOfResult>((AudioBuffer) -> ElementOfResult?) -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc compare<Comparator>(Comparator.Compared, Comparator.Compared) -> ComparisonResult\nfunc contains(where: (AudioBuffer) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc difference<C>(from: C, by: (C.Element, AudioBuffer) -> Bool) -> CollectionDifference<AudioBuffer>\nReturns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test.\nfunc drop(while: (AudioBuffer) -> Bool) -> Slice<UnsafeMutableAudioBufferListPointer>\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Slice<UnsafeMutableAudioBufferListPointer>\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Slice<UnsafeMutableAudioBufferListPointer>\nReturns a subsequence containing all but the specified number of final elements.\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (AudioBuffer, OtherSequence.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc enumerated() -> EnumeratedSequence<UnsafeMutableAudioBufferListPointer>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc filter((AudioBuffer) -> Bool) -> [AudioBuffer]\nReturns an array containing, in order, the elements of the sequence that satisfy the given predicate.\nfunc filter(Predicate<AudioBuffer>) -> [AudioBuffer]\nfunc first(where: (AudioBuffer) -> Bool) -> AudioBuffer?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(where: (AudioBuffer) -> Bool) -> Int?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((AudioBuffer) -> SegmentOfResult) -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((AudioBuffer) -> ElementOfResult?) -> [ElementOfResult]\nDeprecated\nfunc forEach((AudioBuffer) -> Void)\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc formIndex(inout Int, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Int, offsetBy: Int, limitedBy: Int) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc formIndex(after: inout Int)\nReplaces the given index with its successor.\nfunc formIndex(before: inout Int)\nReplaces the given index with its predecessor.\nfunc formatted<S>(S) -> S.FormatOutput\nfunc index(Int, offsetBy: Int, limitedBy: Int) -> Int?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc last(where: (AudioBuffer) -> Bool) -> AudioBuffer?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(where: (AudioBuffer) -> Bool) -> Int?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (AudioBuffer, AudioBuffer) -> Bool) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.\nfunc makeIterator() -> IndexingIterator<UnsafeMutableAudioBufferListPointer>\nReturns an iterator over the elements of the collection.\nfunc map<T>((AudioBuffer) -> T) -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc max(by: (AudioBuffer, AudioBuffer) -> Bool) -> AudioBuffer?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min(by: (AudioBuffer, AudioBuffer) -> Bool) -> AudioBuffer?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements.\nfunc partition(by: (AudioBuffer) -> Bool) -> Int\nReorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don’t match.\nfunc prefix(Int) -> Slice<UnsafeMutableAudioBufferListPointer>\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Int) -> Slice<UnsafeMutableAudioBufferListPointer>\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Int) -> Slice<UnsafeMutableAudioBufferListPointer>\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (AudioBuffer) -> Bool) -> Slice<UnsafeMutableAudioBufferListPointer>\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc randomElement() -> AudioBuffer?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> AudioBuffer?\nReturns a random element of the collection, using the given generator as a source for randomness.\nfunc reduce<Result>(Result, (Result, AudioBuffer) -> Result) -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, AudioBuffer) -> ()) -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reverse()\nReverses the elements of the collection in place.\nfunc reversed() -> ReversedCollection<UnsafeMutableAudioBufferListPointer>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffle()\nShuffles the collection in place.\nfunc shuffle<T>(using: inout T)\nShuffles the collection in place, using the given generator as a source for randomness.\nfunc shuffled() -> [AudioBuffer]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [AudioBuffer]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness.\nfunc sort(by: (AudioBuffer, AudioBuffer) -> Bool)\nSorts the collection in place, using the given predicate as the comparison between elements.\nfunc sort<Comparator>(using: Comparator)\nfunc sort<S, Comparator>(using: S)\nfunc sorted(by: (AudioBuffer, AudioBuffer) -> Bool) -> [AudioBuffer]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc sorted<Comparator>(using: Comparator) -> [AudioBuffer]\nfunc sorted<S, Comparator>(using: S) -> [AudioBuffer]\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (AudioBuffer) -> Bool) -> [Slice<UnsafeMutableAudioBufferListPointer>]\nReturns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (AudioBuffer, PossiblePrefix.Element) -> Bool) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc suffix(Int) -> Slice<UnsafeMutableAudioBufferListPointer>\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Int) -> Slice<UnsafeMutableAudioBufferListPointer>\nReturns a subsequence from the specified position to the end of the collection.\nfunc swapAt(Int, Int)\nExchanges the values at the specified indices of the collection.\nfunc trimmingPrefix(while: (AudioBuffer) -> Bool) -> Slice<UnsafeMutableAudioBufferListPointer>\nfunc withContiguousMutableStorageIfAvailable<R>((inout UnsafeMutableBufferPointer<AudioBuffer>) -> R) -> R?\nExecutes a closure on the collection’s contiguous storage.\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<AudioBuffer>) -> R) -> R?\nExecutes a closure on the sequence’s contiguous storage.\nSubscripts\nsubscript(UnsafeMutableAudioBufferListPointer.Index) -> UnsafeMutableAudioBufferListPointer.Element\nsubscript<R>(R) -> Slice<UnsafeMutableAudioBufferListPointer>\nsubscript((UnboundedRange_) -> ()) -> Slice<UnsafeMutableAudioBufferListPointer>\nsubscript(Range<Int>) -> Slice<UnsafeMutableAudioBufferListPointer>\nAccesses a contiguous subrange of the collection’s elements.\nsubscript<R>(R) -> Slice<UnsafeMutableAudioBufferListPointer>\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nRelationships\nConforms To\nMutableCollection\nRandomAccessCollection"
  },
  {
    "title": "CATapDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/catapdescription",
    "html": "Topics\nInitializers\ninit()\ninit(monoGlobalTapButExcludeProcesses: [AudioObjectID])\ninit(monoMixdownOfProcesses: [AudioObjectID])\ninit(processes: [AudioObjectID], deviceUID: String, stream: UInt)\ninit(stereoGlobalTapButExcludeProcesses: [AudioObjectID])\ninit(stereoMixdownOfProcesses: [AudioObjectID])\nInstance Properties\nvar deviceUID: String?\nvar isExclusive: Bool\nvar isMixdown: Bool\nvar isMono: Bool\nvar isPrivate: Bool\nvar muteBehavior: CATapMuteBehavior\nvar name: String\nvar processes: [AudioObjectID]\nvar stream: UInt?\nvar uuid: UUID\nRelationships\nInherits From\nNSObject"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545886-anonymous",
    "html": "Topics\nConstants\nvar kAudioHardwarePropertyBoxList: AudioObjectPropertySelector\nvar kAudioHardwarePropertyDefaultInputDevice: AudioObjectPropertySelector\nvar kAudioHardwarePropertyDefaultOutputDevice: AudioObjectPropertySelector\nvar kAudioHardwarePropertyDefaultSystemOutputDevice: AudioObjectPropertySelector\nvar kAudioHardwarePropertyDevices: AudioObjectPropertySelector\nvar kAudioHardwarePropertyHogModeIsAllowed: AudioObjectPropertySelector\nvar kAudioHardwarePropertyIsInitingOrExiting: AudioObjectPropertySelector\nvar kAudioHardwarePropertyMixStereoToMono: AudioObjectPropertySelector\nvar kAudioHardwarePropertyPlugInList: AudioObjectPropertySelector\nvar kAudioHardwarePropertyPowerHint: AudioObjectPropertySelector\nvar kAudioHardwarePropertyProcessIsAudible: AudioObjectPropertySelector\nvar kAudioHardwarePropertyProcessIsMaster: AudioObjectPropertySelector\nDeprecated\nvar kAudioHardwarePropertyServiceRestarted: AudioObjectPropertySelector\nvar kAudioHardwarePropertySleepingIsAllowed: AudioObjectPropertySelector\nvar kAudioHardwarePropertyTranslateBundleIDToPlugIn: AudioObjectPropertySelector\nvar kAudioHardwarePropertyTranslateBundleIDToTransportManager: AudioObjectPropertySelector\nvar kAudioHardwarePropertyTranslateUIDToBox: AudioObjectPropertySelector\nvar kAudioHardwarePropertyTranslateUIDToDevice: AudioObjectPropertySelector\nvar kAudioHardwarePropertyTransportManagerList: AudioObjectPropertySelector\nvar kAudioHardwarePropertyUnloadingIsAllowed: AudioObjectPropertySelector\nvar kAudioHardwarePropertyUserIDChanged: AudioObjectPropertySelector\nvar kAudioHardwarePropertyUserSessionIsActiveOrHeadless: AudioObjectPropertySelector\nvar kAudioHardwarePropertyClockDeviceList: AudioObjectPropertySelector\nvar kAudioHardwarePropertyTranslateUIDToClockDevice: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580728-anonymous",
    "html": "Topics\nConstants\nvar kAudioLevelControlPropertyDecibelsToScalarTransferFunction: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580715-anonymous",
    "html": "Topics\nConstants\nvar kAudioDevicePropertyDriverShouldOwniSub: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruVolumeDecibelsToScalarTransferFunction: AudioObjectPropertySelector\nvar kAudioDevicePropertySubVolumeDecibelsToScalarTransferFunction: AudioObjectPropertySelector\nvar kAudioDevicePropertyVolumeDecibelsToScalarTransferFunction: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580741-anonymous",
    "html": "Topics\nConstants\nvar kAudioControlPropertyVariant: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580740-anonymous",
    "html": "Topics\nConstants\nvar kAudioPropertyWildcardChannel: AudioObjectPropertyElement"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580738-anonymous",
    "html": "Topics\nConstants\nvar kAudioHardwarePropertyBootChimeVolumeDecibels: AudioObjectPropertySelector\nvar kAudioHardwarePropertyBootChimeVolumeDecibelsToScalar: AudioObjectPropertySelector\nvar kAudioHardwarePropertyBootChimeVolumeDecibelsToScalarTransferFunction: AudioObjectPropertySelector\nvar kAudioHardwarePropertyBootChimeVolumeRangeDecibels: AudioObjectPropertySelector\nvar kAudioHardwarePropertyBootChimeVolumeScalar: AudioObjectPropertySelector\nvar kAudioHardwarePropertyBootChimeVolumeScalarToDecibels: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580726-anonymous",
    "html": "Topics\nConstants\nvar kAudioDevicePropertyScopeInput: AudioObjectPropertyScope\nvar kAudioDevicePropertyScopeOutput: AudioObjectPropertyScope\nvar kAudioDevicePropertyScopePlayThrough: AudioObjectPropertyScope"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580747-anonymous",
    "html": "Topics\nConstants\nvar kAudioDeviceTransportTypeAutoAggregate: UInt32"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580719-anonymous",
    "html": "Topics\nConstants\nvar kAudioBootChimeVolumeControlClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580722-anonymous",
    "html": "Topics\nConstants\nvar kAudioPropertyWildcardPropertyID: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580720-anonymous",
    "html": "Topics\nConstants\nvar kAudioISubOwnerControlClassID: AudioClassID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580746-anonymous",
    "html": "Topics\nConstants\nvar kAudioDeviceUnknown: AudioObjectID"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580731-anonymous",
    "html": "Topics\nConstants\nvar kAudioDevicePropertyBufferSize: AudioObjectPropertySelector\nvar kAudioDevicePropertyBufferSizeRange: AudioObjectPropertySelector\nvar kAudioDevicePropertyChannelCategoryName: AudioObjectPropertySelector\nvar kAudioDevicePropertyChannelCategoryNameCFString: AudioObjectPropertySelector\nvar kAudioDevicePropertyChannelName: AudioObjectPropertySelector\nvar kAudioDevicePropertyChannelNameCFString: AudioObjectPropertySelector\nvar kAudioDevicePropertyChannelNominalLineLevelNameForID: AudioObjectPropertySelector\nvar kAudioDevicePropertyChannelNumberName: AudioObjectPropertySelector\nvar kAudioDevicePropertyChannelNumberNameCFString: AudioObjectPropertySelector\nvar kAudioDevicePropertyClockSourceNameForID: AudioObjectPropertySelector\nvar kAudioDevicePropertyDataSourceNameForID: AudioObjectPropertySelector\nvar kAudioDevicePropertyDeviceManufacturer: AudioObjectPropertySelector\nvar kAudioDevicePropertyDeviceManufacturerCFString: AudioObjectPropertySelector\nvar kAudioDevicePropertyDeviceName: AudioObjectPropertySelector\nvar kAudioDevicePropertyDeviceNameCFString: AudioObjectPropertySelector\nvar kAudioDevicePropertyHighPassFilterSettingNameForID: AudioObjectPropertySelector\nvar kAudioDevicePropertyPlayThruDestinationNameForID: AudioObjectPropertySelector\nvar kAudioDevicePropertyRegisterBufferList: AudioObjectPropertySelector\nvar kAudioDevicePropertyStreamFormat: AudioObjectPropertySelector\nvar kAudioDevicePropertyStreamFormatMatch: AudioObjectPropertySelector\nvar kAudioDevicePropertyStreamFormatSupported: AudioObjectPropertySelector\nvar kAudioDevicePropertyStreamFormats: AudioObjectPropertySelector\nvar kAudioDevicePropertySupportsMixing: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580748-anonymous",
    "html": "Topics\nConstants\nvar kAudioStreamPropertyOwningDevice: AudioObjectPropertySelector\nvar kAudioStreamPropertyPhysicalFormatMatch: AudioObjectPropertySelector\nvar kAudioStreamPropertyPhysicalFormatSupported: AudioObjectPropertySelector\nvar kAudioStreamPropertyPhysicalFormats: AudioObjectPropertySelector"
  },
  {
    "title": "AudioObjectPropertyAddress | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/audioobjectpropertyaddress",
    "html": "Topics\nInitializers\ninit()\ninit(mSelector: AudioObjectPropertySelector, mScope: AudioObjectPropertyScope, mElement: AudioObjectPropertyElement)\nInstance Properties\nvar mElement: AudioObjectPropertyElement\nvar mScope: AudioObjectPropertyScope\nvar mSelector: AudioObjectPropertySelector"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545878-anonymous",
    "html": "Topics\nConstants\nvar kAudioSubDeviceDriftCompensationHighQuality: UInt32\nDeprecated\nvar kAudioSubDeviceDriftCompensationLowQuality: UInt32\nDeprecated\nvar kAudioSubDeviceDriftCompensationMaxQuality: UInt32\nDeprecated\nvar kAudioSubDeviceDriftCompensationMediumQuality: UInt32\nDeprecated\nvar kAudioSubDeviceDriftCompensationMinQuality: UInt32\nDeprecated"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545875-anonymous",
    "html": "Topics\nConstants\nvar kAudioAggregateDevicePropertyActiveSubDeviceList: AudioObjectPropertySelector\nvar kAudioAggregateDevicePropertyComposition: AudioObjectPropertySelector\nvar kAudioAggregateDevicePropertyFullSubDeviceList: AudioObjectPropertySelector\nvar kAudioAggregateDevicePropertyMasterSubDevice: AudioObjectPropertySelector\nDeprecated\nvar kAudioAggregateDevicePropertyClockDevice: AudioObjectPropertySelector"
  },
  {
    "title": "AudioHardwareIOProcStreamUsage | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/audiohardwareioprocstreamusage",
    "html": "Topics\nInitializers\ninit(mIOProc: UnsafeMutableRawPointer, mNumberStreams: UInt32, mStreamIsOn: (UInt32))\nInstance Properties\nvar mIOProc: UnsafeMutableRawPointer\nvar mNumberStreams: UInt32\nvar mStreamIsOn: (UInt32)"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545861-anonymous",
    "html": "Topics\nConstants\nvar kAudioDeviceStartTimeDontConsultDeviceFlag: UInt32\nvar kAudioDeviceStartTimeDontConsultHALFlag: UInt32\nvar kAudioDeviceStartTimeIsInputFlag: UInt32"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1545874-anonymous",
    "html": "Topics\nConstants\nvar kAudioObjectPropertyCreator: AudioObjectPropertySelector\nvar kAudioObjectPropertyListenerAdded: AudioObjectPropertySelector\nvar kAudioObjectPropertyListenerRemoved: AudioObjectPropertySelector"
  },
  {
    "title": "AudioStreamRangedDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/audiostreamrangeddescription",
    "html": "Topics\nInitializers\ninit()\ninit(mFormat: AudioStreamBasicDescription, mSampleRateRange: AudioValueRange)\nInstance Properties\nvar mFormat: AudioStreamBasicDescription\nvar mSampleRateRange: AudioValueRange"
  },
  {
    "title": "Anonymous | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations/1580723-anonymous",
    "html": "Topics\nConstants\nvar kAudioHardwarePropertyDeviceForUID: AudioObjectPropertySelector\nvar kAudioHardwarePropertyPlugInForBundleID: AudioObjectPropertySelector\nvar kAudioHardwarePropertyRunLoop: AudioObjectPropertySelector"
  },
  {
    "title": "Core Audio Data Types | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_data_types",
    "html": "Topics\nData Types\ntypealias AudioClassID\ntypealias AudioDeviceID\ntypealias AudioDeviceIOBlock\ntypealias AudioDeviceIOProc\ntypealias AudioDeviceIOProcID\ntypealias AudioDevicePropertyID\ntypealias AudioDevicePropertyListenerProc\ntypealias AudioHardwarePropertyID\ntypealias AudioHardwarePropertyListenerProc\ntypealias AudioObjectID\ntypealias AudioObjectPropertyElement\ntypealias AudioObjectPropertyListenerBlock\ntypealias AudioObjectPropertyListenerProc\ntypealias AudioObjectPropertyScope\ntypealias AudioObjectPropertySelector\ntypealias AudioStreamID\ntypealias AudioStreamPropertyListenerProc"
  },
  {
    "title": "ManagedAudioChannelLayout | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/managedaudiochannellayout",
    "html": "Topics\nInitializers\ninit(audioChannelLayoutPointer: AudioChannelLayout.UnsafePointer, deallocator: (AudioChannelLayout.UnsafePointer) -> Void)\ninit(channelDescriptions: [AudioChannelDescription])\ninit(maximumDescriptions: Int)\ninit(tag: AudioChannelLayoutTag)\nInstance Properties\nvar bitmap: AudioChannelBitmap\nvar channelDescriptions: ManagedAudioChannelLayout.ChannelDescriptions\nvar numberOfChannels: Int\nvar sizeInBytes: Int\nvar tag: AudioChannelLayoutTag\nInstance Methods\nfunc setAllToUnknown()\nfunc withUnsafeMutablePointer<Result>((UnsafeMutablePointer<AudioChannelLayout>) -> Result) -> Result\nfunc withUnsafePointer<Result>((UnsafePointer<AudioChannelLayout>) -> Result) -> Result\nOperator Functions\nstatic func != (ManagedAudioChannelLayout, ManagedAudioChannelLayout) -> Bool\nstatic func == (ManagedAudioChannelLayout, ManagedAudioChannelLayout) -> Bool\nStructures\nstruct ManagedAudioChannelLayout.ChannelDescriptions"
  },
  {
    "title": "Building an Audio Server Plug-in and Driver Extension | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/building_an_audio_server_plug-in_and_driver_extension",
    "html": "Overview\n\nThis sample shows how to create an Audio Server plug-in built on top of a DriverKit Driver Extension. The sample provides C++ implementations of the plug-in and the Driver Extension, and shows how to implement the communication between the two, including discovering, connecting to, and calling into the Driver Extension from the plug-in.\n\nThe sample implements a dynamic environment that supports multiple audio devices. The plug-in’s audio devices provide the following features:\n\nConfigurable device master volume.\n\nSupport for 44.1 kHz and 48 kHz sample rates\n\nSupport for two channels of audio I/O in 32-bit, floating point, linear PCM format\n\nConfigure the Sample Code Project\n\nTo deploy the sample driver, you need to create an explicit App ID and provisioning profile with the following entitlements:\n\ncom.apple.developer.driverkit\n\ncom.apple.developer.driverkit.transport.usb\n\n​To learn how to perform this configuration, see Requesting Entitlements for DriverKit Development.\n\nTo bypass this configuration and use ad hoc signing to test the driver in your local development environment, perform the following steps:\n\nDisable System Integrity Protection (SIP) on your system so it recognizes ad hoc-signed DriverKit extensions. For more information, see Disabling and Enabling System Integrity Protection.\n\nConfigure the SimpleAudioDriver target to use local signing. Select the target, and then select its Build Settings tab. Find the Code Signing Identity build setting and select Sign to Run Locally.\n\nUse the included installer script to install the driver on your system. Navigate to the root of the sample project and run the following command:\n\n./Scripts/install.sh\n\nReboot your computer so that the system recognizes the driver. After your computer restarts, open Audio MIDI Setup to inspect the newly installed device.\n\nTo uninstall the driver, run the uninstall.sh script and reboot your computer.\n\nSee Also\nDrivers\nCreating an Audio Server Driver Plug-in\nBuild a virtual audio device by creating a custom driver plug-in."
  },
  {
    "title": "Core Audio Enumerations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_enumerations",
    "html": "Topics\nEnumerations\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nenum AudioHardwarePowerHint\nenum AudioLevelControlTransferFunction\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nAnonymous\nenum CATapMuteBehavior"
  },
  {
    "title": "Core Audio Constants | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_constants",
    "html": "Topics\nConstants\nvar kAudioAggregateDeviceClockDeviceKey: String\nvar kAudioAggregateDeviceIsPrivateKey: String\nvar kAudioAggregateDeviceIsStackedKey: String\nvar kAudioAggregateDeviceMasterSubDeviceKey: String\nvar kAudioAggregateDeviceNameKey: String\nvar kAudioAggregateDeviceSubDeviceListKey: String\nvar kAudioAggregateDeviceUIDKey: String\nvar kAudioEndPointDeviceEndPointListKey: String\nvar kAudioEndPointDeviceIsPrivateKey: String\nvar kAudioEndPointDeviceMasterEndPointKey: String\nvar kAudioEndPointDeviceNameKey: String\nvar kAudioEndPointDeviceUIDKey: String\nvar kAudioEndPointInputChannelsKey: String\nvar kAudioEndPointNameKey: String\nvar kAudioEndPointOutputChannelsKey: String\nvar kAudioEndPointUIDKey: String\nvar kAudioHardwareRunLoopMode: String\nvar kAudioSubDeviceDriftCompensationKey: String\nvar kAudioSubDeviceDriftCompensationQualityKey: String\nvar kAudioSubDeviceExtraInputLatencyKey: String\nvar kAudioSubDeviceExtraOutputLatencyKey: String\nvar kAudioSubDeviceInputChannelsKey: String\nvar kAudioSubDeviceNameKey: String\nvar kAudioSubDeviceOutputChannelsKey: String\nvar kAudioSubDeviceUIDKey: String\nvar kAudioAggregateDeviceMainSubDeviceKey: String\nvar kAudioAggregateDeviceTapAutoStartKey: String\nvar kAudioAggregateDeviceTapListKey: String\nvar kAudioEndPointDeviceMainEndPointKey: String\nvar kAudioSubTapDriftCompensationKey: String\nvar kAudioSubTapDriftCompensationQualityKey: String\nvar kAudioSubTapExtraInputLatencyKey: String\nvar kAudioSubTapExtraOutputLatencyKey: String\nvar kAudioSubTapUIDKey: String"
  },
  {
    "title": "Core Audio Functions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_functions",
    "html": "Topics\nFunctions\nfunc AudioConvertHostTimeToNanos(UInt64) -> UInt64\nfunc AudioConvertNanosToHostTime(UInt64) -> UInt64\nfunc AudioDeviceCreateIOProcID(AudioObjectID, AudioDeviceIOProc, UnsafeMutableRawPointer?, UnsafeMutablePointer<AudioDeviceIOProcID?>) -> OSStatus\nfunc AudioDeviceCreateIOProcIDWithBlock(UnsafeMutablePointer<AudioDeviceIOProcID?>, AudioObjectID, dispatch_queue_t?, AudioDeviceIOBlock) -> OSStatus\nfunc AudioDeviceDestroyIOProcID(AudioObjectID, AudioDeviceIOProcID) -> OSStatus\nfunc AudioDeviceGetCurrentTime(AudioObjectID, UnsafeMutablePointer<AudioTimeStamp>) -> OSStatus\nfunc AudioDeviceGetNearestStartTime(AudioObjectID, UnsafeMutablePointer<AudioTimeStamp>, UInt32) -> OSStatus\nfunc AudioDeviceStart(AudioObjectID, AudioDeviceIOProcID?) -> OSStatus\nfunc AudioDeviceStartAtTime(AudioObjectID, AudioDeviceIOProcID?, UnsafeMutablePointer<AudioTimeStamp>, UInt32) -> OSStatus\nfunc AudioDeviceStop(AudioObjectID, AudioDeviceIOProcID?) -> OSStatus\nfunc AudioDeviceTranslateTime(AudioObjectID, UnsafePointer<AudioTimeStamp>, UnsafeMutablePointer<AudioTimeStamp>) -> OSStatus\nfunc AudioGetCurrentHostTime() -> UInt64\nfunc AudioGetHostClockFrequency() -> Float64\nfunc AudioGetHostClockMinimumTimeDelta() -> UInt32\nfunc AudioHardwareCreateAggregateDevice(CFDictionary, UnsafeMutablePointer<AudioObjectID>) -> OSStatus\nfunc AudioHardwareDestroyAggregateDevice(AudioObjectID) -> OSStatus\nfunc AudioHardwareUnload() -> OSStatus\nfunc AudioObjectAddPropertyListener(AudioObjectID, UnsafePointer<AudioObjectPropertyAddress>, AudioObjectPropertyListenerProc, UnsafeMutableRawPointer?) -> OSStatus\nfunc AudioObjectAddPropertyListenerBlock(AudioObjectID, UnsafePointer<AudioObjectPropertyAddress>, dispatch_queue_t?, AudioObjectPropertyListenerBlock) -> OSStatus\nfunc AudioObjectGetPropertyData(AudioObjectID, UnsafePointer<AudioObjectPropertyAddress>, UInt32, UnsafeRawPointer?, UnsafeMutablePointer<UInt32>, UnsafeMutableRawPointer) -> OSStatus\nfunc AudioObjectGetPropertyDataSize(AudioObjectID, UnsafePointer<AudioObjectPropertyAddress>, UInt32, UnsafeRawPointer?, UnsafeMutablePointer<UInt32>) -> OSStatus\nfunc AudioObjectHasProperty(AudioObjectID, UnsafePointer<AudioObjectPropertyAddress>) -> Bool\nfunc AudioObjectIsPropertySettable(AudioObjectID, UnsafePointer<AudioObjectPropertyAddress>, UnsafeMutablePointer<DarwinBoolean>) -> OSStatus\nfunc AudioObjectRemovePropertyListener(AudioObjectID, UnsafePointer<AudioObjectPropertyAddress>, AudioObjectPropertyListenerProc, UnsafeMutableRawPointer?) -> OSStatus\nfunc AudioObjectRemovePropertyListenerBlock(AudioObjectID, UnsafePointer<AudioObjectPropertyAddress>, dispatch_queue_t?, AudioObjectPropertyListenerBlock) -> OSStatus\nfunc AudioObjectSetPropertyData(AudioObjectID, UnsafePointer<AudioObjectPropertyAddress>, UInt32, UnsafeRawPointer?, UInt32, UnsafeRawPointer) -> OSStatus\nfunc AudioObjectShow(AudioObjectID)\nfunc AudioHardwareCreateProcessTap(CATapDescription!, UnsafeMutablePointer<AudioObjectID>!) -> OSStatus\nfunc AudioHardwareDestroyProcessTap(AudioObjectID) -> OSStatus"
  },
  {
    "title": "Core Audio Structures | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/core_audio_structures",
    "html": "Topics\nStructures\nstruct AudioHardwareIOProcStreamUsage\nstruct AudioObjectPropertyAddress\nstruct AudioStreamRangedDescription\nstruct UnsafeMutableAudioBufferListPointer"
  },
  {
    "title": "Creating an Audio Server Driver Plug-in | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio/creating_an_audio_server_driver_plug-in",
    "html": "Overview\n\nThis sample shows how to create a minimal Audio Server plug-in. Written in standard C, the sample provides the minimal implementation you need to publish a single, functioning audio device to the system. The audio device provides the following features:\n\nConfigurable device primary volume, muting, and data sources\n\n44.1 kHz and 48 kHz sample rates\n\nTwo channels of audio I/O in 32-bit, floating point, linear PCM format\n\nInstall the sample’s .driver bundle to /Library/Audio/Plug-Ins/HAL and reboot your computer. Use Audio MIDI Setup to inspect the newly installed device.\n\nSee Also\nDrivers\nBuilding an Audio Server Plug-in and Driver Extension\nCreate a plug-in and driver extension to support an audio device in macOS."
  },
  {
    "title": "Core Audio | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/coreaudio",
    "html": "Topics\nDrivers\nCreating an Audio Server Driver Plug-in\nBuild a virtual audio device by creating a custom driver plug-in.\nBuilding an Audio Server Plug-in and Driver Extension\nCreate a plug-in and driver extension to support an audio device in macOS.\nReference\nCore Audio Structures\nCore Audio Data Types\nCore Audio Functions\nCore Audio Constants\nCore Audio Enumerations\nStructures\nstruct ManagedAudioChannelLayout\nClasses\nclass CATapDescription"
  }
]
