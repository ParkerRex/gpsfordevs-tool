[
  {
    "title": "song(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/queuechange/item/song(_:)",
    "html": "Parameters\nname\n\nThe name of the song.\n\nDiscussion\n\nWhen a participant adds a song or changes the next song in the queue, call this method to create an item with the song name. When you show the change notice, SharePlay displays the song name to the participant.\n\nSee Also\nCreating the item\nstatic func container(String) -> GroupSessionEvent.Action.QueueChange.Item\nCreates an item that contains the name of a container."
  },
  {
    "title": "container(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/queuechange/item/container(_:)",
    "html": "Parameters\nname\n\nThe name of the container.\n\nDiscussion\n\nWhen a participant changes an entire queue, call this method to create an item with the queue name. When you show the change notice, SharePlay displays the container name to the participant.\n\nSee Also\nCreating the item\nstatic func song(String) -> GroupSessionEvent.Action.QueueChange.Item\nCreates an item that contains the name of a song."
  },
  {
    "title": "GroupSessionEvent.Action.QueueChange.Item",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/queuechange/item",
    "html": "Overview\n\nBefore you notify a participant about a queue-related change, create an item that contains the name of the song or container that changed. Use this item to configure a GroupSessionEvent.Action.QueueChange structure with additional details about the change.\n\nTopics\nCreating the item\nstatic func song(String) -> GroupSessionEvent.Action.QueueChange.Item\nCreates an item that contains the name of a song.\nstatic func container(String) -> GroupSessionEvent.Action.QueueChange.Item\nCreates an item that contains the name of a container."
  },
  {
    "title": "added(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/queuechange/added(_:)",
    "html": "Parameters\nitem\n\nThe item the participant added to the queue.\n\nReturn Value\n\nA type that contains information about the change.\n\nDiscussion\n\nBefore showing a notice to the user, call this method to generate a type for the added item. Pass this type to the updatedQueue(_:) method to create the postable action.\n\nSee Also\nSpecifying the type of change\nstatic func setUpNext(GroupSessionEvent.Action.QueueChange.Item) -> GroupSessionEvent.Action.QueueChange\nReturns a queue change for a new up-next item."
  },
  {
    "title": "setUpNext(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/queuechange/setupnext(_:)",
    "html": "Parameters\nitem\n\nThe next item in the queue.\n\nReturn Value\n\nA type that contains information about the change.\n\nDiscussion\n\nBefore showing a notice to the user, call this method to generate a type for the changed up-next item. Pass this type to the updatedQueue(_:) method to create the postable action.\n\nSee Also\nSpecifying the type of change\nstatic func added(GroupSessionEvent.Action.QueueChange.Item) -> GroupSessionEvent.Action.QueueChange\nReturns a queue change for an added item."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/compactmap(_:)-8vv5m",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/compactmap(_:)-82n76",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "allSatisfy(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "contains(where:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/map(_:)-92o3h",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/compactmap(_:)-8cij7",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-1gln2/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/compactmap(_:)-18u0v",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "next()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/iterator/next()",
    "html": "Return Value\n\nThe next element, if it exists, or nil to signal the end of the sequence."
  },
  {
    "title": "drop(while:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "dropFirst(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "filter(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/flatmap(_:)-27ism",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/flatmap(_:)-81p0l",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "play",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/play",
    "html": "See Also\nGetting playback-related actions\nstatic let pause: GroupSessionEvent.Action\nAn action that indicates an end to playback.\nstatic let seek: GroupSessionEvent.Action\nAn event that indicates a change to the current playback location.\nstatic func skip(item: String) -> GroupSessionEvent.Action\nReturns an event that indicates a skipped track or playback item."
  },
  {
    "title": "first(where:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/map(_:)-3woce",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "pause",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/pause",
    "html": "See Also\nGetting playback-related actions\nstatic let play: GroupSessionEvent.Action\nAn action that indicates the start of playback.\nstatic let seek: GroupSessionEvent.Action\nAn event that indicates a change to the current playback location.\nstatic func skip(item: String) -> GroupSessionEvent.Action\nReturns an event that indicates a skipped track or playback item."
  },
  {
    "title": "max(by:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "seek",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/seek",
    "html": "See Also\nGetting playback-related actions\nstatic let play: GroupSessionEvent.Action\nAn action that indicates the start of playback.\nstatic let pause: GroupSessionEvent.Action\nAn action that indicates an end to playback.\nstatic func skip(item: String) -> GroupSessionEvent.Action\nReturns an event that indicates a skipped track or playback item."
  },
  {
    "title": "skip(item:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/skip(item:)",
    "html": "Parameters\nitem\n\nThe name of the skipped item.\n\nDiscussion\n\nThis function creates an action that represents a skipped playback item. If your app’s activity manages a playlist of items, you might use this action to indicate a participant skipped an item. For example, you might name a skipped song in a shared playlist.\n\nSee Also\nGetting playback-related actions\nstatic let play: GroupSessionEvent.Action\nAn action that indicates the start of playback.\nstatic let pause: GroupSessionEvent.Action\nAn action that indicates an end to playback.\nstatic let seek: GroupSessionEvent.Action\nAn event that indicates a change to the current playback location."
  },
  {
    "title": "reduce(into:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "updatedQueue(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/updatedqueue(_:)",
    "html": "Parameters\nchange\n\nThe change that ocurred to the queue.\n\nDiscussion\n\nWhen you want to notify the user of changes to the playback queue, call this method to create an action type with the details of the change. Then call the showNotice(_:) method to post that action. For example, use the following code to notify the user that someone added a song to the queue.\n\ngroupSession.showNotice(.updatedQueue(.added(.song(\"Here comes the sun\"))))\n\nSee Also\nGetting change-related actions\nstatic let updatedQueue: GroupSessionEvent.Action\nAn action that represents a nonspecific change to the queue.\nstruct QueueChange\nA type that describes a modification to the playback queue."
  },
  {
    "title": "GroupSessionEvent.Action.QueueChange",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/queuechange",
    "html": "Overview\n\nUse this type to inform the participant about changes to the playback queue associated with the current activity. Your app manages the queue, along with any additions or changes. You use this type to communicate those changes back to the participant using the system UI.\n\nWhen a change occurs, configure this type with information about the change, and wrap it in a GroupSessionEvent.Action type. Pass the action to the showNotice(_:) method to display the change to the participant.\n\nTopics\nSpecifying the type of change\nstatic func added(GroupSessionEvent.Action.QueueChange.Item) -> GroupSessionEvent.Action.QueueChange\nReturns a queue change for an added item.\nstatic func setUpNext(GroupSessionEvent.Action.QueueChange.Item) -> GroupSessionEvent.Action.QueueChange\nReturns a queue change for a new up-next item.\nGetting the changed item\nstruct Item\nDetailed information about an item involved in a queue change.\nSee Also\nGetting change-related actions\nstatic func updatedQueue(GroupSessionEvent.Action.QueueChange) -> GroupSessionEvent.Action\nReturns an action that represents a change to the playback queue.\nstatic let updatedQueue: GroupSessionEvent.Action\nAn action that represents a nonspecific change to the queue."
  },
  {
    "title": "updatedQueue",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct/updatedqueue",
    "html": "Discussion\n\nUse this action when the other action types don’t accurately describe the change you made to the queue. If you can specify the change using a GroupSessionEvent.Action.QueueChange type, use the updatedQueue(_:) method instead.\n\nSee Also\nGetting change-related actions\nstatic func updatedQueue(GroupSessionEvent.Action.QueueChange) -> GroupSessionEvent.Action\nReturns an action that represents a change to the playback queue.\nstruct QueueChange\nA type that describes a modification to the playback queue."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/compactmap(_:)-12hpc",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/flatmap(_:)-2y4qr",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "next()",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/iterator/next()",
    "html": "Return Value\n\nThe next element, if it exists, or nil to signal the end of the sequence."
  },
  {
    "title": "next()",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/iterator/next()",
    "html": "Return Value\n\nThe next element, if it exists, or nil to signal the end of the sequence."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-1gln2/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-1gln2/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "reduce(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "prefix(while:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "prefix(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "min(by:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/map(_:)-6miof",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/map(_:)-7zazs",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/flatmap(_:)-6zwvi",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "action",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.property",
    "html": "Discussion\n\nThe system uses this information to craft a message in the system UI.\n\nSee Also\nGetting the event details\nlet originator: Participant\nThe participant that initiated the event.\nlet url: URL?\nThe URL to open when the participant taps the event link in the system UI.\nstruct Action\nA playback-related change that occurs during the session."
  },
  {
    "title": "prefix(while:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "dropFirst(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "reduce(into:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "dropFirst(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "allSatisfy(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "drop(while:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/compactmap(_:)-7a8q4",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "init(from:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/experience-swift.enum/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid."
  },
  {
    "title": "contains(where:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFinding elements\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "encode(to:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/experience-swift.enum/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "first(where:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFinding elements\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/experience-swift.enum/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-1gln2/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "AsyncSequence Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/asyncsequence-implementations",
    "html": "Topics\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(Self.Element) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "originator",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/originator",
    "html": "See Also\nGetting the event details\nlet url: URL?\nThe URL to open when the participant taps the event link in the system UI.\nlet action: GroupSessionEvent.Action\nThe reason for the event.\nstruct Action\nA playback-related change that occurs during the session."
  },
  {
    "title": "init(originator:action:url:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/init(originator:action:url:)",
    "html": "Parameters\noriginator\n\nThe participant that initiated the event.\n\naction\n\nThe action to report for the event. The system uses this value to generate a localized description of the action in the system UI.\n\nurl\n\nThe location in your app where the action occurred. Specify a universal link into your app that takes the participant to the action details. Specify nil to bring your app to the foreground without navigating to a specific location."
  },
  {
    "title": "url",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/url",
    "html": "Discussion\n\nWhen the user taps your custom event in the system UI, the system opens the provided URL. Specify a universal link to open your app to the place where the action occurred. If the value of this link is nil, the system brings your app to the foreground.\n\nFor information about how to support universal links in your app, see doc://com.apple.documentation/documentation/xcode/allowing_apps_and_websites_to_link_to_your_content/supporting_universal_links_in_your_app\n\nSee Also\nGetting the event details\nlet originator: Participant\nThe participant that initiated the event.\nlet action: GroupSessionEvent.Action\nThe reason for the event.\nstruct Action\nA playback-related change that occurs during the session."
  },
  {
    "title": "GroupSessionEvent.Action",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent/action-swift.struct",
    "html": "Overview\n\nUse this structure to communicate playback-related changes to participants using the system UI. You can use this structure to communicate the following types of events:\n\nTransport-related events for a custom player.\n\nChanges to a playback queue your app manages.\n\nWhen a change occurs in your custom player or playback queue, create an instance of this structure to describe the change and wrap it in a GroupSessionEvent structure. To display the event to the participant call the showNotice(_:) method of the session. The system formats and displays the information you provide.\n\nNote\n\nIf your app uses AV Foundation to play content, you don’t need to communicate transport-related events yourself. AV Foundation generates appropriate events when the user plays, pauses, seeks, or skips tracks.\n\nTopics\nGetting playback-related actions\nstatic let play: GroupSessionEvent.Action\nAn action that indicates the start of playback.\nstatic let pause: GroupSessionEvent.Action\nAn action that indicates an end to playback.\nstatic let seek: GroupSessionEvent.Action\nAn event that indicates a change to the current playback location.\nstatic func skip(item: String) -> GroupSessionEvent.Action\nReturns an event that indicates a skipped track or playback item.\nGetting change-related actions\nstatic func updatedQueue(GroupSessionEvent.Action.QueueChange) -> GroupSessionEvent.Action\nReturns an action that represents a change to the playback queue.\nstatic let updatedQueue: GroupSessionEvent.Action\nAn action that represents a nonspecific change to the queue.\nstruct QueueChange\nA type that describes a modification to the playback queue.\nSee Also\nGetting the event details\nlet originator: Participant\nThe participant that initiated the event.\nlet url: URL?\nThe URL to open when the participant taps the event link in the system UI.\nlet action: GroupSessionEvent.Action\nThe reason for the event."
  },
  {
    "title": "next()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/iterator/next()",
    "html": "Return Value\n\nThe next element, if it exists, or nil to signal the end of the sequence."
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/compactmap(_:)-91ttc",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(where:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "drop(while:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "filter(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "first(where:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/map(_:)-5ibmj",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "reduce(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/compactmap(_:)-7ztnv",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/compactmap(_:)-9ys9f",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "next()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/iterator/next()",
    "html": "Return Value\n\nThe next element, if it exists, or nil to signal the end of the sequence."
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "contains(where:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "filter(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "first(where:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/flatmap(_:)-4oyzy",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/flatmap(_:)-5g3pa",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/map(_:)-2raq0",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/flatmap(_:)-5bs6h",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "filter(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n\nSee Also\nExcluding elements\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements."
  },
  {
    "title": "max(by:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n\nSee Also\nFinding elements\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "min(by:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n\nSee Also\nFinding elements\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "allSatisfy(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true.\n\nSee Also\nFinding elements\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "GroupSession.Sessions.Iterator",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> GroupSession<ActivityType>?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> GroupSession<ActivityType>.Sessions.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\ntypealias Element\nThe type of element produced by this asynchronous sequence."
  },
  {
    "title": "SystemCoordinator.GroupImmersionStyles.Iterator",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> SystemCoordinator.GroupImmersionStyles.Element?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol"
  },
  {
    "title": "makeAsyncIterator()",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "GroupSession.Sessions.Element",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/element",
    "html": "See Also\nCreating an iterator\nfunc makeAsyncIterator() -> GroupSession<ActivityType>.Sessions.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Iterator"
  },
  {
    "title": "GroupActivityMetadata.Experience.RawValue",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/experience-swift.enum/rawvalue-swift.typealias",
    "html": "Discussion\n\nEvery distinct value of the conforming type has a corresponding unique value of the RawValue type, but there may be values of the RawValue type that don’t have a corresponding value of the conforming type."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-1gln2/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "SystemCoordinator.ParticipantStates.Iterator",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> SystemCoordinator.ParticipantStates.Element?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> SystemCoordinator.ParticipantStates.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\ntypealias Element\nThe type of element produced by this asynchronous sequence."
  },
  {
    "title": "SystemCoordinator.ParticipantStates.Element",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/element",
    "html": "See Also\nCreating an iterator\nfunc makeAsyncIterator() -> SystemCoordinator.ParticipantStates.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Iterator"
  },
  {
    "title": "AsyncSequence Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/asyncsequence-implementations",
    "html": "Topics\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "makeAsyncIterator()",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence.\n\nSee Also\nCreating an iterator\nstruct Iterator\ntypealias Element\nThe type of element produced by this asynchronous sequence."
  },
  {
    "title": "allSatisfy(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "reduce(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n\nSee Also\nTransforming a sequence\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "reduce(into:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary.\n\nSee Also\nTransforming a sequence\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure."
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/flatmap(_:)-7o987",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "min(by:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "max(by:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "flatMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/flatmap(_:)-15hti",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "prefix(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/map(_:)-3m7k5",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "reduce(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "prefix(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "prefix(while:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/map(_:)-6ntoh",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "max(by:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "min(by:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "reduce(into:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "dropFirst(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nSee Also\nExcluding elements\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "drop(while:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is.\n\nSee Also\nExcluding elements\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "prefix(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence.\n\nSee Also\nSelecting elements\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "prefix(while:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n\nSee Also\nSelecting elements\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence."
  },
  {
    "title": "makeAsyncIterator()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence.\n\nSee Also\nCreating an iterator\nstruct Iterator\ntypealias Element\nThe type of element produced by this asynchronous sequence."
  },
  {
    "title": "compactMap(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/compactmap(_:)-689fe",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/map(_:)-3wx19",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "source",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messagecontext/source",
    "html": "Discussion\n\nEach device has a unique participant. Use this property to determine the origin of the message."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/state-swift.enum/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (GroupSession<ActivityType>.State, GroupSession<ActivityType>.State) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nAvailable when ActivityType conforms to GroupActivity."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/state-swift.enum/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false.\n\nSee Also\nComparing states\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/state-swift.enum/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing states\nstatic func == (GroupSession<ActivityType>.State, GroupSession<ActivityType>.State) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nAvailable when ActivityType conforms to GroupActivity."
  },
  {
    "title": "RawRepresentable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/experience-swift.enum/rawrepresentable-implementations",
    "html": "Topics\nInitializers\ninit(from: any Decoder) throws\nCreates a new instance by decoding from the given decoder, when the type’s RawValue is Int.\nAvailable when Self conforms to Decodable and RawValue is Int.\nInstance Properties\nvar hashValue: Int\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable.\nInstance Methods\nfunc encode(to: any Encoder) throws\nEncodes this value into the given encoder, when the type’s RawValue is Int.\nAvailable when Self conforms to Encodable and RawValue is Int.\nfunc hash(into: inout Hasher)\nAvailable when Self conforms to Hashable and RawValue conforms to Hashable."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-2ijfu/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/experience-swift.enum/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "isDisjoint(with:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/isdisjoint(with:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set has no elements in common with other; otherwise, false.\n\nDiscussion\n\nIn the following example, the employees set is disjoint with the visitors set because no name appears in both sets.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet visitors: Set = [\"Marcia\", \"Nathaniel\", \"Olivia\"]\nprint(employees.isDisjoint(with: visitors))\n// Prints \"true\"\n"
  },
  {
    "title": "init(originator:localizedDescription:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/event/init(originator:localizeddescription:)",
    "html": "Deprecated\n\nUse the new initializer instead"
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/init()",
    "html": "Discussion\n\nThis initializer creates an option set with a raw value of zero."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/sceneassociationbehavior/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "GroupActivitySharingResult",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-1gln2",
    "html": "Topics\nOperators\nstatic func == (GroupActivitySharingResult, GroupActivitySharingResult) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nEnumeration Cases\ncase cancelled\nA result that indicates the user canceled the request.\ncase success\nA result that indicates the user wants to share the activity with the group.\nInstance Properties\nvar hashValue: Int\nThe hash value.\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nSee Also\nGetting the result\nvar result: GroupActivitySharingResult\nThe result of a request to share a group activity."
  },
  {
    "title": "contains(where:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFinding elements\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "max(by:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n\nSee Also\nFinding elements\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "min(by:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n\nSee Also\nFinding elements\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "prefix(while:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n\nSee Also\nSelecting elements\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence."
  },
  {
    "title": "GroupSessionEvent",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionevent",
    "html": "Overview\n\nUse this structure to specify the contents of custom activity-related events. The AV Foundation framework posts media-related events to the system on your app’s behalf; create an instance of this structure if your app posts additional events that don’t route through AV Foundation.\n\nAfter creating an instance of this structure, post it to the system using the showNotice(_:) method of GroupSession.\n\nTopics\nCreating a group session event\ninit(originator: Participant, action: GroupSessionEvent.Action, url: URL?)\nCreates a new event with the specified participant and action details.\nGetting the event details\nlet originator: Participant\nThe participant that initiated the event.\nlet url: URL?\nThe URL to open when the participant taps the event link in the system UI.\nlet action: GroupSessionEvent.Action\nThe reason for the event.\nstruct Action\nA playback-related change that occurs during the session.\nSee Also\nNotifying participants of playback changes\nfunc showNotice(GroupSessionEvent)\nPosts an event to the system, which displays the information in the system UI.\nAvailable when ActivityType conforms to GroupActivity."
  },
  {
    "title": "isSuperset(of:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/issuperset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a superset of another set B if every member of B is also a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isSuperset(of: attendees))\n// Prints \"true\"\n"
  },
  {
    "title": "subtract(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/subtract(_:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nDiscussion\n\nIn the following example, the elements of the employees set that are also members of the neighbors set are removed. In particular, the names \"Bethany\" and \"Eric\" are removed from employees.\n\nvar employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nemployees.subtract(neighbors)\nprint(employees)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "description",
    "url": "https://developer.apple.com/documentation/groupactivities/participant/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "insert(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/insert(_:)",
    "html": "Parameters\nnewMember\n\nThe element to insert.\n\nReturn Value\n\n(true, newMember) if newMember was not contained in self. Otherwise, returns (false, oldMember), where oldMember is the member of the set equal to newMember.\n\nDiscussion\n\nIn the following example, the .secondDay shipping option is added to the freeOptions option set if purchasePrice is greater than 50.0. For the ShippingOptions declaration, see the OptionSet protocol discussion.\n\nlet purchasePrice = 87.55\n\n\nvar freeOptions: ShippingOptions = [.standard, .priority]\nif purchasePrice > 50 {\n    freeOptions.insert(.secondDay)\n}\nprint(freeOptions.contains(.secondDay))\n// Prints \"true\"\n"
  },
  {
    "title": "formIntersection(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/formintersection(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a & (bitwise AND) operation on the two sets’ raw values."
  },
  {
    "title": "formUnion(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/formunion(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a | (bitwise OR) operation on the two sets’ raw values."
  },
  {
    "title": "intersection(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/intersection(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in both this set and other.\n\nDiscussion\n\nThis example uses the intersection(_:) method to limit the available shipping options to what can be used with a PO Box destination.\n\n// Can only ship standard or priority to PO Boxes\nlet poboxShipping: ShippingOptions = [.standard, .priority]\nlet memberShipping: ShippingOptions =\n        [.standard, .priority, .secondDay]\n\n\nlet availableOptions = memberShipping.intersection(poboxShipping)\nprint(availableOptions.contains(.priority))\n// Prints \"true\"\nprint(availableOptions.contains(.secondDay))\n// Prints \"false\"\n"
  },
  {
    "title": "remove(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/remove(_:)",
    "html": "Parameters\nmember\n\nThe element of the set to remove.\n\nReturn Value\n\nThe intersection of [member] and the set, if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIn the following example, the .priority shipping option is removed from the options option set. Attempting to remove the same shipping option a second time results in nil, because options no longer contains .priority as a member.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet priorityOption = options.remove(.priority)\nprint(priorityOption == .priority)\n// Prints \"true\"\n\n\nprint(options.remove(.priority))\n// Prints \"nil\"\n\n\nIn the next example, the .express element is passed to remove(_:). Although .express is not a member of options, .express subsumes the remaining .secondDay element of the option set. Therefore, options is emptied and the intersection between .express and options is returned.\n\nlet expressOption = options.remove(.express)\nprint(expressOption == .express)\n// Prints \"false\"\nprint(expressOption == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "subtracting(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/subtracting(_:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\nA new set.\n\nDiscussion\n\nIn the following example, the nonNeighbors set is made up of the elements of the employees set that are not elements of neighbors:\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet neighbors: Set = [\"Bethany\", \"Eric\", \"Forlani\", \"Greta\"]\nlet nonNeighbors = employees.subtracting(neighbors)\nprint(nonNeighbors)\n// Prints \"[\"Diana\", \"Chris\", \"Alicia\"]\"\n"
  },
  {
    "title": "symmetricDifference(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/symmetricdifference(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set with only the elements contained in either this set or other, but not in both."
  },
  {
    "title": "union(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/union(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nReturn Value\n\nA new option set made up of the elements contained in this set, in other, or in both.\n\nDiscussion\n\nThis example uses the union(_:) method to add two more shipping options to the default set.\n\nlet defaultShipping = ShippingOptions.standard\nlet memberShipping = defaultShipping.union([.secondDay, .priority])\nprint(memberShipping.contains(.priority))\n// Prints \"true\"\n"
  },
  {
    "title": "update(with:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/update(with:)",
    "html": "Return Value\n\nThe intersection of [newMember] and the set if the intersection was nonempty; otherwise, nil.\n\nDiscussion\n\nIf newMember is not contained in the set but subsumes current members of the set, the subsumed members are returned.\n\nvar options: ShippingOptions = [.secondDay, .priority]\nlet replaced = options.update(with: .express)\nprint(replaced == .secondDay)\n// Prints \"true\"\n"
  },
  {
    "title": "AsyncSequence Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/asyncsequence-implementations",
    "html": "Topics\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(Self.Element) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/sceneassociationbehavior/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "GroupSessionMessenger.Messages.Iterator",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> GroupSessionMessenger.Messages<Message>.Element?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> GroupSessionMessenger.Messages<Message>.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\ntypealias Element\nThe type of element produced by this asynchronous sequence."
  },
  {
    "title": "GroupSessionMessenger.Messages.Element",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/element",
    "html": "See Also\nCreating an iterator\nfunc makeAsyncIterator() -> GroupSessionMessenger.Messages<Message>.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Iterator"
  },
  {
    "title": "makeAsyncIterator()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence.\n\nSee Also\nCreating an iterator\nstruct Iterator\ntypealias Element\nThe type of element produced by this asynchronous sequence."
  },
  {
    "title": "loadMetadata(of:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachment/loadmetadata(of:)",
    "html": "Parameters\nof\n\nThe type for your attachment’s custom metadata. This type must match the one added with the attachment.\n\nReturn Value\n\nThe custom metadata object for the attachment.\n\nDiscussion\n\nUse this function to retrieve any metadata you included with the attachment. You might use this metadata to retrieve app-specific details that aren’t part of the item’s intrinsic data format.\n\nSee Also\nDownloading the attachment data\nfunc load<AttachmentType>(AttachmentType.Type) async throws -> AttachmentType\nDownloads the attachment data and asynchronously delivers it as the type you specify."
  },
  {
    "title": "SystemCoordinator.Configuration",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/configuration-swift.struct",
    "html": "Overview\n\nA SystemCoordinator.Configuration structure stores your app’s preferences for the creation and arrangement of Spatial Personas in a FaceTime call. Use this type to tell the system that you support activities that take place in one of your app’s immersive spaces, and how you want the system to arrange Spatial Personas around your app’s content. To create a shared simulation space for your activity, set the supportsGroupImmersiveSpace property to true.\n\nTo specify your app’s preferences, create a new SystemCoordinator.Configuration structure with those preferences and assign it to the configuration property of your SystemCoordinator object. Assign this value before you join the session for the activity.\n\nTopics\nCreating a configuration structure\ninit()\nCreates the type you use to specify your app’s preferences for shared contexts.\nSpecifying spatial position preferences\nvar spatialTemplatePreference: SpatialTemplatePreference\nThe preferred arrangement of Spatial Personas in your app’s immersive space.\nstruct SpatialTemplatePreference\nA structure that specifies the preferred arrangement of participant Spatial Personas in a shared simulation space.\nSupporting activities in immersive spaces\nvar supportsGroupImmersiveSpace: Bool\nA Boolean value that indicates whether your app supports a shared context when an immersive space is open.\nSee Also\nConfiguring the spatial coordinator\nvar configuration: SystemCoordinator.Configuration\nThe current configuration of the system coordinator."
  },
  {
    "title": "activityIdentifier",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivity/activityidentifier-4jgfp",
    "html": "Discussion\n\nImplement this property and return a value that uniquely identifies the activity within your app. An app may support multiple activities, and each activity requires a unique identifier string. Use reverse-DNS notation for your identifier strings. For example, supply a string like \"com.mycompany.myapp.watchmovie\" for a movie-watching activity.\n\nIf you don’t implement this property yourself, the default implementation composes an activity identifier using your app’s bundle identifier and the current class or struct name. For example, if the app’s bundle identifier is \"com.mycompany.myapp\" and your activity type name is MovieActivity, the resulting identifier string is \"com.mycompany.myapp.MovieActivity\"."
  },
  {
    "title": "map(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/map(_:)-ocge",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "AsyncSequence Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles/asyncsequence-implementations",
    "html": "Topics\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc contains(Self.Element) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "SystemCoordinator",
    "url": "https://developer.apple.com/documentation/GroupActivities/SystemCoordinator",
    "html": "Overview\n\nA SystemCoordinator object helps you coordinate the presentation of your app’s content when spatial placement is active. In visionOS, the system can present a SharePlay activity as if the participants were together in the same room with the content. Each participant views the content from a particular vantage point, and sees the changes that others make. The system handles the placement of each participant’s Spatial Persona relative to the content, but you handle any changes to the content itself with the help of the SystemCoordinator object.\n\nYou don’t create a SystemCoordinator object directly. After you receive a GroupSession object for an activity, retrieve the system coordinator from the session’s systemCoordinator property. When you first retrieve the object, update its configuration property to tell the system how you want to arrange participants in the scene. After that, use the information in the system coordinator’s properties to keep your app’s interface up to date. When participants support spatial placement, send additional data to synchronize your content for those participants. For example, when one person scrolls the contents of a window, update the scroll position in the window of other spatially aware participants to preserve the shared context for everyone.\n\nYou choose what information to share among participants, and you choose how to manage the corresponding updates. A system coordinator object only helps you know when to make those changes. Observe the object’s published properties to receive automatic updates when the values change.\n\nTopics\nConfiguring the spatial coordinator\nvar configuration: SystemCoordinator.Configuration\nThe current configuration of the system coordinator.\nstruct Configuration\nA structure that specifies your app’s support for activities that take place in a shared simulation space.\nGetting the participant state\nvar localParticipantState: SystemCoordinator.ParticipantState\nThe current participant’s level of support for an activity that takes place in a shared simulation space.\nvar localParticipantStates: SystemCoordinator.ParticipantStates\nAn asynchronous sequence that reports changes to the local participant’s state.\nstruct ParticipantStates\nAn asynchronous sequence that reports the current person’s ability to participate in a shared context.\nGetting the current immersion level\nvar groupImmersionStyle: SystemCoordinator.GroupImmersionStyles\nThe presentation style to apply to an immersive space for the current activity.\nstruct GroupImmersionStyles\nAn asynchronous sequence that contains one or more incoming immersion styles for you to process.\nSee Also\nSpatial activities\nAdding Spatial Persona support to an activity\nUpdate your SharePlay activities to support Spatial Personas and the shared context when running in visionOS.\nstruct ParticipantState\nA structure that tells you whether a participant supports a shared simulation space for the current activity."
  },
  {
    "title": "init(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/init(_:)",
    "html": "Parameters\nsequence\n\nThe elements to use as members of the new set.\n\nDiscussion\n\nUse this initializer to create a new set from an existing sequence, like an array or a range:\n\nlet validIndices = Set(0..<7).subtracting([2, 4, 5])\nprint(validIndices)\n// Prints \"[6, 0, 1, 3]\"\n"
  },
  {
    "title": "init(arrayLiteral:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/init(arrayliteral:)",
    "html": "Parameters\narrayLiteral\n\nA list of elements of the new set.\n\nDiscussion\n\nDo not call this initializer directly. It is used by the compiler when you use an array literal. Instead, create a new set using an array literal as its value by enclosing a comma-separated list of values in square brackets. You can use an array literal anywhere a set is expected by the type context.\n\nHere, a set of strings is created from an array literal holding only strings:\n\nlet ingredients: Set = [\"cocoa beans\", \"sugar\", \"cocoa butter\", \"salt\"]\nif ingredients.isSuperset(of: [\"sugar\", \"salt\"]) {\n    print(\"Whatever it is, it's bound to be delicious!\")\n}\n// Prints \"Whatever it is, it's bound to be delicious!\"\n"
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/experience-swift.enum/init(rawvalue:)",
    "html": "Parameters\nrawValue\n\nThe raw value to use for the new instance.\n\nDiscussion\n\nIf there is no value of the type that corresponds with the specified raw value, this initializer returns nil. For example:\n\nenum PaperSize: String {\n    case A4, A5, Letter, Legal\n}\n\n\nprint(PaperSize(rawValue: \"Legal\"))\n// Prints \"Optional(\"PaperSize.Legal\")\"\n\n\nprint(PaperSize(rawValue: \"Tabloid\"))\n// Prints \"nil\"\n"
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/experience-swift.enum/rawvalue-swift.property",
    "html": "Discussion\n\nA new instance initialized with rawValue will be equivalent to this instance. For example:\n\nenum PaperSize: String {\n    case A4, A5, Letter, Legal\n}\n\n\nlet selectedSize = PaperSize.Letter\nprint(selectedSize.rawValue)\n// Prints \"Letter\"\n\n\nprint(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)\n// Prints \"true\"\n"
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/activitytype/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "GroupActivitySharingResult.cancelled",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-2ijfu/cancelled",
    "html": "See Also\nGetting the result\ncase success\nA result that indicates someone wants to share the activity with the group."
  },
  {
    "title": "first(where:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.\n\nSee Also\nFinding elements\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "allSatisfy(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true.\n\nSee Also\nFinding elements\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "prefix(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence.\n\nSee Also\nSelecting elements\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "dropFirst(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nSee Also\nExcluding elements\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "drop(while:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is.\n\nSee Also\nExcluding elements\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate."
  },
  {
    "title": "isSubset(of:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/issubset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a subset of another set B if every member of A is also a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isSubset(of: employees))\n// Prints \"true\"\n"
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/deliverymode-swift.enum/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false.\n\nSee Also\nComparing the delivery mode options\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/deliverymode-swift.enum/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/deliverymode-swift.enum/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/deliverymode-swift.enum/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "conversational",
    "url": "https://developer.apple.com/documentation/groupactivities/spatialtemplatepreference/conversational",
    "html": "Discussion\n\nThis arrangement works best when you want participants to converse with each other and also look at your app’s content.\n\nFor example:\n\n      App\n\n\nA             C\n\n\n       B\n\nSee Also\nGetting the spatial position preferences\nstatic var none: SpatialTemplatePreference\nAn arrangement where the system places Spatial Personas based on your app’s content.\nstatic var sideBySide: SpatialTemplatePreference\nAn arrangement where the participants sit in a line with the content in front of them."
  },
  {
    "title": "showNotice(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/shownotice(_:)",
    "html": "Parameters\nevent\n\nThe event to display in the system UI.\n\nDiscussion\n\nCall this method to update the system’s UI with information about session-related events. For example, a music-listening app might post an event to notify the group that a participant stopped playback. The system displays the event information only on the current device, and doesn’t forward events to other devices.\n\nSee Also\nNotifying participants of playback changes\nstruct GroupSessionEvent\nA session-related event that appears in the system UI."
  },
  {
    "title": "supportsGroupImmersiveSpace",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/configuration-swift.struct/supportsgroupimmersivespace",
    "html": "Discussion\n\nIf your app presents an immersive space, set this property to true if you want the system to display Spatial Personas when that space is open. The default value of this property is false.\n\nAn immersive space places a person in their own private experience. To prevent the disruption of that experience, the system disables Spatial Personas by default when any immersive space is open. Setting this property to true tells the system that it can once again display Spatial Personas when an immersive space is open.\n\nWhen displaying Spatial Personas in an immersive space, the system establishes a shared coordinate space among the participants. Specifically, the system moves the origin of the coordinate space to a shared location, which it derives from the template in the spatialTemplatePreference property. Any content you place in the immersive space subsequently appears in the correct relative location from each participant’s perspective. To place content in front of a specific participant, use a GeometryReader3D object to read the geometry of your scene. The doc://com.apple.documentation/documentation/swiftui/geometryproxy3d/immersivespacedisplacement(in:) method of GeometryProxy3D provides you with the offset from the current participant to the shared origin, which you can use to position your content."
  },
  {
    "title": "description",
    "url": "https://developer.apple.com/documentation/groupactivities/spatialtemplatepreference/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstate/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."
  },
  {
    "title": "GroupSession.Event",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/event",
    "html": "Overview\n\nUse this structure to specify the contents of custom activity-related events. The AV Foundation framework posts media-related events to the system on your app’s behalf; create an instance of this structure if your app posts additional events that don’t route through AV Foundation.\n\nAfter creating an instance of this structure, post it to the system using the showNotice(_:) method of GroupSession.\n\nTopics\nGetting the event details\nlet originator: Participant\nThe participant that initiated the event.\nDeprecated\nInitializers\ninit(originator: Participant, localizedDescription: String)\nAvailable when ActivityType conforms to GroupActivity.\nDeprecated\nInstance Properties\nvar localizedDescription: String\nA localized description of the event\nAvailable when ActivityType conforms to GroupActivity."
  },
  {
    "title": "isStrictSuperset(of:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/isstrictsuperset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict superset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict superset of another set B if every member of B is also a member of A and A contains at least one element that is not a member of B.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(employees.isStrictSuperset(of: attendees))\n// Prints \"true\"\n\n\n// A set is never a strict superset of itself:\nprint(employees.isStrictSuperset(of: employees))\n// Prints \"false\"\n"
  },
  {
    "title": "formSymmetricDifference(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/formsymmetricdifference(_:)",
    "html": "Parameters\nother\n\nAn option set.\n\nDiscussion\n\nThis method is implemented as a ^ (bitwise XOR) operation on the two sets’ raw values."
  },
  {
    "title": "contains(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/contains(_:)",
    "html": "Parameters\nmember\n\nThe element to look for in the option set.\n\nReturn Value\n\ntrue if the option set contains member; otherwise, false.\n\nDiscussion\n\nThis example uses the contains(_:) method to check whether next-day shipping is in the availableOptions instance.\n\nlet availableOptions = ShippingOptions.express\nif availableOptions.contains(.nextDay) {\n    print(\"Next day shipping available\")\n}\n// Prints \"Next day shipping available\"\n"
  },
  {
    "title": "isStrictSubset(of:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/isstrictsubset(of:)",
    "html": "Parameters\nother\n\nA set of the same type as the current set.\n\nReturn Value\n\ntrue if the set is a strict subset of other; otherwise, false.\n\nDiscussion\n\nSet A is a strict subset of another set B if every member of A is also a member of B and B contains at least one element that is not a member of A.\n\nlet employees: Set = [\"Alicia\", \"Bethany\", \"Chris\", \"Diana\", \"Eric\"]\nlet attendees: Set = [\"Alicia\", \"Bethany\", \"Diana\"]\nprint(attendees.isStrictSubset(of: employees))\n// Prints \"true\"\n\n\n// A set is never a strict subset of itself:\nprint(attendees.isStrictSubset(of: attendees))\n// Prints \"false\"\n"
  },
  {
    "title": "systemCoordinator",
    "url": "https://developer.apple.com/documentation/GroupActivities/GroupSession/systemCoordinator",
    "html": "Discussion\n\nAfter you join an activity, access this property to determine if a system coordinator object is available. The system coordinator informs you when the device supports Spatial Personas, and when the current participant’s Spatial Persona is available to use in the current activity. When a Spatial Persona is available, update the information you share for the activity and how you present that content. For more information, see SystemCoordinator."
  },
  {
    "title": "CustomStringConvertible Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/customstringconvertible-implementations",
    "html": "Topics\nInstance Properties\nvar description: String\nA textual representation of this instance.\nAvailable when ActivityType conforms to GroupActivity."
  },
  {
    "title": "postEvent(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/postevent(_:)",
    "html": "Deprecated\n\nUse GroupSessionEvent\n\nParameters\nevent\n\nThe event to display in the system UI.\n\nDiscussion\n\nCall this method to update the system’s UI with information about session-related events. For example, a music-listening app might post an event to notify the group that a participant added a song to a shared playlist. The system displays the event information only on the current device. It doesn’t forward events to other devices."
  },
  {
    "title": "systemCoordinator",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/systemcoordinator",
    "html": "Discussion\n\nAfter you join an activity, access this property to determine if a system coordinator object is available. The system coordinator informs you when the device supports Spatial Personas, and when the current participant’s Spatial Persona is available to use in the current activity. When a Spatial Persona is available, update the information you share for the activity and how you present that content. For more information, see SystemCoordinator."
  },
  {
    "title": "makeAsyncIterator()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/makeasynciterator()",
    "html": "Discussion\n\n-Returns: An instance of the Iterator type that produces elements of the asynchronous sequence.\n\nSee Also\nCreating an iterator\nstruct Iterator\nThe asynchronous iterator that produces a sequence of attachments.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "GroupSessionJournal.Attachments.Iterator",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/iterator",
    "html": "Topics\nInstance Methods\nfunc next() async -> GroupSessionJournal.Attachments.Element?\nAsynchronously advances to the next element and returns it, or ends the sequence if there is no next element.\nType Aliases\ntypealias Element\nRelationships\nConforms To\nAsyncIteratorProtocol\nSee Also\nCreating an iterator\nfunc makeAsyncIterator() -> GroupSessionJournal.Attachments.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\ntypealias Element\nThe type of element this asynchronous sequence produces."
  },
  {
    "title": "exportingCondition(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitytransferrepresentation/exportingcondition(_:)",
    "html": "Parameters\ncondition\n\nA closure that determines whether the item is exportable. Don’t perform long-running work in this closure. It shouldn’t contain network requests, file operations, or other potentially time-consuming tasks as they can cause delays during operations with Transferable items.\n\nDiscussion\n\nSome instances of a model type may have state-dependent conditions that make them unsuitable for export. For example, an Archive structure that supports a comma-separated text representation only when it has compatible content:\n\nstruct Archive {\n    var supportsCSV: Bool\n    func csvData() -> Data\n    init(csvData: Data)\n}\n\n\nextension Archive: Transferable {\n    static var transferRepresentation: some TransferRepresentation {\n        DataRepresentation(contentType: .commaSeparatedText) { archive in\n            archive.csvData()\n        } importing: { data in Archive(csvData: data) }\n            .exportingCondition { archive in archive.supportsCSV }\n    }\n}\n"
  },
  {
    "title": "GroupSessionJournal.Attachments.Element",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct/element",
    "html": "See Also\nCreating an iterator\nfunc makeAsyncIterator() -> GroupSessionJournal.Attachments.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Iterator\nThe asynchronous iterator that produces a sequence of attachments."
  },
  {
    "title": "visibility(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitytransferrepresentation/visibility(_:)",
    "html": "Parameters\nvisibility\n\nThe visibility level."
  },
  {
    "title": "suggestedFileName(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitytransferrepresentation/suggestedfilename(_:)-7r3h",
    "html": "Parameters\nfileName\n\nThe suggested filename including the filename extension. If several suggested file names are specified on an item, only the last one will be used.\n\nDiscussion\n\nAny transfer representation can be written to disk.\n\n extension ImageDocumentLayer: Transferable {\n     static var transferRepresentation: some TransferRepresentation {\n         DataRepresentation(contentType: .layer) { layer in\n             layer.data()\n             } importing: { data in\n                 try ImageDocumentLayer(data: data)\n             }\n             .suggestedFileName(\"Layer.exampleLayer\")\n         DataRepresentation(exportedContentType: .png) { layer in\n             layer.pngData()\n         }\n         .suggestedFileName(\"Layer.png\")\n     }\n }\n\n\nThe .exampleLayer filename extension above should match the extension for the layer content type, which you declare in your app’s Info.plist file."
  },
  {
    "title": "suggestedFileName(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitytransferrepresentation/suggestedfilename(_:)-1290n",
    "html": "Parameters\nfileName\n\nThe optional closure that returns the suggested filename including the filename extension. If several suggested file names are specified on an item, only the last one will be used.\n\nDiscussion\n\nAny transfer representation can be written to disk.\n\nstruct Note: Transferable {\n    var title: String\n    var body: String\n    static var transferRepresentation: some TransferRepresentation {\n        ProxyRepresentation(exporting: \\.body)\n            .suggestedFileName { $0.title + \".txt\" }\n     }\n }\n"
  },
  {
    "title": "SystemCoordinator.ParticipantStates",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstates",
    "html": "Topics\nCreating an iterator\nfunc makeAsyncIterator() -> SystemCoordinator.ParticipantStates.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Iterator\ntypealias Element\nThe type of element produced by this asynchronous sequence.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence\nSee Also\nGetting the participant state\nvar localParticipantState: SystemCoordinator.ParticipantState\nThe current participant’s level of support for an activity that takes place in a shared simulation space.\nvar localParticipantStates: SystemCoordinator.ParticipantStates\nAn asynchronous sequence that reports changes to the local participant’s state."
  },
  {
    "title": "Participants.only(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/participants/only(_:)-swift.enum.case",
    "html": "See Also\nGetting the set of participants\ncase all\nThe set of all participants.\nstatic func only(Participant) -> Participants\nReturns a set containing the specified participant."
  },
  {
    "title": "configuration",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/configuration-swift.property",
    "html": "Discussion\n\nThis property stores the SystemCoordinator object’s current support for displaying Spatial Personas and placing them and your content in a shared simulation space. Assign a new value to this property to support Spatial Personas and shared context in the current activity. The default configuration doesn’t enable support for these features.\n\nSee Also\nConfiguring the spatial coordinator\nstruct Configuration\nA structure that specifies your app’s support for activities that take place in a shared simulation space."
  },
  {
    "title": "groupImmersionStyle",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyle",
    "html": "Discussion\n\nDuring an activity, the system uses this property to communicate the style for a currently open immersive space. When no participants are displaying an immersive space, the value of this property is nil. When any participant displays a space, the system sets the value for all participants to the immersion style of the newly presented space. When a participant presents a space with a different presentation style, the system also updates the property to reflect the new style. For example, if the group is currently in a space with the full style, it updates the property when someone presents a space with the full style.\n\nUse this property to synchronize the level of immersion for all participants. Keeping the participants at the same level of immersion preserves the shared context of your activity. When the value of the property changes, transition the current participant to the new immersion level only if doing so doesn’t disrupt any other ongoing tasks. For example, if the current person is editing content in an unrelated window, don’t transition them automatically. Instead, give them the choice of when to make the transition.\n\nSee Also\nGetting the current immersion level\nstruct GroupImmersionStyles\nAn asynchronous sequence that contains one or more incoming immersion styles for you to process."
  },
  {
    "title": "GroupSession.State.invalidated(reason:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/state-swift.enum/invalidated(reason:)",
    "html": "Discussion\n\nThe session transitions to this state when an error occurs, when the FaceTime call ends, or when your app calls the leave() method. When a session is in this state, don’t attempt to join, leave, or end the session again. Instead, release resources related to the session, including the session object itself.\n\nSee Also\nSession states\ncase waiting\nAn idle state that indicates the session is waiting for the app to join the activity.\ncase joined\nAn active state that indicates the session allows data synchronization between devices."
  },
  {
    "title": "ObservableObject Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/observableobject-implementations",
    "html": "Topics\nInstance Properties\nvar objectWillChange: ObservableObjectPublisher\nA publisher that emits before the object has changed.\nAvailable when ObjectWillChangePublisher is ObservableObjectPublisher."
  },
  {
    "title": "none",
    "url": "https://developer.apple.com/documentation/groupactivities/sceneassociationbehavior/none",
    "html": "Discussion\n\nChoose this option when you don’t want the system to associate one of your scenes with the SharePlay activity. You might choose this option when you handle an activity separately from your app’s scenes.\n\nSee Also\nGetting the scene-association options\nstatic let `default`: SceneAssociationBehavior\nA behavior that matches the activity to a scene using the identifier of your activity object.\nstatic func content(String) -> SceneAssociationBehavior\nA behavior that matches the activity to a scene using a custom string that you supply."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/participant/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA Value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing participants\nstatic func == (Participant, Participant) -> Bool\nReturns a Boolean value indicating whether two values are equal."
  },
  {
    "title": "messageIdentifier",
    "url": "https://developer.apple.com/documentation/groupactivities/custommessageidentifiable/messageidentifier",
    "html": "Required\n\nDiscussion\n\nThe string you return from this property must be unique among your app’s custom message types. When you send a message, GroupSessionMessenger includes this string in the data it sends to other devices. When it receives a message, GroupSessionMessenger creates the type that contains the matching string in this property."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/activitytype/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "result",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingcontroller-4gtfk/result",
    "html": "Discussion\n\nUse this property to perform actions related to the starting of the activity. You don’t need to start the activity itself, since the view controller automatically joins your app to the activity when the result is GroupActivitySharingResult/success.\n\nSee Also\nGetting the result\nenum GroupActivitySharingResult\nThe result of a request to share a group activity in macOS."
  },
  {
    "title": "init(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingcontroller-4gtfk/init(_:)",
    "html": "Parameters\nactivity\n\nThe activity object to start.\n\nSee Also\nCreating the group activity sharing controller\ninit<ActivityType>(preparationHandler: () async throws -> ActivityType)\nInitializes the SharePlay sharing controller with a closure that creates the activity object."
  },
  {
    "title": "init(preparationHandler:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingcontroller-4gtfk/init(preparationhandler:)",
    "html": "Parameters\npreparationHandler\n\nA closure that takes no parameters and returns the activity object.\n\nDiscussion\n\nThe initializer executes the closure asynchronously so that your app can present the view controller in a timely manner. Use this method when the creation of the GroupActivity object might take a significant amount of time.\n\nSee Also\nCreating the group activity sharing controller\ninit<ActivityType>(ActivityType) throws\nInitializes the sharing controller with the specified activity and type information."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/activitytype/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/activitytype/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false.\n\nSee Also\nComparing Activity Types\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "description",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/description",
    "html": "Discussion\n\nCalling this property directly is discouraged. Instead, convert an instance of any type to a string by using the String(describing:) initializer. This initializer works with any type, and uses the custom description property for types that conform to CustomStringConvertible:\n\nstruct Point: CustomStringConvertible {\n    let x: Int, y: Int\n\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nlet p = Point(x: 21, y: 30)\nlet s = String(describing: p)\nprint(s)\n// Prints \"(21, 30)\"\n\n\nThe conversion of p to a string in the assignment to s uses the Point type’s description property.\n\nSee Also\nGetting the session details\nvar state: GroupSession<ActivityType>.State\nThe current state of the session.\nenum State\nThe possible states of a session.\nlet id: UUID\nThe unique identifier of the current session."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/activitytype/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing Activity Types\nstatic func == (GroupActivityMetadata.ActivityType, GroupActivityMetadata.ActivityType) -> Bool\nReturns a Boolean value indicating whether two values are equal."
  },
  {
    "title": "watchTogether",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/activitytype/watchtogether",
    "html": "See Also\nGetting the Activity Types\nstatic let generic: GroupActivityMetadata.ActivityType\nA generic activity.\nstatic let listenTogether: GroupActivityMetadata.ActivityType\nA shared listening activity, such as listening to music together."
  },
  {
    "title": "sceneSessionIdentifier",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/scenesessionidentifier",
    "html": "Discussion\n\nUse this property to determine which of your app’s scenes belongs with this session. You can configure a GroupActivity object with a SceneAssociationBehavior type that tells the system how to associate the activity with one of your app’s scenes. After matching the activity to a specific scene, the system places the scene identifier in this property."
  },
  {
    "title": "listenTogether",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/activitytype/listentogether",
    "html": "See Also\nGetting the Activity Types\nstatic let generic: GroupActivityMetadata.ActivityType\nA generic activity.\nstatic let watchTogether: GroupActivityMetadata.ActivityType\nA shared watching activity, such as watching an episode of a television show together."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-2ijfu/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-2ijfu/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "GroupActivitySharingResult.success",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-2ijfu/success",
    "html": "See Also\nGetting the result\ncase cancelled\nA result that indicates someone canceled the request."
  },
  {
    "title": "Encodable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/encodable-implementations",
    "html": "Topics\nInstance Methods\nfunc encode(to: any Encoder) throws\nEncodes this value into the given encoder."
  },
  {
    "title": "BroadcastOptions.Element",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/element",
    "html": "Discussion\n\nTo inherit all the default implementations from the OptionSet protocol, the Element type must be Self, the default."
  },
  {
    "title": "init(rawValue:)",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/init(rawvalue:)",
    "html": "Parameters\nrawValue\n\nThe value from which to create the broadcasting attributes.\n\nSee Also\nCreating options from a raw value\nlet rawValue: Int\nThe raw value."
  },
  {
    "title": "rawValue",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/rawvalue-swift.property",
    "html": "See Also\nCreating options from a raw value\ninit(rawValue: Int)\nCreates a set of options from a raw value."
  },
  {
    "title": "mirroredVideo",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/mirroredvideo",
    "html": "Discussion\n\nInclude this option when your activity includes left-right directions in the video for the FaceTime call. The option mirrors the video along the vertical axis, which makes it easy for participants to mimic an instuctor’s movements. Without mirroring, views move in the opposite direction of the instructor, which can be jarring."
  },
  {
    "title": "GroupSession.Sessions",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/sessions",
    "html": "Overview\n\nWhen a participant engages one of your app’s activities, a Sessions structure provides the session you use to handle synchronization. Iterate over the contents of this structure asynchronously to retrieve each new session the system delivers to your app. The system delivers only one GroupSession for each activity. To monitor changes to that session, configure subscribers to its published properties.\n\nDon’t create this structure directly. Instead, use the sessions() method to retrieve the sessions.\n\nTopics\nCreating an iterator\nfunc makeAsyncIterator() -> GroupSession<ActivityType>.Sessions.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Iterator\ntypealias Element\nThe type of element produced by this asynchronous sequence.\nFinding elements\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nSelecting elements\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nExcluding elements\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nTransforming a sequence\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence"
  },
  {
    "title": "subtitle",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/subtitle",
    "html": "Discussion\n\nUse this string to provide additional descriptive information about the activity. For example, specify the season and episode information for a television-watching activity. Localize the string for the current device. The system displays this string along with the title in the system UI.\n\nSee Also\nPresenting the activity\nvar title: String?\nThe localized string to display as the title of your activity.\nvar previewImage: CGImage?\nThe image to display for the current activity.\nvar fallbackURL: URL?\nA URL that offers participants a way to identify or join the activity from a web browser."
  },
  {
    "title": "AsyncSequence Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/asyncsequence-implementations",
    "html": "Topics\nInstance Methods\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "reduce(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n\nSee Also\nTransforming a sequence\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value."
  },
  {
    "title": "reduce(into:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary.\n\nSee Also\nTransforming a sequence\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure."
  },
  {
    "title": "filter(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n\nSee Also\nExcluding elements\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/deliverymode-swift.enum/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing the delivery mode options\nstatic func == (GroupSessionMessenger.DeliveryMode, GroupSessionMessenger.DeliveryMode) -> Bool\nReturns a Boolean value indicating whether two values are equal."
  },
  {
    "title": "GroupSessionMessenger.DeliveryMode.unreliable",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/deliverymode-swift.enum/unreliable",
    "html": "Discussion\n\nUse this approach when it’s okay to drop messages occasionally. Typically, you use this approach for messages you send frequently with similar information. For example, use it when the information in each new message replaces information in the preceding message.\n\nThis approach makes a best-effort attempt to deliver your messages to the known participants, and makes no guarantees on the delivery order of messages.\n\nSee Also\nGetting the delivery mode options\ncase reliable\nAn attempt to ensure the delivery of messages to known participants."
  },
  {
    "title": "SpatialTemplatePreference",
    "url": "https://developer.apple.com/documentation/groupactivities/spatialtemplatepreference",
    "html": "Overview\n\nUse the static members of this structure to specify your preferred arrangement of participants around your app’s content. The system applies your preference only when displaying Spatial Personas in the scene.\n\nTopics\nGetting the spatial position preferences\nstatic var none: SpatialTemplatePreference\nAn arrangement where the system places Spatial Personas based on your app’s content.\nstatic var sideBySide: SpatialTemplatePreference\nAn arrangement where the participants sit in a line with the content in front of them.\nstatic var conversational: SpatialTemplatePreference\nAn arrangement where the participants can see one another and the app’s content.\nSpecifying the distance between content and participants\nfunc contentExtent(CGFloat) -> SpatialTemplatePreference\nSets the distance between the app’s content and any participants.\nGetting the template description\nvar description: String\nA textual representation of this instance.\nRelationships\nConforms To\nCustomStringConvertible\nSee Also\nSpecifying spatial position preferences\nvar spatialTemplatePreference: SpatialTemplatePreference\nThe preferred arrangement of Spatial Personas in your app’s immersive space."
  },
  {
    "title": "only(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/participants/only(_:)-swift.type.method",
    "html": "Parameters\nparticipant\n\nThe participant to add to the set.\n\nSee Also\nGetting the set of participants\ncase all\nThe set of all participants.\ncase only(Set<Participant>)\nA custom subset of participants."
  },
  {
    "title": "none",
    "url": "https://developer.apple.com/documentation/groupactivities/spatialtemplatepreference/none",
    "html": "Discussion\n\nWith this option, the system examines your app’s content to determine the best arrangement. For content in a vertical plane such as a window, the system arranges participants side by side and facing the content. For volumes, the system surrounds the volume with the participants. This option is the default.\n\nSee Also\nGetting the spatial position preferences\nstatic var sideBySide: SpatialTemplatePreference\nAn arrangement where the participants sit in a line with the content in front of them.\nstatic var conversational: SpatialTemplatePreference\nAn arrangement where the participants can see one another and the app’s content."
  },
  {
    "title": "sideBySide",
    "url": "https://developer.apple.com/documentation/groupactivities/spatialtemplatepreference/sidebyside",
    "html": "Discussion\n\nThe participants are side by side and face your app’s shared content. This arrangement works best for windows and other vertically oriented content. For example, you might use it for a group of participants watching a movie. However, you can apply it to any for other content configurations.\n\nFor example:\n\n        App\n\n\nA     B     C     D\n\nSee Also\nGetting the spatial position preferences\nstatic var none: SpatialTemplatePreference\nAn arrangement where the system places Spatial Personas based on your app’s content.\nstatic var conversational: SpatialTemplatePreference\nAn arrangement where the participants can see one another and the app’s content."
  },
  {
    "title": "Participants.all",
    "url": "https://developer.apple.com/documentation/groupactivities/participants/all",
    "html": "See Also\nGetting the set of participants\ncase only(Set<Participant>)\nA custom subset of participants.\nstatic func only(Participant) -> Participants\nReturns a set containing the specified participant."
  },
  {
    "title": "spatialTemplatePreference",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/configuration-swift.struct/spatialtemplatepreference",
    "html": "Discussion\n\nWhen the system displays Spatial Personas, it uses the value of this property to determine how to arrange them around the content in your app’s immersive space. The default value of this property is none , which lets the system determine placement based on the activity’s content. Specify other options if you prefer a specific arrangement around your app’s content.\n\nSee Also\nSpecifying spatial position preferences\nstruct SpatialTemplatePreference\nA structure that specifies the preferred arrangement of participant Spatial Personas in a shared simulation space."
  },
  {
    "title": "SystemCoordinator.GroupImmersionStyles",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/groupimmersionstyles",
    "html": "Overview\n\nWhen a participant in an activity changes the immersion style of their immersive space, the system adds the style to this sequence. Configure an asynchronous task to monitor this sequence and process results when they arrive.\n\nThe following example shows you how to configure this task and use it to iterate over the available items. The systemCoordinator variable contains the session’s SystemCoordinator object.\n\nTask.detached {\n    for await immersionStyle in systemCoordinator.groupImmersionStyle {\n        if let immersionStyle {\n            // Open an immersive space with the same style.\n        }\n        else {\n            // Dismiss the immersive space.\n        }\n    }\n}\n\nTopics\nClasses\nclass Iterator\nInstance Methods\nfunc makeAsyncIterator() -> SystemCoordinator.GroupImmersionStyles.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\ntypealias Element\nThe type of element produced by this asynchronous sequence.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence\nSee Also\nGetting the current immersion level\nvar groupImmersionStyle: SystemCoordinator.GroupImmersionStyles\nThe presentation style to apply to an immersive space for the current activity."
  },
  {
    "title": "GroupSessionMessenger.MessageContext",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messagecontext",
    "html": "Topics\nGetting the initiating participant\nvar source: Participant\nThe participant device that sent the message.\nSee Also\nReceiving data from other participants\nfunc messages(of: Data.Type) -> GroupSessionMessenger.Messages<Data>\nReturns the asynchronous sequence of messages that contain a generic data object.\nfunc messages<Message>(of: Message.Type) -> GroupSessionMessenger.Messages<Message>\nReturns the asynchronous sequence of messages that match the app-specific type.\nstruct Messages\nAn asynchronous sequence of messages sent to the session."
  },
  {
    "title": "content(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/sceneassociationbehavior/content(_:)",
    "html": "Parameters\ncontentIdentifier\n\nThe string to compare against the scene’s defined activation conditions. This string has a similar purpose to the targetContentIdentifier of an NSUserActivity object.\n\nReturn Value\n\nA SceneAssociationBehavior type with the specified identifier.\n\nDiscussion\n\nUse this option when you want more control over the scene-selection process for your GroupActivity object. You might use it to direct the activity to different scenes, or to direct the activity to a specific instance of a scene. For example, a drawing app might direct the activity to the specific canvas someone wants to share, and not to a new or unrelated canvas that uses the same scene type.\n\nSee Also\nGetting the scene-association options\nstatic let `default`: SceneAssociationBehavior\nA behavior that matches the activity to a scene using the identifier of your activity object.\nstatic let none: SceneAssociationBehavior\nA behavior that doesn’t match any scenes to the activity."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/groupactivities/participant/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/groupactivities/participant/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/participant/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false.\n\nSee Also\nComparing participants\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/groupactivities/participant/id-swift.property",
    "html": "Discussion\n\nUse this property to differentiate among the devices active in a session."
  },
  {
    "title": "end()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/end()",
    "html": "Discussion\n\nCall this method to end the activity for all participants. When you call this method, the session transitions to the GroupSession.State.invalidated(reason:) state and stops the delivery of session-related updates. After ending the session, you can’t join it again.\n\nDon’t call this method on a session already in the GroupSession.State.invalidated(reason:) state.\n\nSee Also\nJoining and leaving the session\nfunc join()\nStarts the shared activity on the current device.\nfunc leave()\nLeaves the current activity and stops receiving synchronized data."
  },
  {
    "title": "GroupSession.State.joined",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/state-swift.enum/joined",
    "html": "Discussion\n\nCall the join() method to begin the transition to this state. When the transition completes, use the session object to synchronize your app’s data with the other participants’ devices.\n\nSee Also\nSession states\ncase waiting\nAn idle state that indicates the session is waiting for the app to join the activity.\ncase invalidated(reason: any Error)\nA state that indicates the session is no longer valid and can’t be used for shared activities."
  },
  {
    "title": "GroupSession.State.waiting",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/state-swift.enum/waiting",
    "html": "See Also\nSession states\ncase joined\nAn active state that indicates the session allows data synchronization between devices.\ncase invalidated(reason: any Error)\nA state that indicates the session is no longer valid and can’t be used for shared activities."
  },
  {
    "title": "state",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/state-swift.property",
    "html": "Discussion\n\nUse this property to get the current state value, or configure a subscriber to detect changes to the value. To change the state of a session, call the join() and leave() methods.\n\nIf a failure occurs or the session ends, the session object transitions to the GroupSession.State.invalidated(reason:)state. If the session ends because of an error, it provides information about that error.\n\nSee Also\nGetting the session details\nenum State\nThe possible states of a session.\nlet id: UUID\nThe unique identifier of the current session.\nvar description: String\nA textual representation of this instance.\nAvailable when ActivityType conforms to GroupActivity."
  },
  {
    "title": "GroupSession.State",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/state-swift.enum",
    "html": "Topics\nSession states\ncase waiting\nAn idle state that indicates the session is waiting for the app to join the activity.\ncase joined\nAn active state that indicates the session allows data synchronization between devices.\ncase invalidated(reason: any Error)\nA state that indicates the session is no longer valid and can’t be used for shared activities.\nComparing states\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (GroupSession<ActivityType>.State, GroupSession<ActivityType>.State) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nAvailable when ActivityType conforms to GroupActivity.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nSee Also\nGetting the session details\nvar state: GroupSession<ActivityType>.State\nThe current state of the session.\nlet id: UUID\nThe unique identifier of the current session.\nvar description: String\nA textual representation of this instance.\nAvailable when ActivityType conforms to GroupActivity."
  },
  {
    "title": "id",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/id",
    "html": "Discussion\n\nThe system assigns a globally unique identifier to each session. This identifier is valid only for the lifetime of the session object.\n\nSee Also\nGetting the session details\nvar state: GroupSession<ActivityType>.State\nThe current state of the session.\nenum State\nThe possible states of a session.\nvar description: String\nA textual representation of this instance.\nAvailable when ActivityType conforms to GroupActivity."
  },
  {
    "title": "activity",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/activity",
    "html": "Discussion\n\nUse this property to fetch information about the selected activity. The value in this property conforms to the GroupActivity protocol. Use it to fetch the activity details.\n\nThe participants of a session may change the current activity at any time, and the session updates this property dynamically to reflect any changes. Subscribe to the property to listen for changes, and update your app’s activity to match.\n\nImportant\n\nUpdate this property only when the activity is in the GroupSession.State.joined state; otherwise, the behavior is undefined."
  },
  {
    "title": "localParticipant",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/localparticipant",
    "html": "Discussion\n\nUse this property to differentiate the participant on the current device from participants on other devices.\n\nSee Also\nGetting the participants\nvar activeParticipants: Set<Participant>\nThe set of participants currently engaged in the activity."
  },
  {
    "title": "requestForegroundPresentation()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/requestforegroundpresentation()",
    "html": "Discussion\n\nCall this method if your app is in the background and can’t start the activity without the participant’s assistance. For example, you might call the method if your app requires the participant’s credentials to play back a shared media file. Don’t call this method if you’re able to start the activity without assistance. When you call this method, the system asks the participant to continue the activity in your app.\n\nTo create a smoother user experience, the system might launch your app in the background when starting an activity. Apps can start activities in either the foreground or background, but you might configure your app differently when in the background. For example, when in the background, you play media files in a picture-in-picture window instead of a fullscreen interface. This method lets you notify the user when a background solution isn’t possible.\n\nThe session must be in the GroupSession.State.waiting or GroupSession.State.joined state when you call this method. If it isn’t, this method does nothing."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-2ijfu/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-2ijfu/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "GroupActivityMetadata.Experience",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/experience-swift.enum",
    "html": "Topics\nEnumeration Cases\ncase listenTogether\nDeprecated\ncase watchTogether\nDeprecated\nInitializers\ninit?(rawValue: Int)\nCreates a new instance with the specified raw value.\nDeprecated\nInstance Properties\nvar rawValue: Int\nThe corresponding value of the raw type.\nDeprecated\nType Aliases\ntypealias RawValue\nThe raw type that can be used to represent all values of the conforming type.\nDeprecated\nDefault Implementations\nEquatable Implementations\nRawRepresentable Implementations\nRelationships\nConforms To\nDecodable\nEncodable\nEquatable\nHashable\nRawRepresentable"
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "SetAlgebra Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/setalgebra-implementations",
    "html": "Topics\nInitializers\ninit<S>(S)\nCreates a new set from a finite sequence of items.\ninit(arrayLiteral: Self.Element...)\nCreates a set containing the elements of the given array literal.\nAvailable when ArrayLiteralElement is Self.Element.\nInstance Properties\nvar isEmpty: Bool\nA Boolean value that indicates whether the set has no elements.\nInstance Methods\nfunc isDisjoint(with: Self) -> Bool\nReturns a Boolean value that indicates whether the set has no members in common with the given set.\nfunc isStrictSubset(of: Self) -> Bool\nReturns a Boolean value that indicates whether this set is a strict subset of the given set.\nfunc isStrictSuperset(of: Self) -> Bool\nReturns a Boolean value that indicates whether this set is a strict superset of the given set.\nfunc isSubset(of: Self) -> Bool\nReturns a Boolean value that indicates whether the set is a subset of another set.\nfunc isSuperset(of: Self) -> Bool\nReturns a Boolean value that indicates whether the set is a superset of the given set.\nfunc subtract(Self)\nRemoves the elements of the given set from this set.\nfunc subtracting(Self) -> Self\nReturns a new set containing the elements of this set that do not occur in the given set."
  },
  {
    "title": "OptionSet Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/optionset-implementations",
    "html": "Topics\nInitializers\ninit()\nCreates an empty option set.\nAvailable when RawValue conforms to FixedWidthInteger.\nInstance Methods\nfunc contains(Self) -> Bool\nReturns a Boolean value that indicates whether a given element is a member of the option set.\nAvailable when Self is Self.Element.\nfunc formIntersection(Self)\nRemoves all elements of this option set that are not also present in the given set.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc formSymmetricDifference(Self)\nReplaces this set with a new set containing all elements contained in either this set or the given set, but not in both.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc formUnion(Self)\nInserts the elements of another set into this option set.\nAvailable when RawValue conforms to FixedWidthInteger.\nfunc insert(Self.Element) -> (inserted: Bool, memberAfterInsert: Self.Element)\nAdds the given element to the option set if it is not already a member.\nAvailable when Self is Self.Element.\nfunc intersection(Self) -> Self\nReturns a new option set with only the elements contained in both this set and the given set.\nfunc remove(Self.Element) -> Self.Element?\nRemoves the given element and all elements subsumed by it.\nAvailable when Self is Self.Element.\nfunc symmetricDifference(Self) -> Self\nReturns a new option set with the elements contained in this set or in the given set, but not in both.\nfunc union(Self) -> Self\nReturns a new option set of the elements contained in this set, in the given set, or in both.\nfunc update(with: Self.Element) -> Self.Element?\nInserts the given element into the set.\nAvailable when Self is Self.Element."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/sceneassociationbehavior/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "Decodable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/decodable-implementations",
    "html": "Topics\nInitializers\ninit(from: any Decoder) throws\nCreates a new instance by decoding from the given decoder."
  },
  {
    "title": "BroadcastOptions.RawValue",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions/rawvalue-swift.typealias",
    "html": "Discussion\n\nEvery distinct value of the conforming type has a corresponding unique value of the RawValue type, but there may be values of the RawValue type that don’t have a corresponding value of the conforming type."
  },
  {
    "title": "encode(to:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nIf the value fails to encode anything, encoder will encode an empty keyed container in its place.\n\nThis function throws an error if any values are invalid for the given encoder’s format."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false.\n\nSee Also\nComparing metadata objects\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "GroupActivityMetadata.ActivityType",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/activitytype",
    "html": "Topics\nGetting the Activity Types\nstatic let generic: GroupActivityMetadata.ActivityType\nA generic activity.\nstatic let listenTogether: GroupActivityMetadata.ActivityType\nA shared listening activity, such as listening to music together.\nstatic let watchTogether: GroupActivityMetadata.ActivityType\nA shared watching activity, such as watching an episode of a television show together.\nComparing Activity Types\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (GroupActivityMetadata.ActivityType, GroupActivityMetadata.ActivityType) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nInstance Properties\nvar hashValue: Int\nThe hash value.\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nType Properties\nstatic let createTogether: GroupActivityMetadata.ActivityType\nA shared creation activity, such as drawing on an art canvas together.\nstatic let exploreTogether: GroupActivityMetadata.ActivityType\nA shared exploration activity, such as planning a trip together or browsing a web feed together.\nstatic let learnTogether: GroupActivityMetadata.ActivityType\nA shared learning activity, such as studying a topic together.\nstatic let readTogether: GroupActivityMetadata.ActivityType\nA shared reading activity, such as reading a book together.\nstatic let shopTogether: GroupActivityMetadata.ActivityType\nA shared shopping activity, such as browsing for products online together.\nstatic let workoutTogether: GroupActivityMetadata.ActivityType\nA shared workout activity, such as participating in a fitness class together.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nSee Also\nIndicating the activity’s type\nvar type: GroupActivityMetadata.ActivityType\nThe type of shared experience."
  },
  {
    "title": "!=(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/!=(_:_:)",
    "html": "Parameters\nlhs\n\nA Value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nInequality is the inverse of equality. For any values a and b, a != b implies that a == b is false.\n\nThis is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.\n\nSee Also\nComparing metadata objects\nstatic func == (GroupActivityMetadata, GroupActivityMetadata) -> Bool\nReturns a Boolean value indicating whether two values are equal."
  },
  {
    "title": "ObservableObject Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupstateobserver/observableobject-implementations",
    "html": "Topics\nInstance Properties\nvar objectWillChange: ObservableObjectPublisher\nA publisher that emits before the object has changed.\nAvailable when ObjectWillChangePublisher is ObservableObjectPublisher."
  },
  {
    "title": "previewImage",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/previewimage",
    "html": "Discussion\n\nUse this property to specify an image for the activity. For example, you might display a movie poster for a movie-watching activity. The system scales the image as needed and displays it with the rest of the activity information.\n\nSee Also\nPresenting the activity\nvar title: String?\nThe localized string to display as the title of your activity.\nvar subtitle: String?\nThe localized string that provides additional information about the activity.\nvar fallbackURL: URL?\nA URL that offers participants a way to identify or join the activity from a web browser."
  },
  {
    "title": "title",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/title",
    "html": "Discussion\n\nUse this string as the main description of the activity, and localize it for the current device. The system displays this string prominently when it presents the activity to the participant.\n\nSee Also\nPresenting the activity\nvar subtitle: String?\nThe localized string that provides additional information about the activity.\nvar previewImage: CGImage?\nThe image to display for the current activity.\nvar fallbackURL: URL?\nA URL that offers participants a way to identify or join the activity from a web browser."
  },
  {
    "title": "init(from:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/init(from:)",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid.\n\nSee Also\nCreating group activity metadata\ninit()\nCreates a new instance for storing descriptive information about an activity."
  },
  {
    "title": "init()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/init()",
    "html": "Discussion\n\nAfter you create a new GroupActivityMetadata structure, assign values to its properties and deliver it to the system from the metadata property of your custom GroupActivity type.\n\nSee Also\nCreating group activity metadata\ninit(from: any Decoder) throws\nCreates a new instance by decoding from the given decoder."
  },
  {
    "title": "TransferRepresentation Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitytransferrepresentation/transferrepresentation-implementations",
    "html": "Topics\nInstance Methods\nfunc exportingCondition((Self.Item) -> Bool) -> _ConditionalTransferRepresentation<Self>\nPrevents the system from exporting an item if it does not meet the supplied condition.\nfunc suggestedFileName((Self.Item) -> String?) -> some TransferRepresentation<Self.Item>\nProvides a filename to use if the receiver chooses to write the item to disk.\nfunc suggestedFileName(String) -> some TransferRepresentation<Self.Item>\nProvides a filename to use if the receiver chooses to write the item to disk.\nfunc visibility(TransferRepresentationVisibility) -> some TransferRepresentation<Self.Item>\nSpecifies the kinds of apps and processes that can see an item in transit."
  },
  {
    "title": "body",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitytransferrepresentation/body-swift.property",
    "html": "Discussion\n\nCombine multiple existing transfer representations to compose a single transfer representation that describes how to transfer an item in multiple scenarios.\n\nstruct CombinedRepresentation: TransferRepresentation {\n   var body: some TransferRepresentation {\n       DataRepresentation(...)\n       FileRepresentation(...)\n   }\n}\n"
  },
  {
    "title": "init(exporting:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitytransferrepresentation/init(exporting:)",
    "html": "Parameters\nexporting\n\nA closure that creates the GroupActivity for the given item."
  },
  {
    "title": "activate()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivity/activate()",
    "html": "Discussion\n\nTypically, you call this method only when the prepareForActivation() method delivers the GroupActivityActivationResult.activationPreferred result. However, you may call it directly if your activity only makes sense in a group setting. For example, call it if the activity applies only to groups and can’t be performed without other participants.\n\nIf a FaceTime call is active, this method configures a session. The system also invites other participants to join the activity. If a session will be delivered to your app this function returns true, otherwise it returns false. A case where this function could return false is when a session is created and handed off to an Apple TV. If a call isn’t active or a session wasn’t created, this method throws an error\n\nSee Also\nStarting an activity immediately\nfunc prepareForActivation() async -> GroupActivityActivationResult\nReturns the participant’s preferred option for how to start the activity.\nenum GroupActivityActivationResult\nThe result of preparing to start a custom activity."
  },
  {
    "title": "GroupSessionJournal.Attachment",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachment",
    "html": "Overview\n\nWhen your app receives a new item, the system packages it in an GroupSessionJournal.Attachment and delivers it to your app. Use this container type to download the contents of the file and decode it to a type that your app recognizes.\n\nTopics\nDownloading the attachment data\nfunc load<AttachmentType>(AttachmentType.Type) async throws -> AttachmentType\nDownloads the attachment data and asynchronously delivers it as the type you specify.\nfunc loadMetadata<MetadataType>(of: MetadataType.Type) async throws -> MetadataType\nDownloads the metadata for the attachment asynchronously and delivers it as the type you specify.\nIdentifying the attachment\nvar id: UUID\nThe unique identifier for this attachment.\nType Aliases\ntypealias ID\nA type representing the stable identity of the entity associated with an instance.\nRelationships\nConforms To\nIdentifiable\nSee Also\nDownloading content from the session\nvar attachments: GroupSessionJournal.Attachments\nThe currently available attachments for you to download and incorporate into your app.\nstruct Attachments\nAn asynchronous sequence that contains one or more incoming attachment containers for you to process."
  },
  {
    "title": "GroupSessionJournal.Attachments",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.struct",
    "html": "Overview\n\nAfter a participant uploads a file or data, the system makes that content available on the GroupSessionJournal.Attachments asynchronous sequence of each session participant. Configure an asynchronous task to monitor this sequence and process results when they arrive.\n\nThe following example shows you how to configure this task and use it to iterate over the available items. The journal variable contains a previously configured GroupSessionJournal object.\n\nlet attachmentListener = Task {\n   for await attachments in journal.attachments {\n      for attachment in attachments {\n         // Download and process each attachment.\n      }\n   }\n}\n\nTopics\nCreating an iterator\nfunc makeAsyncIterator() -> GroupSessionJournal.Attachments.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Iterator\nThe asynchronous iterator that produces a sequence of attachments.\ntypealias Element\nThe type of element this asynchronous sequence produces.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence\nSee Also\nDownloading content from the session\nvar attachments: GroupSessionJournal.Attachments\nThe currently available attachments for you to download and incorporate into your app.\nstruct Attachment\nA container for the data you download."
  },
  {
    "title": "load(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachment/load(_:)",
    "html": "Parameters\nattachmentType\n\nThe type you use to interpret the data. An app typically uploads and downloads a single type of data for an activity. For more information about defining your types, see Transferable.\n\nReturn Value\n\nA requested type that contains the downloaded information.\n\nDiscussion\n\nUse this function to retrieve the file or data another participant provides. The method asynchronously retrieves and decodes the data, returning it as the requested type. If the requested type isn’t available, the method throws an error.\n\nSee Also\nDownloading the attachment data\nfunc loadMetadata<MetadataType>(of: MetadataType.Type) async throws -> MetadataType\nDownloads the metadata for the attachment asynchronously and delivers it as the type you specify."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivityactivationresult/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false.\n\nSee Also\nComparing reliability options\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "remove(attachment:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/remove(attachment:)",
    "html": "Parameters\nattachment\n\nThe attachment object associated with the item. You receive this object when you call the add(_:) or add(_:metadata:) method.\n\nDiscussion\n\nCall this method to remove an attachment that is no longer relevant. For example, you might remove an attachment containing a photo in response to someone deleting that photo from the activity. When you remove an attachment, the journal object updates the array of attachments and sends it to all participants. Remove any attachments from your app that aren’t still in the array."
  },
  {
    "title": "type",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/type",
    "html": "See Also\nIndicating the activity’s type\nstruct ActivityType\nConstants that indicate the group activity’s type to the system."
  },
  {
    "title": "activityIdentifier",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivity/activityidentifier-6jlef",
    "html": "Required Default implementation provided.\n\nDiscussion\n\nImplement this property and return a value that uniquely identifies the activity within your app. An app may support multiple activities, and each activity requires a unique identifier string. Use reverse-DNS notation for your identifier strings. For example, supply a string like \"com.mycompany.myapp.watchmovie\" for a movie-watching activity.\n\nIf you don’t implement this property yourself, the default implementation composes an activity identifier using your app’s bundle identifier and the current class or struct name. For example, if the app’s bundle identifier is \"com.mycompany.myapp\" and your activity type name is MovieActivity, the resulting identifier string is \"com.mycompany.myapp.MovieActivity\".\n\nDefault Implementations\nGroupActivity Implementations\nstatic var activityIdentifier: String\nAn app-defined string that uniquely identifies the activity.\nSee Also\nSpecifying the activity details\nvar metadata: GroupActivityMetadata\nA description of the activity, and optional image to display to the user.\n\nRequired"
  },
  {
    "title": "GroupSessionMessenger.DeliveryMode",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/deliverymode-swift.enum",
    "html": "Topics\nGetting the delivery mode options\ncase reliable\nAn attempt to ensure the delivery of messages to known participants.\ncase unreliable\nA best-effort attempt to deliver the message to known participants.\nComparing the delivery mode options\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (GroupSessionMessenger.DeliveryMode, GroupSessionMessenger.DeliveryMode) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nInstance Properties\nvar hashValue: Int\nThe hash value.\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nHashable"
  },
  {
    "title": "GroupSessionMessenger.Messages",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages",
    "html": "Overview\n\nWhen you use a GroupSessionMessenger to communicate across devices, the Messages structure provides the sequence of messages the other devices send. Iterate over the contents of this structure asynchronously to retrieve each message and update your app.\n\nDon’t create this structure directly. Instead, use the messages(of:) or messages(of:) method to retrieve the messages for a given session.\n\nTopics\nCreating an iterator\nfunc makeAsyncIterator() -> GroupSessionMessenger.Messages<Message>.Iterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\nstruct Iterator\ntypealias Element\nThe type of element produced by this asynchronous sequence.\nFinding elements\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nSelecting elements\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nExcluding elements\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nTransforming a sequence\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.\nType Aliases\ntypealias AsyncIterator\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\nDefault Implementations\nAsyncSequence Implementations\nRelationships\nConforms To\nAsyncSequence\nSee Also\nReceiving data from other participants\nfunc messages(of: Data.Type) -> GroupSessionMessenger.Messages<Data>\nReturns the asynchronous sequence of messages that contain a generic data object.\nfunc messages<Message>(of: Message.Type) -> GroupSessionMessenger.Messages<Message>\nReturns the asynchronous sequence of messages that match the app-specific type.\nstruct MessageContext\nA structure that contains additional information about an incoming message, such as which device sent it."
  },
  {
    "title": "send(_:to:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/send(_:to:)-4o52m",
    "html": "Parameters\ndata\n\nThe data object to send.\n\nparticipants\n\nThe recipients of the message. The default value of this parameter is the set of all active participants in the session. Use the Participants.only(_:) option to specify a subset of participants.\n\nDiscussion\n\nUse this method to send data with a standard data object. Your app is responsible for decoding and using the data it receives.\n\nSee Also\nSending data to the group\nfunc send<Message>(Message, to: Participants) async throws\nSends a custom type asynchronously to other participants in the group session.\nfunc send(Data, to: Participants, completion: ((any Error)?) -> Void)\nSends a standard data object to other participants in the group session.\nfunc send<Message>(Message, to: Participants, completion: ((any Error)?) -> Void)\nSends a custom type to other participants in the group session.\nenum Participants\nThe set of participants to include in messages."
  },
  {
    "title": "GroupSessionMessenger.DeliveryMode.reliable",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/deliverymode-swift.enum/reliable",
    "html": "Discussion\n\nUse this approach to send messages that are critical to the experience you create. The GroupSessionMessenger enqueues a message until it is successfully transmitted to all known participants. The system doesn’t guarantee delivery to participants who join a group session after you send a message, or who leave the group prior to delivery.\n\nSee Also\nGetting the delivery mode options\ncase unreliable\nA best-effort attempt to deliver the message to known participants."
  },
  {
    "title": "Participants",
    "url": "https://developer.apple.com/documentation/groupactivities/participants",
    "html": "Topics\nGetting the set of participants\ncase all\nThe set of all participants.\ncase only(Set<Participant>)\nA custom subset of participants.\nstatic func only(Participant) -> Participants\nReturns a set containing the specified participant.\nSee Also\nSending data to the group\nfunc send(Data, to: Participants) async throws\nSends a standard data object asynchronously to other participants in the group session.\nfunc send<Message>(Message, to: Participants) async throws\nSends a custom type asynchronously to other participants in the group session.\nfunc send(Data, to: Participants, completion: ((any Error)?) -> Void)\nSends a standard data object to other participants in the group session.\nfunc send<Message>(Message, to: Participants, completion: ((any Error)?) -> Void)\nSends a custom type to other participants in the group session."
  },
  {
    "title": "messages(of:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages(of:)-626qo",
    "html": "Parameters\ntype\n\nThe type of the Data class. Specify Data.self.\n\nDiscussion\n\nCall this method to receive the messages that other participants send to the group. This method returns a GroupSessionMessenger.Messages structure, which conforms to the AsyncSequence protocol. This sequence contains all, some, or none of the messages sent over time. You retrieve messages by iterating over them using an asynchronous for-in loop, as shown in the following example:\n\nlet sessionMessenger = GroupSessionMessenger(session: groupSession)\n\n\nasync {\n    for await dataMessage in sessionMessenger.messages(of: Data.self) {\n        self.processDataMessage(dataMessage)\n    }\n}\n\nSee Also\nReceiving data from other participants\nfunc messages<Message>(of: Message.Type) -> GroupSessionMessenger.Messages<Message>\nReturns the asynchronous sequence of messages that match the app-specific type.\nstruct Messages\nAn asynchronous sequence of messages sent to the session.\nstruct MessageContext\nA structure that contains additional information about an incoming message, such as which device sent it."
  },
  {
    "title": "contentExtent(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/spatialtemplatepreference/contentextent(_:)",
    "html": "Discussion\n\nUse this modifier to set the distance between your app’s content and the participants in a shared context. You might use this modifier if the intrinsic size of your content doesn’t represent an optimal viewing distance. Specify the new size in points.\n\nIf you don’t apply this modifier, the system uses the intrinsic size of the scene’s content to determine the viewing distance for participants."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/participant/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "CustomStringConvertible Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/participant/customstringconvertible-implementations",
    "html": "Topics\nInstance Properties\nvar description: String\nA textual representation of this instance."
  },
  {
    "title": "localParticipantStates",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/localparticipantstates",
    "html": "Discussion\n\nUse this property to detect when the current person starts or stops displaying their Spatial Persona. The following example shows how to set up a task to monitor the sequence and respond to changes:\n\nTask.detached {\n    for await localParticipantState in systemCoordinator.localParticipantStates {\n         if localParticipantState.isSpatial {\n              // Handle changes to the state.\n         }\n    }\n}\n\nSee Also\nGetting the participant state\nvar localParticipantState: SystemCoordinator.ParticipantState\nThe current participant’s level of support for an activity that takes place in a shared simulation space.\nstruct ParticipantStates\nAn asynchronous sequence that reports the current person’s ability to participate in a shared context."
  },
  {
    "title": "default",
    "url": "https://developer.apple.com/documentation/groupactivities/sceneassociationbehavior/default",
    "html": "Discussion\n\nWith this option, the system uses the string in the activityIdentifier property of your GroupActivity object to locate an appropriate scene. Choose this option if your app has only one scene, or if you always use the same scene to display the intended activity.\n\nSee Also\nGetting the scene-association options\nstatic func content(String) -> SceneAssociationBehavior\nA behavior that matches the activity to a scene using a custom string that you supply.\nstatic let none: SceneAssociationBehavior\nA behavior that doesn’t match any scenes to the activity."
  },
  {
    "title": "localParticipantState",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/localparticipantstate",
    "html": "Discussion\n\nThis property tells you when the current participant supports inclusion in a shared simulation space. This property is true if the participant is using a device that supports spatial placement, configured their Spatial Persona on that device, and enabled it for the current activity.\n\nThis property reflects only the state of the current participant. When this property is true, share additional information during activity updates to reflect changes the participant makes to the shared content. For example, if the participant rotates a 3D model, share the rotation amount so that your app can rotate the model on the devices of other participants. When your app receives such a change from another participant, incorporate those changes only if the value of this property is true. The goal of sharing information is to preserve the shared context of the scene, and to make it seem like people are experiencing the content together.\n\nSee Also\nGetting the participant state\nvar localParticipantStates: SystemCoordinator.ParticipantStates\nAn asynchronous sequence that reports changes to the local participant’s state.\nstruct ParticipantStates\nAn asynchronous sequence that reports the current person’s ability to participate in a shared context."
  },
  {
    "title": "init(session:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/init(session:)",
    "html": "Parameters\nsession\n\nThe group session to use for communication with participants. Specify a session object that is in either the GroupSession.State.waiting or GroupSession.State.joined state for this parameter. However, a session must be in the joined state to send or receive messages."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstate/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "isSpatial",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstate/isspatial",
    "html": "Discussion\n\nThe value of this property is true when the current person supports activities that place participants relative to the activity itself. The person must use a device that supports spatial experiences, and must configure their Spatial Persona to support inclusion in a shared simulation space."
  },
  {
    "title": "==(_:_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstate/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "GroupSession",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession",
    "html": "Overview\n\nA GroupSession object contains details about the user’s currently selected activity, its status, and its participants. When a participant engages in an activity, the system binds a session to that activity for you. You use the session object to synchronize your app’s activity-related content, including your app’s UI.\n\nYou don’t create GroupSession objects directly. Instead, the system creates sessions and makes them available to your app asynchronously. Use the AsyncSequence type returned by the sessions() method of your activity to retrieve new sessions when they become available.\n\nBefore the system can create a session object, your app must create a GroupActivity object and activate it. For information about how to configure group activities, see GroupActivity.\n\nStart and Stop the Session\n\nWhen you receive a new session object, it’s initially in the GroupSession.State.waiting state. As soon as your app is ready to begin the associated activity, call the session’s join() method. Joining a session validates the connection and starts the synchronization process between the current device and other participants’ devices. If your app successfully joins the session, the session transitions to the GroupSession.State.joined state.\n\nWhen the user quits your app, or navigates away from the shared activity, call the session’s leave() method. Leaving a session gracefully transitions it to the GroupSession.State.invalidated(reason:) state, and informs the system that the user isn’t currently engaged in the activity.\n\nTopics\nGetting the current session\nstruct Sessions\nAn asynchronous sequence of sessions you use to manage a specific activity.\nAvailable when ActivityType conforms to GroupActivity.\nJoining and leaving the session\nfunc join()\nStarts the shared activity on the current device.\nfunc leave()\nLeaves the current activity and stops receiving synchronized data.\nfunc end()\nEnds the activity for the entire group and stops the transfer of synchronized data.\nAccessing the shared activity\nvar activity: ActivityType\nThe current activity associated with the session.\nGetting the session details\nvar state: GroupSession<ActivityType>.State\nThe current state of the session.\nenum State\nThe possible states of a session.\nlet id: UUID\nThe unique identifier of the current session.\nvar description: String\nA textual representation of this instance.\nAvailable when ActivityType conforms to GroupActivity.\nGetting the participants\nvar localParticipant: Participant\nThe participant on the current device.\nvar activeParticipants: Set<Participant>\nThe set of participants currently engaged in the activity.\nGetting the scene-association identifier\nlet sceneSessionIdentifier: String?\nThe persistent identifier of the session’s associated scene.\nGetting the participant’s attention\nfunc requestForegroundPresentation()\nTells the system that your app needs to be in the foreground to continue an activity.\nNotifying participants of playback changes\nfunc showNotice(GroupSessionEvent)\nPosts an event to the system, which displays the information in the system UI.\nAvailable when ActivityType conforms to GroupActivity.\nstruct GroupSessionEvent\nA session-related event that appears in the system UI.\nPublishing changes\nvar objectWillChange: ObservableObjectPublisher\nA publisher that emits before the object has changed.\nAvailable when ObjectWillChangePublisher is ObservableObjectPublisher.\nStructures\nstruct Event\nA session-related event to display in the system UI.\nAvailable when ActivityType conforms to GroupActivity.\nDeprecated\nInstance Properties\nvar $activeParticipants: Published<Set<Participant>>.Publisher\nvar $activity: Published<ActivityType>.Publisher\nvar $state: Published<GroupSession<ActivityType>.State>.Publisher\nvar systemCoordinator: SystemCoordinator?\nThe system coordinator associated with an active session.\nAvailable when ActivityType conforms to GroupActivity.\nInstance Methods\nfunc postEvent(GroupSession<ActivityType>.Event)\nPosts an event to the system, which displays the information in the system UI.\nAvailable when ActivityType conforms to GroupActivity.\nDeprecated\nType Aliases\ntypealias ObjectWillChangePublisher\nThe type of publisher that emits before the object has changed.\nDefault Implementations\nCustomStringConvertible Implementations\nObservableObject Implementations\nRelationships\nConforms To\nCustomStringConvertible\nObservableObject\nSee Also\nSession management\nJoining and managing a shared activity\nConfigure the session when a SharePlay activity starts, and handle events that occur during the lifetime of the activity.\nDrawing content in a group session\nInvite your friends to draw on a shared canvas while on a FaceTime call.\nprotocol CustomMessageIdentifiable\nA type that assigns a custom ID string to messages you send to other devices.\nstruct Participant\nAn active participant in a group session."
  },
  {
    "title": "activeParticipants",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/activeparticipants",
    "html": "Discussion\n\nThis property reflects the set of people invited to a group session and currently engaged in the shared activity on their device. Members who join the conversation over FaceTime but don’t join the shared activity aren’t active participants. As people join or leave the activity, the session object updates the set of active participants. To detect changes to this property, configure a subscriber.\n\nEach Participant object corresponds to a joined session on a device. If a single person joins the activity from two devices simultaneously, the set contains a separate Participant object for each device.\n\nSee Also\nGetting the participants\nvar localParticipant: Participant\nThe participant on the current device."
  },
  {
    "title": "CustomMessageIdentifiable",
    "url": "https://developer.apple.com/documentation/groupactivities/custommessageidentifiable",
    "html": "Overview\n\nAdopt this protocol in the custom types you use to send and receive messages during a group activity. You use a GroupSessionMessenger object to send custom messages between the same app on different devices. In addition to the message data, GroupSessionMessenger encodes your custom type name so that it can construct the correct type on those other devices. Use this protocol to identify your custom message types using an app-specific string instead of the type name.\n\nProviding an app-specific string makes it possible to use different types to support messages. When the message data contains a custom message ID, GroupSessionMessenger looks for a type that conforms to the protocol with a messageIdentifier property that contains the matching string. It then creates that type and decodes the message data into it.\n\nNote\n\nCustom types that adopt this protocol must also adopt the Codable protocol.\n\nTopics\nType Properties\nstatic var messageIdentifier: String\nA custom identification string for the current type.\n\nRequired\n\nSee Also\nSession management\nJoining and managing a shared activity\nConfigure the session when a SharePlay activity starts, and handle events that occur during the lifetime of the activity.\nDrawing content in a group session\nInvite your friends to draw on a shared canvas while on a FaceTime call.\nclass GroupSession\nA session for an in-progress activity that synchronizes content among participant devices.\nstruct Participant\nAn active participant in a group session."
  },
  {
    "title": "leave()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/leave()",
    "html": "Discussion\n\nWhen you call this method, the session transitions to the GroupSession.State.invalidated(reason:) state and stops the delivery of session-related updates. Call this method when the user dismisses your app’s activity-related UI.\n\nDon’t call this method on a session already in the GroupSession.State.invalidated(reason:) state.\n\nSee Also\nJoining and leaving the session\nfunc join()\nStarts the shared activity on the current device.\nfunc end()\nEnds the activity for the entire group and stops the transfer of synchronized data."
  },
  {
    "title": "send(_:to:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/send(_:to:)-2a4ku",
    "html": "Parameters\nmessage\n\nThe custom data structure you want to send. The data structure must conform to the Codable protocol.\n\nparticipants\n\nThe recipients of the message. The default value of this parameter is the set of all active participants in the session. Use the Participants.only(_:) option to specify a subset of participants.\n\nDiscussion\n\nUse this method to send data that you package into a custom class or structure. The method encodes your custom structure’s type information, and delivers the data only to message sequences of the same type.\n\nSee Also\nSending data to the group\nfunc send(Data, to: Participants) async throws\nSends a standard data object asynchronously to other participants in the group session.\nfunc send(Data, to: Participants, completion: ((any Error)?) -> Void)\nSends a standard data object to other participants in the group session.\nfunc send<Message>(Message, to: Participants, completion: ((any Error)?) -> Void)\nSends a custom type to other participants in the group session.\nenum Participants\nThe set of participants to include in messages."
  },
  {
    "title": "messages(of:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/messages(of:)-jvoz",
    "html": "Parameters\ntype\n\nThe class of the custom type you use to package the message contents.\n\nDiscussion\n\nCall this method to receive the messages that other participants send to the group. This method returns a GroupSessionMessenger.Messages structure, which conforms to the AsyncSequence protocol. This sequence contains all, some, or none of the messages sent over time. You retrieve messages by iterating over them using an asynchronous for-in loop, as shown in the following example:\n\nlet sessionMessenger = GroupSessionMessenger(session: groupSession)\n\n\nasync {\n    for await move in sessionMessenger.messages(of: TicTacToe.Move.self) {\n        self.board.addMove(move)\n    }\n}\n\nSee Also\nReceiving data from other participants\nfunc messages(of: Data.Type) -> GroupSessionMessenger.Messages<Data>\nReturns the asynchronous sequence of messages that contain a generic data object.\nstruct Messages\nAn asynchronous sequence of messages sent to the session.\nstruct MessageContext\nA structure that contains additional information about an incoming message, such as which device sent it."
  },
  {
    "title": "GroupActivitySharingController",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingcontroller-4gtfk",
    "html": "Overview\n\nA GroupActivitySharingController helps you start a SharePlay activity, even when a FaceTime call isn’t currently active. When presented, the view controller prompts the person to start the activity you provided. If no FaceTime call is active, the view controller also displays a people picker to let the person select the participants for the activity. When they choose to start the activity, the view controller automatically starts the FaceTime call as needed and joins your app to the activity.\n\nIf your app’s interface includes controls to start SharePlay activities, present this view controller in response to interactions with those controls. Initialize the GroupActivitySharingController object with the activity you want to start. After you present it, the view controller handles all further interactions. It manages the interface that appears onscreen and responds when someone chooses to start or cancel the activity. It starts the FaceTime call if one isn’t currently active. It also dismisses itself and returns control back to your app, updating its result property to let you know what happened.\n\nTopics\nCreating the group activity sharing controller\ninit<ActivityType>(ActivityType) throws\nInitializes the sharing controller with the specified activity and type information.\ninit<ActivityType>(preparationHandler: () async throws -> ActivityType)\nInitializes the SharePlay sharing controller with a closure that creates the activity object.\nGetting the result\nvar result: GroupActivitySharingResult\nThe result of a request to share a group activity.\nenum GroupActivitySharingResult\nThe result of a request to share a group activity in macOS.\nResponding to view-related events\nfunc viewDidLoad()\nNotifies the view controller that the system added a view to a view hierarchy.\nInstance Methods\nfunc loadView()\nfunc viewWillAppear()\nNotifies the view controller that the system is going to add a view to a view hierarchy.\nRelationships\nInherits From\nNSViewController\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSEditor\nNSExtensionRequestHandling\nNSObjectProtocol\nNSSeguePerforming\nNSStandardKeyBindingResponding\nNSTouchBarProvider\nNSUserActivityRestoring\nNSUserInterfaceItemIdentification\nSee Also\nInterface presentation\nPresenting SharePlay activities from your app’s UI\nMake it easy for people to start activities from your app’s UI, from the system share sheet, or using AirPlay over AirDrop.\nclass GroupActivitySharingController\nAn iOS view controller that displays the system interface for starting an activity, and optionally starts a FaceTime call for that activity."
  },
  {
    "title": "generic",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/activitytype/generic",
    "html": "Discussion\n\nThis is the default value if no type is set.\n\nSee Also\nGetting the Activity Types\nstatic let listenTogether: GroupActivityMetadata.ActivityType\nA shared listening activity, such as listening to music together.\nstatic let watchTogether: GroupActivityMetadata.ActivityType\nA shared watching activity, such as watching an episode of a television show together."
  },
  {
    "title": "modalPresentationStyle",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingcontroller-ybcy/modalpresentationstyle",
    "html": "Discussion\n\nThis property always sets the presentation style for the view controller to UIModalPresentationStyle.pageSheet."
  },
  {
    "title": "join()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsession/join()",
    "html": "Discussion\n\nCall this method to begin the delivery of synchronized data to the current device. Typically, you call this method when your app is ready to engage in an activity. For example, call it when you present your app’s UI for the activity. When your app successfully joins the session, the session changes the value in its state property to GroupSession.State.joined.\n\nSee Also\nJoining and leaving the session\nfunc leave()\nLeaves the current activity and stops receiving synchronized data.\nfunc end()\nEnds the activity for the entire group and stops the transfer of synchronized data."
  },
  {
    "title": "viewWillAppear(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingcontroller-ybcy/viewwillappear(_:)",
    "html": "See Also\nResponding to view-related events\nfunc viewDidLoad()\nNotifies the view controller that the system added a view to a view hierarchy."
  },
  {
    "title": "viewDidLoad()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingcontroller-ybcy/viewdidload()",
    "html": "See Also\nResponding to view-related events\nfunc viewWillAppear(Bool)\nNotifies the view controller that the system is going to add a view to a view hierarchy."
  },
  {
    "title": "GroupActivitySharingResult",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingresult-2ijfu",
    "html": "Topics\nGetting the result\ncase success\nA result that indicates someone wants to share the activity with the group.\ncase cancelled\nA result that indicates someone canceled the request.\nComparing results\nstatic func == (GroupActivitySharingResult, GroupActivitySharingResult) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nGetting the hash value\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nInstance Properties\nvar hashValue: Int\nThe hash value.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nSee Also\nGetting the result\nvar result: GroupActivitySharingResult\nThe result of a request to share a group activity."
  },
  {
    "title": "init(preparationHandler:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingcontroller-ybcy/init(preparationhandler:)",
    "html": "Parameters\npreparationHandler\n\nA closure that takes no parameters and returns the activity object.\n\nDiscussion\n\nThe initializer executes the closure asynchronously so that your app can present the view controller in a timely manner. Use this method when the creation of the GroupActivity object might take a significant amount of time.\n\nSee Also\nCreating the group activity sharing controller\ninit<ActivityType>(ActivityType) throws\nInitializes the sharing controller with the specified activity and type information."
  },
  {
    "title": "result",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingcontroller-ybcy/result",
    "html": "Discussion\n\nUse this property to perform actions related to the starting of the activity. You don’t need to start the activity itself, since the view controller automatically joins your app to the activity when the result is GroupActivitySharingResult/success.\n\nSee Also\nGetting the result\nenum GroupActivitySharingResult\nThe result of a request to share a group activity in iOS."
  },
  {
    "title": "SceneAssociationBehavior",
    "url": "https://developer.apple.com/documentation/groupactivities/sceneassociationbehavior",
    "html": "Overview\n\nUse a SceneAssociationBehavior type to match SharePlay activities to your app’s scenes. The static accessors of this type offer different scene-selection behaviors. For example, you can match each activity type to a specific scene, match scenes dynamically based on the contents of the activity, or prevent matching altogether. Select one of these behaviors and assign the related type to your GroupActivity object’s metadata. On some platforms, the system adds a custom indicator to a scene to let people know that SharePlay is active.\n\nAdd activation conditions to your SwiftUI or UIKit scenes to tell the system which activities they support. An activation condition is a custom string that identifies one of your app’s supported activities. You add these strings to your scenes to direct different types of external events to them. In SwiftUI, specify the activation conditions for a scene using the handlesExternalEvents(matching:) modifier. In the following example, the scene handles two app-related activities, including a group activity.\n\nlet activationConditions : Set = [\"com.mycompany.MySharePlayActivity\",\n                                  \"com.mycompany.MyUserActivity\"]\nvar body: some Scene {\n   WindowGroup {\n      ContentView()\n   }\n   .handlesExternalEvents(matching: activationConditions)\n\n\nTo handle the same activation condition in a UIKit app, add rules to the activationConditions property of your UIScene object. Assign these rules in the scene(_:willConnectTo:options:) method when you first configure your scene for use. Use the prefersToActivateForTargetContentIdentifierPredicate property when the scene is the preferred choice for handling the action. The following example shows how to configure a scene to handle two app-related activities, including a group activity.\n\nlet activationConditions = [\"com.example.MySharePlayActivity\", \"com.example.MyUserActivity\"]\nfunc scene(_ scene: UIScene,\n           willConnectTo session: UISceneSession,\n           options connectionOptions: UIScene.ConnectionOptions) {\n   // Specify the activities that this scene prefers to handle.\n   scene.activationConditions.prefersToActivateForTargetContentIdentifierPredicate\n        = NSPredicate(format: \"self in %@\", activationConditions)\n}\n\nTopics\nGetting the scene-association options\nstatic let `default`: SceneAssociationBehavior\nA behavior that matches the activity to a scene using the identifier of your activity object.\nstatic func content(String) -> SceneAssociationBehavior\nA behavior that matches the activity to a scene using a custom string that you supply.\nstatic let none: SceneAssociationBehavior\nA behavior that doesn’t match any scenes to the activity.\nOperators\nstatic func == (SceneAssociationBehavior, SceneAssociationBehavior) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nSee Also\nAssigning an app-specific scene\nvar sceneAssociationBehavior: SceneAssociationBehavior\nCriteria the system uses to direct an activity to a specific scene of your app."
  },
  {
    "title": "BroadcastOptions",
    "url": "https://developer.apple.com/documentation/groupactivities/broadcastoptions",
    "html": "Overview\n\nUse these options to alter how the system presents audio and video associated with an activity’s FaceTime call. For example, you might mirror video during a workout activity to make it easier to follow the instructor’s movements.\n\nTopics\nGetting the broadcast options\nstatic let mirroredVideo: BroadcastOptions\nAn option to mirror video on its vertical axis.\nCreating options from a raw value\ninit(rawValue: Int)\nCreates a set of options from a raw value.\nlet rawValue: Int\nThe raw value.\nType Aliases\ntypealias ArrayLiteralElement\nThe type of the elements of an array literal.\ntypealias Element\nThe element type of the option set.\ntypealias RawValue\nThe raw type that can be used to represent all values of the conforming type.\nDefault Implementations\nEquatable Implementations\nOptionSet Implementations\nSetAlgebra Implementations\nRelationships\nConforms To\nEquatable\nExpressibleByArrayLiteral\nOptionSet\nRawRepresentable\nSetAlgebra\nSee Also\nSpecifying media-related behavior\nvar supportsContinuationOnTV: Bool\nA Boolean value that indicates whether your app supports activity continuation on an Apple TV.\nvar preferredBroadcastOptions: BroadcastOptions\nPreferences for how to present audio and video on the main communication channel."
  },
  {
    "title": "sceneAssociationBehavior",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/sceneassociationbehavior",
    "html": "Discussion\n\nAn app with multiple Scene types typically uses each scene for a different purpose. For example, you might use one scene type for your app’s documents, and a different scene type for tool palettes, information windows, and other content. When a group activity starts, the system uses the information in this property to deliver the activity to the appropriate scene. On some platforms, the system also adds a custom indicator to the scene to let people know that SharePlay is active.\n\nAssign a value to this property to specify the scene-selection behavior for your app. If you don’t specify a value for this property, the system adopts the default scene association behavior.\n\nSee Also\nAssigning an app-specific scene\nstruct SceneAssociationBehavior\nA type that tells the system which scene to associate with an incoming group activity."
  },
  {
    "title": "supportsContinuationOnTV",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/supportscontinuationontv",
    "html": "Discussion\n\nThe default value of this property is false. Set it to true to allow participants to continue the activity on Apple TV.\n\nSee Also\nSpecifying media-related behavior\nvar preferredBroadcastOptions: BroadcastOptions\nPreferences for how to present audio and video on the main communication channel.\nstruct BroadcastOptions\nOptions for how to broadcast media on the shared communications channel."
  },
  {
    "title": "preferredBroadcastOptions",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/preferredbroadcastoptions",
    "html": "Discussion\n\nUse this property to request special handling of the audio and video on the FaceTime call. For example, you might request video mirroring to simplify activities that involve left-right movement. The system respects your preferences when possible, but may override those preferences if system- or user-specific settings are present. The default value of this property is an empty set.\n\nSee Also\nSpecifying media-related behavior\nvar supportsContinuationOnTV: Bool\nA Boolean value that indicates whether your app supports activity continuation on an Apple TV.\nstruct BroadcastOptions\nOptions for how to broadcast media on the shared communications channel."
  },
  {
    "title": "transferRepresentation",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivity/transferrepresentation",
    "html": "Discussion\n\nThis property contains a default GroupActivityTransferRepresentation for your activity. The system uses this type to offer your activity via SharePlay."
  },
  {
    "title": "GroupActivity.Sessions",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivity/sessions",
    "html": "Discussion\n\nA Sessions type contains a sequence of GroupSession objects specific to the current activity. The sessions() method returns this type, and you use it to retrieve the current session, if any, for that activity. The system creates only one GroupSession object for each new activity. To detect changes to the session’s state, activity type, or active participants, subscribe to the corresponding properties.\n\nSee Also\nReceiving an activity-related session\nstatic func sessions() -> Self.Sessions\nReturns the sessions for this activity as an asynchronous sequence."
  },
  {
    "title": "sessions()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivity/sessions()",
    "html": "Return Value\n\nAn AsyncSequence type that contains the GroupSession objects for this activity.\n\nDiscussion\n\nUse this method to retrieve new sessions for the current activity. The method returns a sequence that may contain some or none of its values when you access it. The system adds an element to the sequence when the participant joins a new activity. It doesn’t update the sequence when properties of an active session change. For example, it doesn’t update the sequence when the state of the session changes.\n\nUse a for-in loop to iterate over the values in the sequence. Preface your loop with await to receive each value asynchronously as it becomes available. To avoid blocking your code, perform the iteration from an asynchronous task in your app. The following example shows a typical way to call this method asynchronously:\n\nasync {\n    for await newSession in MyActivity.sessions() {\n       // Start a new activity.\n    }\n}\n\n\nWhen a new session arrives, use it to prepare your app’s UI for the new activity.\n\nSee Also\nReceiving an activity-related session\ntypealias Sessions\nA type that provides asynchronous, sequential, iterated access to the sessions for the activity."
  },
  {
    "title": "Equatable Implementations",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivityactivationresult/equatable-implementations",
    "html": "Topics\nOperators\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal."
  },
  {
    "title": "hash(into:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivityactivationresult/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future."
  },
  {
    "title": "hashValue",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivityactivationresult/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you."
  },
  {
    "title": "GroupActivityActivationResult.activationPreferred",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivityactivationresult/activationpreferred",
    "html": "Discussion\n\nWhen you receive this result in your completion handler, call the activate() method of your GroupActivity type to advertise the activity to other participants in the group.\n\nSee Also\nGetting the activation results\ncase activationDisabled\nA result that indicates the user disabled the automatic sharing of activities, or prefers to perform the activity locally.\ncase cancelled\nA result that indicates the user canceled the activation request."
  },
  {
    "title": "GroupActivityActivationResult.activationDisabled",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivityactivationresult/activationdisabled",
    "html": "Discussion\n\nUse the available context to determine the best way to proceed with this action. For example, instead of sharing a movie with a group, configure playback locally on the user’s device. For activities that only make sense in a group environment, you might alert the user that you can’t start the activity.\n\nSee Also\nGetting the activation results\ncase activationPreferred\nA result that indicates the user wants to share the activity with the group.\ncase cancelled\nA result that indicates the user canceled the activation request."
  },
  {
    "title": "GroupActivityActivationResult.cancelled",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivityactivationresult/cancelled",
    "html": "Discussion\n\nWhen you receive this result, ignore the activity.\n\nSee Also\nGetting the activation results\ncase activationPreferred\nA result that indicates the user wants to share the activity with the group.\ncase activationDisabled\nA result that indicates the user disabled the automatic sharing of activities, or prefers to perform the activity locally."
  },
  {
    "title": "metadata",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivity/metadata",
    "html": "Required\n\nDiscussion\n\nThe system accesses this property when it’s ready to invite other participants to join the activity. Don’t access this property directly. Instead, implement it in your custom activity types and provide descriptive information about the current activity. For example, provide the title of the activity and an image that illustrates the activity.\n\nSee Also\nSpecifying the activity details\nstatic var activityIdentifier: String\nAn app-defined string that uniquely identifies the activity.\n\nRequired Default implementation provided."
  },
  {
    "title": "GroupStateObserver",
    "url": "https://developer.apple.com/documentation/groupactivities/groupstateobserver",
    "html": "Overview\n\nStarting a SharePlay experience with the Group Activities framework requires an active FaceTime call. Use a GroupStateObserver object to determine whether it’s possible to start such an experience. When no call is active, you might adjust your app’s user interface. For example, you might hide or remove controls that start a shared activity.\n\nTo get the current system state, create a GroupStateObserver object and check the value of its isEligibleForGroupSession property. To respond right away when the value of the property changes, configure a subscriber for that property.\n\nTopics\nCreating a group state observer\nconvenience init()\nCreates a new group state observer object for determining the availability of group sessions.\nDetermining the eligibility for shared activities\nvar isEligibleForGroupSession: Bool\nA Boolean value that indicates whether the system can start a group session.\nInstance Properties\nvar $isEligibleForGroupSession: Published<Bool>.Publisher\nType Aliases\ntypealias ObjectWillChangePublisher\nThe type of publisher that emits before the object has changed.\nDefault Implementations\nObservableObject Implementations\nRelationships\nConforms To\nObservableObject"
  },
  {
    "title": "fallbackURL",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata/fallbackurl",
    "html": "Discussion\n\nUse this property to provide fallback behavior for users who don’t have your app installed on their device. For example, if your app runs only on iOS, use this property to supply activity-related information for users on a Mac. When your app isn’t available, the system opens the specified URL in Safari.\n\nImportant\n\nMake sure that the URL in this property eventually leads to a webpage with the same content as the activity. Safari automatically synchronizes media playback for listen-together and watch-together experiences.\n\nSee Also\nPresenting the activity\nvar title: String?\nThe localized string to display as the title of your activity.\nvar subtitle: String?\nThe localized string that provides additional information about the activity.\nvar previewImage: CGImage?\nThe image to display for the current activity."
  },
  {
    "title": "attachments",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/attachments-swift.property",
    "html": "Discussion\n\nThis property contains an asynchronous sequence that you monitor while the current session is active. To monitor this sequence, configure an asynchronous task and iterate over the contents of the GroupSessionJournal.Attachments type. For an example of how to configure this task, see the overview for GroupSessionJournal.\n\nThe system updates this array whenever a participant adds or removes an attachment. Iterate over the array and update your app’s data structures to match the current contents.\n\nSee Also\nDownloading content from the session\nstruct Attachments\nAn asynchronous sequence that contains one or more incoming attachment containers for you to process.\nstruct Attachment\nA container for the data you download."
  },
  {
    "title": "add(_:metadata:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/add(_:metadata:)",
    "html": "Parameters\nitem\n\nThe item to send to other session participants. The type you specify must conform to the Transferable protocol. For more information about creating transferable types, see Core Transferable.\n\nmetadata\n\nCustom metadata to include with the item. Specify a Codable type that contains information to help your app interpret or process the item on other devices. For example, you might include app-specific details that aren’t part of the item’s intrinsic data format.\n\nReturn Value\n\nAn attachment object you can remove by passing it to the remove(attachment:) function.\n\nDiscussion\n\nCall this method when you want to send a file or codable data type to the other participants of an activity. The method runs asynchronously and can return before the upload operation finishes.\n\nSee Also\nUploading content to the session\nfunc add<ItemType>(ItemType) async throws -> GroupSessionJournal.Attachment\nAdds the specified item to the journal and begins transferring the item’s data to the other participants’ devices so they can access it."
  },
  {
    "title": "add(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/add(_:)",
    "html": "Parameters\nitem\n\nThe item to send to other session participants. The type you specify must conform to the Transferable protocol. For more information about creating transferable types, see Core Transferable.\n\nReturn Value\n\nAn attachment object you can remove by passing it to the remove(attachment:) function.\n\nDiscussion\n\nCall this method when you want to send a file or codable data type to the other participants of an activity. The method runs asynchronously and can return before the upload operation finishes.\n\nSee Also\nUploading content to the session\nfunc add<ItemType, MetadataType>(ItemType, metadata: MetadataType) async throws -> GroupSessionJournal.Attachment\nAdds the specified item and metadata to the journal and begins transferring the data to the other participants’ devices so they can access it."
  },
  {
    "title": "init(session:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal/init(session:)",
    "html": "Parameters\nsession\n\nThe session you use for communicating with participants. The session must be in the GroupSession.State.waiting or GroupSession.State.joined state when you create the journal, and the session must be in the GroupSession.State.joined state before you can send or receive attachments.\n\nReturn Value\n\nA GroupSessionJournal object configured for the specified session."
  },
  {
    "title": "init(session:deliveryMode:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/init(session:deliverymode:)",
    "html": "Parameters\nsession\n\nThe group session to use for communication with participants. Specify a session object that is in either the GroupSession.State.waiting or GroupSession.State.joined state for this parameter. However, a session must be in the joined state to send or receive messages.\n\ndeliveryMode\n\nThe delivery mode for sending and receiving messages. Specify a delivery mode option for the underlying transport of either GroupSessionMessenger.DeliveryMode.reliable or GroupActivities/GroupSessionMessenger/DeliveryMode-swift.enum-swift.enum/unreliable"
  },
  {
    "title": "SystemCoordinator",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator",
    "html": "Overview\n\nA SystemCoordinator object helps you coordinate the presentation of your app’s content when spatial placement is active. In visionOS, the system can present a SharePlay activity as if the participants were together in the same room with the content. Each participant views the content from a particular vantage point, and sees the changes that others make. The system handles the placement of each participant’s Spatial Persona relative to the content, but you handle any changes to the content itself with the help of the SystemCoordinator object.\n\nYou don’t create a SystemCoordinator object directly. After you receive a GroupSession object for an activity, retrieve the system coordinator from the session’s systemCoordinator property. When you first retrieve the object, update its configuration property to tell the system how you want to arrange participants in the scene. After that, use the information in the system coordinator’s properties to keep your app’s interface up to date. When participants support spatial placement, send additional data to synchronize your content for those participants. For example, when one person scrolls the contents of a window, update the scroll position in the window of other spatially aware participants to preserve the shared context for everyone.\n\nYou choose what information to share among participants, and you choose how to manage the corresponding updates. A system coordinator object only helps you know when to make those changes. Observe the object’s published properties to receive automatic updates when the values change.\n\nTopics\nConfiguring the spatial coordinator\nvar configuration: SystemCoordinator.Configuration\nThe current configuration of the system coordinator.\nstruct Configuration\nA structure that specifies your app’s support for activities that take place in a shared simulation space.\nGetting the participant state\nvar localParticipantState: SystemCoordinator.ParticipantState\nThe current participant’s level of support for an activity that takes place in a shared simulation space.\nvar localParticipantStates: SystemCoordinator.ParticipantStates\nAn asynchronous sequence that reports changes to the local participant’s state.\nstruct ParticipantStates\nAn asynchronous sequence that reports the current person’s ability to participate in a shared context.\nGetting the current immersion level\nvar groupImmersionStyle: SystemCoordinator.GroupImmersionStyles\nThe presentation style to apply to an immersive space for the current activity.\nstruct GroupImmersionStyles\nAn asynchronous sequence that contains one or more incoming immersion styles for you to process.\nSee Also\nSpatial activities\nAdding Spatial Persona support to an activity\nUpdate your SharePlay activities to support Spatial Personas and the shared context when running in visionOS.\nstruct ParticipantState\nA structure that tells you whether a participant supports a shared simulation space for the current activity."
  },
  {
    "title": "send(_:to:completion:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/send(_:to:completion:)-9e0sn",
    "html": "Parameters\nmessage\n\nThe custom data structure you want to send. The data structure must conform to the Codable protocol.\n\nparticipants\n\nThe recipients of the message. The default value of this parameter is the set of all active participants in the session. Use the Participants.only(_:) option to specify a subset of participants.\n\ncompletion\n\nThe handler block to call with the results of the delivery attempt. The handler has no return value and takes a single Error parameter. The value of this parameter is nil if delivery succeeds; otherwise, it contains an appropriate error object.\n\nDiscussion\n\nUse this method to send data that you package into a custom class or structure. The method encodes your custom structure’s type information, and delivers the data only to message sequences of the same type.\n\nSee Also\nSending data to the group\nfunc send(Data, to: Participants) async throws\nSends a standard data object asynchronously to other participants in the group session.\nfunc send<Message>(Message, to: Participants) async throws\nSends a custom type asynchronously to other participants in the group session.\nfunc send(Data, to: Participants, completion: ((any Error)?) -> Void)\nSends a standard data object to other participants in the group session.\nenum Participants\nThe set of participants to include in messages."
  },
  {
    "title": "send(_:to:completion:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger/send(_:to:completion:)-zufl",
    "html": "Parameters\ndata\n\nThe data object to send.\n\nparticipants\n\nThe recipients of the message. The default value of this parameter is the set of all active participants in the session. Use the Participants.only(_:) option to specify a subset of participants.\n\ncompletion\n\nThe handler block to call with the results of the delivery attempt. The handler has no return value and takes a single Error parameter. The value of this parameter is nil if delivery succeeds; otherwise, it contains an appropriate error object.\n\nDiscussion\n\nUse this method to send data using a standard data object. Your app is responsible for decoding and using the data it receives.\n\nSee Also\nSending data to the group\nfunc send(Data, to: Participants) async throws\nSends a standard data object asynchronously to other participants in the group session.\nfunc send<Message>(Message, to: Participants) async throws\nSends a custom type asynchronously to other participants in the group session.\nfunc send<Message>(Message, to: Participants, completion: ((any Error)?) -> Void)\nSends a custom type to other participants in the group session.\nenum Participants\nThe set of participants to include in messages."
  },
  {
    "title": "Adding Spatial Persona support to an activity",
    "url": "https://developer.apple.com/documentation/groupactivities/adding-spatial-persona-support-to-an-activity",
    "html": "Overview\n\nA person who participates in SharePlay activities on Apple Vision Pro has the option to participate using their Spatial Persona. The system arranges Spatial Personas around the activity content, giving each person a clear view of the content and each other. Each person sees the facial expressions of other participants, what they’re looking at, and where they’re pointing. This experience creates the feeling that they’re in the same physical space interacting with shared content and each other.\n\nTo maintain the experience when Spatial Personas are visible, apps share additional information to maintain the shared context for the activity. Because participants can see where others are looking, your app’s content must look the same for everyone. Share any additional information you need to keep everyone’s content in sync visually. For example, synchronize your window’s scroll position to ensure everyone sees the same portion of that window.\n\nYou don’t need to define new GroupActivity types specifically to support Spatial Personas. The system automatically displays Spatial Personas for existing activities that take place in a window or volume. However, if you support activities in a Full Space, you need to do additional work to support Spatial Personas for your experience. For information about how to define activities in your app, see Defining your app’s SharePlay activities.\n\nAssociate SharePlay activities with your app’s scenes\n\nYou use scenes to manage the content for your app’s windows, volumes, and immersive spaces. You also use scenes to display any activity-related content. When a participant joins an activity, the system selects or opens the scene that supports the activity. If your app has only one scene and one window, the system has only one choice. However, if your app has multiple scenes, you need to help the system choose the correct one.\n\nFor each of your app’s scenes, activation conditions tell the system how to handle your app’s SharePlay activities. You also use activation conditions to specify how to handle NSUserActivity objects, and other incoming events. To specify activation conditions for one of your scenes:\n\nFor SwiftUI, add the handlesExternalEvents(preferring:allowing:) modifier to your scene type.\n\nFor UIKit, configure the scene’s activationConditions property in the scene(_:willConnectTo:options:) method of your scene delegate.\n\nWhen you add an activation condition to a scene, you specify a string that uniquely identifies your SharePlay activity. The string can be anything you want, as long as it creates a unique connection between the activity and the specific scene. When there is a one-to-one correspondence between an activity and scene, the string in the activityIdentifier property of your activity object is a good choice. When there isn’t a one-to-one correspondence between scene and activity, you must create a string that uniquely identifies the scene. For example, in a document-based app, you might specify the name of a document to direct the system to the scene that contains the document.\n\nThe following code defines a SwiftUI scene for a window, and associates two activities with that window. Because the app uses the same scene to display content for two different activities, the activation conditions contain the identifiers for the two GroupActivity types. When either activity starts, the system directs the activity to the window containing the scene. If no such window is open, the system launches the app and creates the window as needed.\n\nlet activationConditions : Set = [\"com.mycompany.MySharePlayActivity\",\n                                  \"com.mycompany.MyUserActivity\"]\nvar body: some Scene {\n    WindowGroup {\n        ContentView()\n            .handlesExternalEvents(preferring: [], allowing: activationConditions)\n    }\n\n\nIn addition to configuring your scene, you need to update your activity object’s metadata with the appropriate string. Specify the string using the sceneAssociationBehavior property of your activity object’s GroupActivityMetadata structure. Assign the default value to this property if you use the activity identifier as the string. For any custom strings, assign the content(_:) value and specify your string. To disable scene association for the activity and handle the presentation of activity-related UI yourself, specify the none value.\n\nConfigure your app’s support for Spatial Personas\n\nThe system provides some default behaviors to make it easier for you to adopt Spatial Personas in your app. For activities that take place in a window or volume, the system chooses a default arrangement of the Spatial Personas around your scene. The system also adorns the scene with a Share menu, which provides a visual indication when sharing is active and contains controls to start activities. The system doesn’t display Spatial Personas in a Full Space by default.\n\nTo change the default behavior of your app, update the SystemCoordinator of your GroupSession before you call the session’s join() method. Use the SystemCoordinator to:\n\nSpecify a different arrangement for Spatial Personas.\n\nSpecify whether your app supports Spatial Personas when a Full Space is visible.\n\nThe following example changes the arrangement of Spatial Personas to be side by side facing the app’s content. The code also tells the system that the app supports Spatial Personas when a Full Space is open.\n\nif let coordinator = await newSession.systemCoordinator {\n    var config = SystemCoordinator.Configuration()\n    config.spatialTemplatePreference = .sideBySide.contentExtent(200)\n    config.supportsGroupImmersiveSpace = true\n    coordinator.configuration = config\n}\n\n\n// Join the session.\nnewSession.join()\n\n\nSpatial template preferences tell the system whether to arrange participants side by side, in a circle, or in an arrangement that supports conversation. For each template, the system uses the size of your content to determine how far away to place Spatial Personas. For example, the system moves them farther away when your content is larger, and brings them closer together when your content is small. To override this distance, add the contentExtent(_:) modifier to your template preference. That modifier tells the system to use the distance you specify, instead of the content size.\n\nIf you enable support for Spatial Personas in a Full Space, you must do additional work to support that experience. When an activity moves to a Full Space, the system creates a shared coordinate system for all participants and the content. In this new coordinate system, participants are no longer at the center of the coordinate system, which might require you to update the position of your content. For more information, see Place content relative to a participant in an immersive space.\n\nSynchronize additional data when Spatial Personas are visible\n\nWhen Spatial Personas are visible, it’s your responsibility to maintain the shared context for your activity. The shared context includes both the content you display and how that content appears to each participant. People can gesture or look at content using their Spatial Persona, so it’s important that everyone sees the same thing when that happens. For example, Freeform synchronizes both the page content and the current scroll position to ensure everyone sees the same portion of the page.\n\nWhen defining an activity, define additional data messages to synchronize any information you need to maintain the shared context. When the current participant shows their Spatial Persona, send the extra messages when the participant makes relevant changes to the activity. For example, send them when the person scrolls the activity window. Similarly, receive those messages and incorporate the results into your app when the Spatial Persona is visible.\n\nNote\n\nMake sure you separate the messages that all participants require from the ones that only make sense when Spatial Personas are visible. Maintaining the shared context is necessary when Spatial Personas are visible, but isn’t always necessary at other times. For example, Freeform doesn’t synchronize the scroll position for someone without a Spatial Persona.\n\nTo determine when someone’s Spatial Persona is visible, monitor the localParticipantStates of your session’s SystemCoordinator object. The AsyncSequence in this property reports participant-related state changes, including changes to the visibility of their Spatial Persona. Get the isSpatial property of the returned SystemCoordinator.ParticipantState structure and use it to configure your app’s behavior. The following example uses a task to update the game state to accommodate Spatial Personas. When the current participant is spatial, the game sends additional messages to maintain the shared context.\n\nTask.detached { @MainActor in\n    for await state in coordinator.localParticipantStates {\n        if state.isSpatial {\n            // Synchronize additional data for the shared context.\n            gameModel.isSpatial = true\n        } else {\n            // Don't synchronize additional data.\n            gameModel.isSpatial = false\n        }\n    }\n}\n\nUpdate the immersion level automatically for a Full Space\n\nIf one participant opens an immersive space as part of an activity, the system doesn’t automatically open the same immersive space for other participants. Making a transition to an immersive space is a significant change, and some participants might not want to make the transition right away. For example, if a participant is on a phone call, they might not want another app to open an immersive space and hide their call. Instead, the system reports when transitions to immersive spaces occur, and lets you decide when to transition other participants automatically.\n\nTo determine when any participant transitions to an immersive space, monitor the groupImmersionStyle property of your SystemCoordinator object. This property contains an AsyncSequence that reports the most recent immersion style that a participant adopts. When a participant presents an immersive space, or when they change the immersion style of the current space, the system updates the sequence with the new value. The following example shows a task that transitions automatically in some cases, but not others:\n\nTask.detached {\n    if let systemCoordinator = try await groupSession.systemCoordinator {\n        for await immersionStyle in systemCoordinator.groupImmersionStyle {\n            switch immersionStyle {\n                case .full:\n                    // Transition to a Full Space only if the participant\n                    // gives permission to do so.\n                    break\n                        \n                case .mixed:\n                    // Open or transition to a mixed style immersive space automatically.\n                    break\n                        \n                case .progressive:\n                    // Open or transition to a progressive style immersive space automatically\n                    break\n                        \n                default:\n                    // Dismiss the immersive space completely.\n                    break\n            }\n        }\n    }\n}\n\n\nThe system reports nil for the immersion style when a participant dismisses their open immersive space. Use that option to dismiss the space for other participants and return to a window or volume.\n\nNote\n\nIf a participant presses the Digital Crown while an immersive space is open, the system dismisses the space without notifying the rest of the group. Someone might use this feature to temporarily leave the activity and perform another task. After they perform that task, they can use the system-provided UI to rejoin the activity and return to the group immersive space.\n\nPlace content relative to a participant in an immersive space\n\nWhen an activity takes place in an immersive space, the system creates a shared coordinate system for the participants and content. In this new coordinate space, the origin of the coordinate space is not the same as the origin of any of the participants. If an activity-related window or volume is visible, the system places the window or volume at the new origin. If the activity doesn’t use a window or volume, the system arranges the participants in a circle and sets the origin of the coordinate space to the circle’s center. The following figure shows the origin of the shared coordinate system for a window, volume, and immersive space relative to several Spatial Personas.\n\nIn a side-by-side arrangement with a window, the origin is under the window.\n\nIn a surround arrangement with a volume, the origin is under the volume.\n\nWhen no window or volume is present, the system uses the surround presentation style and places the origin at the center of the group.\n\nIf you place content directly into your immersive space, you must adjust the position of that content to account for the modified coordinate space. To do that, you first determine the person’s location in the new coordinate system. Read the person’s location in the scene using a GeometryProxy3D. The proxy for this reader contains a doc://com.apple.documentation/documentation/swiftui/geometryproxy3d/immersivespacedisplacement(in:) method, which you can use to locate the origin of the shared coordinate space. Call the method using the global value as a parameter to get the displacement of the coordinate space’s origin, relative to the person’s location. Invert that displacement value to get the location of the participant relative in the new coordinate space. The following example shows how to use a GeometryProxy3D to get the offset to the current participant and use that information to place a custom view:\n\nvar body: some Scene {\n    ImmersiveSpace(id:\"earth\") {\n        GeometryReader3D { proxy in\n            let displacement = \n                proxy.immersiveSpaceDisplacement(in: .global).inverse\n                \n            CustomView()\n                .offset(displacement.position)\n                .rotation3DEffect(displacement.rotation)\n        }\n    }\n}\n\n\nThe displacement between a person and the origin of the scene doesn’t change during the course of your activity even when the participant moves. The system sets the origin of an immersive space when you first present it, and updates it only once when changing it to a shared coordinate space.\n\nSee Also\nSpatial activities\nclass SystemCoordinator\nA type you use to coordinate your interface’s behavior when an active SharePlay session supports spatial placement of content.\nstruct ParticipantState\nA structure that tells you whether a participant supports a shared simulation space for the current activity."
  },
  {
    "title": "Participant",
    "url": "https://developer.apple.com/documentation/groupactivities/participant",
    "html": "Overview\n\nUse a Participant object to differentiate among users in a session. A participant object doesn’t contain any sensitive data about the user, but provides a unique identifier to distinguish the user while the session is active.\n\nYou don’t create participant objects directly. The system creates a participant object for each user that joins an activity. Access the current set of participants from the activeParticipants property of the GroupSession object associated with the activity.\n\nTopics\nGetting the unique identifier\nlet id: UUID\nA globally unique identifier for the session participant.\nComparing participants\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (Participant, Participant) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nInstance Properties\nvar hashValue: Int\nThe hash value.\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nType Aliases\ntypealias ID\nA type representing the stable identity of the entity associated with an instance.\nDefault Implementations\nCustomStringConvertible Implementations\nEquatable Implementations\nRelationships\nConforms To\nCustomStringConvertible\nEquatable\nHashable\nIdentifiable\nSee Also\nSession management\nJoining and managing a shared activity\nConfigure the session when a SharePlay activity starts, and handle events that occur during the lifetime of the activity.\nDrawing content in a group session\nInvite your friends to draw on a shared canvas while on a FaceTime call.\nclass GroupSession\nA session for an in-progress activity that synchronizes content among participant devices.\nprotocol CustomMessageIdentifiable\nA type that assigns a custom ID string to messages you send to other devices."
  },
  {
    "title": "Joining and managing a shared activity",
    "url": "https://developer.apple.com/documentation/groupactivities/joining-and-managing-a-shared-activity",
    "html": "Overview\n\nWhen one person in a group starts an activity, other people’s devices display system UI to prompt them to join that activity. When each person joins, the system prepares a GroupSession object for the activity and delivers it to their app. Your app uses that session object to:\n\nPrepare any required UI.\n\nStart the activity, monitor its state, and respond to changes.\n\nSynchronize activity-related information.\n\nFor information about how to define activities, see Defining your app’s SharePlay activities. For information about how to start activities, see Presenting SharePlay activities from your app’s UI.\n\nJoin an activity from a background task\n\nActivities can start at any time, so you need to set up an asynchronous handler in your app to listen for when they start. After a participant joins an activity, the system creates a GroupSession object and delivers it to the sessions property of the GroupActivity type you defined. Monitor the sessions property from an asynchronous handler, and process new session objects when they become available.\n\nConfigure separate asynchronous handlers for each of your app’s activity types, and use each one to receive new sessions for their activity. In SwiftUI, create your handler by adding the task(priority:_:) modifier to the view containing the UI for the activity, as shown in the example below. Inside the block for the task modifier, wait on the activity’s sessions property using a for..in loop. The sessions property contains an AsyncSequence type, which wakes up the task and executes your code when a new session arrives. Use your code to begin the activity in your app.\n\nstruct ContentView: View {\n\n\n    var body: some View {\n        VStack {\n            MyCustomView()\n            MyOtherCustomView()\n        }\n        .task {\n            for await session in MyActivity.sessions() {\n                // Perform any app-specific tasks...\n\n\n                // Join the session.\n                session.join\n            }\n        }\n    }\n}\n\n\nIf you’re not using SwiftUI, handle the arrival of sessions using a Task block, as shown in the following example. This block offers the same behavior as the SwiftUI task modifier, and you use it in similar ways. When a new session arrives, update your app’s UI to reflect the current activity, or perform any other tasks you need to prepare for the activity.\n\n// Process an asynchronously delivered session.\nvar task = Task {\n    for await session in DrawTogether.sessions() {\n\n\n        // Perform any app-specific tasks...\n\n\n        // Join the session.\n        session.join()\n    }\n}\n\n\nSave a reference to any sessions you receive asynchronously and remove those references when the session state changes to GroupSession.State.invalidated(reason:). The system delivers one new session for each joined activity. When the state of the session changes, or when other properties change, the system updates the already delivered session. To detect updates while the session is active, add subscribers to the properties of the GroupSession object.\n\nPrepare your app’s interface\n\nWhen your app receives a GroupSession object, start preparing your app’s UI immediately. The activity doesn’t start until you call the join method of the session object you received. However, don’t call that method until you’re ready to display the UI for the activity itself. If your app needs to collect login credentials or download content before starting the activity, present the UI for those tasks and wait for them to complete before you call the join method.\n\nAfter you join an activity, update your UI as needed to reflect relevant information. In particular:\n\nProvide a way for people to see who joined the activity, and who hasn’t joined. Some people might not join an activity right away, because they don’t have the app or are doing something else. Keeping everyone informed lets them know who’s aware of the activity details.\n\nProvide visual cues when someone makes a change, and optionally display information about who made the change. For example, annotate the change temporarily with the person’s identity, or add app-specific messages to the conversation.\n\nSupport people navigating away from an activity but staying on the group FaceTime call or Messages conversation. For activities that involve video playback, support Picture in Picture to continue playback even when someone changes apps.\n\nMake sure app-specific controls are easy to access.\n\nJoin the session to start the activity\n\nWhen your app has everything it needs and is ready to start the activity, call the join() method of the GroupSession object. The join() method asks the system to start the activity in your app.\nEven after you call this method, the session remains in the GroupSession.State.waiting state until the system establishes a connection to the activity.\n\nIf your call to join() is successful, the system changes the state of the session to GroupSession.State.joined and begins sending information to and from the current device. If you tried to synchronize data after calling join(), but before the system completed the request, those requests remain queued until your session enters the GroupSession.State.joined state. After successfully joining the session, the system expects you to handle session-related changes and messages. For information about how to send messages between participants, see Synchronizing data during a SharePlay activity.\n\nAccommodate people who arrive late to the session\n\nParticipants join activities separately, and people can join immediately or after a delay. If participants need to download your app, or don’t see the invitation to join the activity, they might arrive several minutes after others. If your activity manages state information that all participants require, devise a way to deliver that information to someone who arrives late. For example, a whiteboard app needs to deliver the current whiteboard content to any late joiners.\n\nConsider the experience for people who arrive late to an activity, and plan for it when implementing your activity support. You might create a lobby interface where participants wait until everyone is present, or you might define custom messages to let people catch up with the rest of the group. Choose an experience that makes sense for your app, and remember that every participant is equal in a SharePlay activity. There’s no single activity owner who controls the experience.\n\nTo determine when new participants join the session, monitor the activeParticipants property of the session using a separate task. When the list of participants changes, compare the new list with a saved copy your app maintains. When you detect new participants, update them with the current state of the activity.\n\nTask {\n    for try await updatedParticipants in session.$activeParticipants.values {\n        for participant in updatedParticipants {\n            // Compare the current list to a saved version you maintain.\n        }\n    }\n}\n\nEnd the activity for one or more participants\n\nThe GroupSession object contains methods to end the session for the current participant or the entire group. When designing your UI, make it clear which option someone is choosing, and call the correct method in response.\n\nWhen a participant quits your app, switches to a different app, or navigates away from your app’s activity-related UI, call leave() to end the activity for that participant. Other participants remain engaged in the activity until they leave or until someone ends the activity for everyone.\n\nWhen a participant leaves an activity, the system moves their session to the GroupSession.State.invalidated(reason:) state and stops the flow of information between their device and the rest of the group. When the session moves to this state, it’s safe to discard the session object itself and perform any activity-related cleanup. If the person is still active on the FaceTime call or Messages conversation and rejoins the activity later, the system delivers a new session object to your app.\n\nWhen you want to end the activity for everyone, call the end() method. This method invalidates the sessions for all participants. Make sure any buttons or UI that calls this method makes it clear that the activity ends for everyone. The session also ends when everyone leaves the activity.\n\nSee Also\nSession management\nDrawing content in a group session\nInvite your friends to draw on a shared canvas while on a FaceTime call.\nclass GroupSession\nA session for an in-progress activity that synchronizes content among participant devices.\nprotocol CustomMessageIdentifiable\nA type that assigns a custom ID string to messages you send to other devices.\nstruct Participant\nAn active participant in a group session."
  },
  {
    "title": "init(_:)",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingcontroller-ybcy/init(_:)",
    "html": "Parameters\nactivity\n\nThe activity object to start.\n\nSee Also\nCreating the group activity sharing controller\ninit<ActivityType>(preparationHandler: () async throws -> ActivityType)\nInitializes the SharePlay sharing controller with a closure that creates the activity object."
  },
  {
    "title": "GroupActivityMetadata",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitymetadata",
    "html": "Overview\n\nUse a GroupActivityMetadata structure to store user-facing information about a specific activity your app suggests. Metadata information includes the title of the activity, an image that corresponds to the activity, and a fallback URL for users who don’t have your app. For example, a movie-watching activity might include the poster of the specific movie a participant suggests. The system uses the provided metadata to generate invitations for other participants.\n\nCreate a GroupActivityMetadata structure in the metadata property of your custom GroupActivity subclass. Populate the new structure with the relevant data for your activity.\n\nTopics\nCreating group activity metadata\ninit()\nCreates a new instance for storing descriptive information about an activity.\ninit(from: any Decoder) throws\nCreates a new instance by decoding from the given decoder.\nPresenting the activity\nvar title: String?\nThe localized string to display as the title of your activity.\nvar subtitle: String?\nThe localized string that provides additional information about the activity.\nvar previewImage: CGImage?\nThe image to display for the current activity.\nvar fallbackURL: URL?\nA URL that offers participants a way to identify or join the activity from a web browser.\nIndicating the activity’s type\nvar type: GroupActivityMetadata.ActivityType\nThe type of shared experience.\nstruct ActivityType\nConstants that indicate the group activity’s type to the system.\nAssigning an app-specific scene\nvar sceneAssociationBehavior: SceneAssociationBehavior\nCriteria the system uses to direct an activity to a specific scene of your app.\nstruct SceneAssociationBehavior\nA type that tells the system which scene to associate with an incoming group activity.\nSpecifying media-related behavior\nvar supportsContinuationOnTV: Bool\nA Boolean value that indicates whether your app supports activity continuation on an Apple TV.\nvar preferredBroadcastOptions: BroadcastOptions\nPreferences for how to present audio and video on the main communication channel.\nstruct BroadcastOptions\nOptions for how to broadcast media on the shared communications channel.\nComparing metadata objects\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (GroupActivityMetadata, GroupActivityMetadata) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nEncoding the metadata\nfunc encode(to: any Encoder) throws\nEncodes this value into the given encoder.\nInstance Properties\nvar experience: GroupActivityMetadata.Experience?\nDeprecated\nvar localizedSubtitle: String?\nDeprecated\nvar localizedTitle: String?\nDeprecated\nEnumerations\nenum Experience\nDeprecated\nDefault Implementations\nDecodable Implementations\nEncodable Implementations\nEquatable Implementations\nRelationships\nConforms To\nDecodable\nEncodable\nEquatable\nSee Also\nActivity definition\nDefining your app’s SharePlay activities\nConfigure your app’s SharePlay support and define the activities that people can perform from your app.\nSupporting Coordinated Media Playback\nCreate synchronized media experiences that enable users to watch and listen across devices.\nprotocol GroupActivity\nA type that can advertise your app’s activities to other participants.\nenum GroupActivityActivationResult\nThe result of preparing to start a custom activity.\nstruct GroupActivityTransferRepresentation\nA type that lets you start a group activity from a known context."
  },
  {
    "title": "isEligibleForGroupSession",
    "url": "https://developer.apple.com/documentation/groupactivities/groupstateobserver/iseligibleforgroupsession",
    "html": "Discussion\n\nThis property indicates whether a FaceTime call is active and the system can create group sessions. Configure a subscriber to this property to monitor changes to the system’s state. When the system can create group sessions, it sets the value of this property to true. When the creation of a group session isn’t possible, the system sets the value to false."
  },
  {
    "title": "GroupActivityTransferRepresentation",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitytransferrepresentation",
    "html": "Topics\nInitializers\ninit<ActivityType>(exporting: (Item) async throws -> ActivityType)\nCreates a type that exports a group activity for the specified item.\nInstance Properties\nvar body: some TransferRepresentation\nA builder expression that describes the process of importing and exporting an item.\nType Aliases\ntypealias Body\nThe transfer representation for the item.\nDefault Implementations\nTransferRepresentation Implementations\nRelationships\nConforms To\nSendable\nTransferRepresentation\nSee Also\nActivity definition\nDefining your app’s SharePlay activities\nConfigure your app’s SharePlay support and define the activities that people can perform from your app.\nSupporting Coordinated Media Playback\nCreate synchronized media experiences that enable users to watch and listen across devices.\nprotocol GroupActivity\nA type that can advertise your app’s activities to other participants.\nstruct GroupActivityMetadata\nText and image content that describes an activity to potential participants.\nenum GroupActivityActivationResult\nThe result of preparing to start a custom activity."
  },
  {
    "title": "GroupActivity",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivity",
    "html": "Overview\n\nAdopt the GroupActivity protocol in custom app data structures that represent your app’s shareable experiences. The protocol provides the system with the context and metadata to start an activity-related session. For example, the protocol defines the unique identity of the activity, and returns information about the activity.\n\nIn addition to the protocol’s methods and properties, make sure your type includes the information you need to start the activity. When a participant accepts an activity, the system provides a copy of your activity type. You must use that type to begin the activity. For example, use it to present the appropriate UI for the activity and to load any required content.\n\nTo initiate an activity, create an instance of your custom type and call its prepareForActivation() or activate() method. You might call one of these methods from a button in your app’s UI, or in response to other user actions. If activation succeeds, the system advertises the activity on the current FaceTime call.\n\nWhen an activity begins, the system creates a GroupSession instance for the activity and delivers it asynchronously to your app. Use the sessions() method to get the session and configure your app’s UI.\n\nImportant\n\nGroupActivity types must be Codable so that the system can serialize them and send them to other participant’s devices.\n\nTopics\nSpecifying the activity details\nstatic var activityIdentifier: String\nAn app-defined string that uniquely identifies the activity.\n\nRequired Default implementation provided.\n\nvar metadata: GroupActivityMetadata\nA description of the activity, and optional image to display to the user.\n\nRequired\n\nStarting an activity immediately\nfunc prepareForActivation() async -> GroupActivityActivationResult\nReturns the participant’s preferred option for how to start the activity.\nenum GroupActivityActivationResult\nThe result of preparing to start a custom activity.\nfunc activate() async throws -> Bool\nBegins the activity immediately and creates a session for the app when a FaceTime call is active.\nReceiving an activity-related session\nstatic func sessions() -> Self.Sessions\nReturns the sessions for this activity as an asynchronous sequence.\ntypealias Sessions\nA type that provides asynchronous, sequential, iterated access to the sessions for the activity.\nTransferring data types\nstatic var transferRepresentation: some TransferRepresentation\nA default type that lets the system share your activity.\nAvailable when Self conforms to Transferable.\nRelationships\nInherits From\nDecodable\nEncodable\nSee Also\nActivity definition\nDefining your app’s SharePlay activities\nConfigure your app’s SharePlay support and define the activities that people can perform from your app.\nSupporting Coordinated Media Playback\nCreate synchronized media experiences that enable users to watch and listen across devices.\nstruct GroupActivityMetadata\nText and image content that describes an activity to potential participants.\nenum GroupActivityActivationResult\nThe result of preparing to start a custom activity.\nstruct GroupActivityTransferRepresentation\nA type that lets you start a group activity from a known context."
  },
  {
    "title": "prepareForActivation()",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivity/prepareforactivation()",
    "html": "Return Value\n\nThe action to take for the activity. Use this value to determine whether to start an activity locally or as a shared experience.\n\nDiscussion\n\nCall this method as the first step in starting a group activity, instead of calling the activate() method. Specifically, call this method when the participant tries to start an activity directly from your app’s UI — for example, when they try to watch a movie that’s shareable with a group. This method determines if sharing is possible, and may also prompt the participant to choose whether to start the activity locally or share it with the group.\n\nThe system learns over time what activities the user commonly shares, and may not prompt the user in all situations. The system also doesn’t prompt the user if the user disabled activity sharing or isn’t a member of an active group.\n\nSee Also\nStarting an activity immediately\nenum GroupActivityActivationResult\nThe result of preparing to start a custom activity.\nfunc activate() async throws -> Bool\nBegins the activity immediately and creates a session for the app when a FaceTime call is active."
  },
  {
    "title": "GroupSessionJournal",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionjournal",
    "html": "Overview\n\nA GroupSessionJournal object lets you transfer files and other data objects between participants of a shared activity. A journal object isn’t a replacement for a GroupSessionMessenger object, which you use to transfer time-sensitive messages and commands between participants. Instead, use it to associate files and other data objects with the activity. For example, you might share images that people drag into your app as part of the activity. The journal makes these data objects available to all participants, regardless of when they joined the session.\n\nAfter your app joins an activity and receives a session object, create a GroupSessionJournal object and store a strong reference to it. To add a file or data object to the group’s journal, call the add(_:) or add(_:metadata:) method with the data you want to share. The types you specify must adopt the Transferable protocol from the Core Transferable framework. The journal object uses that protocol to package a version of your data suitable for sending to other devices.\n\nTo receive data that a participant added to the journal, configure a task to listen for asynchronous updates to the attachments property of your GroupSessionJournal object. When someone adds or removes an attachment, the journal updates the array and executes your task. Load the contents of an attachment using the load(_:) method of that type. You can also retrieve any attachment-specific metadata, such as a shared ID or display name, that you included with the attached file. The following example creates a task that waits on a custom image type. The journal variable contains a previously configured GroupSessionJournal object.\n\nlet attachmentListener = Task {\n   for await attachments in journal.attachments {\n       for attachment in attachments {\n           let receivedItem = try await attachment.load(MyImageItem.self)\n           // Do something with the item you receive.\n       }\n   }\n}\n\nTopics\nCreating an attachment manager\nconvenience init<Activity>(session: GroupSession<Activity>)\nCreates a journal and associates it with the specified session of a group activity.\nUploading content to the session\nfunc add<ItemType>(ItemType) async throws -> GroupSessionJournal.Attachment\nAdds the specified item to the journal and begins transferring the item’s data to the other participants’ devices so they can access it.\nfunc add<ItemType, MetadataType>(ItemType, metadata: MetadataType) async throws -> GroupSessionJournal.Attachment\nAdds the specified item and metadata to the journal and begins transferring the data to the other participants’ devices so they can access it.\nDownloading content from the session\nvar attachments: GroupSessionJournal.Attachments\nThe currently available attachments for you to download and incorporate into your app.\nstruct Attachments\nAn asynchronous sequence that contains one or more incoming attachment containers for you to process.\nstruct Attachment\nA container for the data you download.\nRemoving content from the session\nfunc remove(attachment: GroupSessionJournal.Attachment) async throws\nRemoves the specified attachment from the journal on all sessions.\nSee Also\nFile and data transfer\nSynchronizing data during a SharePlay activity\nSend custom messages and data between devices to synchronize content for your activity, and incorporate messages your app receives from other participants.\nclass GroupSessionMessenger\nAn object that transfers app-specific data between the devices joined in a group session."
  },
  {
    "title": "GroupSessionMessenger",
    "url": "https://developer.apple.com/documentation/groupactivities/groupsessionmessenger",
    "html": "Overview\n\nUse a GroupSessionMessenger object to coordinate your app’s behavior across the devices attached to a group session. This object leverages the existing FaceTime communication channel to send app-specific data related to a SharePlay experience. For example, a movie-watching app might share user comments or tags while the movie plays.\n\nYou create a GroupSessionMessenger object directly and use it to send and receive app data. Create the messenger using an active GroupSession object, which manages the underlying communication channel. Store a strong reference to your GroupSessionMessenger object for the lifetime of the session. The following example shows a custom object for managing a movie-watching experience. The object stores the GroupSession object associated with the experience and creates a GroupSessionMessenger for sending messages between participants.\n\nclass CowatchingExperience : ObservableObject {\n    let groupSession: GroupSession<Trailer>\n    let messenger: GroupSessionMessenger\n\n\n    init(groupSession: GroupSession<Trailer>, item: Trailer) {\n        self.groupSession = groupSession\n        self.messenger = GroupSessionMessenger(session: groupSession)\n\n\n        self.groupSession.join()\n        // …\n    }\n}\n\n\nFor more information about establishing a group session, see GroupSession.\n\nReceive Messages from Other Devices\n\nThe system delivers messages to your app asynchronously when they arrive and adds them to a message sequence. Use the messages(of:) or messages(of:) method to retrieve the sequence you want and iterate over its results. Use a for-in loop with the await keyword to iterate asynchronously over the results. The following example shows how a Tic Tac Toe game might retrieve moves sent by the current opponent. After receiving each move, the code adds that move to the current participant’s board.\n\nlet sessionMessenger = GroupSessionMessenger(session: groupSession)\n\n\nasync {\n    for await move in sessionMessenger.messages(of: TicTacToe.Move.self) {\n        self.board.addMove(move)\n    }\n}\n\nTopics\nCreating a group session messenger\ninit<Activity>(session: GroupSession<Activity>)\nCreates a new group session messenger with GroupSessionMessenger.DeliveryMode.reliable delivery mode and associates it with the specified session object.\nSending data to the group\nfunc send(Data, to: Participants) async throws\nSends a standard data object asynchronously to other participants in the group session.\nfunc send<Message>(Message, to: Participants) async throws\nSends a custom type asynchronously to other participants in the group session.\nfunc send(Data, to: Participants, completion: ((any Error)?) -> Void)\nSends a standard data object to other participants in the group session.\nfunc send<Message>(Message, to: Participants, completion: ((any Error)?) -> Void)\nSends a custom type to other participants in the group session.\nenum Participants\nThe set of participants to include in messages.\nReceiving data from other participants\nfunc messages(of: Data.Type) -> GroupSessionMessenger.Messages<Data>\nReturns the asynchronous sequence of messages that contain a generic data object.\nfunc messages<Message>(of: Message.Type) -> GroupSessionMessenger.Messages<Message>\nReturns the asynchronous sequence of messages that match the app-specific type.\nstruct Messages\nAn asynchronous sequence of messages sent to the session.\nstruct MessageContext\nA structure that contains additional information about an incoming message, such as which device sent it.\nInitializers\ninit<Activity>(session: GroupSession<Activity>, deliveryMode: GroupSessionMessenger.DeliveryMode)\nCreates a new group session messenger with the specified delivery mode, GroupSessionMessenger.DeliveryMode, and associates it with the specified session object.\nInstance Properties\nlet deliveryMode: GroupSessionMessenger.DeliveryMode\nThe GroupSessionMessenger.DeliveryMode specified at initialization time (defaults to reliable).\nEnumerations\nenum DeliveryMode\nThe transmission characteristics to apply to the delivery of messages.\nSee Also\nFile and data transfer\nSynchronizing data during a SharePlay activity\nSend custom messages and data between devices to synchronize content for your activity, and incorporate messages your app receives from other participants.\nclass GroupSessionJournal\nAn object that manages file and data transfers between participants joined in a group session."
  },
  {
    "title": "SystemCoordinator.ParticipantState",
    "url": "https://developer.apple.com/documentation/groupactivities/systemcoordinator/participantstate",
    "html": "Overview\n\nA SystemCoordinator.ParticipantState structure reports the current person’s ability to display a Spatial Persona when joined to a group activity. A person can display a Spatial Persona only if the device supports it, and only if they configured that Spatial Persona in advance.\n\nWhen someone’s Spatial Persona is active, SharePlay positions the person in the scene relative to the shared content. When that happens, share any extra activity-related details that preserve the shared context of the scene. For example, when one person scrolls the content in a shared window, communicate the new scroll position as an activity update. When your app receives those extra updates, apply them only if the current Spatial Persona is also active.\n\nObserve the participant’s spatial state from the localParticipantState property of your session’s SystemCoordinator object. Spatial state information can change, so update your app’s presentation to reflect the person’s current support for the activity.\n\nTopics\nGetting the participant details\nlet isSpatial: Bool\nA Boolean value that indicates whether the person supports being in a shared simulation space for an activity.\nOperators\nstatic func == (SystemCoordinator.ParticipantState, SystemCoordinator.ParticipantState) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nSee Also\nSpatial activities\nAdding Spatial Persona support to an activity\nUpdate your SharePlay activities to support Spatial Personas and the shared context when running in visionOS.\nclass SystemCoordinator\nA type you use to coordinate your interface’s behavior when an active SharePlay session supports spatial placement of content."
  },
  {
    "title": "Drawing content in a group session",
    "url": "https://developer.apple.com/documentation/groupactivities/drawing_content_in_a_group_session",
    "html": "Overview\n\nNote\n\nThis sample code project is associated with WWDC23 session 10241: Share files with SharePlay, and WWDC21 session 10187: Build custom experiences with Group Activities.\n\nGroup Activities allows you to build shared experiences across devices with SharePlay. Although its focus is on creating media experiences, you can design your own custom app experiences to share with multiple devices. The real-time interactions you unlock, and the instant reaction people who use your app get, can lead to some truly special moments.\n\nThe sample app, DrawTogether, builds on some of the concepts introduced in WWDC21 session 10225: Coordinate media experiences with Group Activities. It allows you to draw together while on a FaceTime call. The entire screen is the canvas, and everyone draws with a random color.\n\nThere are two steps to adopt a GroupActivity: activity creation and session management. These are covered in detail in WWDC21 session 10225: Coordinate media experiences with Group Activities and in Supporting Coordinated Media Playback.\n\nThese steps change slightly when building a custom experience, starting with activity creation. Activity creation consists of configuring the activity, and then activating the activity. Only the configuration part is different for a custom activity compared to a media activity.\n\nConfigure the sample code project\n\nBuild the sample with Xcode 13 or later, and Swift 5.5 or later.\n\nThis sample runs on physical devices with iOS 15 or later.\n\nTo see the custom drawing experience together, install the app on two or more devices with unique Apple IDs, and start a FaceTime call between the devices. Tap the bottom-left icon, and respond to the system prompt to start a shared DrawTogether experience. On the other device, join the group session. The app gives each user a random color to draw with. When the user draws on the screen, the app propagates the drawing to all the other devices in the group session.\n\nConfigure a custom activity\n\nTo make drawing a group experience, the sample defines a DrawTogether structure that adopts the GroupActivity protocol. This protocol defines a shareable experience in the app. The GroupActivity protocol has two properties that the app implements: activityIdentifier and metadata. The app relies on the default implementation for activityIdentifier, and the metadata property is required. To make this activity a custom activity, the sample code sets the type on the metadata to generic. This is crucial for a custom activity, and is the only difference between configuring a custom activity and a media activity.\n\nstruct DrawTogether: GroupActivity {\n    var metadata: GroupActivityMetadata {\n        var metadata = GroupActivityMetadata()\n        metadata.title = NSLocalizedString(\"Draw Together\", comment: \"Title of group activity\")\n        metadata.type = .generic\n        return metadata\n    }\n}\n\nActivate an activity\n\nAfter configuring the activity, the app needs to activate it at the appropriate moment. The sample provides a button for activation. First, the sample checks to make sure a GroupSession doesn’t exist already. Next, it calls the GroupStateObserver isEligibleForGroupSession method to make sure a FaceTime call is active and the system can create group sessions. Then, in the action closure, the sample calls its canvas.startSharing() method to activate the activity.\n\nif canvas.groupSession == nil && groupStateObserver.isEligibleForGroupSession {\n    Button {\n        canvas.startSharing()\n    } label: {\n        Image(systemName: \"person.2.fill\")\n    }\n    .buttonStyle(.borderedProminent)\n}\n\n\nIn its canvas.startSharing() method, the sample creates a new instance of the custom activity, and calls the activate() method on it. That’s all that’s necessary to activate the activity.\n\nfunc startSharing() {\n    Task {\n        do {\n            _ = try await DrawTogether().activate()\n        } catch {\n            print(\"Failed to activate DrawTogether activity: \\(error)\")\n        }\n    }\n}\n\nConfigure the session for sending and receiving custom data\n\nThe sample uses GroupSessionMessenger to configure the session for sending and receiving its custom drawing data. The app creates a GroupSessionMessenger from the GroupSession. It also adds the messenger property to its Canvas to hold the messenger object.\n\nfunc configureGroupSession(_ groupSession: GroupSession<DrawTogether>) {\n    strokes = []\n\n\n    self.groupSession = groupSession\n    let messenger = GroupSessionMessenger(session: groupSession)\n    self.messenger = messenger\n\n\nWhen using GroupSessionMessenger, the sample code defines the type of data to exchange between participants. The app shares the strokes themselves. The sample defines the UpsertStrokeMessage structure to represent a stroke with three properties: an identifier, a color, and a coordinate point. The sample also specifies that the UpsertStrokeMessage structure conforms to the Codable protocol. GroupSessionMessenger automatically handles the serialization and deserialization of the message data if the messages are Codable.\n\nstruct UpsertStrokeMessage: Codable {\n    let id: UUID\n    let color: Stroke.Color\n    let point: CGPoint\n}\n\n\nThe second step in configuring the session is to call the GroupSessionMessenger messages(of:) method to receive the UpsertStrokeMessages data. The sample specifies the UpsertStrokeMessage type when calling the messages method. This method returns an async sequence that provides a tuple containing messages of that type and the context surrounding the message, such as which participant sends the message.\n\nfor await (message, _) in messenger.messages(of: UpsertStrokeMessage.self) {\n    handle(message)\n}\n\n\nThe third step for configuring the session is to send data using the GroupSessionMessenger send(_:to:) method. The app sends an UpsertStrokeMessage to all participants within the group.\n\ntry? await messenger.send(UpsertStrokeMessage(id: stroke.id, color: stroke.color, point: point))\n\nReceive custom data\n\nThe sample creates a detached task to receive the UpsertStrokeMessages from the async sequence, then calls its handle method to process the message.\n\nvar task = Task {\n    for await (message, _) in messenger.messages(of: UpsertStrokeMessage.self) {\n        handle(message)\n    }\n}\ntasks.insert(task)\n\n\nThe handle method checks the stroke identifier to see if one exists already — and if so, adds the point to it. Otherwise, it creates a new stroke, adds the point to it, and appends the stroke to an array of strokes.\n\nfunc handle(_ message: UpsertStrokeMessage) {\n    if let stroke = strokes.first(where: { $0.id == message.id }) {\n        stroke.points.append(message.point)\n    } else {\n        let stroke = Stroke(id: message.id, color: message.color)\n        stroke.points.append(message.point)\n        strokes.append(stroke)\n    }\n}\n\nSend custom data\n\nThe sample calls its addPointToActiveStroke method to send the messages using the GroupSessionMessenger send(_:to:) method.\n\nfunc addPointToActiveStroke(_ point: CGPoint) {\n    let stroke: Stroke\n    if let activeStroke = activeStroke {\n        stroke = activeStroke\n    } else {\n        stroke = Stroke(color: strokeColor)\n        activeStroke = stroke\n    }\n\n\n    stroke.points.append(point)\n\n\n    if let messenger = messenger {\n        Task {\n            try? await messenger.send(UpsertStrokeMessage(id: stroke.id, color: stroke.color, point: point))\n        }\n    }\n}\n\nHandle late joiners\n\nLate joiners are devices that join an activity session after the session starts. To ensure a proper experience, the app gives late joiners the most recent information so all the devices use the same data.\n\nWhen a new device calls join() on the GroupSession, every other device in the GroupSession receives an update of the GroupSession activeParticipants property. Devices that observe the update then send their own catch-up data (in this case, the existing drawing canvas) to the newly joined device.\n\nThe app defines its catch-up data in the CanvasMessage structure. This structure contains all of the existing strokes and a variable pointCount, a heuristic that calculates which message is the most up-to-date.\n\nstruct CanvasMessage: Codable {\n    let strokes: [Stroke]\n    let pointCount: Int\n}\n\n\nThe sample defines a message handler in its configureGroupSession method to receive this message using the GroupSessionMessenger messages(of:) method. The handler calls the samples handle() method to process the message.\n\ntask = Task {\n    for await (message, _) in messenger.messages(of: CanvasMessage.self) {\n        handle(message)\n    }\n}\n\n\nThe sample’s handle() method guards against the pointCount heuristic to only accept catch-up messages that are newer than any currently saved messages. Then the sample overrides the canvas strokes with the catch-up message’s strokes.\n\nfunc handle(_ message: CanvasMessage) {\n    guard message.pointCount > self.pointCount else { return }\n    self.strokes = message.strokes\n}\n\n\nNext, the sample listens for activeParticipants changes to determine whether there are any new participants to communicate with. The sample’s configureGroupSession method handler obtains the delta between the new activeParticipants and the previous activeParticipants. This ensures that the sample only sends catch-up messages to the newly joined participants. Finally, the sample forms and sends the message. The message contains the current canvas state and sends it only to the newParticipants.\n\ngroupSession.$activeParticipants\n    .sink { activeParticipants in\n        let newParticipants = activeParticipants.subtracting(groupSession.activeParticipants)\n\n\n        Task {\n            try? await messenger.send(CanvasMessage(strokes: self.strokes, pointCount: self.pointCount), to: .only(newParticipants))\n        }\n    }\n\nChange activities\n\nThe Group Activities framework provides two ways to change activities: create a GroupSession, or update the activity for everyone in the existing GroupSession.\n\nThe sample app resets for each new drawing canvas. The sample triggers a new session when the user taps the Reset button. In this case, the sample calls its Canvas reset method to reset the local state and create a GroupSession.\n\nButton {\n    canvas.reset()\n} label: {\n    Image(systemName: \"trash.fill\")\n}\n\n\nThe sample’s reset method removes the existing GroupSession, which allows for a clean transition to a new canvas in the new session. The reset method cancels any tasks for the GroupSession. It also checks for an existing GroupSession, and if one exists, it calls the leave() method to leave the current activity. It then calls the activate() method to start the activity immediately and create a session for the app. Thereafter, the sample waits for the system to deliver a GroupSession object asynchronously through the GroupActivity.Sessions method of the GroupActivity.\n\nfunc reset() {\n    // Clear the local drawing canvas.\n    strokes = []\n\n\n    // Tear down the existing groupSession.\n    messenger = nil\n    tasks.forEach { $0.cancel() }\n    tasks = []\n    subscriptions = []\n    if groupSession != nil {\n        groupSession?.leave()\n        groupSession = nil\n        self.startSharing()\n    }\n}\n\n\nfunc startSharing() {\n    Task {\n        do {\n            _ = try await DrawTogether().activate()\n        } catch {\n            print(\"Failed to activate DrawTogether activity: \\(error)\")\n        }\n    }\n}\n\nStart SharePlay experiences\n\nThe sample’s ControlBar view contains a button to allow users to share the canvas with their friends. The sample dynamically displays the button only when it’s helpful to the user. The sample uses the GroupStateObserver isEligibleForGroupSession property to determine whether a FaceTime call is active and the system can create group sessions. The ControlBar only shows the button if the system is eligible for a group session, and not in a group session already.\n\nstruct ControlBar: View {\n    @ObservedObject var canvas: Canvas\n    @StateObject var groupStateObserver = GroupStateObserver()\n\n\n    var body: some View {\n        HStack {\n            if canvas.groupSession == nil && groupStateObserver.isEligibleForGroupSession {\n                Button {\n                    canvas.startSharing()\n                } label: {\n                    Image(systemName: \"person.2.fill\")\n                }\n                .buttonStyle(.borderedProminent)\n            }\n\n\n            Spacer()\n\n\n            Button {\n                canvas.reset()\n            } label: {\n                Image(systemName: \"trash.fill\")\n            }\n        }\n        .buttonStyle(.bordered)\n        .controlSize(.large)\n    }\n}\n"
  },
  {
    "title": "GroupActivitySharingController",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivitysharingcontroller-ybcy",
    "html": "Overview\n\nA GroupActivitySharingController helps you start a SharePlay activity, even when a FaceTime call isn’t currently active. When presented, the view controller prompts the person to start the activity you provided. If no FaceTime call is active, the view controller also displays a people picker to let the person select the participants for the activity. When they choose to start the activity, the view controller automatically starts the FaceTime call as needed and joins your app to the activity.\n\nIf your app’s interface includes controls to start SharePlay activities, present this view controller in response to interactions with those controls. Initialize the GroupActivitySharingController object with the activity you want to start. After you present it, the view controller handles all further interactions. It manages the interface that appears onscreen and responds when someone chooses to start or cancel the activity. It starts the FaceTime call if one isn’t currently active. It also dismisses itself and returns control back to your app, updating its result property to let you know what happened.\n\nTopics\nCreating the group activity sharing controller\ninit<ActivityType>(ActivityType) throws\nInitializes the sharing controller with the specified activity and type information.\ninit<ActivityType>(preparationHandler: () async throws -> ActivityType)\nInitializes the SharePlay sharing controller with a closure that creates the activity object.\nGetting the result\nvar result: GroupActivitySharingResult\nThe result of a request to share a group activity.\nenum GroupActivitySharingResult\nThe result of a request to share a group activity in iOS.\nResponding to view-related events\nfunc viewDidLoad()\nNotifies the view controller that the system added a view to a view hierarchy.\nfunc viewWillAppear(Bool)\nNotifies the view controller that the system is going to add a view to a view hierarchy.\nInstance Properties\nvar modalPresentationStyle: UIModalPresentationStyle\nThe presentation style for the view controller.\nRelationships\nInherits From\nUIViewController\nConforms To\nCVarArg\nCustomDebugStringConvertible\nCustomStringConvertible\nEquatable\nHashable\nNSCoding\nNSExtensionRequestHandling\nNSObjectProtocol\nNSTouchBarProvider\nUIActivityItemsConfigurationProviding\nUIAppearanceContainer\nUIContentContainer\nUIFocusEnvironment\nUIPasteConfigurationSupporting\nUIResponderStandardEditActions\nUIStateRestoring\nUITraitChangeObservable\nUITraitEnvironment\nUIUserActivityRestoring\nSee Also\nInterface presentation\nPresenting SharePlay activities from your app’s UI\nMake it easy for people to start activities from your app’s UI, from the system share sheet, or using AirPlay over AirDrop.\nclass GroupActivitySharingController\nA macOS view controller that displays the system interface for starting an activity, and optionally starts a FaceTime call for that activity."
  },
  {
    "title": "Presenting SharePlay activities from your app’s UI",
    "url": "https://developer.apple.com/documentation/groupactivities/promoting-shareplay-activities-from-your-apps-ui",
    "html": "Overview\n\nAfter you define one or more SharePlay activities for your app, make them easy for people to discover in your UI. Include buttons, menus items, and other elements to start activities, present activities in system interfaces like the share sheet, and update your activities to take advantage of other system behaviors.\n\nStarting an activity requires an active FaceTime call or Messages conversation. When a conversation is active, you can start an activity right away from your UI. If no conversation is active, the Group Activities framework facilitates starting a conversation as part of starting your activity. Some system features also help you start conversations.\n\nFor guidance about the best ways to add SharePlay support to your app’s UI, see Human Interface Guidelines > SharePlay.\n\nAdd a SharePlay button to your UI\n\nThe most direct way to start activities is to provide controls in your UI. Because you control the placement of buttons and other controls in your UI, you can put them where people are most likely to find them. Provide a label or additional context to let someone know that your UI element starts an activity. For example, update your button’s label to include the shareplay symbol from the SF Symbols library.\n\nThe following example shows a SwiftUI button with both a text label and the SharePlay icon:\n\nButton {\n    // Start the activity.\n} label: {\n    Label(\"Start Activity\", systemImage: \"shareplay\")\n}\n.buttonStyle(.borderedProminent)\n\n\nIn iOS, the preceding example creates a button with a prominent appearance as shown below. When creating buttons in your app, use a style that makes sense for the current platform and your app’s design.\n\nWhen someone interacts with your app’s custom buttons, start the corresponding activity immediately if there is an active FaceTime call or Messages conversation. To determine if a conversation is active, check the isEligibleForGroupSession property of GroupStateObserver. If the value of that property is true, call the prepareForActivation() or activate() method of your GroupActivity type to start the activity. If the value of the property is false, present a GroupActivitySharingController, which prompts the person to invite friends to join the activity.\n\nShare activities in SwiftUI using a share link\n\nTo surface SharePlay activities using the system share sheet in SwiftUI, configure a ShareLink view with items that have an associated activity. A ShareLink view adds a standard share button to your UI, and you can customize the appearance of that button using the buttonStyle(_:) modifier. Tapping or clicking the button displays the system share sheet for the provided items. A person can then use the sheet to copy the items to the pasteboard or send them to a different process.\n\nTo surface your SharePlay activities from a ShareLink view, include a representation that contains your GroupActivity type. The share sheet in SwiftUI requires items to support the Transferable protocol. Adopt this protocol in your custom data types and implement the transferRepresentation property. Use that property to supply the representations of your data, and add a GroupActivityTransferRepresentation type to specify the GroupActivity for that data.\n\nThe following example shows the implementation of a movie data type and its transferRepresentation property. The property returns two representations: one for the movie’s URL and one for the movie-watching activity. The closure for the GroupActivityTransferRepresentation creates the WatchMovieTogether activity and initializes it with the selected movie.\n\nstruct Movie : Transferable {\n    var title : String\n    var url: URL\n\n\n    static var transferRepresentation: some TransferRepresentation {\n        // Export the movie as a URL.\n        ProxyRepresentation(exporting: \\.url) \n        \n        // Specify the associated SharePlay activity.\n        GroupActivityTransferRepresentation { movie in\n            WatchMovieTogether(from: movie)\n        }\n    }\n}\n\n\nThe following example creates a ShareLink to share a movie associated with the current view. When someone displays the share sheet and clicks the SharePlay link, the system initializes the app’s WatchMovieTogether activity with the specified movie and starts the activity.\n\nShareLink(item: movie,\n          preview: .init(\"Play the movie together\"))\n\nAdd activities to the system share sheet in UIKit or AppKit\n\nWhen displaying a share sheet using UIKit or AppKit, specify any SharePlay activities using NSItemProvider objects. When you configure the UIKit or AppKit share sheets, you specify one or more NSItemProvider objects with the data you want to share. If you have an activity you want to share for that item, create an instance of the appropriate GroupActivity type and pass it to the item provider’s registerGroupActivity(_:) method. When an item provider has a registered activity, the share sheet displays a SharePlay button to start the associated activity.\n\nThe following example creates a WatchMovieTogether activity to allow friends to watch a movie over SharePlay. After it creates an item provider for the movie, it registers the activity with that item provider and displays the share sheet. When someone clicks the SharePlay button in the share sheet, the system starts the movie-watching activity.\n\nlet activity = WatchMovieTogether(movie: movie)\n        \n// Create an item provider for the activity.\nif let itemProvider = NSItemProvider(contentsOf: movie.url) {\n    itemProvider.registerGroupActivity(activity)\n            \n    // Create and present the share sheet.\n    let shareSheet = UIActivityViewController(activityItems: [itemProvider], applicationActivities: nil)\n    shareSheet.allowsProminentActivity = true\n            \n    present(shareSheet, animated: true)\n}\n\n\nIn AppKit, display the share sheet using an NSSharingServicePicker object. When creating the picker object, specify your NSItemProvider objects as the items you want to share.\n\nShare activities using SharePlay over AirDrop\n\nSharePlay over AirDrop lets one person initiate an activity on their iPhone and share that activity with people in close proximity. The initiator opens an app on their iPhone and navigates to a page with the activity they want to start. When their iPhone comes in close proximity to other people’s iPhone devices, the initiator’s phone prompts them to start the activity. After they start the activity, the system prompts the other people to join and creates a Messages conversation for the group. Anyone in the group can then invite others to join the conversation and activity, including people who aren’t nearby.\n\nIn a SwiftUI app, the system enables SharePlay over AirDrop when the UI contains a ShareLink with an appropriate activity. The activity you include in the link must adopt the Transferable protocol and provide a GroupActivityTransferRepresentation type in its set of representations.\n\nTo support SharePlay over AirDrop in a UIKit app, assign activities to objects in the responder chain of your app’s UI. Typically, you add activities to your app’s view controllers, but you can add activities to any responder. When devices are nearby, the system searches the responder chain for a responder that contains an activity in its activityItemsConfiguration property. If an activity is available, the system displays UI to start that activity on the initiator’s device. The activityItemsConfiguration property stores one or more NSItemProvider objects, which you configure with activities by calling the registerGroupActivity(_:) method.\n\nDisplay activities in the Share menu in visionOS\n\nIn a visionOS app, the system displays a Share menu above windows and volumes to indicate when sharing is active. The system populates this control with activities the current scene supports.\n\nNot sharing\nSelect an activity\nSharing started\n\nThe Share menu is in the idle state, and sharing is not active for the window.\n\nSpecify activities in any of the following ways:\n\nInclude a ShareLink view with a properly configured activity, as described in Share activities using SharePlay over AirDrop.\n\nConfigure the activityItemsConfiguration property of a UIKit responder object with an activity object.\n\nAssociate an activity with the scene. See Adding Spatial Persona support to an activity.\n\nSee Also\nInterface presentation\nclass GroupActivitySharingController\nA macOS view controller that displays the system interface for starting an activity, and optionally starts a FaceTime call for that activity.\nclass GroupActivitySharingController\nAn iOS view controller that displays the system interface for starting an activity, and optionally starts a FaceTime call for that activity."
  },
  {
    "title": "GroupActivityActivationResult",
    "url": "https://developer.apple.com/documentation/groupactivities/groupactivityactivationresult",
    "html": "Overview\n\nWhen you call prepareForActivation(), the system determines whether you share the activity with other participants in a FaceTime call, or perform it locally. After making the determination, it passes a GroupActivityActivationResult value to the method’s completion handler. Use that value to start the activity in the selected setting.\n\nTopics\nGetting the activation results\ncase activationPreferred\nA result that indicates the user wants to share the activity with the group.\ncase activationDisabled\nA result that indicates the user disabled the automatic sharing of activities, or prefers to perform the activity locally.\ncase cancelled\nA result that indicates the user canceled the activation request.\nComparing reliability options\nstatic func != (Self, Self) -> Bool\nReturns a Boolean value indicating whether two values are not equal.\nstatic func == (GroupActivityActivationResult, GroupActivityActivationResult) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nInstance Properties\nvar hashValue: Int\nThe hash value.\nInstance Methods\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nDefault Implementations\nEquatable Implementations\nRelationships\nConforms To\nEquatable\nHashable\nSee Also\nActivity definition\nDefining your app’s SharePlay activities\nConfigure your app’s SharePlay support and define the activities that people can perform from your app.\nSupporting Coordinated Media Playback\nCreate synchronized media experiences that enable users to watch and listen across devices.\nprotocol GroupActivity\nA type that can advertise your app’s activities to other participants.\nstruct GroupActivityMetadata\nText and image content that describes an activity to potential participants.\nstruct GroupActivityTransferRepresentation\nA type that lets you start a group activity from a known context."
  },
  {
    "title": "Defining your app’s SharePlay activities",
    "url": "https://developer.apple.com/documentation/groupactivities/defining-your-apps-shareplay-activities",
    "html": "Overview\n\nSharePlay activities are an organic way to create experiences that people can enjoy together. When you add the Group Activities framework to your app, you gain the ability to share your app’s features over FaceTime, Messages, and AirDrop. Some examples of experiences people can share together include:\n\nWatching or listening to content\n\nParticipating in an online fitness class\n\nCreating content on a shared whiteboard or painter’s canvas\n\nShopping for food, clothes, or other online products\n\nPlanning a trip or browsing the web\n\nReading a book or taking an online class\n\nConsider the preceding list of activities, and any other activities your app supports, and build SharePlay support for them. Think about how people might enjoy those activities if they were together in the same physical space. Consider the types of interactions that can occur in the real world, and build support for those interactions into your activities. For example, a movie-watching app needs to pause playback for all participants when one person hits the pause button. A shared whiteboard app needs to transmit newly drawn content to other participants, and send all of the content to someone who arrives late.\n\nNote\n\nMake activities available on all the platforms your app supports to ensure people can join from any device. Customize the experience as needed for each platform to give it a more intuitive feel.\n\nConfigure the SharePlay entitlements\n\nBefore you start adding SharePlay support to your app, add the com.apple.developer.group-session entitlement to your Xcode project. Because SharePlay involves communication with other devices, you need this entitlement to support activities. To add the entitlement to your app:\n\nOpen your Xcode project.\n\nSelect your app target.\n\nGo to the Signing & Capabilities pane.\n\nAdd the Group Activities capability to the target.\n\nConfigure this entitlement only for app targets. When you add the Group Activities capability, Xcode adds the necessary entitlements to your app and updates its provisioning profile.\n\nTurn an existing app feature into an activity\n\nTurn one of your app’s features into a SharePlay experience by adopting the GroupActivity protocol in the appropriate place in your code. This protocol provides the basic definition of a SharePlay activity. When you adopt it in one of your app’s existing types, that type provides the information that SharePlay needs to promote that activity to participants. If you prefer to keep the activity separate from your app data structures, define a new type and add any app-specific data you need to manage the activity.\n\nMost of the content in a GroupActivity type is the data you use to support the activity itself. Include data that is critical for performing the activity, such as the URL of the movie in a movie-watching activity. Also, include information to support the overall experience, such as the name of the movie and an image to display in the SharePlay UI. Store as little data as possible to support the activity, and share state information instead of detailed changes wherever possible. For example, store a link to the movie instead of the movie file itself. The following example defines a Movie type that stores information about a movie to watch, and a group activity to share the experience:\n\nstruct Movie: Codable{\n    var title : String\n    var movieURL : URL\n\n\n    // Codable support...\n}\n\n\nstruct WatchTogether: GroupActivity {\n    // The movie to watch together.\n    var movie: Movie\n   \n    init(movie: Movie) {\n        self.movie = movie\n    }\n}\n\nCustomize the unique identifier for your activity\n\nTo differentiate one activity from another, each GroupActivity type must have a unique string in its activityIdentifier property. The default implementation of this property combines your app’s bundle identifier with the name of your custom GroupActivity type. This string is sufficient for most activity types, but you can also specify a custom value if you prefer.\n\nIf you specify a custom string, include your company name in reverse-DNS format along with any other information you need to distinguish the activity from others in your app. The following code adds a custom identifier for the WatchTogether activity:\n\nstruct WatchTogether: GroupActivity {\n    // Specify the activity type to the system.\n    static let activityIdentifier = \"com.example.myapp.watch-movie-together\"\n\n\n    // The movie to watch together.\n    var movie: Movie\n\n\n    init(movie: Movie) {\n        self.movie = movie\n    }\n}\n\n\nMake activity identifiers as granular as needed to differentiate the activities within your app. Don’t create one activity type that serves multiple purposes. Instead, define separate types and give them unique activity identifiers. For example, if your video player supports playing both movies and television shows, create separate activities for each.\n\nProvide descriptive information about the activity\n\nEach activity contains a GroupActivityMetadata type that stores descriptive information about the activity. When inviting people to join the activity, the system incorporates this metadata into the system UI. A concise title, a short description of the activity, and an image help people understand which activity they’re joining. You can also provide additional details, such as a fallback URL that someone can use to join the activity from a web browser.\n\nCreate a GroupActivityMetadata type dynamically from your activity, and populate it with activity-related details. Fill in as much of the information as possible, and make your descriptions concise and clear. People need to quickly identify the purpose of the activity and whether it’s one they want to join, so make sure your descriptions are clear enough for someone to make a decision. The following example creates the metadata for the WatchTogether activity and populates it with the movie details. Use the fallbackURL property to provide a URL to the content in case a participant doesn’t have the app.\n\nextension WatchTogether {\n    // Provide information about the activity.\n    var metadata: GroupActivityMetadata {\n        var metadata = GroupActivityMetadata()\n        metadata.type = .watchTogether\n        metadata.title = \"\\(movie.title)\"\n        metadata.fallbackURL = movie.movieURL\n        metadata.supportsContinuationOnTV = true\n\n\n        return metadata\n    }\n}\n\n\nClassify your app’s activities by specifying an appropriate value for the type property of GroupActivityMetadata. In the SharePlay banner, the system displays an icon that matches the type of the activity. The icon provides an additional visual cue about what people can expect from the activity.\n\nInclude a transferable representation of your activity\n\nThe Core Transferable framework helps you build data types that you can easily transfer between different processes or devices. In particular, the Transferable protocol makes it easy to support pasteboard operations and drag and drop. The Group Activities framework supports this protocol by letting you associate a GroupActivity with one of your transferable types. SwiftUI and SharePlay via AirDrop also take advantage of this association to present possible activities from your UI.\n\nIf you initialize an activity using one of your app’s data types, adopt the Transferable protocol in that data type and include a transfer representation for the activity. Implement the transferRepresentation property of the protocol, and include a GroupActivityTransferRepresentation structure in addition to any representations you use to support the pasteboard. Use the GroupActivityTransferRepresentation structure to initialize an activity using the current data type. For example, the following code creates an activity to watch a movie for a custom Movie type:\n\nstruct Movie: Transferable, Codable{\n    var title : String\n    var movieURL : URL\n    \n    /// A transferable version of the movie URL and group activity.\n    static var transferRepresentation: some TransferRepresentation {\n        ProxyRepresentation(exporting: \\.movieURL)\n        \n        GroupActivityTransferRepresentation { movie in\n            WatchTogether(movie: movie)\n        }\n    }\n\n\n    // Codable support...\n}\n\n\nWhen you include a ShareLink view in your SwiftUI interface, you can specify your transferable data type as the shareable item from that view. When someone taps or clicks the link, the system displays a share sheet with options for sharing the data. If you include a GroupActivityTransferRepresentation type, the sheet includes an option to start the associated activity. The following example creates a ShareLink view using the Movie data type:\n\nstruct MovieDetailView: View {\n    let movie: Movie\n\n\n    var body: some View {\n        ShareLink(\n            item: movie, \n            preview: SharePreview(\n                movie.title))\n    }\n}\n\n\nFor more information on displaying a share sheet or supporting SharePlay via AirDrop, see Presenting SharePlay activities from your app’s UI.\n\nSee Also\nActivity definition\nSupporting Coordinated Media Playback\nCreate synchronized media experiences that enable users to watch and listen across devices.\nprotocol GroupActivity\nA type that can advertise your app’s activities to other participants.\nstruct GroupActivityMetadata\nText and image content that describes an activity to potential participants.\nenum GroupActivityActivationResult\nThe result of preparing to start a custom activity.\nstruct GroupActivityTransferRepresentation\nA type that lets you start a group activity from a known context."
  },
  {
    "title": "Group Activities",
    "url": "https://developer.apple.com/documentation/GroupActivities",
    "html": "Overview\n\nWith the Group Activities framework, you can provide your app’s content in SharePlay experiences, which create a sense of connection and immediacy for your users. For example, a video-streaming app might offer the ability to attend movie-watching parties in which participants watch simultaneously from their personal devices. The app handles the playback on each device, but the Group Activities framework synchronizes that playback and facilitates communication between the devices.\n\nThis framework leverages the FaceTime infrastructure to synchronize your app’s activities and to invite other participants to join those activities. When your app’s UI contains shareable activities, adopt the GroupActivity protocol in the objects you use to represent those activities. When a group activity begins, use the GroupSession object to synchronize your app’s behavior with other participating devices.\n\nNote\n\nThe Group Activities framework uses end-to-end encryption on all session data that the GroupSession object synchronizes between devices. Apple doesn’t have the keys to decrypt this data. Your use of the Group Activities framework doesn’t provide Apple with visibility into the content your app shares, or information related to playback of media content in your app, such as where in the content a user starts, pauses, or skips a session. Apple servers facilitating Group Activities sessions don’t know the identity of your app. Occasionally, Apple may ask a small number of users to help troubleshoot issues, such as by capturing a sysdiagnose or installing a debugging profile, which may incidentally result in Apple collecting some information related to content shared in your app.\n\nTopics\nEssentials\ncom.apple.developer.group-session\nA Boolean value that indicates whether the app may implement shared group experiences.\nActivity definition\nDefining your app’s SharePlay activities\nConfigure your app’s SharePlay support and define the activities that people can perform from your app.\nSupporting Coordinated Media Playback\nCreate synchronized media experiences that enable users to watch and listen across devices.\nprotocol GroupActivity\nA type that can advertise your app’s activities to other participants.\nstruct GroupActivityMetadata\nText and image content that describes an activity to potential participants.\nenum GroupActivityActivationResult\nThe result of preparing to start a custom activity.\nstruct GroupActivityTransferRepresentation\nA type that lets you start a group activity from a known context.\nInterface presentation\nPresenting SharePlay activities from your app’s UI\nMake it easy for people to start activities from your app’s UI, from the system share sheet, or using AirPlay over AirDrop.\nclass GroupActivitySharingController\nA macOS view controller that displays the system interface for starting an activity, and optionally starts a FaceTime call for that activity.\nclass GroupActivitySharingController\nAn iOS view controller that displays the system interface for starting an activity, and optionally starts a FaceTime call for that activity.\nSession management\nJoining and managing a shared activity\nConfigure the session when a SharePlay activity starts, and handle events that occur during the lifetime of the activity.\nDrawing content in a group session\nInvite your friends to draw on a shared canvas while on a FaceTime call.\nclass GroupSession\nA session for an in-progress activity that synchronizes content among participant devices.\nprotocol CustomMessageIdentifiable\nA type that assigns a custom ID string to messages you send to other devices.\nstruct Participant\nAn active participant in a group session.\nSpatial activities\nAdding Spatial Persona support to an activity\nUpdate your SharePlay activities to support Spatial Personas and the shared context when running in visionOS.\nclass SystemCoordinator\nA type you use to coordinate your interface’s behavior when an active SharePlay session supports spatial placement of content.\nstruct ParticipantState\nA structure that tells you whether a participant supports a shared simulation space for the current activity.\nFile and data transfer\nSynchronizing data during a SharePlay activity\nSend custom messages and data between devices to synchronize content for your activity, and incorporate messages your app receives from other participants.\nclass GroupSessionMessenger\nAn object that transfers app-specific data between the devices joined in a group session.\nclass GroupSessionJournal\nAn object that manages file and data transfers between participants joined in a group session.\nSystem status\nclass GroupStateObserver\nAn object that contains information about the system’s ability to start SharePlay experiences."
  }
]