[
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/endindex",
    "html": "Discussion\n\nWhen you need a range that includes the last element of a collection, use the half-open range operator (..<) with endIndex. The ..< operator creates a range that doesn’t include the upper bound, so it’s always safe to use with endIndex. For example:\n\nlet numbers = [10, 20, 30, 40, 50]\nif let index = numbers.firstIndex(of: 30) {\n    print(numbers[index ..< numbers.endIndex])\n}\n// Prints \"[30, 40, 50]\"\n\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/startindex",
    "html": "Discussion\n\nIf the collection is empty, startIndex is equal to endIndex."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/map(_:)-87c3z",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removefirst()-5bf95",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "popFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/popfirst()",
    "html": "Return Value\n\nThe first element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/removefirst(_:)-5qb6j",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "unicodeScalars | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalars",
    "html": "See Also\nWorking with String Views\ninit(String.UnicodeScalarView)\nCreates a string corresponding to the given collection of Unicode scalars.\ninit(Substring.UnicodeScalarView)\nCreates a String having the given content.\nvar utf16: String.UTF16View\nA UTF-16 encoding of self.\ninit(String.UTF16View)\nCreates a string corresponding to the given sequence of UTF-16 code units.\ninit?(Substring.UTF16View)\nCreates a String having the given content.\nvar utf8: String.UTF8View\nA UTF-8 encoding of self.\ninit(String.UTF8View)\nCreates a string corresponding to the given sequence of UTF-8 code units.\ninit?(Substring.UTF8View)\nCreates a String having the given content."
  },
  {
    "title": "utf8 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8",
    "html": "See Also\nWorking with String Views\nvar unicodeScalars: String.UnicodeScalarView\nThe string’s value represented as a collection of Unicode scalar values.\ninit(String.UnicodeScalarView)\nCreates a string corresponding to the given collection of Unicode scalars.\ninit(Substring.UnicodeScalarView)\nCreates a String having the given content.\nvar utf16: String.UTF16View\nA UTF-16 encoding of self.\ninit(String.UTF16View)\nCreates a string corresponding to the given sequence of UTF-16 code units.\ninit?(Substring.UTF16View)\nCreates a String having the given content.\ninit(String.UTF8View)\nCreates a string corresponding to the given sequence of UTF-8 code units.\ninit?(Substring.UTF8View)\nCreates a String having the given content."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/iterator/next()",
    "html": "Return Value\n\nThe next element in the underlying sequence, if a next element exists; otherwise, nil.\n\nDiscussion\n\nRepeatedly calling this method returns, in order, all the elements of the underlying sequence. As soon as the sequence has run out of elements, all subsequent calls return nil.\n\nYou must not call this method if any other copy of this iterator has been advanced with a call to its next() method.\n\nThe following example shows how an iterator can be used explicitly to emulate a for-in loop. First, retrieve a sequence’s iterator, and then call the iterator’s next() method until it returns nil.\n\nlet numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\n\n\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints \"2\"\n// Prints \"3\"\n// Prints \"5\"\n// Prints \"7\"\n"
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/iterator/next()",
    "html": "Return Value\n\nThe next element in the underlying sequence, if a next element exists; otherwise, nil.\n\nDiscussion\n\nRepeatedly calling this method returns, in order, all the elements of the underlying sequence. As soon as the sequence has run out of elements, all subsequent calls return nil.\n\nYou must not call this method if any other copy of this iterator has been advanced with a call to its next() method.\n\nThe following example shows how an iterator can be used explicitly to emulate a for-in loop. First, retrieve a sequence’s iterator, and then call the iterator’s next() method until it returns nil.\n\nlet numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\n\n\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints \"2\"\n// Prints \"3\"\n// Prints \"5\"\n// Prints \"7\"\n"
  },
  {
    "title": "Substring.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/subscript(_:)-4h7r7",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/subscript(_:)-2nr4p",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nOverview\n\nThe following example accesses an element of an array through its subscript to print its value:\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nprint(streets[1])\n// Prints \"Bryant\"\n\n\nYou can subscript a collection with any valid index other than the collection’s end index. The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/joined(separator:)-5cgwz",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "Encodable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Swift/Encodable",
    "html": "Topics\nInstance Methods\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder.\n\nRequired Default implementation provided.\n\nRelationships\nInherited By\nSIMD\nConforming Types\nArray\nConforms when Element conforms to Encodable.\nBool\nClosedRange\nConforms when Bound conforms to Comparable and Encodable.\nCollectionDifference\nConforms when ChangeElement conforms to Decodable and Encodable.\nCollectionDifference.Change\nConforms when ChangeElement conforms to Decodable and Encodable.\nContiguousArray\nConforms when Element conforms to Encodable.\nContinuousClock.Instant\nDictionary\nConforms when Key conforms to Encodable, Key conforms to Hashable, and Value conforms to Encodable.\nDouble\nDuration\nDuration.TimeFormatStyle\nDuration.TimeFormatStyle.Attributed\nDuration.TimeFormatStyle.Pattern\nDuration.UnitsFormatStyle\nDuration.UnitsFormatStyle.Attributed\nDuration.UnitsFormatStyle.FractionalPartDisplayStrategy\nDuration.UnitsFormatStyle.Unit\nDuration.UnitsFormatStyle.UnitWidth\nDuration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy\nFloat\nFloat16\nInt\nInt16\nInt32\nInt64\nInt8\nLocalTestingActorID\nNever\nObservationRegistrar\nOptional\nConforms when Wrapped conforms to Encodable.\nPartialRangeFrom\nConforms when Bound conforms to Comparable and Encodable.\nPartialRangeThrough\nConforms when Bound conforms to Comparable and Encodable.\nPartialRangeUpTo\nConforms when Bound conforms to Comparable and Encodable.\nRange\nConforms when Bound conforms to Comparable and Encodable.\nSIMD16\nSIMD2\nSIMD3\nSIMD32\nSIMD4\nSIMD64\nSIMD8\nSIMDMask\nSet\nConforms when Element conforms to Encodable and Hashable.\nString\nString.Comparator\nString.LocalizationValue\nString.LocalizationValue.Placeholder\nString.StandardComparator\nSuspendingClock.Instant\nTaskPriority\nUInt\nUInt16\nUInt32\nUInt64\nUInt8\nSee Also\nCustom Encoding and Decoding\ntypealias Codable\nA type that can convert itself into and out of an external representation.\nprotocol Decodable\nA type that can decode itself from an external representation.\nprotocol CodingKey\nA type that can be used as a key for encoding and decoding.\nprotocol CodingKeyRepresentable\nA type that can be converted to and from a coding key.\nstruct CodingUserInfoKey\nA user-defined key for providing context during encoding and decoding."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/index(_:offsetby:)-17asz",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false otherwise. Once predicate returns false it will not be called again."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(_:)-3a5mh",
    "html": "See Also\nWorking with Paths\ninit?(validatingUTF8: FilePath)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/flatmap(_:)-726ic",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift.\n\nSee Also\nReordering a String’s Characters\nfunc sorted() -> [Self.Element]\nReturns the elements of the sequence, sorted.\nAvailable when Element conforms to Comparable.\nfunc sorted(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc reversed() -> ReversedCollection<Self>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffled() -> [Self.Element]\nReturns the elements of the sequence, shuffled."
  },
  {
    "title": "init(validatingUTF8:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(validatingutf8:)-6i0in",
    "html": "See Also\nWorking with Paths\ninit(FilePath)"
  },
  {
    "title": "init(decodingCString:as:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(decodingcstring:as:)-8yowf",
    "html": "Parameters\nnullTerminatedCodeUnits\n\nA pointer to a sequence of contiguous code units in the encoding specified in sourceEncoding, ending just before the first zero code unit.\n\nsourceEncoding\n\nThe encoding in which the code units should be interpreted."
  },
  {
    "title": "withCString(encodedAs:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/withcstring(encodedas:_:)",
    "html": "Parameters\nbody\n\nA closure with a pointer parameter that points to a null-terminated sequence of code units. If body has a return value, that value is also used as the return value for the withCString(encodedAs:_:) method. The pointer argument is valid only for the duration of the method’s execution.\n\ntargetEncoding\n\nThe encoding in which the code units should be interpreted.\n\nReturn Value\n\nThe return value, if any, of the body closure parameter.\n\nDiscussion\n\nThe pointer passed as an argument to body is valid only during the execution of withCString(encodedAs:_:). Do not store or return the pointer for later use.\n\nSee Also\nGetting C Strings\nvar utf8CString: ContiguousArray<CChar>\nA contiguously stored null-terminated UTF-8 representation of the string.\nfunc withCString<Result>((UnsafePointer<Int8>) throws -> Result) rethrows -> Result\nCalls the given closure with a pointer to the contents of the string, represented as a null-terminated sequence of UTF-8 code units."
  },
  {
    "title": "withCString(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/withcstring(_:)",
    "html": "Parameters\nbody\n\nA closure with a pointer parameter that points to a null-terminated sequence of UTF-8 code units. If body has a return value, that value is also used as the return value for the withCString(_:) method. The pointer argument is valid only for the duration of the method’s execution.\n\nReturn Value\n\nThe return value, if any, of the body closure parameter.\n\nDiscussion\n\nThe pointer passed as an argument to body is valid only during the execution of withCString(_:). Do not store or return the pointer for later use.\n\nSee Also\nGetting C Strings\nvar utf8CString: ContiguousArray<CChar>\nA contiguously stored null-terminated UTF-8 representation of the string.\nfunc withCString<Result, TargetEncoding>(encodedAs: TargetEncoding.Type, (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result\nCalls the given closure with a pointer to the contents of the string, represented as a null-terminated sequence of code units."
  },
  {
    "title": "transferRepresentation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/transferrepresentation",
    "html": "Discussion\n\nA transferRepresentation can contain multiple representations for different content types."
  },
  {
    "title": "makeContiguousUTF8() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/makecontiguousutf8()",
    "html": "Discussion\n\nComplexity: O(n) if non-contiguous, O(1) if already contiguous\n\nSee Also\nWorking with Encodings\nstatic var availableStringEncodings: [String.Encoding]\nAn array of the encodings that strings support in the application’s environment.\nstatic var defaultCStringEncoding: String.Encoding\nThe C-string encoding assumed for any method accepting a C string as an argument.\nstatic func localizedName(of: String.Encoding) -> String\nReturns a human-readable string giving the name of the specified encoding.\nvar isContiguousUTF8: Bool\nReturns whether this string is capable of providing access to validly-encoded UTF-8 contents in contiguous memory in O(1) time.\nfunc withUTF8<R>((UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R\nRuns body over the content of this string in contiguous memory. If this string is not contiguous, this will first make it contiguous, which will also speed up subsequent access. If this mutates the string, it will invalidate any pre-existing indices."
  },
  {
    "title": "String.Representation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/representation",
    "html": "Discussion\n\nSwift infers this type from the return value of the transferRepresentation property."
  },
  {
    "title": "defaultCStringEncoding | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/defaultcstringencoding",
    "html": "See Also\nWorking with Encodings\nstatic var availableStringEncodings: [String.Encoding]\nAn array of the encodings that strings support in the application’s environment.\nstatic func localizedName(of: String.Encoding) -> String\nReturns a human-readable string giving the name of the specified encoding.\nvar isContiguousUTF8: Bool\nReturns whether this string is capable of providing access to validly-encoded UTF-8 contents in contiguous memory in O(1) time.\nfunc makeContiguousUTF8()\nIf this string is not contiguous, make it so. If this mutates the string, it will invalidate any pre-existing indices.\nfunc withUTF8<R>((UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R\nRuns body over the content of this string in contiguous memory. If this string is not contiguous, this will first make it contiguous, which will also speed up subsequent access. If this mutates the string, it will invalidate any pre-existing indices."
  },
  {
    "title": "localizedName(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/localizedname(of:)",
    "html": "Parameters\nencoding\n\nA string encoding. For possible values, see String.Encoding.\n\nReturn Value\n\nA human-readable string giving the name of encoding in the current locale.\n\nSee Also\nWorking with Encodings\nstatic var availableStringEncodings: [String.Encoding]\nAn array of the encodings that strings support in the application’s environment.\nstatic var defaultCStringEncoding: String.Encoding\nThe C-string encoding assumed for any method accepting a C string as an argument.\nvar isContiguousUTF8: Bool\nReturns whether this string is capable of providing access to validly-encoded UTF-8 contents in contiguous memory in O(1) time.\nfunc makeContiguousUTF8()\nIf this string is not contiguous, make it so. If this mutates the string, it will invalidate any pre-existing indices.\nfunc withUTF8<R>((UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R\nRuns body over the content of this string in contiguous memory. If this string is not contiguous, this will first make it contiguous, which will also speed up subsequent access. If this mutates the string, it will invalidate any pre-existing indices."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(_:)-11jx3",
    "html": "Discussion\n\nComplexity\n\nO(N), where N is the length of the resulting String’s UTF-16.\n\nSee Also\nWorking with String Views\nvar unicodeScalars: String.UnicodeScalarView\nThe string’s value represented as a collection of Unicode scalar values.\ninit(String.UnicodeScalarView)\nCreates a string corresponding to the given collection of Unicode scalars.\nvar utf16: String.UTF16View\nA UTF-16 encoding of self.\ninit(String.UTF16View)\nCreates a string corresponding to the given sequence of UTF-16 code units.\ninit?(Substring.UTF16View)\nCreates a String having the given content.\nvar utf8: String.UTF8View\nA UTF-8 encoding of self.\ninit(String.UTF8View)\nCreates a string corresponding to the given sequence of UTF-8 code units.\ninit?(Substring.UTF8View)\nCreates a String having the given content."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(_:)-6sprj",
    "html": "See Also\nWorking with String Views\nvar unicodeScalars: String.UnicodeScalarView\nThe string’s value represented as a collection of Unicode scalar values.\ninit(String.UnicodeScalarView)\nCreates a string corresponding to the given collection of Unicode scalars.\ninit(Substring.UnicodeScalarView)\nCreates a String having the given content.\nvar utf16: String.UTF16View\nA UTF-16 encoding of self.\ninit(String.UTF16View)\nCreates a string corresponding to the given sequence of UTF-16 code units.\ninit?(Substring.UTF16View)\nCreates a String having the given content.\nvar utf8: String.UTF8View\nA UTF-8 encoding of self.\ninit?(Substring.UTF8View)\nCreates a String having the given content."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/flatmap(_:)-i3m9",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result.\n\nSee Also\nTransforming a String’s Characters\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc compactMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nfunc reduce<Result>(Result, (Result, Self.Element) throws -> Result) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) throws -> ()) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nvar lazy: LazySequence<Self>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(_:)-83bub",
    "html": "Discussion\n\nIf codeUnits is an ill-formed code unit sequence, the result is nil.\n\nComplexity\n\nO(N), where N is the length of the resulting String’s UTF-16.\n\nSee Also\nWorking with String Views\nvar unicodeScalars: String.UnicodeScalarView\nThe string’s value represented as a collection of Unicode scalar values.\ninit(String.UnicodeScalarView)\nCreates a string corresponding to the given collection of Unicode scalars.\ninit(Substring.UnicodeScalarView)\nCreates a String having the given content.\nvar utf16: String.UTF16View\nA UTF-16 encoding of self.\ninit(String.UTF16View)\nCreates a string corresponding to the given sequence of UTF-16 code units.\ninit?(Substring.UTF16View)\nCreates a String having the given content.\nvar utf8: String.UTF8View\nA UTF-8 encoding of self.\ninit(String.UTF8View)\nCreates a string corresponding to the given sequence of UTF-8 code units."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nSee Also\nTransforming a String’s Characters\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc compactMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nfunc reduce<Result>(Result, (Result, Self.Element) throws -> Result) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nvar lazy: LazySequence<Self>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nSee Also\nTransforming a String’s Characters\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc compactMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) throws -> ()) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nvar lazy: LazySequence<Self>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence.\n\nSee Also\nTransforming a String’s Characters\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc flatMap<SegmentOfResult>((Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nfunc reduce<Result>(Result, (Result, Self.Element) throws -> Result) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) throws -> ()) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nvar lazy: LazySequence<Self>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/flatmap(_:)-6chuq",
    "html": "See Also\nTransforming a String’s Characters\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc compactMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc reduce<Result>(Result, (Result, Self.Element) throws -> Result) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) throws -> ()) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nvar lazy: LazySequence<Self>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily."
  },
  {
    "title": "lazy | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/lazy",
    "html": "See Also\nTransforming a String’s Characters\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc compactMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nfunc reduce<Result>(Result, (Result, Self.Element) throws -> Result) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) throws -> ()) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls.\n\nSee Also\nIterating over a String’s Characters\nfunc enumerated() -> EnumeratedSequence<Self>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc makeIterator() -> String.Iterator\nReturns an iterator over the elements of the collection.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/startindex",
    "html": "Discussion\n\nIn an empty string, startIndex is equal to endIndex.\n\nSee Also\nManipulating Indices\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>."
  },
  {
    "title": "Substring.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nSee Also\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence.\n\nSee Also\nReordering a String’s Characters\nfunc sorted(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc reversed() -> ReversedCollection<Self>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffled() -> [Self.Element]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [Self.Element]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "String | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Swift/String",
    "html": "Overview\n\nA string is a series of characters, such as \"Swift\", that forms a collection. Strings in Swift are Unicode correct and locale insensitive, and are designed to be efficient. The String type bridges with the Objective-C class NSString and offers interoperability with C functions that works with strings.\n\nYou can create new strings using string literals or string interpolations. A string literal is a series of characters enclosed in quotes.\n\nlet greeting = \"Welcome!\"\n\n\nString interpolations are string literals that evaluate any included expressions and convert the results to string form. String interpolations give you an easy way to build a string from multiple pieces. Wrap each expression in a string interpolation in parentheses, prefixed by a backslash.\n\nlet name = \"Rosa\"\nlet personalizedGreeting = \"Welcome, \\(name)!\"\n// personalizedGreeting == \"Welcome, Rosa!\"\n\n\nlet price = 2\nlet number = 3\nlet cookiePrice = \"\\(number) cookies: $\\(price * number).\"\n// cookiePrice == \"3 cookies: $6.\"\n\n\nCombine strings using the concatenation operator (+).\n\nlet longerGreeting = greeting + \" We're glad you're here!\"\n// longerGreeting == \"Welcome! We're glad you're here!\"\n\n\nMultiline string literals are enclosed in three double quotation marks (\"\"\"), with each delimiter on its own line. Indentation is stripped from each line of a multiline string literal to match the indentation of the closing delimiter.\n\nlet banner = \"\"\"\n          __,\n         (           o  /) _/_\n          `.  , , , ,  //  /\n        (___)(_(_/_(_ //_ (__\n                     /)\n                    (/\n        \"\"\"\n\nModifying and Comparing Strings\n\nStrings always have value semantics. Modifying a copy of a string leaves the original unaffected.\n\nvar otherGreeting = greeting\notherGreeting += \" Have a nice time!\"\n// otherGreeting == \"Welcome! Have a nice time!\"\n\n\nprint(greeting)\n// Prints \"Welcome!\"\n\n\nComparing strings for equality using the equal-to operator (==) or a relational operator (like < or >=) is always performed using Unicode canonical representation. As a result, different representations of a string compare as being equal.\n\nlet cafe1 = \"Cafe\\u{301}\"\nlet cafe2 = \"Café\"\nprint(cafe1 == cafe2)\n// Prints \"true\"\n\n\nThe Unicode scalar value \"\\u{301}\" modifies the preceding character to include an accent, so \"e\\u{301}\" has the same canonical representation as the single Unicode scalar value \"é\".\n\nBasic string operations are not sensitive to locale settings, ensuring that string comparisons and other operations always have a single, stable result, allowing strings to be used as keys in Dictionary instances and for other purposes.\n\nAccessing String Elements\n\nA string is a collection of extended grapheme clusters, which approximate human-readable characters. Many individual characters, such as “é”, “김”, and “🇮🇳”, can be made up of multiple Unicode scalar values. These scalar values are combined by Unicode’s boundary algorithms into extended grapheme clusters, represented by the Swift Character type. Each element of a string is represented by a Character instance.\n\nFor example, to retrieve the first word of a longer string, you can search for a space and then create a substring from a prefix of the string up to that point:\n\nlet name = \"Marie Curie\"\nlet firstSpace = name.firstIndex(of: \" \") ?? name.endIndex\nlet firstName = name[..<firstSpace]\n// firstName == \"Marie\"\n\n\nThe firstName constant is an instance of the Substring type—a type that represents substrings of a string while sharing the original string’s storage. Substrings present the same interface as strings.\n\nprint(\"\\(name)'s first name has \\(firstName.count) letters.\")\n// Prints \"Marie Curie's first name has 5 letters.\"\n\nAccessing a String’s Unicode Representation\n\nIf you need to access the contents of a string as encoded in different Unicode encodings, use one of the string’s unicodeScalars, utf16, or utf8 properties. Each property provides access to a view of the string as a series of code units, each encoded in a different Unicode encoding.\n\nTo demonstrate the different views available for every string, the following examples use this String instance:\n\nlet cafe = \"Cafe\\u{301} du 🌍\"\nprint(cafe)\n// Prints \"Café du 🌍\"\n\n\nThe cafe string is a collection of the nine characters that are visible when the string is displayed.\n\nprint(cafe.count)\n// Prints \"9\"\nprint(Array(cafe))\n// Prints \"[\"C\", \"a\", \"f\", \"é\", \" \", \"d\", \"u\", \" \", \"🌍\"]\"\n\nUnicode Scalar View\n\nA string’s unicodeScalars property is a collection of Unicode scalar values, the 21-bit codes that are the basic unit of Unicode. Each scalar value is represented by a Unicode.Scalar instance and is equivalent to a UTF-32 code unit.\n\nprint(cafe.unicodeScalars.count)\n// Prints \"10\"\nprint(Array(cafe.unicodeScalars))\n// Prints \"[\"C\", \"a\", \"f\", \"e\", \"\\u{0301}\", \" \", \"d\", \"u\", \" \", \"\\u{0001F30D}\"]\"\nprint(cafe.unicodeScalars.map { $0.value })\n// Prints \"[67, 97, 102, 101, 769, 32, 100, 117, 32, 127757]\"\n\n\nThe unicodeScalars view’s elements comprise each Unicode scalar value in the cafe string. In particular, because cafe was declared using the decomposed form of the \"é\" character, unicodeScalars contains the scalar values for both the letter \"e\" (101) and the accent character \"´\" (769).\n\nUTF-16 View\n\nA string’s utf16 property is a collection of UTF-16 code units, the 16-bit encoding form of the string’s Unicode scalar values. Each code unit is stored as a UInt16 instance.\n\nprint(cafe.utf16.count)\n// Prints \"11\"\nprint(Array(cafe.utf16))\n// Prints \"[67, 97, 102, 101, 769, 32, 100, 117, 32, 55356, 57101]\"\n\n\nThe elements of the utf16 view are the code units for the string when encoded in UTF-16. These elements match those accessed through indexed NSString APIs.\n\nlet nscafe = cafe as NSString\nprint(nscafe.length)\n// Prints \"11\"\nprint(nscafe.character(at: 3))\n// Prints \"101\"\n\nUTF-8 View\n\nA string’s utf8 property is a collection of UTF-8 code units, the 8-bit encoding form of the string’s Unicode scalar values. Each code unit is stored as a UInt8 instance.\n\nprint(cafe.utf8.count)\n// Prints \"14\"\nprint(Array(cafe.utf8))\n// Prints \"[67, 97, 102, 101, 204, 129, 32, 100, 117, 32, 240, 159, 140, 141]\"\n\n\nThe elements of the utf8 view are the code units for the string when encoded in UTF-8. This representation matches the one used when String instances are passed to C APIs.\n\nlet cLength = strlen(cafe)\nprint(cLength)\n// Prints \"14\"\n\nMeasuring the Length of a String\n\nWhen you need to know the length of a string, you must first consider what you’ll use the length for. Are you measuring the number of characters that will be displayed on the screen, or are you measuring the amount of storage needed for the string in a particular encoding? A single string can have greatly differing lengths when measured by its different views.\n\nFor example, an ASCII character like the capital letter A is represented by a single element in each of its four views. The Unicode scalar value of A is 65, which is small enough to fit in a single code unit in both UTF-16 and UTF-8.\n\nlet capitalA = \"A\"\nprint(capitalA.count)\n// Prints \"1\"\nprint(capitalA.unicodeScalars.count)\n// Prints \"1\"\nprint(capitalA.utf16.count)\n// Prints \"1\"\nprint(capitalA.utf8.count)\n// Prints \"1\"\n\n\nOn the other hand, an emoji flag character is constructed from a pair of Unicode scalar values, like \"\\u{1F1F5}\" and \"\\u{1F1F7}\". Each of these scalar values, in turn, is too large to fit into a single UTF-16 or UTF-8 code unit. As a result, each view of the string \"🇵🇷\" reports a different length.\n\nlet flag = \"🇵🇷\"\nprint(flag.count)\n// Prints \"1\"\nprint(flag.unicodeScalars.count)\n// Prints \"2\"\nprint(flag.utf16.count)\n// Prints \"4\"\nprint(flag.utf8.count)\n// Prints \"8\"\n\n\nTo check whether a string is empty, use its isEmpty property instead of comparing the length of one of the views to 0. Unlike with isEmpty, calculating a view’s count property requires iterating through the elements of the string.\n\nAccessing String View Elements\n\nTo find individual elements of a string, use the appropriate view for your task. For example, to retrieve the first word of a longer string, you can search the string for a space and then create a new string from a prefix of the string up to that point.\n\nlet name = \"Marie Curie\"\nlet firstSpace = name.firstIndex(of: \" \") ?? name.endIndex\nlet firstName = name[..<firstSpace]\nprint(firstName)\n// Prints \"Marie\"\n\n\nStrings and their views share indices, so you can access the UTF-8 view of the name string using the same firstSpace index.\n\nprint(Array(name.utf8[..<firstSpace]))\n// Prints \"[77, 97, 114, 105, 101]\"\n\n\nNote that an index into one view may not have an exact corresponding position in another view. For example, the flag string declared above comprises a single character, but is composed of eight code units when encoded as UTF-8. The following code creates constants for the first and second positions in the flag.utf8 view. Accessing the utf8 view with these indices yields the first and second code UTF-8 units.\n\nlet firstCodeUnit = flag.startIndex\nlet secondCodeUnit = flag.utf8.index(after: firstCodeUnit)\n// flag.utf8[firstCodeUnit] == 240\n// flag.utf8[secondCodeUnit] == 159\n\n\nWhen used to access the elements of the flag string itself, however, the secondCodeUnit index does not correspond to the position of a specific character. Instead of only accessing the specific UTF-8 code unit, that index is treated as the position of the character at the index’s encoded offset. In the case of secondCodeUnit, that character is still the flag itself.\n\n// flag[firstCodeUnit] == \"🇵🇷\"\n// flag[secondCodeUnit] == \"🇵🇷\"\n\n\nIf you need to validate that an index from one string’s view corresponds with an exact position in another view, use the index’s samePosition(in:) method or the init(_:within:) initializer.\n\nif let exactIndex = secondCodeUnit.samePosition(in: flag) {\n    print(flag[exactIndex])\n} else {\n    print(\"No exact match for this position.\")\n}\n// Prints \"No exact match for this position.\"\n\nPerformance Optimizations\n\nAlthough strings in Swift have value semantics, strings use a copy-on-write strategy to store their data in a buffer. This buffer can then be shared by different copies of a string. A string’s data is only copied lazily, upon mutation, when more than one string instance is using the same buffer. Therefore, the first in any sequence of mutating operations may cost O(n) time and space.\n\nWhen a string’s contiguous storage fills up, a new buffer must be allocated and data must be moved to the new storage. String buffers use an exponential growth strategy that makes appending to a string a constant time operation when averaged over many append operations.\n\nBridging Between String and NSString\n\nAny String instance can be bridged to NSString using the type-cast operator (as), and any String instance that originates in Objective-C may use an NSString instance as its storage. Because any arbitrary subclass of NSString can become a String instance, there are no guarantees about representation or efficiency when a String instance is backed by NSString storage. Because NSString is immutable, it is just as though the storage was shared by a copy. The first in any sequence of mutating operations causes elements to be copied into unique, contiguous storage which may cost O(n) time and space, where n is the length of the string’s encoded representation (or more, if the underlying NSString has unusual performance characteristics).\n\nFor more information about the Unicode terms used in this discussion, see the Unicode.org glossary. In particular, this discussion mentions extended grapheme clusters, Unicode scalar values, and canonical equivalence.\n\nTopics\nCreating a String\nIn addition to creating a string from a single string literal, you can also create an empty string, a string containing an existing group of characters, or a string repeating the contents of another string.\ninit(decoding: FilePath)\nCreates a string by interpreting the file path’s content as UTF-8 on Unix and UTF-16 on Windows.\ninit()\nCreates an empty string.\ninit(Character)\nCreates a string containing the given character.\ninit<S>(S)\nCreates a new string containing the characters in the given sequence.\ninit<S>(S)\nCreates a new instance of a collection containing the elements of a sequence.\ninit<S>(S)\nCreates a new string containing the characters in the given sequence.\ninit(Substring)\nCreates a new string from the given substring.\ninit(repeating: String, count: Int)\nCreates a new string representing the given string repeated the specified number of times.\ninit(repeating: Character, count: Int)\nCreates a string representing the given character repeated the specified number of times.\ninit(unsafeUninitializedCapacity: Int, initializingUTF8With: (UnsafeMutableBufferPointer<UInt8>) throws -> Int) rethrows\nCreates a new string with the specified capacity in UTF-8 code units, and then calls the given closure with a buffer covering the string’s uninitialized memory.\nInspecting a String\nvar isEmpty: Bool\nA Boolean value indicating whether a string has no characters.\nvar count: Int\nThe number of characters in a string.\nCreating a String from Unicode Data\ninit(Unicode.Scalar)\ninit?(data: Data, encoding: String.Encoding)\nReturns a String initialized by converting given data into Unicode characters using a given encoding.\ninit?(validatingUTF8: UnsafePointer<CChar>)\nCreates a new string by copying and validating the null-terminated UTF-8 data referenced by the given pointer.\ninit(utf16CodeUnits: UnsafePointer<unichar>, count: Int)\nCreates a new string that contains the specified number of characters from the given C array of Unicode characters.\ninit(utf16CodeUnitsNoCopy: UnsafePointer<unichar>, count: Int, freeWhenDone: Bool)\nCreates a new string that contains the specified number of characters from the given C array of UTF-16 code units.\ninit<C, Encoding>(decoding: C, as: Encoding.Type)\nCreates a string from the given Unicode code units in the specified encoding.\nCreating a String Using Formats\ninit(format: String, CVarArg...)\nReturns a String object initialized by using a given format string as a template into which the remaining argument values are substituted.\ninit(format: String, arguments: [CVarArg])\nReturns a String object initialized by using a given format string as a template into which the remaining argument values are substituted according to the user’s default locale.\ninit(format: String, locale: Locale?, CVarArg...)\nReturns a String object initialized by using a given format string as a template into which the remaining argument values are substituted according to given locale information.\ninit(format: String, locale: Locale?, arguments: [CVarArg])\nReturns a String object initialized by using a given format string as a template into which the remaining argument values are substituted according to given locale information.\nstatic func localizedStringWithFormat(String, CVarArg...) -> String\nReturns a string created by using a given format string as a template into which the remaining argument values are substituted according to the user’s default locale.\nConverting Numeric Values\ninit<T>(T, radix: Int, uppercase: Bool)\nCreates a string representing the given value in base 10, or some other specified base.\nConverting a C String\ninit?<S>(bytes: S, encoding: String.Encoding)\nCreates a new string equivalent to the given bytes interpreted in the specified encoding.\ninit?(bytesNoCopy: UnsafeMutableRawPointer, length: Int, encoding: String.Encoding, freeWhenDone: Bool)\nCreates a new string that contains the specified number of bytes from the given buffer, interpreted in the specified encoding, and optionally frees the buffer.\ninit(cString: UnsafePointer<CChar>)\nCreates a new string by copying the null-terminated UTF-8 data referenced by the given pointer.\ninit(cString: UnsafePointer<UInt8>)\nCreates a new string by copying the null-terminated UTF-8 data referenced by the given pointer.\ninit<Encoding>(decodingCString: [Encoding.CodeUnit], as: Encoding.Type)\nstatic func decodeCString<Encoding>(UnsafePointer<Encoding.CodeUnit>?, as: Encoding.Type, repairingInvalidCodeUnits: Bool) -> (result: String, repairsMade: Bool)?\nCreates a new string by copying the null-terminated data referenced by the given pointer using the specified encoding.\nConverting Other Types to Strings\ninit<T>(T)\nCreates an instance from the description of a given LosslessStringConvertible instance.\ninit<Subject>(describing: Subject)\nCreates a string representing the given value.\ninit<Subject>(describing: Subject)\nCreates a string representing the given value.\ninit<Subject>(describing: Subject)\nCreates a string representing the given value.\ninit<Subject>(describing: Subject)\nCreates a string representing the given value.\ninit<Subject>(reflecting: Subject)\nCreates a string with a detailed representation of the given value, suitable for debugging.\nCreating a String from a File or URL\ninit(contentsOf: URL) throws\ninit(contentsOf: URL, encoding: String.Encoding) throws\nProduces a string created by reading data from a given URL interpreted using a given encoding. Errors are written into the inout error argument.\ninit(contentsOf: URL, usedEncoding: inout String.Encoding) throws\nProduces a string created by reading data from a given URL and returns by reference the encoding used to interpret the data. Errors are written into the inout error argument.\ninit(contentsOfFile: String) throws\ninit(contentsOfFile: String, encoding: String.Encoding) throws\nProduces a string created by reading data from the file at a given path interpreted using a given encoding.\ninit(contentsOfFile: String, usedEncoding: inout String.Encoding) throws\nProduces a string created by reading data from the file at a given path and returns by reference the encoding used to interpret the file.\nWriting to a File or URL\nfunc write(String)\nAppends the given string to this string.\nfunc write<Target>(to: inout Target)\nWrites the string into the given output stream.\nAppending Strings and Characters\nfunc append(String)\nAppends the given string to this string.\nfunc append(Character)\nAppends the given character to the string.\nfunc append(contentsOf: String)\nfunc append(contentsOf: Substring)\nfunc append<S>(contentsOf: S)\nAppends the characters in the given sequence to the string.\nfunc append<S>(contentsOf: S)\nAdds the elements of a sequence or collection to the end of this collection.\nfunc reserveCapacity(Int)\nReserves enough space in the string’s underlying storage to store the specified number of ASCII characters.\nstatic func + (String, String) -> String\nstatic func += (inout String, String)\nstatic func + <Other>(Other, Self) -> Self\nCreates a new collection by concatenating the elements of a sequence and a collection.\nstatic func + <Other>(Self, Other) -> Self\nCreates a new collection by concatenating the elements of a collection and a sequence.\nstatic func + <Other>(Self, Other) -> Self\nCreates a new collection by concatenating the elements of two collections.\nstatic func += <Other>(inout Self, Other)\nAppends the elements of a sequence to a range-replaceable collection.\nInserting Characters\nfunc insert(Character, at: String.Index)\nInserts a new character at the specified position.\nfunc insert(Self.Element, at: Self.Index)\nInserts a new element into the collection at the specified position.\nfunc insert<C>(contentsOf: C, at: Self.Index)\nInserts the elements of a sequence into the collection at the specified position.\nfunc insert<S>(contentsOf: S, at: String.Index)\nInserts a collection of characters at the specified position.\nReplacing Substrings\nfunc replaceSubrange<C>(Range<String.Index>, with: C)\nReplaces the text within the specified bounds with the given characters.\nfunc replaceSubrange<C, R>(R, with: C)\nReplaces the specified subrange of elements with the given collection.\nRemoving Substrings\nfunc remove(at: String.Index) -> Character\nRemoves and returns the character at the specified position.\nfunc remove(at: Self.Index) -> Self.Element\nRemoves and returns the element at the specified position.\nfunc removeAll(keepingCapacity: Bool)\nReplaces this string with the empty string.\nfunc removeAll(where: (Self.Element) throws -> Bool) rethrows\nRemoves all the elements that satisfy the given predicate.\nfunc removeFirst() -> Self.Element\nRemoves and returns the first element of the collection.\nfunc removeFirst(Int)\nRemoves the specified number of elements from the beginning of the collection.\nfunc removeLast() -> Self.Element\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeLast(Int)\nRemoves the specified number of elements from the end of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nfunc removeSubrange(Range<String.Index>)\nRemoves the characters in the given range.\nfunc removeSubrange(Range<Self.Index>)\nRemoves the elements in the specified subrange from the collection.\nfunc removeSubrange<R>(R)\nRemoves the elements in the specified subrange from the collection.\nfunc filter((Self.Element) throws -> Bool) rethrows -> Self\nReturns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.\nfunc drop(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence by skipping elements while predicate returns true and returning the remaining elements.\nfunc dropFirst(Int) -> Self.SubSequence\nReturns a subsequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> Self.SubSequence\nReturns a subsequence containing all but the specified number of final elements.\nfunc popLast() -> Self.Element?\nRemoves and returns the last element of the collection.\nAvailable when Self conforms to BidirectionalCollection.\nChanging Case\nfunc lowercased() -> String\nReturns a lowercase version of the string.\nfunc uppercased() -> String\nReturns an uppercase version of the string.\nComparing Strings Using Operators\nComparing strings using the equal-to operator (==) or a relational operator (like < and >=) is always performed using the Unicode canonical representation, so that different representations of a string compare as being equal.\nstatic func == (String, String) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nstatic func == <RHS>(Self, RHS) -> Bool\nReturns a Boolean value indicating whether two values are equal.\nstatic func != (Self, Self) -> Bool\nstatic func != <RHS>(Self, RHS) -> Bool\nstatic func ~= (String, Substring) -> Bool\nComparing Characters\nfunc elementsEqual<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.\nAvailable when Element conforms to Equatable.\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (Self.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc starts<PossiblePrefix>(with: PossiblePrefix) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.\nAvailable when Element conforms to Equatable.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (Self.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.\nAvailable when Element conforms to Comparable.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.\nCreating and Applying Differences\nfunc applying(CollectionDifference<Self.Element>) -> Self?\nApplies the given difference to this collection.\nfunc difference<C>(from: C) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection.\nAvailable when Element conforms to Equatable.\nfunc difference<C>(from: C, by: (C.Element, Self.Element) -> Bool) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test.\nFinding Substrings\nfunc hasPrefix(String) -> Bool\nfunc hasSuffix(String) -> Bool\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements.\nGetting Substrings\nsubscript(Range<String.Index>) -> Substring\nAccesses a contiguous subrange of the collection’s elements.\nsubscript<R>(R) -> Self.SubSequence\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Self.SubSequence\nfunc prefix(Int) -> Self.SubSequence\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Self.SubSequence\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection.\nSplitting a String\nfunc split(separator: Self.Element, maxSplits: Int, omittingEmptySubsequences: Bool) -> [Self.SubSequence]\nReturns the longest possible subsequences of the collection, in order, around elements equal to the given element.\nAvailable when Element conforms to Equatable.\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (Self.Element) throws -> Bool) rethrows -> [Self.SubSequence]\nReturns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.\nGetting Characters and Bytes\nsubscript(String.Index) -> Character\nAccesses the character at the given position.\nvar first: Self.Element?\nThe first element of the collection.\nvar last: Self.Element?\nThe last element of the collection.\nfunc randomElement() -> Self.Element?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> Self.Element?\nReturns a random element of the collection, using the given generator as a source for randomness.\nWorking with Encodings\nstatic var availableStringEncodings: [String.Encoding]\nAn array of the encodings that strings support in the application’s environment.\nstatic var defaultCStringEncoding: String.Encoding\nThe C-string encoding assumed for any method accepting a C string as an argument.\nstatic func localizedName(of: String.Encoding) -> String\nReturns a human-readable string giving the name of the specified encoding.\nvar isContiguousUTF8: Bool\nReturns whether this string is capable of providing access to validly-encoded UTF-8 contents in contiguous memory in O(1) time.\nfunc makeContiguousUTF8()\nIf this string is not contiguous, make it so. If this mutates the string, it will invalidate any pre-existing indices.\nfunc withUTF8<R>((UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R\nRuns body over the content of this string in contiguous memory. If this string is not contiguous, this will first make it contiguous, which will also speed up subsequent access. If this mutates the string, it will invalidate any pre-existing indices.\nWorking with String Views\nvar unicodeScalars: String.UnicodeScalarView\nThe string’s value represented as a collection of Unicode scalar values.\ninit(String.UnicodeScalarView)\nCreates a string corresponding to the given collection of Unicode scalars.\ninit(Substring.UnicodeScalarView)\nCreates a String having the given content.\nvar utf16: String.UTF16View\nA UTF-16 encoding of self.\ninit(String.UTF16View)\nCreates a string corresponding to the given sequence of UTF-16 code units.\ninit?(Substring.UTF16View)\nCreates a String having the given content.\nvar utf8: String.UTF8View\nA UTF-8 encoding of self.\ninit(String.UTF8View)\nCreates a string corresponding to the given sequence of UTF-8 code units.\ninit?(Substring.UTF8View)\nCreates a String having the given content.\nTransforming a String’s Characters\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc compactMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nfunc reduce<Result>(Result, (Result, Self.Element) throws -> Result) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) throws -> ()) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nvar lazy: LazySequence<Self>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.\nIterating over a String’s Characters\nfunc forEach((Self.Element) throws -> Void) rethrows\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc enumerated() -> EnumeratedSequence<Self>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc makeIterator() -> String.Iterator\nReturns an iterator over the elements of the collection.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection.\nReordering a String’s Characters\nfunc sorted() -> [Self.Element]\nReturns the elements of the sequence, sorted.\nAvailable when Element conforms to Comparable.\nfunc sorted(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc reversed() -> ReversedCollection<Self>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffled() -> [Self.Element]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [Self.Element]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness.\nGetting C Strings\nvar utf8CString: ContiguousArray<CChar>\nA contiguously stored null-terminated UTF-8 representation of the string.\nfunc withCString<Result>((UnsafePointer<Int8>) throws -> Result) rethrows -> Result\nCalls the given closure with a pointer to the contents of the string, represented as a null-terminated sequence of UTF-8 code units.\nfunc withCString<Result, TargetEncoding>(encodedAs: TargetEncoding.Type, (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result\nCalls the given closure with a pointer to the contents of the string, represented as a null-terminated sequence of code units.\nWorking with Paths\ninit(FilePath)\ninit?(validatingUTF8: FilePath)\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>.\nCreating a Range Expression\nstatic func ... (Self, Self) -> ClosedRange<Self>\nReturns a closed range that contains both of its bounds.\nstatic func ... (Self) -> PartialRangeThrough<Self>\nReturns a partial range up to, and including, its upper bound.\nstatic func ... (Self) -> PartialRangeFrom<Self>\nReturns a partial range extending upward from a lower bound.\nEncoding and Decoding\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder.\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder.\nDescribing a String\nvar description: String\nThe value of this string.\nvar debugDescription: String\nA representation of the string that is suitable for debugging.\nvar customMirror: Mirror\nA mirror that reflects the String instance.\nvar hashValue: Int\nThe hash value.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nUsing a String as a Data Value\ninit?(from: MLDataValue)\nCreates an instance of the conforming type from a data value.\nvar dataValue: MLDataValue\nThe value of the conforming type’s instance wrapped in a data value.\nvar identifierValue: MLDataValue\nThe value of the unique identifier wrapped in a data value.\nstatic var dataValueType: MLDataValue.ValueType\nThe underlying type the conforming type uses when it wraps itself in a data value.\nInfrequently Used Functionality\nfunc index(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\ninit(NSString)\ninit(stringInterpolation: DefaultStringInterpolation)\nCreates a new instance from an interpolated string literal.\ninit(stringLiteral: String)\nCreates an instance initialized to the given string value.\ninit(unicodeScalarLiteral: Self.ExtendedGraphemeClusterLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.UnicodeScalarLiteralType.\ninit(extendedGraphemeClusterLiteral: Self.StringLiteralType)\nCreates an instance initialized to the given value.\nAvailable when ExtendedGraphemeClusterLiteralType is Self.StringLiteralType.\nvar customPlaygroundQuickLook: _PlaygroundQuickLook\nA custom playground Quick Look for the String instance.\nDeprecated\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?\nExecutes a closure on the sequence’s contiguous storage.\nReference Types\nUse bridged reference types when you need reference semantics or Foundation-specific behavior.\nclass NSString\nA static, plain-text Unicode string object which you use when you need reference semantics or other Foundation-specific behavior.\nclass NSMutableString\nA dynamic plain-text Unicode string object, for use instead of a variable in cases that require reference semantics.\nRelated String Types\nstruct Substring\nA slice of a string.\nprotocol StringProtocol\nA type that can represent a string as a collection of characters.\nstruct Index\nA position of a character or code unit in a string.\nstruct UnicodeScalarView\nA view of a string’s contents as a collection of Unicode scalar values.\nstruct UTF16View\nA view of a string’s contents as a collection of UTF-16 code units.\nstruct UTF8View\nA view of a string’s contents as a collection of UTF-8 code units.\nstruct Iterator\nA type that provides the collection’s iteration interface and encapsulates its iteration state.\nstruct Encoding\nStructures\nstruct Comparator\nA String comparison performed using the given comparison options and locale.\nstruct IntentInputOptions\nstruct LocalizationOptions\nstruct LocalizationValue\nstruct StandardComparator\nCompares Strings using one of a fixed set of standard comparison algorithms.\nInitializers\ninit(Slice<AttributedString.CharacterView>)\ninit(cString: inout CChar)\nDeprecated\ninit(cString: inout UInt8)\nDeprecated\ninit(cString: [UInt8])\ninit(cString: [CChar])\ninit(cString: String)\nDeprecated\ninit?(cString: inout CChar, encoding: String.Encoding)\nDeprecated\ninit?(cString: [CChar], encoding: String.Encoding)\nProduces a string by copying the null-terminated bytes in a given array, interpreted according to a given encoding.\ninit?(cString: UnsafePointer<CChar>, encoding: String.Encoding)\nProduces a string by copying the null-terminated bytes in a given C array, interpreted according to a given encoding.\ninit?(cString: String, encoding: String.Encoding)\nDeprecated\ninit(decoding: FilePath.Root)\nOn Unix, creates the string \"/\"\ninit(decoding: FilePath.Component)\nCreates a string by interpreting the path component’s content as UTF-8 on Unix and UTF-16 on Windows.\ninit<Encoding>(decodingCString: String, as: Encoding.Type)\nDeprecated\ninit<Encoding>(decodingCString: inout Encoding.CodeUnit, as: Encoding.Type)\nDeprecated\ninit(localized: LocalizedStringResource)\ninit(localized: StaticString, defaultValue: String.LocalizationValue, options: String.LocalizationOptions, table: String?, bundle: Bundle?, locale: Locale, comment: StaticString?)\ninit(localized: StaticString, defaultValue: String.LocalizationValue, table: String?, bundle: Bundle?, locale: Locale, comment: StaticString?)\ninit(localized: LocalizedStringResource, options: String.LocalizationOptions)\ninit(localized: String.LocalizationValue, options: String.LocalizationOptions, table: String?, bundle: Bundle?, locale: Locale, comment: StaticString?)\ninit(localized: String.LocalizationValue, table: String?, bundle: Bundle?, locale: Locale, comment: StaticString?)\ninit(platformString: String)\nDeprecated\ninit(platformString: inout CInterop.PlatformChar)\nDeprecated\ninit(platformString: UnsafePointer<CInterop.PlatformChar>)\nCreates a string by interpreting the null-terminated platform string as UTF-8 on Unix and UTF-16 on Windows.\ninit(platformString: [CInterop.PlatformChar])\nCreates a string by interpreting the null-terminated platform string as UTF-8 on Unix and UTF-16 on Windows.\ninit?(utf8String: UnsafePointer<CChar>)\nCreates a string by copying the data from a given null-terminated C array of UTF8-encoded bytes.\ninit?(utf8String: String)\nDeprecated\ninit?(utf8String: inout CChar)\nDeprecated\ninit?(utf8String: [CChar])\nCreates a string by copying the data from a given null-terminated array of UTF8-encoded bytes.\ninit?(validating: FilePath.Root)\nOn Unix, creates the string \"/\"\ninit?(validating: FilePath.Component)\nCreates a string from a path component, validating its contents as UTF-8 on Unix and UTF-16 on Windows.\ninit?(validating: FilePath)\nCreates a string from a file path, validating its contents as UTF-8 on Unix and UTF-16 on Windows.\ninit?(validatingPlatformString: UnsafePointer<CInterop.PlatformChar>)\nCreates a string by interpreting the null-terminated platform string as UTF-8 on Unix and UTF-16 on Windows.\ninit?(validatingPlatformString: inout CInterop.PlatformChar)\nDeprecated\ninit?(validatingPlatformString: [CInterop.PlatformChar])\nCreates a string by interpreting the null-terminated platform string as UTF-8 on Unix and UTF-16 on Windows.\ninit?(validatingPlatformString: String)\nDeprecated\ninit?(validatingUTF8: [CChar])\ninit?(validatingUTF8: inout CChar)\nDeprecated\ninit?(validatingUTF8: String)\nDeprecated\nInstance Properties\nvar characters: String\nA view of the string’s contents as a collection of characters.\nInstance Methods\nfunc withMutableCharacters<R>((inout String) -> R) -> R\nApplies the given closure to a mutable view of the string’s characters.\nfunc withPlatformString<Result>((UnsafePointer<CInterop.PlatformChar>) throws -> Result) rethrows -> Result\nCalls the given closure with a pointer to the contents of the string, represented as a null-terminated platform string.\nType Aliases\ntypealias CharacterView\nA view of a string’s contents as a collection of characters.\ntypealias CompareOptions\ntypealias EncodingConversionOptions\ntypealias EnumerationOptions\ntypealias IndexDistance\nA type that represents the number of steps between two String.Index values, where one value is reachable from the other.\nDeprecated\ntypealias Output\ntypealias UnicodeScalarIndex\nThe index type for a string’s unicodeScalars view.\nType Methods\nstatic func decodeCString<Encoding>(inout Encoding.CodeUnit, as: Encoding.Type, repairingInvalidCodeUnits: Bool) -> (result: String, repairsMade: Bool)?\nDeprecated\nstatic func decodeCString<Encoding>([Encoding.CodeUnit], as: Encoding.Type, repairingInvalidCodeUnits: Bool) -> (result: String, repairsMade: Bool)?\nstatic func decodeCString<Encoding>(String, as: Encoding.Type, repairingInvalidCodeUnits: Bool) -> (result: String, repairsMade: Bool)?\nDeprecated\nDefault Implementations\nBidirectionalCollection Implementations\nCodingKeyRepresentable Implementations\nCollection Implementations\nComparable Implementations\nCustomDebugStringConvertible Implementations\nCustomReflectable Implementations\nCustomStringConvertible Implementations\nDecodable Implementations\nEncodable Implementations\nEntityIdentifierConvertible Implementations\nEquatable Implementations\nExpressibleByExtendedGraphemeClusterLiteral Implementations\nExpressibleByStringInterpolation Implementations\nExpressibleByStringLiteral Implementations\nExpressibleByUnicodeScalarLiteral Implementations\nHashable Implementations\nLosslessStringConvertible Implementations\nMLDataValueConvertible Implementations\nMLIdentifier Implementations\nRangeReplaceableCollection Implementations\nRegexComponent Implementations\nSequence Implementations\nStringProtocol Implementations\nTextOutputStream Implementations\nTextOutputStreamable Implementations\nTransferable Implementations\n_CustomPlaygroundQuickLookable Implementations\n_IntentValue Implementations\nRelationships\nConforms To\nBidirectionalCollection\nBindableData\nCVarArg\nCodingKeyRepresentable\nCollection\nComparable\nCustomDebugStringConvertible\nCustomReflectable\nCustomStringConvertible\nDecodable\nEncodable\nEntityIdentifierConvertible\nEquatable\nExpressibleByExtendedGraphemeClusterLiteral\nExpressibleByStringInterpolation\nExpressibleByStringLiteral\nExpressibleByUnicodeScalarLiteral\nHashable\nLosslessStringConvertible\nMLDataValueConvertible\nMLIdentifier\nMirrorPath\nMusicLibraryRequestFilterValueEquatable\nPlottable\nPrimitivePlottableProtocol\nRangeReplaceableCollection\nRegexComponent\nSendable\nSequence\nStringProtocol\nTextOutputStream\nTextOutputStreamable\nTransferable\nSee Also\nStandard Library\nstruct Int\nA signed integer value type.\nstruct Double\nA double-precision, floating-point value type.\nstruct Array\nAn ordered, random-access collection.\nstruct Dictionary\nA collection whose elements are key-value pairs.\nSwift Standard Library\nSolve complex problems and write high-performance, readable code."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence.\n\nSee Also\nReordering a String’s Characters\nfunc sorted() -> [Self.Element]\nReturns the elements of the sequence, sorted.\nAvailable when Element conforms to Comparable.\nfunc reversed() -> ReversedCollection<Self>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffled() -> [Self.Element]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [Self.Element]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nSee Also\nReordering a String’s Characters\nfunc sorted() -> [Self.Element]\nReturns the elements of the sequence, sorted.\nAvailable when Element conforms to Comparable.\nfunc sorted(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc reversed() -> ReversedCollection<Self>\nReturns a view presenting the elements of the collection in reverse order.\nfunc shuffled<T>(using: inout T) -> [Self.Element]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "AsyncSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Swift/AsyncSequence",
    "html": "Overview\n\nAn AsyncSequence resembles the Sequence type — offering a list of values you can step through one at a time — and adds asynchronicity. An AsyncSequence may have all, some, or none of its values available when you first use it. Instead, you use await to receive values as they become available.\n\nAs with Sequence, you typically iterate through an AsyncSequence with a for await-in loop. However, because the caller must potentially wait for values, you use the await keyword. The following example shows how to iterate over Counter, a custom AsyncSequence that produces Int values from 1 up to a howHigh value:\n\nfor await number in Counter(howHigh: 10) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 7 8 9 10 \"\n\n\nAn AsyncSequence doesn’t generate or contain the values; it just defines how you access them. Along with defining the type of values as an associated type called Element, the AsyncSequence defines a makeAsyncIterator() method. This returns an instance of type AsyncIterator. Like the standard IteratorProtocol, the AsyncIteratorProtocol defines a single next() method to produce elements. The difference is that the AsyncIterator defines its next() method as async, which requires a caller to wait for the next value with the await keyword.\n\nAsyncSequence also defines methods for processing the elements you receive, modeled on the operations provided by the basic Sequence in the standard library. There are two categories of methods: those that return a single value, and those that return another AsyncSequence.\n\nSingle-value methods eliminate the need for a for await-in loop, and instead let you make a single await call. For example, the contains(_:) method returns a Boolean value that indicates if a given value exists in the AsyncSequence. Given the Counter sequence from the previous example, you can test for the existence of a sequence member with a one-line call:\n\nlet found = await Counter(howHigh: 10).contains(5) // true\n\n\nMethods that return another AsyncSequence return a type specific to the method’s semantics. For example, the .map(_:) method returns a AsyncMapSequence (or a AsyncThrowingMapSequence, if the closure you provide to the map(_:) method can throw an error). These returned sequences don’t eagerly await the next member of the sequence, which allows the caller to decide when to start work. Typically, you’ll iterate over these sequences with for await-in, like the base AsyncSequence you started with. In the following example, the map(_:) method transforms each Int received from a Counter sequence into a String:\n\nlet stream = Counter(howHigh: 10)\n    .map { $0 % 2 == 0 ? \"Even\" : \"Odd\" }\nfor await s in stream {\n    print(s, terminator: \" \")\n}\n// Prints \"Odd Even Odd Even Odd Even Odd Even Odd Even \"\n\nTopics\nCreating an Iterator\nfunc makeAsyncIterator() -> Self.AsyncIterator\nCreates the asynchronous iterator that produces elements of this asynchronous sequence.\n\nRequired\n\nassociatedtype AsyncIterator : AsyncIteratorProtocol\nThe type of asynchronous iterator that produces elements of this asynchronous sequence.\n\nRequired\n\nprotocol AsyncIteratorProtocol\nA type that asynchronously supplies the values of a sequence one at a time.\nassociatedtype Element\nThe type of element produced by this asynchronous sequence.\n\nRequired\n\nFinding Elements\nfunc contains(Self.Element) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.\nfunc allSatisfy((Self.Element) async throws -> Bool) async rethrows -> Bool\nReturns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfy the given predicate.\nfunc first(where: (Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc min() async rethrows -> Self.Element?\nReturns the minimum element in an asynchronous sequence of comparable elements.\nAvailable when Element conforms to Comparable.\nfunc min(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nfunc max() async rethrows -> Self.Element?\nReturns the maximum element in an asynchronous sequence of comparable elements.\nAvailable when Element conforms to Comparable.\nfunc max(by: (Self.Element, Self.Element) async throws -> Bool) async rethrows -> Self.Element?\nReturns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.\nSelecting Elements\nfunc prefix(Int) -> AsyncPrefixSequence<Self>\nReturns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.\nstruct AsyncPrefixSequence\nAn asynchronous sequence, up to a specified maximum length, containing the initial elements of a base asynchronous sequence.\nAvailable when Base conforms to AsyncSequence.\nfunc prefix(while: (Self.Element) async -> Bool) rethrows -> AsyncPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.\nstruct AsyncPrefixWhileSequence\nAn asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy a given predicate.\nAvailable when Base conforms to AsyncSequence.\nfunc prefix(while: (Self.Element) async throws -> Bool) rethrows -> AsyncThrowingPrefixWhileSequence<Self>\nReturns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given error-throwing predicate.\nstruct AsyncThrowingPrefixWhileSequence\nAn asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given error-throwing predicate.\nAvailable when Base conforms to AsyncSequence.\nExcluding Elements\nfunc dropFirst(Int) -> AsyncDropFirstSequence<Self>\nOmits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nstruct AsyncDropFirstSequence\nAn asynchronous sequence which omits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.\nAvailable when Base conforms to AsyncSequence.\nfunc drop(while: (Self.Element) async -> Bool) -> AsyncDropWhileSequence<Self>\nOmits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.\nstruct AsyncDropWhileSequence\nAn asynchronous sequence which omits elements from the base sequence until a given closure returns false, after which it passes through all remaining elements.\nAvailable when Base conforms to AsyncSequence.\nfunc drop(while: (Self.Element) async throws -> Bool) -> AsyncThrowingDropWhileSequence<Self>\nOmits elements from the base sequence until a given error-throwing closure returns false, after which it passes through all remaining elements.\nstruct AsyncThrowingDropWhileSequence\nAn asynchronous sequence which omits elements from the base sequence until a given error-throwing closure returns false, after which it passes through all remaining elements.\nAvailable when Base conforms to AsyncSequence.\nfunc filter((Self.Element) async -> Bool) -> AsyncFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\nstruct AsyncFilterSequence\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy a given predicate.\nAvailable when Base conforms to AsyncSequence.\nfunc filter((Self.Element) async throws -> Bool) -> AsyncThrowingFilterSequence<Self>\nCreates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given error-throwing predicate.\nstruct AsyncThrowingFilterSequence\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given error-throwing predicate.\nAvailable when Base conforms to AsyncSequence.\nTransforming a Sequence\nfunc map<Transformed>((Self.Element) async -> Transformed) -> AsyncMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nstruct AsyncMapSequence\nAn asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.\nAvailable when Base conforms to AsyncSequence.\nfunc map<Transformed>((Self.Element) async throws -> Transformed) -> AsyncThrowingMapSequence<Self, Transformed>\nCreates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nstruct AsyncThrowingMapSequence\nAn asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.\nAvailable when Base conforms to AsyncSequence.\nfunc compactMap<ElementOfResult>((Self.Element) async -> ElementOfResult?) -> AsyncCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nstruct AsyncCompactMapSequence\nAn asynchronous sequence that maps a given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.\nAvailable when Base conforms to AsyncSequence.\nfunc compactMap<ElementOfResult>((Self.Element) async throws -> ElementOfResult?) -> AsyncThrowingCompactMapSequence<Self, ElementOfResult>\nCreates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nstruct AsyncThrowingCompactMapSequence\nAn asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.\nAvailable when Base conforms to AsyncSequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async -> SegmentOfResult) -> AsyncFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.\nstruct AsyncFlatMapSequence\nAn asynchronous sequence that concatenates the results of calling a given transformation with each element of this sequence.\nAvailable when Base conforms to AsyncSequence and SegmentOfResult conforms to AsyncSequence.\nfunc flatMap<SegmentOfResult>((Self.Element) async throws -> SegmentOfResult) -> AsyncThrowingFlatMapSequence<Self, SegmentOfResult>\nCreates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.\nstruct AsyncThrowingFlatMapSequence\nAn asynchronous sequence that concatenates the results of calling a given error-throwing transformation with each element of this sequence.\nAvailable when Base conforms to AsyncSequence and SegmentOfResult conforms to AsyncSequence.\nfunc reduce<Result>(Result, (Result, Self.Element) async throws -> Result) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) async throws -> Void) async rethrows -> Result\nReturns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.\nAdapting Textual Sequences\nvar characters: AsyncCharacterSequence<Self>\nA non-blocking sequence of Characters created by decoding the elements of self as UTF8.\nAvailable when Element is UInt8.\nstruct AsyncCharacterSequence\nAn asychronous sequence of characters.\nvar unicodeScalars: AsyncUnicodeScalarSequence<Self>\nA non-blocking sequence of UnicodeScalars created by decoding the elements of self as UTF8.\nAvailable when Element is UInt8.\nstruct AsyncUnicodeScalarSequence\nAn asychronous sequence of Unicode scalar values.\nvar lines: AsyncLineSequence<Self>\nA non-blocking sequence of newline-separated Strings created by decoding the elements of self as UTF8.\nAvailable when Element is UInt8.\nstruct AsyncLineSequence\nAn asychronous sequence of lines of text.\nRelationships\nConforming Types\nAsyncCompactMapSequence\nConforms when Base conforms to AsyncSequence.\nAsyncDropFirstSequence\nConforms when Base conforms to AsyncSequence.\nAsyncDropWhileSequence\nConforms when Base conforms to AsyncSequence.\nAsyncFilterSequence\nConforms when Base conforms to AsyncSequence.\nAsyncFlatMapSequence\nConforms when Base conforms to AsyncSequence and SegmentOfResult conforms to AsyncSequence.\nAsyncMapSequence\nConforms when Base conforms to AsyncSequence.\nAsyncPrefixSequence\nConforms when Base conforms to AsyncSequence.\nAsyncPrefixWhileSequence\nConforms when Base conforms to AsyncSequence.\nAsyncStream\nAsyncThrowingCompactMapSequence\nConforms when Base conforms to AsyncSequence.\nAsyncThrowingDropWhileSequence\nConforms when Base conforms to AsyncSequence.\nAsyncThrowingFilterSequence\nConforms when Base conforms to AsyncSequence.\nAsyncThrowingFlatMapSequence\nConforms when Base conforms to AsyncSequence and SegmentOfResult conforms to AsyncSequence.\nAsyncThrowingMapSequence\nConforms when Base conforms to AsyncSequence.\nAsyncThrowingPrefixWhileSequence\nConforms when Base conforms to AsyncSequence.\nAsyncThrowingStream\nConforms when Failure conforms to Error.\nTaskGroup\nConforms when ChildTaskResult conforms to Sendable.\nThrowingTaskGroup\nConforms when ChildTaskResult conforms to Sendable and Failure conforms to Error.\nSee Also\nAsynchronous Sequences\nstruct AsyncStream\nAn asynchronous sequence generated from a closure that calls a continuation to produce new elements.\nstruct AsyncThrowingStream\nAn asynchronous sequence generated from an error-throwing closure that calls a continuation to produce new elements.\nAvailable when Failure conforms to Error."
  },
  {
    "title": "Never | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Swift/Never",
    "html": "Overview\n\nUse Never as the return type when declaring a closure, function, or method that unconditionally throws an error, traps, or otherwise does not terminate.\n\nfunc crashAndBurn() -> Never {\n    fatalError(\"Something very, very bad happened\")\n}\n\nTopics\nDefault Implementations\nAppExtensionScene Implementations\nAppIntent Implementations\nAttachmentContent Implementations\nComparable Implementations\nDecodable Implementations\nEncodable Implementations\nEquatable Implementations\nHashable Implementations\nIdentifiable Implementations\nIntentResult Implementations\nParameterSummary Implementations\nPersistentlyIdentifiable Implementations\nSortComparator Implementations\nTransferRepresentation Implementations\nTransferable Implementations\n_IntentValue Implementations\nRelationships\nConforms To\nAccessibilityRotorContent\nAppExtensionScene\nAppIntent\nAttachmentContent\nAxisContent\nAxisMark\nChartContent\nCommands\nComparable\nCustomizableToolbarContent\nDecodable\nEncodable\nEquatable\nError\nGesture\nHashable\nIdentifiable\nImmersiveSpaceContent\nIntentResult\nKeyframes\nParameterSummary\nPersistentlyIdentifiable\nPlottable\nPrimitivePlottableProtocol\nScene\nSendable\nShapeStyle\nSortComparator\nTableColumnContent\nTableRowContent\nToolbarContent\nTransferRepresentation\nTransferable\nView\nWidgetConfiguration\nSee Also\nExiting a Program\nfunc fatalError(() -> String, file: StaticString, line: UInt) -> Never\nUnconditionally prints a given message and stops execution."
  },
  {
    "title": "Range | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Swift/Range",
    "html": "Overview\n\nYou create a Range instance by using the half-open range operator (..<).\n\nlet underFive = 0.0..<5.0\n\n\nYou can use a Range instance to quickly check if a value is contained in a particular range of values. For example:\n\nunderFive.contains(3.14)\n// true\nunderFive.contains(6.28)\n// false\nunderFive.contains(5.0)\n// false\n\n\nRange instances can represent an empty interval, unlike ClosedRange.\n\nlet empty = 0.0..<0.0\nempty.contains(0.0)\n// false\nempty.isEmpty\n// true\n\nUsing a Range as a Collection of Consecutive Values\n\nWhen a range uses integers as its lower and upper bounds, or any other type that conforms to the Strideable protocol with an integer stride, you can use that range in a for-in loop or with any sequence or collection method. The elements of the range are the consecutive values from its lower bound up to, but not including, its upper bound.\n\nfor n in 3..<5 {\n    print(n)\n}\n// Prints \"3\"\n// Prints \"4\"\n\n\nBecause floating-point types such as Float and Double are their own Stride types, they cannot be used as the bounds of a countable range. If you need to iterate over consecutive floating-point values, see the stride(from:to:by:) function.\n\nTopics\nCreating a Range\nCreate a new range using the half-open range operator (..<).\nstatic func ..< (Self, Self) -> Range<Self>\nReturns a half-open range that contains its lower bound but not its upper bound.\nConverting Ranges\nfunc relative<C>(to: C) -> Range<Bound>\nReturns the range of indices described by this range expression within the given collection.\nAvailable when Bound conforms to Comparable.\ninit?(NSRange, in: String)\nAvailable when Bound is String.Index.\ninit?<S>(NSRange, in: S)\nAvailable when Bound is String.Index.\nInspecting a Range\nvar isEmpty: Bool\nA Boolean value indicating whether the range contains no elements.\nlet lowerBound: Bound\nThe range’s lower bound.\nlet upperBound: Bound\nThe range’s upper bound.\nChecking for Containment\nfunc contains(Bound) -> Bool\nReturns a Boolean value indicating whether the given element is contained within the range.\nstatic func ~= (Self, Self.Bound) -> Bool\nReturns a Boolean value indicating whether a value is included in a range.\nClamping a Range\nfunc clamped(to: Range<Bound>) -> Range<Bound>\nReturns a copy of this range clamped to the given limiting range.\nAvailable when Bound conforms to Comparable.\nWorking with Foundation Ranges\ninit?(NSRange)\nAvailable when Bound is Int.\ninit?(NSRange)\nAvailable when Bound conforms to BinaryInteger.\nComparing Ranges\nstatic func == (Range<Bound>, Range<Bound>) -> Bool\nReturns a Boolean value indicating whether two ranges are equal.\nAvailable when Bound conforms to Comparable.\nstatic func != (Self, Self) -> Bool\nfunc overlaps(Range<Bound>) -> Bool\nReturns a Boolean value indicating whether this range and the given range contain an element in common.\nAvailable when Bound conforms to Comparable.\nfunc overlaps(ClosedRange<Bound>) -> Bool\nAvailable when Bound conforms to Comparable.\nManipulating Indices\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher.\nAvailable when Bound conforms to Comparable and Hashable.\nDescribing a Range\nvar description: String\nA textual representation of the range.\nAvailable when Bound conforms to Comparable.\nvar debugDescription: String\nA textual representation of the range, suitable for debugging.\nAvailable when Bound conforms to Comparable.\nvar customMirror: Mirror\nThe custom mirror for this instance.\nAvailable when Bound conforms to Comparable.\nEncoding and Decoding a Range\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder.\nAvailable when Bound conforms to Comparable and Encodable.\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder.\nAvailable when Bound conforms to Comparable and Decodable.\nInfrequently Used Functionality\ninit(uncheckedBounds: (lower: Bound, upper: Bound))\nCreates an instance with the given bounds.\nvar hashValue: Int\nThe hash value.\nAvailable when Bound conforms to Comparable and Hashable.\nInitializers\ninit(Range<Bound>)\nNow that Range is conditionally a collection when Bound: Strideable, CountableRange is no longer needed. This is a deprecated initializer for any remaining uses of Range(countableRange).\nAvailable when Bound conforms to Strideable and Bound.Stride conforms to SignedInteger.\ninit(ClosedRange<Bound>)\nCreates an instance equivalent to the given ClosedRange.\nAvailable when Bound conforms to Strideable and Bound.Stride conforms to SignedInteger.\ninit?<S>(NSRange, in: S)\nAvailable when Bound is AttributedString.Index.\ninit?<R, S>(R, in: S)\nAvailable when Bound is AttributedString.Index.\ninit?<R, S>(R, in: S)\nAvailable when Bound is String.Index.\ninit?<S>(AttributedString.MarkdownSourcePosition, in: S)\nAvailable when Bound is String.Index.\nInstance Methods\nfunc formatted() -> String\nFormats the date range as an interval.\nAvailable when Bound is Date.\nfunc formatted<S>(S) -> S.FormatOutput\nFormats the date range using the specified style.\nAvailable when Bound is Date.\nfunc formatted(date: Date.IntervalFormatStyle.DateStyle, time: Date.IntervalFormatStyle.TimeStyle) -> String\nFormats the date range using the specified date and time format styles.\nAvailable when Bound is Date.\nType Methods\nstatic func upToNextMajor(from: Version) -> Range<Bound>\nReturns a requirement for a version range, starting at the given minimum version and going up to the next major version. This is the recommended version requirement.\nAvailable when Bound conforms to Comparable.\nstatic func upToNextMinor(from: Version) -> Range<Bound>\nReturns a requirement for a version range, starting at the given minimum version and going up to the next minor version.\nAvailable when Bound conforms to Comparable.\nDefault Implementations\nBidirectionalCollection Implementations\nCollection Implementations\nCustomDebugStringConvertible Implementations\nCustomReflectable Implementations\nCustomStringConvertible Implementations\nDecodable Implementations\nEncodable Implementations\nEquatable Implementations\nHashable Implementations\nRangeExpression Implementations\nSequence Implementations\nRelationships\nConforms To\nBidirectionalCollection\nConforms when Bound conforms to Strideable and Bound.Stride conforms to SignedInteger.\nCollection\nConforms when Bound conforms to Strideable and Bound.Stride conforms to SignedInteger.\nCustomDebugStringConvertible\nConforms when Bound conforms to Comparable.\nCustomReflectable\nConforms when Bound conforms to Comparable.\nCustomStringConvertible\nConforms when Bound conforms to Comparable.\nDecodable\nConforms when Bound conforms to Comparable and Decodable.\nEncodable\nConforms when Bound conforms to Comparable and Encodable.\nEquatable\nConforms when Bound conforms to Comparable.\nHashable\nConforms when Bound conforms to Comparable and Hashable.\nRandomAccessCollection\nConforms when Bound conforms to Strideable and Bound.Stride conforms to SignedInteger.\nRangeExpression\nConforms when Bound conforms to Comparable.\nSendable\nConforms when Bound conforms to Comparable and Sendable.\nSequence\nConforms when Bound conforms to Strideable and Bound.Stride conforms to SignedInteger.\nSee Also\nRanges\nstatic func ..< (Self, Self) -> Range<Self>\nReturns a half-open range that contains its lower bound but not its upper bound.\nstatic func ... (Self, Self) -> ClosedRange<Self>\nReturns a closed range that contains both of its bounds.\nstruct ClosedRange\nAn interval from a lower bound up to, and including, an upper bound."
  },
  {
    "title": "Decodable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Swift/Decodable",
    "html": "Topics\nInitializers\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder.\n\nRequired Default implementation provided.\n\nRelationships\nInherited By\nSIMD\nConforming Types\nArray\nConforms when Element conforms to Decodable.\nBool\nClosedRange\nConforms when Bound conforms to Comparable and Decodable.\nCollectionDifference\nConforms when ChangeElement conforms to Decodable and Encodable.\nCollectionDifference.Change\nConforms when ChangeElement conforms to Decodable and Encodable.\nContiguousArray\nConforms when Element conforms to Decodable.\nContinuousClock.Instant\nDictionary\nConforms when Key conforms to Decodable, Key conforms to Hashable, and Value conforms to Decodable.\nDouble\nDuration\nDuration.TimeFormatStyle\nDuration.TimeFormatStyle.Attributed\nDuration.TimeFormatStyle.Pattern\nDuration.UnitsFormatStyle\nDuration.UnitsFormatStyle.Attributed\nDuration.UnitsFormatStyle.FractionalPartDisplayStrategy\nDuration.UnitsFormatStyle.Unit\nDuration.UnitsFormatStyle.UnitWidth\nDuration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy\nFloat\nFloat16\nInt\nInt16\nInt32\nInt64\nInt8\nLocalTestingActorID\nNever\nObservationRegistrar\nOptional\nConforms when Wrapped conforms to Decodable.\nPartialRangeFrom\nConforms when Bound conforms to Comparable and Decodable.\nPartialRangeThrough\nConforms when Bound conforms to Comparable and Decodable.\nPartialRangeUpTo\nConforms when Bound conforms to Comparable and Decodable.\nRange\nConforms when Bound conforms to Comparable and Decodable.\nSIMD16\nSIMD2\nSIMD3\nSIMD32\nSIMD4\nSIMD64\nSIMD8\nSIMDMask\nSet\nConforms when Element conforms to Decodable and Hashable.\nString\nString.Comparator\nString.LocalizationValue\nString.LocalizationValue.Placeholder\nString.StandardComparator\nSuspendingClock.Instant\nTaskPriority\nUInt\nUInt16\nUInt32\nUInt64\nUInt8\nSee Also\nCustom Encoding and Decoding\ntypealias Codable\nA type that can convert itself into and out of an external representation.\nprotocol Encodable\nA type that can encode itself to an external representation.\nprotocol CodingKey\nA type that can be used as a key for encoding and decoding.\nprotocol CodingKeyRepresentable\nA type that can be converted to and from a coding key.\nstruct CodingUserInfoKey\nA user-defined key for providing context during encoding and decoding."
  },
  {
    "title": "Error | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Swift/Error",
    "html": "Overview\n\nAny type that declares conformance to the Error protocol can be used to represent an error in Swift’s error handling system. Because the Error protocol has no requirements of its own, you can declare conformance on any custom type you create.\n\nUsing Enumerations as Errors\n\nSwift’s enumerations are well suited to represent simple errors. Create an enumeration that conforms to the Error protocol with a case for each possible error. If there are additional details about the error that could be helpful for recovery, use associated values to include that information.\n\nThe following example shows an IntParsingError enumeration that captures two different kinds of errors that can occur when parsing an integer from a string: overflow, where the value represented by the string is too large for the integer data type, and invalid input, where nonnumeric characters are found within the input.\n\nenum IntParsingError: Error {\n    case overflow\n    case invalidInput(Character)\n}\n\n\nThe invalidInput case includes the invalid character as an associated value.\n\nThe next code sample shows a possible extension to the Int type that parses the integer value of a String instance, throwing an error when there is a problem during parsing.\n\nextension Int {\n    init(validating input: String) throws {\n        // ...\n        let c = _nextCharacter(from: input)\n        if !_isValid(c) {\n            throw IntParsingError.invalidInput(c)\n        }\n        // ...\n    }\n}\n\n\nWhen calling the new Int initializer within a do statement, you can use pattern matching to match specific cases of your custom error type and access their associated values, as in the example below.\n\ndo {\n    let price = try Int(validating: \"$100\")\n} catch IntParsingError.invalidInput(let invalid) {\n    print(\"Invalid character: '\\(invalid)'\")\n} catch IntParsingError.overflow {\n    print(\"Overflow error\")\n} catch {\n    print(\"Other error\")\n}\n// Prints \"Invalid character: '$'\"\n\nIncluding More Data in Errors\n\nSometimes you may want different error states to include the same common data, such as the position in a file or some of your application’s state. When you do, use a structure to represent errors. The following example uses a structure to represent an error when parsing an XML document, including the line and column numbers where the error occurred:\n\nstruct XMLParsingError: Error {\n    enum ErrorKind {\n        case invalidCharacter\n        case mismatchedTag\n        case internalError\n    }\n\n\n    let line: Int\n    let column: Int\n    let kind: ErrorKind\n}\n\n\nfunc parse(_ source: String) throws -> XMLDoc {\n    // ...\n    throw XMLParsingError(line: 19, column: 5, kind: .mismatchedTag)\n    // ...\n}\n\n\nOnce again, use pattern matching to conditionally catch errors. Here’s how you can catch any XMLParsingError errors thrown by the parse(_:) function:\n\ndo {\n    let xmlDoc = try parse(myXMLData)\n} catch let e as XMLParsingError {\n    print(\"Parsing error: \\(e.kind) [\\(e.line):\\(e.column)]\")\n} catch {\n    print(\"Other error: \\(error)\")\n}\n// Prints \"Parsing error: mismatchedTag [19:5]\"\n\nTopics\nDescribing an Error\nvar localizedDescription: String\nRetrieve the localized description for this error.\nRelationships\nInherits From\nSendable\nInherited By\nDistributedActorSystemError\nConforming Types\nCancellationError\nDecodingError\nDistributedActorCodingError\nEncodingError\nExecuteDistributedTargetError\nLocalTestingDistributedActorSystemError\nNever\nSee Also\nErrors\nenum Result\nA value that represents either a success or a failure, including an associated value in each case."
  },
  {
    "title": "Codable | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/Swift/Codable",
    "html": "Discussion\n\nCodable is a type alias for the Encodable and Decodable protocols. When you use Codable as a type or a generic constraint, it matches any type that conforms to both protocols.\n\nSee Also\nCustom Encoding and Decoding\nprotocol Encodable\nA type that can encode itself to an external representation.\nprotocol Decodable\nA type that can decode itself from an external representation.\nprotocol CodingKey\nA type that can be used as a key for encoding and decoding.\nprotocol CodingKeyRepresentable\nA type that can be converted to and from a coding key.\nstruct CodingUserInfoKey\nA user-defined key for providing context during encoding and decoding."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "LazyDropWhileSequence.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/distance(from:to:)-9uku",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "LazyDropWhileSequence.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/index(_:offsetby:limitedby:)-k9zq",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/split(separator:maxsplits:omittingemptysubsequences:)-16h0n",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/subscript(_:)-6z76q",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nOverview\n\nThe following example accesses an element of an array through its subscript to print its value:\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nprint(streets[1])\n// Prints \"Bryant\"\n\n\nYou can subscript a collection with any valid index other than the collection’s end index. The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/filter(_:)",
    "html": "Discussion\n\nNote\n\nThe elements of the result are computed on-demand, as the result is used. No buffering storage is allocated and each traversal step invokes predicate on one or more underlying elements."
  },
  {
    "title": "utf8CString | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf8cstring",
    "html": "Discussion\n\nTo access the underlying memory, invoke withUnsafeBufferPointer on the array.\n\nlet s = \"Hello!\"\nlet bytes = s.utf8CString\nprint(bytes)\n// Prints \"[72, 101, 108, 108, 111, 33, 0]\"\n\n\nbytes.withUnsafeBufferPointer { ptr in\n    print(strlen(ptr.baseAddress!))\n}\n// Prints \"6\"\n\nSee Also\nGetting C Strings\nfunc withCString<Result>((UnsafePointer<Int8>) throws -> Result) rethrows -> Result\nCalls the given closure with a pointer to the contents of the string, represented as a null-terminated sequence of UTF-8 code units.\nfunc withCString<Result, TargetEncoding>(encodedAs: TargetEncoding.Type, (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result\nCalls the given closure with a pointer to the contents of the string, represented as a null-terminated sequence of code units."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/map(_:)-9dpwp",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(_:)-2t931",
    "html": "Parameters\nunicodeScalars\n\nA collection of Unicode scalar values.\n\nDiscussion\n\nYou can use this initializer to create a new string from a slice of another string’s unicodeScalars view.\n\nlet picnicGuest = \"Deserving porcupine\"\nif let i = picnicGuest.unicodeScalars.firstIndex(of: \" \") {\n    let adjective = String(picnicGuest.unicodeScalars[..<i])\n    print(adjective)\n}\n// Prints \"Deserving\"\n\n\nThe adjective constant is created by calling this initializer with a slice of the picnicGuest.unicodeScalars view.\n\nSee Also\nWorking with String Views\nvar unicodeScalars: String.UnicodeScalarView\nThe string’s value represented as a collection of Unicode scalar values.\ninit(Substring.UnicodeScalarView)\nCreates a String having the given content.\nvar utf16: String.UTF16View\nA UTF-16 encoding of self.\ninit(String.UTF16View)\nCreates a string corresponding to the given sequence of UTF-16 code units.\ninit?(Substring.UTF16View)\nCreates a String having the given content.\nvar utf8: String.UTF8View\nA UTF-8 encoding of self.\ninit(String.UTF8View)\nCreates a string corresponding to the given sequence of UTF-8 code units.\ninit?(Substring.UTF8View)\nCreates a String having the given content."
  },
  {
    "title": "isContiguousUTF8 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/iscontiguousutf8",
    "html": "Discussion\n\nContiguous strings always operate in O(1) time for withUTF8 and always give a result for String.UTF8View.withContiguousStorageIfAvailable. Contiguous strings also benefit from fast-paths and better optimizations.\n\nSee Also\nWorking with Encodings\nstatic var availableStringEncodings: [String.Encoding]\nAn array of the encodings that strings support in the application’s environment.\nstatic var defaultCStringEncoding: String.Encoding\nThe C-string encoding assumed for any method accepting a C string as an argument.\nstatic func localizedName(of: String.Encoding) -> String\nReturns a human-readable string giving the name of the specified encoding.\nfunc makeContiguousUTF8()\nIf this string is not contiguous, make it so. If this mutates the string, it will invalidate any pre-existing indices.\nfunc withUTF8<R>((UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R\nRuns body over the content of this string in contiguous memory. If this string is not contiguous, this will first make it contiguous, which will also speed up subsequent access. If this mutates the string, it will invalidate any pre-existing indices."
  },
  {
    "title": "withUTF8(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/withutf8(_:)",
    "html": "Discussion\n\nNote that it is unsafe to escape the pointer provided to body. For example, strings of up to 15 UTF-8 code units in length may be represented in a small-string representation, and thus will be spilled into temporary stack space which is invalid after withUTF8 finishes execution.\n\nComplexity: O(n) if non-contiguous, O(1) if already contiguous\n\nSee Also\nWorking with Encodings\nstatic var availableStringEncodings: [String.Encoding]\nAn array of the encodings that strings support in the application’s environment.\nstatic var defaultCStringEncoding: String.Encoding\nThe C-string encoding assumed for any method accepting a C string as an argument.\nstatic func localizedName(of: String.Encoding) -> String\nReturns a human-readable string giving the name of the specified encoding.\nvar isContiguousUTF8: Bool\nReturns whether this string is capable of providing access to validly-encoded UTF-8 contents in contiguous memory in O(1) time.\nfunc makeContiguousUTF8()\nIf this string is not contiguous, make it so. If this mutates the string, it will invalidate any pre-existing indices."
  },
  {
    "title": "utf16 | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/utf16",
    "html": "See Also\nWorking with String Views\nvar unicodeScalars: String.UnicodeScalarView\nThe string’s value represented as a collection of Unicode scalar values.\ninit(String.UnicodeScalarView)\nCreates a string corresponding to the given collection of Unicode scalars.\ninit(Substring.UnicodeScalarView)\nCreates a String having the given content.\ninit(String.UTF16View)\nCreates a string corresponding to the given sequence of UTF-16 code units.\ninit?(Substring.UTF16View)\nCreates a String having the given content.\nvar utf8: String.UTF8View\nA UTF-8 encoding of self.\ninit(String.UTF8View)\nCreates a string corresponding to the given sequence of UTF-8 code units.\ninit?(Substring.UTF8View)\nCreates a String having the given content."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(_:)-wbcx",
    "html": "See Also\nWorking with String Views\nvar unicodeScalars: String.UnicodeScalarView\nThe string’s value represented as a collection of Unicode scalar values.\ninit(String.UnicodeScalarView)\nCreates a string corresponding to the given collection of Unicode scalars.\ninit(Substring.UnicodeScalarView)\nCreates a String having the given content.\nvar utf16: String.UTF16View\nA UTF-16 encoding of self.\ninit?(Substring.UTF16View)\nCreates a String having the given content.\nvar utf8: String.UTF8View\nA UTF-8 encoding of self.\ninit(String.UTF8View)\nCreates a string corresponding to the given sequence of UTF-8 code units.\ninit?(Substring.UTF8View)\nCreates a String having the given content."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(_:)-expd",
    "html": "Discussion\n\nIf codeUnits is an ill-formed code unit sequence, the result is nil.\n\nComplexity\n\nO(N), where N is the length of the resulting String’s UTF-16.\n\nSee Also\nWorking with String Views\nvar unicodeScalars: String.UnicodeScalarView\nThe string’s value represented as a collection of Unicode scalar values.\ninit(String.UnicodeScalarView)\nCreates a string corresponding to the given collection of Unicode scalars.\ninit(Substring.UnicodeScalarView)\nCreates a String having the given content.\nvar utf16: String.UTF16View\nA UTF-16 encoding of self.\ninit(String.UTF16View)\nCreates a string corresponding to the given sequence of UTF-16 code units.\nvar utf8: String.UTF8View\nA UTF-8 encoding of self.\ninit(String.UTF8View)\nCreates a string corresponding to the given sequence of UTF-8 code units.\ninit?(Substring.UTF8View)\nCreates a String having the given content."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/subscript(_:)-jkb6",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/split(separator:maxsplits:omittingemptysubsequences:)-259d7",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/iterator/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil."
  },
  {
    "title": "~(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/~(_:)-6mr7y",
    "html": "Discussion\n\nThe bitwise NOT operator (~) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are 1 in the argument are 0 in the result, and bits that are 0 in the argument are 1 in the result. This is equivalent to the inverse of a set. For example:\n\nlet x: UInt8 = 5        // 0b00000101\nlet notX = ~x           // 0b11111010\n\n\nPerforming a bitwise NOT operation on 0 returns a value with every bit set to 1.\n\nlet allOnes = ~UInt8.min   // 0b11111111\n\n\nComplexity\n\nO(1)."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the resulting distance.\n\nSee Also\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(n), where n is the absolute value of distance.\n\nSee Also\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i.\n\nSee Also\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/endindex",
    "html": "Discussion\n\nIn an empty string, endIndex is equal to startIndex.\n\nSee Also\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(n), where n is the absolute value of distance.\n\nSee Also\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nSee Also\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)\n\nSee Also\nReordering a String’s Characters\nfunc sorted() -> [Self.Element]\nReturns the elements of the sequence, sorted.\nAvailable when Element conforms to Comparable.\nfunc sorted(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc shuffled() -> [Self.Element]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [Self.Element]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness."
  },
  {
    "title": "entityIdentifierString | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/entityidentifierstring",
    "html": "Discussion\n\nNote: Due to system-imposed limitations, the length of this value can not exceed 512 characters!"
  },
  {
    "title": "String.RegexOutput | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/regexoutput",
    "html": "Discussion\n\nA Regex instance’s output type depends on whether the Regex has captures and how it is created.\n\nA Regex created from a string using the init(_:) initializer has an output type of AnyRegexOutput, whether it has captures or not.\n\nA Regex without captures created from a regex literal, the init(_:as:) initializer, or a RegexBuilder closure has a Substring output type, where the substring is the portion of the string that was matched.\n\nA Regex with captures created from a regex literal or the init(_:as:) initializer has a tuple of substrings as its output type. The first component of the tuple is the full portion of the string that was matched, with the remaining components holding the captures."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)\n\nSee Also\nIterating over a String’s Characters\nfunc forEach((Self.Element) throws -> Void) rethrows\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc makeIterator() -> String.Iterator\nReturns an iterator over the elements of the collection.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection."
  },
  {
    "title": "init(bitPattern:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/init(bitpattern:)",
    "html": "Parameters\nbitPattern\n\nThe integer encoding of a Double instance.\n\nDiscussion\n\nThe value passed as bitPattern is interpreted in the binary interchange format defined by the IEEE 754 specification.\n\nSee Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawSignificand\nA type that represents the encoded significand of a value.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "IteratorProtocol Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/iterator/iteratorprotocol-implementations",
    "html": "Topics\nInstance Methods\nfunc next() -> PrefixSequence<Base>.Iterator.Element?\nAdvances to the next element and returns it, or nil if no next element exists.\nAvailable when Base conforms to Sequence.\nType Aliases\ntypealias Element\nThe type of element traversed by the iterator.\nAvailable when Base conforms to Sequence."
  },
  {
    "title": "init(nan:signaling:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/init(nan:signaling:)",
    "html": "Parameters\npayload\n\nThe payload to use for the new NaN value.\n\nsignaling\n\nPass true to create a signaling NaN or false to create a quiet NaN.\n\nDiscussion\n\nNaN values compare not equal to every value, including themselves. Most operations with a NaN operand produce a NaN result. Don’t use the equal-to operator (==) to test whether a value is NaN. Instead, use the value’s isNaN property.\n\nlet x = Double(nan: 0, signaling: false)\nprint(x == .nan)\n// Prints \"false\"\nprint(x.isNaN)\n// Prints \"true\"\n\nSee Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawSignificand\nA type that represents the encoded significand of a value.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "bitPattern | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/bitpattern",
    "html": "Discussion\n\nThe bit pattern matches the binary interchange format defined by the IEEE 754 specification.\n\nSee Also\nWorking with Binary Representation\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawSignificand\nA type that represents the encoded significand of a value.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "IteratorProtocol Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/iterator/iteratorprotocol-implementations",
    "html": "Topics\nInstance Methods\nfunc next() -> DropWhileSequence<Base>.Iterator.Element?\nAdvances to the next element and returns it, or nil if no next element exists.\nAvailable when Base conforms to Sequence.\nType Aliases\ntypealias Element\nThe type of element traversed by the iterator.\nAvailable when Base conforms to Sequence."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/endindex",
    "html": "Discussion\n\nWhen you need a range that includes the last element of a collection, use the half-open range operator (..<) with endIndex. The ..< operator creates a range that doesn’t include the upper bound, so it’s always safe to use with endIndex. For example:\n\nlet numbers = [10, 20, 30, 40, 50]\nif let index = numbers.firstIndex(of: 30) {\n    print(numbers[index ..< numbers.endIndex])\n}\n// Prints \"[30, 40, 50]\"\n\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/startindex",
    "html": "Discussion\n\nIf the collection is empty, startIndex is equal to endIndex."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/map(_:)-tngw",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "LazyDropWhileSequence.Elements | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/elements-swift.typealias",
    "html": "Discussion\n\nSee also: elements"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false otherwise. Once predicate returns false it will not be called again."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/flatmap(_:)-6szox",
    "html": "Discussion\n\nUse this method to receive a single-level sequence when your transformation produces a sequence or collection for each element. Calling flatMap(_:) on a sequence s is equivalent to calling s.map(transform).joined().\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength.\n\nSee Also\nGetting Substrings\nsubscript(Range<String.Index>) -> Substring\nAccesses a contiguous subrange of the collection’s elements.\nsubscript<R>(R) -> Self.SubSequence\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Self.SubSequence\nfunc prefix(Int) -> Self.SubSequence\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nSplitting a String\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (Self.Element) throws -> Bool) rethrows -> [Self.SubSequence]\nReturns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate."
  },
  {
    "title": "String.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/map(_:)-87c4v",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\nSee Also\nTransforming a String’s Characters\nfunc compactMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc flatMap<SegmentOfResult>((Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc flatMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nfunc reduce<Result>(Result, (Result, Self.Element) throws -> Result) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) throws -> ()) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nvar lazy: LazySequence<Self>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily."
  },
  {
    "title": "makeIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/makeiterator()",
    "html": "See Also\nIterating over a String’s Characters\nfunc forEach((Self.Element) throws -> Void) rethrows\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc enumerated() -> EnumeratedSequence<Self>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the collection."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nSee Also\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance.\n\nSee Also\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance.\n\nSee Also\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices.\nvar indices: DefaultIndices<Self>\nThe indices that are valid for subscripting the collection, in ascending order.\nAvailable when Indices is DefaultIndices<Self>."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nSee Also\nIterating over a String’s Characters\nfunc forEach((Self.Element) throws -> Void) rethrows\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc enumerated() -> EnumeratedSequence<Self>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc makeIterator() -> String.Iterator\nReturns an iterator over the elements of the collection."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n\nSee Also\nManipulating Indices\nvar startIndex: String.Index\nThe position of the first character in a nonempty string.\nvar endIndex: String.Index\nA string’s “past the end” position—that is, the position one greater than the last valid subscript argument.\nfunc index(after: String.Index) -> String.Index\nReturns the position immediately after the given index.\nfunc formIndex(after: inout Self.Index)\nReplaces the given index with its successor.\nfunc index(before: String.Index) -> String.Index\nReturns the position immediately before the given index.\nfunc formIndex(before: inout Self.Index)\nReplaces the given index with its predecessor.\nfunc index(String.Index, offsetBy: Int) -> String.Index\nReturns an index that is the specified distance from the given index.\nfunc index(String.Index, offsetBy: Int, limitedBy: String.Index) -> String.Index?\nReturns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.\nfunc formIndex(inout Self.Index, offsetBy: Int)\nOffsets the given index by the specified distance.\nfunc formIndex(inout Self.Index, offsetBy: Int, limitedBy: Self.Index) -> Bool\nOffsets the given index by the specified distance, or so that it equals the given limiting index.\nfunc distance(from: String.Index, to: String.Index) -> Int\nReturns the distance between two indices."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/'...(_:)-4mm4o",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN).\n\nSee Also\nCreating a Range Expression\nstatic func ... (Self, Self) -> ClosedRange<Self>\nReturns a closed range that contains both of its bounds.\nstatic func ... (Self) -> PartialRangeFrom<Self>\nReturns a partial range extending upward from a lower bound."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/'...(_:)-6ct5g",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN).\n\nSee Also\nCreating a Range Expression\nstatic func ... (Self, Self) -> ClosedRange<Self>\nReturns a closed range that contains both of its bounds.\nstatic func ... (Self) -> PartialRangeThrough<Self>\nReturns a partial range up to, and including, its upper bound."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/_(_:_:)-24u5x",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/_(_:_:)-6o7qv",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/_=(_:_:)-5y22v",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format.\n\nSee Also\nEncoding and Decoding\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/_=(_:_:)-8lyim",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/_(_:_:)-1incq",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/_=(_:_:)-nd86",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "String.StringInterpolation | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/stringinterpolation",
    "html": "Discussion\n\nThe StringLiteralType of an interpolation type must match the StringLiteralType of the conforming type."
  },
  {
    "title": "String.StringLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/stringliteraltype",
    "html": "Discussion\n\nValid types for StringLiteralType are String and StaticString."
  },
  {
    "title": "String.ExtendedGraphemeClusterLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/extendedgraphemeclusterliteraltype",
    "html": "Discussion\n\nValid types for ExtendedGraphemeClusterLiteralType are Character, String, and StaticString."
  },
  {
    "title": "init(stringInterpolation:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(stringinterpolation:)-62d9",
    "html": "Discussion\n\nDon’t call this initializer directly. It’s used by the compiler when you create a string using string interpolation. Instead, use string interpolation to create a new string by including values, literals, variables, or expressions enclosed in parentheses, prefixed by a backslash (\\(…)).\n\nlet price = 2\nlet number = 3\nlet message = \"\"\"\n              If one cookie costs \\(price) dollars, \\\n              \\(number) cookies cost \\(price * number) dollars.\n              \"\"\"\n// message == \"If one cookie costs 2 dollars, 3 cookies cost 6 dollars.\"\n"
  },
  {
    "title": "init(repeating:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(repeating:count:)-5y5em",
    "html": "Parameters\nrepeatedValue\n\nThe element to repeat.\n\ncount\n\nThe number of times to repeat the value passed in the repeating parameter. count must be zero or greater.\n\nDiscussion\n\nHere’s an example of creating an array initialized with five strings containing the letter Z.\n\nlet fiveZs = Array(repeating: \"Z\", count: 5)\nprint(fiveZs)\n// Prints \"[\"Z\", \"Z\", \"Z\", \"Z\", \"Z\"]\"\n"
  },
  {
    "title": "removeAll(keepingCapacity:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/removeall(keepingcapacity:)-6xw7h",
    "html": "Parameters\nkeepCapacity\n\nPass true to request that the collection avoid releasing its storage. Retaining the collection’s storage can be a useful optimization when you’re planning to grow the collection again. The default value is false.\n\nDiscussion\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "append(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/append(_:)-1re5n",
    "html": "Parameters\nnewElement\n\nThe element to append to the collection.\n\nDiscussion\n\nIf the collection does not have sufficient capacity for another element, additional storage is allocated before appending newElement. The following example adds a new number to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(100)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 100]\"\n\n\nComplexity\n\nO(1) on average, over many calls to append(_:) on the same collection."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/replacesubrange(_:with:)-3hkd6",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(from:)-qki5",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid.\n\nSee Also\nEncoding and Decoding\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder."
  },
  {
    "title": "reserveCapacity(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/reservecapacity(_:)-8lw57",
    "html": "Parameters\nn\n\nThe requested number of elements to store.\n\nDiscussion\n\nIf you will be adding a known number of elements to a collection, use this method to avoid multiple reallocations. A type that conforms to RangeReplaceableCollection can choose how to respond when this method is called. Depending on the type, it may make sense to allocate more or less storage than requested or to take no action at all."
  },
  {
    "title": "availableStringEncodings | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/availablestringencodings",
    "html": "See Also\nWorking with Encodings\nstatic var defaultCStringEncoding: String.Encoding\nThe C-string encoding assumed for any method accepting a C string as an argument.\nstatic func localizedName(of: String.Encoding) -> String\nReturns a human-readable string giving the name of the specified encoding.\nvar isContiguousUTF8: Bool\nReturns whether this string is capable of providing access to validly-encoded UTF-8 contents in contiguous memory in O(1) time.\nfunc makeContiguousUTF8()\nIf this string is not contiguous, make it so. If this mutates the string, it will invalidate any pre-existing indices.\nfunc withUTF8<R>((UnsafeBufferPointer<UInt8>) throws -> R) rethrows -> R\nRuns body over the content of this string in contiguous memory. If this string is not contiguous, this will first make it contiguous, which will also speed up subsequent access. If this mutates the string, it will invalidate any pre-existing indices."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift.\n\nSee Also\nGetting Characters and Bytes\nsubscript(String.Index) -> Character\nAccesses the character at the given position.\nvar first: Self.Element?\nThe first element of the collection.\nvar last: Self.Element?\nThe last element of the collection.\nfunc randomElement() -> Self.Element?\nReturns a random element of the collection."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other.\n\nSee Also\nComparing Characters\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (Self.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc starts<PossiblePrefix>(with: PossiblePrefix) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.\nAvailable when Element conforms to Equatable.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (Self.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.\nAvailable when Element conforms to Comparable.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other.\n\nSee Also\nComparing Characters\nfunc elementsEqual<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.\nAvailable when Element conforms to Equatable.\nfunc starts<PossiblePrefix>(with: PossiblePrefix) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.\nAvailable when Element conforms to Equatable.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (Self.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.\nAvailable when Element conforms to Comparable.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/subscript(_:)-7qiik",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/compactmap(_:)-9ksui",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/iterator/next()",
    "html": "Return Value\n\nThe next element in the underlying sequence, if a next element exists; otherwise, nil.\n\nDiscussion\n\nRepeatedly calling this method returns, in order, all the elements of the underlying sequence. As soon as the sequence has run out of elements, all subsequent calls return nil.\n\nYou must not call this method if any other copy of this iterator has been advanced with a call to its next() method.\n\nThe following example shows how an iterator can be used explicitly to emulate a for-in loop. First, retrieve a sequence’s iterator, and then call the iterator’s next() method until it returns nil.\n\nlet numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\n\n\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints \"2\"\n// Prints \"3\"\n// Prints \"5\"\n// Prints \"7\"\n"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "&(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/binaryinteger/&(_:_:)-685zl",
    "html": "Parameters\nlhs\n\nAn integer value.\n\nrhs\n\nAnother integer value.\n\nDiscussion\n\nA bitwise AND operation results in a value that has each bit set to 1 where both of its arguments have that bit set to 1. For example:\n\nlet x: UInt8 = 5          // 0b00000101\nlet y: UInt8 = 14         // 0b00001110\nlet z = x & y             // 0b00000100\n// z == 4\n"
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "Substring.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "range | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/element/range",
    "html": "Discussion\n\nIf nothing was captured, range is nil."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix.\n\nSee Also\nComparing Characters\nfunc elementsEqual<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.\nAvailable when Element conforms to Equatable.\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (Self.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc starts<PossiblePrefix>(with: PossiblePrefix) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.\nAvailable when Element conforms to Equatable.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.\nAvailable when Element conforms to Comparable.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix.\n\nSee Also\nComparing Characters\nfunc elementsEqual<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.\nAvailable when Element conforms to Equatable.\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (Self.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (Self.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.\nAvailable when Element conforms to Comparable.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other.\n\nSee Also\nComparing Characters\nfunc elementsEqual<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.\nAvailable when Element conforms to Equatable.\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (Self.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc starts<PossiblePrefix>(with: PossiblePrefix) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.\nAvailable when Element conforms to Equatable.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (Self.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.\nAvailable when Element conforms to Comparable."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other.\n\nSee Also\nComparing Characters\nfunc elementsEqual<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.\nAvailable when Element conforms to Equatable.\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (Self.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc starts<PossiblePrefix>(with: PossiblePrefix) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.\nAvailable when Element conforms to Equatable.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (Self.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements."
  },
  {
    "title": "hasPrefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/hasprefix(_:)",
    "html": "See Also\nFinding Substrings\nfunc hasSuffix(String) -> Bool"
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements.\n\nSee Also\nCreating and Applying Differences\nfunc applying(CollectionDifference<Self.Element>) -> Self?\nApplies the given difference to this collection.\nfunc difference<C>(from: C) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection.\nAvailable when Element conforms to Equatable."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nSee Also\nFinding Characters\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "hasSuffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/hassuffix(_:)",
    "html": "See Also\nFinding Substrings\nfunc hasPrefix(String) -> Bool"
  },
  {
    "title": "max(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/max(_:_:)",
    "html": "See Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)\n\nSee Also\nGetting Substrings\nsubscript(Range<String.Index>) -> Substring\nAccesses a contiguous subrange of the collection’s elements.\nsubscript<R>(R) -> Self.SubSequence\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Self.SubSequence\nfunc prefix(Int) -> Self.SubSequence\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Self.SubSequence\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/subscript(_:)-4al9c",
    "html": "See Also\nGetting Substrings\nsubscript(Range<String.Index>) -> Substring\nAccesses a contiguous subrange of the collection’s elements.\nsubscript<R>(R) -> Self.SubSequence\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nfunc prefix(Int) -> Self.SubSequence\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Self.SubSequence\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)\n\nSee Also\nGetting Substrings\nsubscript(Range<String.Index>) -> Substring\nAccesses a contiguous subrange of the collection’s elements.\nsubscript<R>(R) -> Self.SubSequence\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Self.SubSequence\nfunc prefix(Int) -> Self.SubSequence\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Self.SubSequence\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)\n\nSee Also\nGetting Substrings\nsubscript(Range<String.Index>) -> Substring\nAccesses a contiguous subrange of the collection’s elements.\nsubscript<R>(R) -> Self.SubSequence\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Self.SubSequence\nfunc prefix(Int) -> Self.SubSequence\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Self.SubSequence\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "min(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/min(_:_:)",
    "html": "See Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nSplitting a String\nfunc split(separator: Self.Element, maxSplits: Int, omittingEmptySubsequences: Bool) -> [Self.SubSequence]\nReturns the longest possible subsequences of the collection, in order, around elements equal to the given element.\nAvailable when Element conforms to Equatable."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/subscript(_:)-4h7s3",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)\n\nSee Also\nGetting Substrings\nsubscript(Range<String.Index>) -> Substring\nAccesses a contiguous subrange of the collection’s elements.\nsubscript((UnboundedRange_) -> ()) -> Self.SubSequence\nfunc prefix(Int) -> Self.SubSequence\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Self.SubSequence\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/subscript(_:)-2so14",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)\n\nSee Also\nGetting Substrings\nsubscript<R>(R) -> Self.SubSequence\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Self.SubSequence\nfunc prefix(Int) -> Self.SubSequence\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Self.SubSequence\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/_(_:_:)-8d1wy",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/_=(_:_:)-1ih6",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "String.UnicodeScalarLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/unicodescalarliteraltype",
    "html": "Discussion\n\nValid types for UnicodeScalarLiteralType are Unicode.Scalar, Character, String, and StaticString."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/subscript(_:)-lc0v",
    "html": "Parameters\ni\n\nA valid index of the string. i must be less than the string’s end index.\n\nOverview\n\nYou can use the same indices for subscripting a string and its substring. For example, this code finds the first letter after the first space:\n\nlet str = \"Greetings, friend! How are you?\"\nlet firstSpace = str.firstIndex(of: \" \") ?? str.endIndex\nlet substr = str[firstSpace...]\nif let nextCapital = substr.firstIndex(where: { $0 >= \"A\" && $0 <= \"Z\" }) {\n    print(\"Capital after a space: \\(str[nextCapital])\")\n}\n// Prints \"Capital after a space: H\"\n\nSee Also\nGetting Characters and Bytes\nvar first: Self.Element?\nThe first element of the collection.\nvar last: Self.Element?\nThe last element of the collection.\nfunc randomElement() -> Self.Element?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> Self.Element?\nReturns a random element of the collection, using the given generator as a source for randomness."
  },
  {
    "title": "Sequence Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/sequence-implementations",
    "html": "Topics\nInstance Properties\nvar lazy: LazySequence<Self>\nA sequence containing the same elements as this sequence, but on which some operations, such as map and filter, are implemented lazily.\nInstance Methods\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc elementsEqual<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.\nAvailable when Element conforms to Equatable.\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (Self.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc enumerated() -> EnumeratedSequence<Self>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nfunc flatMap<SegmentOfResult>((Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc forEach((Self.Element) throws -> Void) rethrows\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.\nAvailable when Element conforms to Comparable.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements.\nfunc reduce<Result>(Result, (Result, Self.Element) throws -> Result) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) throws -> ()) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc shuffled() -> [Self.Element]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [Self.Element]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness.\nfunc sorted() -> [Self.Element]\nReturns the elements of the sequence, sorted.\nAvailable when Element conforms to Comparable.\nfunc sorted(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc starts<PossiblePrefix>(with: PossiblePrefix) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.\nAvailable when Element conforms to Equatable.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (Self.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?\nExecutes a closure on the sequence’s contiguous storage.\nType Aliases\ntypealias Element\nA type representing the sequence’s elements."
  },
  {
    "title": "StringProtocol Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/stringprotocol-implementations",
    "html": "Topics\nStructures\nstruct UTF16View\nA view of a string’s contents as a collection of UTF-16 code units.\nstruct UTF8View\nA view of a string’s contents as a collection of UTF-8 code units.\nstruct UnicodeScalarView\nA view of a string’s contents as a collection of Unicode scalar values.\nOperators\nstatic func != <RHS>(Self, RHS) -> Bool\nInitializers\ninit(cString: UnsafePointer<CChar>)\nCreates a new string by copying the null-terminated UTF-8 data referenced by the given pointer.\ninit<C, Encoding>(decoding: C, as: Encoding.Type)\nCreates a string from the given Unicode code units in the specified encoding.\ninit<Encoding>(decodingCString: UnsafePointer<Encoding.CodeUnit>, as: Encoding.Type)\nCreates a string from the null-terminated sequence of bytes at the given pointer.\nInstance Properties\nvar unicodeScalars: String.UnicodeScalarView\nThe string’s value represented as a collection of Unicode scalar values.\nvar utf16: String.UTF16View\nA UTF-16 encoding of self.\nvar utf8: String.UTF8View\nA UTF-8 encoding of self.\nInstance Methods\nfunc hasPrefix(String) -> Bool\nfunc hasSuffix(String) -> Bool\nfunc lowercased() -> String\nReturns a lowercase version of the string.\nfunc uppercased() -> String\nReturns an uppercase version of the string.\nfunc withCString<Result>((UnsafePointer<Int8>) throws -> Result) rethrows -> Result\nCalls the given closure with a pointer to the contents of the string, represented as a null-terminated sequence of UTF-8 code units.\nfunc withCString<Result, TargetEncoding>(encodedAs: TargetEncoding.Type, (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result\nCalls the given closure with a pointer to the contents of the string, represented as a null-terminated sequence of code units."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n\nSee Also\nGetting Characters and Bytes\nsubscript(String.Index) -> Character\nAccesses the character at the given position.\nvar last: Self.Element?\nThe last element of the collection.\nfunc randomElement() -> Self.Element?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> Self.Element?\nReturns a random element of the collection, using the given generator as a source for randomness."
  },
  {
    "title": "Transferable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/transferable-implementations",
    "html": "Topics\nType Aliases\ntypealias Representation\nThe type of the representation used to import and export the item.\nType Properties\nstatic var transferRepresentation: some TransferRepresentation\nThe representation used to import and export the item."
  },
  {
    "title": "TextOutputStreamable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/textoutputstreamable-implementations",
    "html": "Topics\nInstance Methods\nfunc write<Target>(to: inout Target)\nWrites the string into the given output stream."
  },
  {
    "title": "TextOutputStream Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/textoutputstream-implementations",
    "html": "Topics\nInstance Methods\nfunc write(String)\nAppends the given string to this string."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdstorage/subscript(_:)-5dslw",
    "html": "Overview\n\nThe elements of the index vector are wrapped modulo the count of elements in this vector. Because of this, the index is always in-range and no trap can occur."
  },
  {
    "title": "substring | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/element/substring",
    "html": "Discussion\n\nIf nothing was captured, substring is nil."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdstorage/subscript(_:)-4wdyq",
    "html": "Overview\n\nThe elements of the index vector are wrapped modulo the count of elements in this vector. Because of this, the index is always in-range and no trap can occur."
  },
  {
    "title": "name | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/element/name",
    "html": "Discussion\n\nIf the capture is unnamed, name is nil."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdstorage/subscript(_:)-8lp1s",
    "html": "Overview\n\nThe elements of the index vector are wrapped modulo the count of elements in this vector. Because of this, the index is always in-range and no trap can occur."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdstorage/subscript(_:)-4bxif",
    "html": "Overview\n\nThe elements of the index vector are wrapped modulo the count of elements in this vector. Because of this, the index is always in-range and no trap can occur."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/description",
    "html": "Discussion\n\nUsing this property directly is discouraged. Instead, use simple assignment to create a new constant or variable equal to this string.\n\nSee Also\nDescribing a String\nvar debugDescription: String\nA representation of the string that is suitable for debugging.\nvar customMirror: Mirror\nA mirror that reflects the String instance.\nvar hashValue: Int\nThe hash value.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdstorage/subscript(_:)-11tl0",
    "html": "Overview\n\nThe elements of the index vector are wrapped modulo the count of elements in this vector. Because of this, the index is always in-range and no trap can occur."
  },
  {
    "title": "hashValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/hashvalue",
    "html": "Discussion\n\nHash values are not guaranteed to be equal across different executions of your program. Do not save hash values to use during a future execution.\n\nImportant\n\nhashValue is deprecated as a Hashable requirement. To conform to Hashable, implement the hash(into:) requirement instead. The compiler provides an implementation for hashValue for you.\n\nSee Also\nDescribing a String\nvar description: String\nThe value of this string.\nvar debugDescription: String\nA representation of the string that is suitable for debugging.\nvar customMirror: Mirror\nA mirror that reflects the String instance.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/debugdescription",
    "html": "See Also\nDescribing a String\nvar description: String\nThe value of this string.\nvar customMirror: Mirror\nA mirror that reflects the String instance.\nvar hashValue: Int\nThe hash value.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nSee Also\nDescribing a String\nvar description: String\nThe value of this string.\nvar debugDescription: String\nA representation of the string that is suitable for debugging.\nvar customMirror: Mirror\nA mirror that reflects the String instance.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "applying(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/applying(_:)",
    "html": "Parameters\ndifference\n\nThe difference to be applied.\n\nReturn Value\n\nAn instance representing the state of the receiver with the difference applied, or nil if the difference is incompatible with the receiver’s state.\n\nDiscussion\n\nComplexity\n\nO(n + c), where n is self.count and c is the number of changes contained by the parameter.\n\nSee Also\nCreating and Applying Differences\nfunc difference<C>(from: C) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection.\nAvailable when Element conforms to Equatable.\nfunc difference<C>(from: C, by: (C.Element, Self.Element) -> Bool) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable.\n\nSee Also\nCreating and Applying Differences\nfunc applying(CollectionDifference<Self.Element>) -> Self?\nApplies the given difference to this collection.\nfunc difference<C>(from: C, by: (C.Element, Self.Element) -> Bool) -> CollectionDifference<Self.Element>\nReturns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nSee Also\nFinding Characters\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc firstIndex(of: Self.Element) -> Self.Index?\nReturns the first index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc firstIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the first index in which an element of the collection satisfies the given predicate.\nfunc last(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the last element of the sequence that satisfies the given predicate.\nfunc lastIndex(of: Self.Element) -> Self.Index?\nReturns the last index where the specified value appears in the collection.\nAvailable when Element conforms to Equatable.\nfunc lastIndex(where: (Self.Element) throws -> Bool) rethrows -> Self.Index?\nReturns the index of the last element in the collection that matches the given predicate.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max<T>(T, T) -> T\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min<T>(T, T) -> T\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection.\n\nSee Also\nGetting Substrings\nsubscript(Range<String.Index>) -> Substring\nAccesses a contiguous subrange of the collection’s elements.\nsubscript<R>(R) -> Self.SubSequence\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Self.SubSequence\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc prefix(while: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence\nReturns a subsequence containing the initial elements until predicate returns false and skipping the remaining elements.\nfunc suffix(Int) -> Self.SubSequence\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nSee Also\nGetting Substrings\nsubscript(Range<String.Index>) -> Substring\nAccesses a contiguous subrange of the collection’s elements.\nsubscript<R>(R) -> Self.SubSequence\nAccesses the contiguous subrange of the collection’s elements specified by a range expression.\nsubscript((UnboundedRange_) -> ()) -> Self.SubSequence\nfunc prefix(Int) -> Self.SubSequence\nReturns a subsequence, up to the specified maximum length, containing the initial elements of the collection.\nfunc prefix(through: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection through the specified position.\nfunc prefix(upTo: Self.Index) -> Self.SubSequence\nReturns a subsequence from the start of the collection up to, but not including, the specified position.\nfunc suffix(Int) -> Self.SubSequence\nReturns a subsequence, up to the given maximum length, containing the final elements of the collection.\nfunc suffix(from: Self.Index) -> Self.SubSequence\nReturns a subsequence from the specified position to the end of the collection."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/init(from:)-gcys",
    "html": "See Also\nUsing a String as a Data Value\nvar dataValue: MLDataValue\nThe value of the conforming type’s instance wrapped in a data value.\nvar identifierValue: MLDataValue\nThe value of the unique identifier wrapped in a data value.\nstatic var dataValueType: MLDataValue.ValueType\nThe underlying type the conforming type uses when it wraps itself in a data value."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingstream/iterator/next()",
    "html": "Discussion\n\nWhen next() returns nil, this signifies the end of the AsyncThrowingStream.\n\nIt is a programmer error to invoke next() from a concurrent context that contends with another such call, which results in a call to fatalError().\n\nIf you cancel the task this iterator is running in while next() is awaiting a value, the AsyncThrowingStream terminates. In this case, next() may return nil immediately, or else return nil on subsequent calls."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/systemrandomnumbergenerator/next()-70qj7",
    "html": "Return Value\n\nAn unsigned 64-bit random value.\n\nDiscussion\n\nUse this method when you need random binary data to generate another value. If you need an integer value within a specific range, use the static random(in:using:) method on that integer type instead of this method."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/flatmap(_:)-2njko",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)\n\nSee Also\nGetting Characters and Bytes\nsubscript(String.Index) -> Character\nAccesses the character at the given position.\nvar first: Self.Element?\nThe first element of the collection.\nfunc randomElement() -> Self.Element?\nReturns a random element of the collection.\nfunc randomElement<T>(using: inout T) -> Self.Element?\nReturns a random element of the collection, using the given generator as a source for randomness."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nSee Also\nGetting Characters and Bytes\nsubscript(String.Index) -> Character\nAccesses the character at the given position.\nvar first: Self.Element?\nThe first element of the collection.\nvar last: Self.Element?\nThe last element of the collection.\nfunc randomElement<T>(using: inout T) -> Self.Element?\nReturns a random element of the collection, using the given generator as a source for randomness."
  },
  {
    "title": "_IntentValue Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/_intentvalue-implementations",
    "html": "Topics\nType Aliases\ntypealias Specification\ntypealias UnwrappedType\ntypealias ValueType\nType Properties\nstatic var defaultResolverSpecification: some ResolverSpecification"
  },
  {
    "title": "value | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyregexoutput/element/value",
    "html": "Discussion\n\nIf nothing was captured, value is nil."
  },
  {
    "title": "_CustomPlaygroundQuickLookable Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/_customplaygroundquicklookable-implementations",
    "html": "Topics\nInstance Properties\nvar customPlaygroundQuickLook: _PlaygroundQuickLook\nA custom playground Quick Look for the String instance.\nDeprecated"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdstorage/subscript(_:)-9ota9",
    "html": "Overview\n\nThe elements of the index vector are wrapped modulo the count of elements in this vector. Because of this, the index is always in-range and no trap can occur."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/simdstorage/subscript(_:)-9go95",
    "html": "Overview\n\nThe elements of the index vector are wrapped modulo the count of elements in this vector. Because of this, the index is always in-range and no trap can occur."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/string/custommirror",
    "html": "See Also\nDescribing a String\nvar description: String\nThe value of this string.\nvar debugDescription: String\nA representation of the string that is suitable for debugging.\nvar hashValue: Int\nThe hash value.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "AsyncThrowingFilterSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/element",
    "html": "Discussion\n\nThe filter sequence produces whatever type of element its base sequence produces."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/joined(separator:)-4nirn",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/joined(separator:)-9h36m",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "encodedReplacementCharacter | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/ascii/encodedreplacementcharacter",
    "html": "Discussion\n\nIf the Unicode replacement character U+FFFD is representable in this encoding, encodedReplacementCharacter encodes that scalar value."
  },
  {
    "title": "transcode(_:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/ascii/transcode(_:from:)-ot11",
    "html": "Discussion\n\nA default implementation of this method will be provided automatically for any conforming type that does not implement one."
  },
  {
    "title": "transcode(_:from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/ascii/transcode(_:from:)-6q4sv",
    "html": "Discussion\n\nA default implementation of this method will be provided automatically for any conforming type that does not implement one."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/map(_:)-9dpw2",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unsafebufferpointer/iterator/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil."
  },
  {
    "title": "encode(_:into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/utf16/encode(_:into:)",
    "html": "Parameters\ninput\n\nThe Unicode scalar value to encode.\n\nprocessCodeUnit\n\nA closure that processes one code unit argument at a time.\n\nDiscussion\n\nFor example, the musical fermata symbol (“𝄐”) is a single Unicode scalar value (\\u{1D110}) but requires two code units for its UTF-16 representation. The following code encodes a fermata in UTF-16:\n\nvar codeUnits: [UTF16.CodeUnit] = []\nUTF16.encode(\"𝄐\", into: { codeUnits.append($0) })\nprint(codeUnits)\n// Prints \"[55348, 56592]\"\n"
  },
  {
    "title": "decode(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/utf16/decode(_:)-swift.method",
    "html": "Parameters\ninput\n\nAn iterator of code units to be decoded. input must be the same iterator instance in repeated calls to this method. Do not advance the iterator or any copies of the iterator outside this method.\n\nReturn Value\n\nA UnicodeDecodingResult instance, representing the next Unicode scalar, an indication of an error, or an indication that the UTF sequence has been fully decoded.\n\nDiscussion\n\nTo decode a code unit sequence completely, call this method repeatedly until it returns UnicodeDecodingResult.emptyInput. Checking that the iterator was exhausted is not sufficient, because the decoder can store buffered data from the input iterator.\n\nBecause of buffering, it is impossible to find the corresponding position in the iterator for a given returned Unicode.Scalar or an error.\n\nThe following example decodes the UTF-16 encoded bytes of a string into an array of Unicode.Scalar instances. This is a demonstration only—if you need the Unicode scalar representation of a string, use its unicodeScalars view.\n\nlet str = \"✨Unicode✨\"\nprint(Array(str.utf16))\n// Prints \"[10024, 85, 110, 105, 99, 111, 100, 101, 10024]\"\n\n\nvar codeUnitIterator = str.utf16.makeIterator()\nvar scalars: [Unicode.Scalar] = []\nvar utf16Decoder = UTF16()\nDecode: while true {\n    switch utf16Decoder.decode(&codeUnitIterator) {\n    case .scalarValue(let v): scalars.append(v)\n    case .emptyInput: break Decode\n    case .error:\n        print(\"Decoding error\")\n        break Decode\n    }\n}\nprint(scalars)\n// Prints \"[\"\\u{2728}\", \"U\", \"n\", \"i\", \"c\", \"o\", \"d\", \"e\", \"\\u{2728}\"]\"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethroughiterator/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/set/iterator/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridetoiterator/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/endindex",
    "html": "Discussion\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/subscript(_:)",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/zip2sequence/iterator/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/map(_:)-6flae",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/flatmap(_:)-4pdyq",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/map(_:)-56b34",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/flatmap(_:)-jrk7",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/compactmap(_:)-7anrq",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/compactmap(_:)-6sxlx",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "encode(_:into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/utf8/encode(_:into:)",
    "html": "Parameters\ninput\n\nThe Unicode scalar value to encode.\n\nprocessCodeUnit\n\nA closure that processes one code unit argument at a time.\n\nDiscussion\n\nFor example, the musical fermata symbol (“𝄐”) is a single Unicode scalar value (\\u{1D110}) but requires four code units for its UTF-8 representation. The following code encodes a fermata in UTF-8:\n\nvar bytes: [UTF8.CodeUnit] = []\nUTF8.encode(\"𝄐\", into: { bytes.append($0) })\nprint(bytes)\n// Prints \"[240, 157, 132, 144]\"\n"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unfoldsequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "isSameExclusiveExecutionContext(other:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/serialexecutor/issameexclusiveexecutioncontext(other:)-2dhzl",
    "html": "Parameters\nother\n\nthe executor to compare with.\n\nReturn Value\n\ntrue, if self and the other executor actually are mutually exclusive and it is safe–from a concurrency perspective–to execute code assuming one on the other.\n\nDiscussion\n\nThis method must be implemented with great care, as wrongly returning true would allow code from a different execution context (e.g. thread) to execute code which was intended to be isolated by another actor.\n\nThis check is not used when performing executor switching.\n\nThis check is used when performing preconditionTaskOnActorExecutor, preconditionTaskOnActorExecutor, assumeOnActorExecutor and similar APIs which assert about the same “exclusive serial execution context”."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/removefirst()",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "decode(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/utf8/decode(_:)-swift.method",
    "html": "Parameters\ninput\n\nAn iterator of code units to be decoded. input must be the same iterator instance in repeated calls to this method. Do not advance the iterator or any copies of the iterator outside this method.\n\nReturn Value\n\nA UnicodeDecodingResult instance, representing the next Unicode scalar, an indication of an error, or an indication that the UTF sequence has been fully decoded.\n\nDiscussion\n\nTo decode a code unit sequence completely, call this method repeatedly until it returns UnicodeDecodingResult.emptyInput. Checking that the iterator was exhausted is not sufficient, because the decoder can store buffered data from the input iterator.\n\nBecause of buffering, it is impossible to find the corresponding position in the iterator for a given returned Unicode.Scalar or an error.\n\nThe following example decodes the UTF-8 encoded bytes of a string into an array of Unicode.Scalar instances. This is a demonstration only—if you need the Unicode scalar representation of a string, use its unicodeScalars view.\n\nlet str = \"✨Unicode✨\"\nprint(Array(str.utf8))\n// Prints \"[226, 156, 168, 85, 110, 105, 99, 111, 100, 101, 226, 156, 168]\"\n\n\nvar bytesIterator = str.utf8.makeIterator()\nvar scalars: [Unicode.Scalar] = []\nvar utf8Decoder = UTF8()\nDecode: while true {\n    switch utf8Decoder.decode(&bytesIterator) {\n    case .scalarValue(let v): scalars.append(v)\n    case .emptyInput: break Decode\n    case .error:\n        print(\"Decoding error\")\n        break Decode\n    }\n}\nprint(scalars)\n// Prints \"[\"\\u{2728}\", \"U\", \"n\", \"i\", \"c\", \"o\", \"d\", \"e\", \"\\u{2728}\"]\"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/flatmap(_:)-5jiot",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/map(_:)-7ikmf",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Calculating count can be an O(n) operation.\n\nComplexity\n\nO(n)"
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingfiltersequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/startindex",
    "html": "Discussion\n\nIn an empty collection, startIndex == endIndex."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/joined(separator:)-6ag5z",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "AsyncThrowingStream.Continuation.YieldResult.enqueued(remaining:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingstream/continuation/yieldresult/enqueued(remaining:)",
    "html": "Discussion\n\nThis value represents the successful enqueueing of an element, whether the stream buffers the element or delivers it immediately to a pending call to next(). The associated value remaining is a hint that indicates the number of remaining slots in the buffer at the time of the yield call.\n\nNote\n\nFrom a thread safety perspective, remaining is a lower bound on the number of remaining slots. This is because a subsequent call that uses the remaining value could race on the consumption of values from the stream.\n\nSee Also\nYield Results\ncase dropped(Element)\nThe stream didn’t enqueue the element because the buffer was full.\ncase terminated\nThe stream didn’t enqueue the element because the stream was in a terminal state."
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/removelast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to remove."
  },
  {
    "title": "AsyncThrowingStream.Continuation.YieldResult.dropped(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingstream/continuation/yieldresult/dropped(_:)",
    "html": "Discussion\n\nThe associated element for this case is the element that the stream dropped.\n\nSee Also\nYield Results\ncase enqueued(remaining: Int)\nThe stream successfully enqueued the element.\ncase terminated\nThe stream didn’t enqueue the element because the stream was in a terminal state."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/map(_:)-59k4z",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "popFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/popfirst()",
    "html": "Return Value\n\nThe first element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/split(separator:maxsplits:omittingemptysubsequences:)-5dxmc",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/subscript(_:)-8f134",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "AnyBidirectionalCollection.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/removefirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "AnyBidirectionalCollection.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "AnyBidirectionalCollection.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/flatmap(_:)-78q3j",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/joined(separator:)-75msx",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/joined(separator:)-8i1yu",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/map(_:)-6vhfn",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf8view/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/split(separator:maxsplits:omittingemptysubsequences:)-4y1gu",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "AsyncThrowingStream.Continuation.YieldResult.terminated | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingstream/continuation/yieldresult/terminated",
    "html": "Discussion\n\nThis indicates the stream terminated prior to calling yield, either because the stream finished normally or through cancellation, or it threw an error.\n\nSee Also\nYield Results\ncase enqueued(remaining: Int)\nThe stream successfully enqueued the element.\ncase dropped(Element)\nThe stream didn’t enqueue the element because the buffer was full."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/poplast()",
    "html": "Return Value\n\nThe last element of the collection if the collection has one or more elements; otherwise, nil.\n\nDiscussion\n\nYou can use popLast() to remove the last element of a collection that might be empty. The removeLast() method must be used only on a nonempty collection.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/collectionofone/iterator/next()",
    "html": "Return Value\n\nThe next element in the underlying sequence, if a next element exists; otherwise, nil.\n\nDiscussion\n\nOnce nil has been returned, all subsequent calls return nil."
  },
  {
    "title": "AsyncThrowingStream.Continuation.Termination.finished(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingstream/continuation/termination/finished(_:)",
    "html": "Discussion\n\nThe associated Failure value provides the error that terminated the stream. If no error occurred, this value is nil.\n\nSee Also\nTermination States\ncase cancelled\nThe stream finished as a result of cancellation."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removefirst()-5t2ib",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/+(_:_:)-9qjws",
    "html": "Parameters\nlhs\n\nA range-replaceable collection.\n\nrhs\n\nA collection or finite sequence.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of an integer array and a Range<Int> instance.\n\nlet numbers = [1, 2, 3, 4]\nlet moreNumbers = numbers + (5...10)\nprint(moreNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of the argument on the left-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removesubrange(_:)-2qm37",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/poplast()-7zgh4",
    "html": "Return Value\n\nThe last element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/flatmap(_:)-7sppg",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/map(_:)-k0kj",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/map(_:)-3ry4c",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/removelast()",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty. To remove the last element of a collection that might be empty, use the popLast() method instead.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/subscript(_:)-9b37e",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/endindex",
    "html": "Discussion\n\nendIndex is always reachable from startIndex by zero or more applications of index(after:)."
  },
  {
    "title": "AsyncThrowingStream.Continuation.BufferingPolicy.bufferingNewest(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingstream/continuation/bufferingpolicy/bufferingnewest(_:)",
    "html": "Discussion\n\nThis strategy enforces keeping the specified amount of newest values.\n\nSee Also\nBuffering Policies\ncase unbounded\nContinue to add to the buffer, treating its capacity as infinite.\ncase bufferingOldest(Int)\nWhen the buffer is full, discard the newly received element."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anybidirectionalcollection/subscript(_:)-95c1r",
    "html": "Overview\n\nPrecondition\n\nposition indicates a valid position in self and position != endIndex."
  },
  {
    "title": "AsyncThrowingStream.Continuation.BufferingPolicy.unbounded | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingstream/continuation/bufferingpolicy/unbounded",
    "html": "See Also\nBuffering Policies\ncase bufferingOldest(Int)\nWhen the buffer is full, discard the newly received element.\ncase bufferingNewest(Int)\nWhen the buffer is full, discard the oldest element in the buffer."
  },
  {
    "title": "AsyncThrowingStream.Continuation.BufferingPolicy.bufferingOldest(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingstream/continuation/bufferingpolicy/bufferingoldest(_:)",
    "html": "Discussion\n\nThis strategy enforces keeping the specified amount of oldest values.\n\nSee Also\nBuffering Policies\ncase unbounded\nContinue to add to the buffer, treating its capacity as infinite.\ncase bufferingNewest(Int)\nWhen the buffer is full, discard the oldest element in the buffer."
  },
  {
    "title": "AsyncThrowingStream.Continuation.Termination.cancelled | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingstream/continuation/termination/cancelled",
    "html": "See Also\nTermination States\ncase finished(Failure?)\nThe stream finished as a result of calling the continuation’s finish method."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/throwingtaskgroup/iterator/next()",
    "html": "Return Value\n\nThe value returned by the next child task that completes, or nil if there are no remaining child tasks,\n\nDiscussion\n\nThe elements returned from this method appear in the order that the tasks completed, not in the order that those tasks were added to the task group. After this method returns nil, this iterator is guaranteed to never produce more values.\n\nFor more information about the iteration order and semantics, see ThrowingTaskGroup.next()\n\nThrows\n\nThe error thrown by the next child task that completes."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/startindex",
    "html": "Discussion\n\nIf the collection is empty, startIndex is equal to endIndex."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removelast(_:)-74qgu",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(k), where k is the specified number of elements."
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removelast(_:)-30fw5",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(k), where k is the specified number of elements."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removefirst(_:)-2lfkb",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removelast()-3izvn",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeAll(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removeall(where:)",
    "html": "Parameters\nshouldBeRemoved\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.\n\nDiscussion\n\nUse this method to remove every element in a collection that meets particular criteria. The order of the remaining elements is preserved. This example removes all the vowels from a string:\n\nvar phrase = \"The rain in Spain stays mainly in the plain.\"\n\n\nlet vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nphrase.removeAll(where: { vowels.contains($0) })\n// phrase == \"Th rn n Spn stys mnly n th pln.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removefirst()-2a3ja",
    "html": "Return Value\n\nThe removed element.\n\nDiscussion\n\nThe collection must not be empty.\n\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst()\nprint(bugs)\n// Prints \"[\"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeAll(keepingCapacity:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removeall(keepingcapacity:)",
    "html": "Parameters\nkeepCapacity\n\nPass true to request that the collection avoid releasing its storage. Retaining the collection’s storage can be a useful optimization when you’re planning to grow the collection again. The default value is false.\n\nDiscussion\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "remove(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/remove(at:)",
    "html": "Parameters\nposition\n\nThe position of the element to remove. position must be a valid index of the collection that is not equal to the collection’s end index.\n\nReturn Value\n\nThe removed element.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes the middle element from an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.6]\nlet removed = measurements.remove(at: 2)\nprint(measurements)\n// Prints \"[1.2, 1.5, 1.2, 1.6]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/poplast()-46voy",
    "html": "Return Value\n\nThe last element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "insert(contentsOf:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/insert(contentsof:at:)",
    "html": "Parameters\nnewElements\n\nThe new elements to insert into the collection.\n\ni\n\nThe position at which to insert the new elements. index must be a valid index of the collection.\n\nDiscussion\n\nThe new elements are inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new elements are appended to the collection.\n\nHere’s an example of inserting a range of integers into an array of the same type:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(contentsOf: 100...103, at: 3)\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 101, 102, 103, 4, 5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If i == endIndex, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "insert(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/insert(_:at:)",
    "html": "Parameters\nnewElement\n\nThe new element to insert into the collection.\n\ni\n\nThe position at which to insert the new element. index must be a valid index into the collection.\n\nDiscussion\n\nThe new element is inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new element is appended to the collection.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(100, at: 3)\nnumbers.insert(200, at: numbers.endIndex)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 4, 5, 200]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection. If i == endIndex, this method is equivalent to append(_:)."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned collection.\n\nReturn Value\n\nA collection of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "applying(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/applying(_:)",
    "html": "Parameters\ndifference\n\nThe difference to be applied.\n\nReturn Value\n\nAn instance representing the state of the receiver with the difference applied, or nil if the difference is incompatible with the receiver’s state.\n\nDiscussion\n\nComplexity\n\nO(n + c), where n is self.count and c is the number of changes contained by the parameter."
  },
  {
    "title": "append(contentsOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/append(contentsof:)",
    "html": "Parameters\nnewElements\n\nThe elements to append to the collection.\n\nDiscussion\n\nThe collection being appended to allocates any additional necessary storage to hold the new elements.\n\nThe following example appends the elements of a Range<Int> instance to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(contentsOf: 10...15)\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]\"\n\n\nComplexity\n\nO(m), where m is the length of newElements."
  },
  {
    "title": "append(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/append(_:)",
    "html": "Parameters\nnewElement\n\nThe element to append to the collection.\n\nDiscussion\n\nIf the collection does not have sufficient capacity for another element, additional storage is allocated before appending newElement. The following example adds a new number to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(100)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 100]\"\n\n\nComplexity\n\nO(1) on average, over many calls to append(_:) on the same collection."
  },
  {
    "title": "init(repeating:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/init(repeating:count:)",
    "html": "Parameters\nrepeatedValue\n\nThe element to repeat.\n\ncount\n\nThe number of times to repeat the value passed in the repeating parameter. count must be zero or greater.\n\nDiscussion\n\nHere’s an example of creating an array initialized with five strings containing the letter Z.\n\nlet fiveZs = Array(repeating: \"Z\", count: 5)\nprint(fiveZs)\n// Prints \"[\"Z\", \"Z\", \"Z\", \"Z\", \"Z\"]\"\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/init(_:)",
    "html": "Parameters\nelements\n\nThe sequence of elements for the new collection."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/+(_:_:)-1c1pd",
    "html": "Parameters\nlhs\n\nA collection or finite sequence.\n\nrhs\n\nA range-replaceable collection.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of a Range<Int> instance and an integer array.\n\nlet numbers = [7, 8, 9, 10]\nlet moreNumbers = (1...6) + numbers\nprint(moreNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of argument on the right-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/+(_:_:)-1p67y",
    "html": "Parameters\nlhs\n\nA range-replaceable collection.\n\nrhs\n\nAnother range-replaceable collection.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of two integer arrays.\n\nlet lowerNumbers = [1, 2, 3, 4]\nlet higherNumbers: ContiguousArray = [5, 6, 7, 8, 9, 10]\nlet allNumbers = lowerNumbers + higherNumbers\nprint(allNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of the argument on the left-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe array to append to.\n\nrhs\n\nA collection or finite sequence.\n\nDiscussion\n\nUse this operator to append the elements of a sequence to the end of range-replaceable collection with same Element type. This example appends the elements of a Range<Int> instance to an array of integers.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers += 10...15\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]\"\n\n\nComplexity\n\nO(m), where m is the length of the right-hand-side argument."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/map(_:)-9dihk",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removelast()-8b12x",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty. To remove the last element of a collection that might be empty, use the popLast() method instead.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removelast(_:)-4vtt6",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to remove."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/poplast()-7f9to",
    "html": "Return Value\n\nThe last element of the collection if the collection has one or more elements; otherwise, nil.\n\nDiscussion\n\nYou can use popLast() to remove the last element of a collection that might be empty. The removeLast() method must be used only on a nonempty collection.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/subscript(_:)-ua5x",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "Substring.UnicodeScalarView.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "Substring.UnicodeScalarView.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/subscript(_:)-57h51",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nOverview\n\nThe following example accesses an element of an array through its subscript to print its value:\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nprint(streets[1])\n// Prints \"Bryant\"\n\n\nYou can subscript a collection with any valid index other than the collection’s end index. The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/subscript(_:)-7ylky",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removefirst(_:)-2iv78",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/map(_:)-1idf8",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removefirst()-2wary",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/endindex",
    "html": "Discussion\n\nWhen you need a range that includes the last element of a collection, use the half-open range operator (..<) with endIndex. The ..< operator creates a range that doesn’t include the upper bound, so it’s always safe to use with endIndex. For example:\n\nlet numbers = [10, 20, 30, 40, 50]\nif let index = numbers.firstIndex(of: 30) {\n    print(numbers[index ..< numbers.endIndex])\n}\n// Prints \"[30, 40, 50]\"\n\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/replacesubrange(_:with:)-4kmx6",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/replacesubrange(_:with:)-9vko",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "reserveCapacity(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/reservecapacity(_:)",
    "html": "Parameters\nn\n\nThe requested number of elements to store.\n\nDiscussion\n\nIf you will be adding a known number of elements to a collection, use this method to avoid multiple reallocations. A type that conforms to RangeReplaceableCollection can choose how to respond when this method is called. Depending on the type, it may make sense to allocate more or less storage than requested or to take no action at all."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removesubrange(_:)-5c1al",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/replacesubrange(_:with:)-7xjpm",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, the complexity is O(m)."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removefirst(_:)-5314w",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst(3)\nprint(bugs)\n// Prints \"[\"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/removelast()-75qy7",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/flatmap(_:)-1uifa",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/compactmap(_:)-2brmn",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/compactmap(_:)-1c7j6",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/flatmap(_:)-8dfa3",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/flatmap(_:)-7jz5y",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "Substring.UnicodeScalarView.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "popFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/popfirst()",
    "html": "Return Value\n\nThe first element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "init() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/init()",
    "html": "See Also\nInfrequently Used Functionality\ninit(floatLiteral: Double)\nCreates an instance initialized to the specified floating-point value.\ninit(integerLiteral: Int64)\nCreates an instance initialized to the specified integer value.\ninit(integerLiteral: Self)\nCreates an instance initialized to the specified integer value.\nAvailable when Self conforms to _ExpressibleByBuiltinIntegerLiteral.\ntypealias FloatLiteralType\nA type that represents a floating-point literal.\ntypealias IntegerLiteralType\nA type that represents an integer literal.\nfunc advanced(by: Double) -> Double\nReturns a value that is offset the specified distance from this value.\nfunc distance(to: Double) -> Double\nReturns the distance from this value to the given value, expressed as a stride.\ntypealias Stride\nA type that represents the distance between two values.\nfunc write<Target>(to: inout Target)\nWrites a textual representation of this instance into the given output stream.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/compactmap(_:)-11hbc",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "AsyncThrowingDropWhileSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/element",
    "html": "Discussion\n\nThe drop-while sequence produces whatever type of element its base sequence produces."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/map(_:)-785ao",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/compactmap(_:)-9jfg4",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/flatmap(_:)-3aiq0",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/flatmap(_:)-3qp1z",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/map(_:)-7g3xh",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/map(_:)-8nbqn",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "AsyncDropFirstSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/element",
    "html": "Discussion\n\nThe drop-first sequence produces whatever type of element its base iterator produces."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/compactmap(_:)-2zfm7",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/flatmap(_:)-60388",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/flatmap(_:)-7yxkz",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/map(_:)-21iha",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/unicodescalarview/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/map(_:)-46zuh",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/map(_:)-8is9u",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "leastNormalMagnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/leastnormalmagnitude",
    "html": "Discussion\n\nThis value compares less than or equal to all positive normal numbers. There may be smaller positive numbers, but they are subnormal, meaning that they are represented with less precision than normal numbers.\n\nThis value corresponds to type-specific C macros such as FLT_MIN and DBL_MIN. The naming of those macros is slightly misleading, because subnormals, zeros, and negative numbers are smaller than this value.\n\nSee Also\nAccessing Numeric Constants\nstatic var pi: Double\nThe mathematical constant pi (π), approximately equal to 3.14159.\nstatic var infinity: Double\nPositive infinity.\nstatic var greatestFiniteMagnitude: Double\nThe greatest finite number representable by this type.\nstatic var nan: Double\nA quiet NaN (“not a number”).\nstatic var signalingNaN: Double\nA signaling NaN (“not a number”).\nstatic var ulpOfOne: Double\nThe unit in the last place of 1.0.\nstatic var leastNonzeroMagnitude: Double\nThe least positive number.\nstatic var zero: Self\nThe zero value.\nAvailable when Self conforms to ExpressibleByIntegerLiteral."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "Double.Exponent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/exponent-swift.typealias",
    "html": "See Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias RawSignificand\nA type that represents the encoded significand of a value.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "leastNonzeroMagnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/leastnonzeromagnitude",
    "html": "Discussion\n\nThis value compares less than or equal to all positive numbers, but greater than zero. If the type supports subnormal values, leastNonzeroMagnitude is smaller than leastNormalMagnitude; otherwise they are equal.\n\nSee Also\nAccessing Numeric Constants\nstatic var pi: Double\nThe mathematical constant pi (π), approximately equal to 3.14159.\nstatic var infinity: Double\nPositive infinity.\nstatic var greatestFiniteMagnitude: Double\nThe greatest finite number representable by this type.\nstatic var nan: Double\nA quiet NaN (“not a number”).\nstatic var signalingNaN: Double\nA signaling NaN (“not a number”).\nstatic var ulpOfOne: Double\nThe unit in the last place of 1.0.\nstatic var leastNormalMagnitude: Double\nThe least positive normal number.\nstatic var zero: Self\nThe zero value.\nAvailable when Self conforms to ExpressibleByIntegerLiteral."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "AsyncCompactMapSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/element",
    "html": "Discussion\n\nThe compact map sequence produces whatever type of element its transforming closure produces."
  },
  {
    "title": "sharedUnownedExecutor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/globalactor/sharedunownedexecutor-7vdm6",
    "html": "Discussion\n\nThe value of this property must be equivalent to shared.unownedExecutor."
  },
  {
    "title": "assertIsolated(_:file:line:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/mainactor/assertisolated(_:file:line:)",
    "html": "Discussion\n\nIn playgrounds and -Onone builds (the default for Xcode’s Debug configuration): If condition evaluates to false, stop program execution in a debuggable state after printing message.\n\nIn -O builds (the default for Xcode’s Release configuration), condition is not evaluated, and there are no effects.\n\nIn -Ounchecked builds, condition is not evaluated, but the optimizer may assume that it always evaluates to true. Failure to satisfy that assumption is a serious programming error."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint/words-swift.struct/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "assumeIsolated(_:file:line:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/mainactor/assumeisolated(_:file:line:)-swift.method",
    "html": "Discussion\n\nThis API should only be used as last resort, when it is not possible to express the current execution context definitely belongs to the specified actor in other ways. E.g. one may need to use this in a delegate style API, where a synchronous method is guaranteed to be called by the specified actor, however it is not possible to move this method as being declared on the specified actor.\n\nWarning\n\nIf the current executor is not the expected serial executor, this function will crash.\n\nNote that this check is performed against the passed in actor’s serial executor, meaning that if another actor uses the same serial executor–by using that actor’s unownedExecutor as its own unownedExecutor–this check will succeed, as from a concurrency safety perspective, the serial executor guarantees mutual exclusion of those two actors."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "preconditionIsolated(_:file:line:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/mainactor/preconditionisolated(_:file:line:)",
    "html": "Discussion\n\nThis function’s effect varies depending on the build flag used:\n\nIn playgrounds and -Onone builds (the default for Xcode’s Debug configuration), stops program execution in a debuggable state after printing message.\n\nIn -O builds (the default for Xcode’s Release configuration), stops program execution.\n\nIn -Ounchecked builds, the optimizer may assume that this function is never called. Failure to satisfy that assumption is a serious programming error."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/compactmap(_:)-1pl3p",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/compactmap(_:)-1in33",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/compactmap(_:)-1wsos",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/map(_:)-4ntdo",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "AsyncDropWhileSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropwhilesequence/element",
    "html": "Discussion\n\nThe drop-while sequence produces whatever type of element its base sequence produces."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/compactmap(_:)-874pn",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/compactmap(_:)-9t1q8",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncdropfirstsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/flatmap(_:)-3eezo",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/flatmap(_:)-3yes2",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/_(_:_:)-24u4i",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "...(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/'...(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.\n\nlet lowercase = \"a\"...\"z\"\nprint(lowercase.contains(\"z\"))\n// Prints \"true\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/_(_:_:)-7lwp5",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/_(_:_:)-552jp",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/_(_:_:)-fe4t",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis function is the only requirement of the Comparable protocol. The remainder of the relational operator functions are implemented by the standard library for any type that conforms to Comparable."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/_=(_:_:)-1iil",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/_=(_:_:)-9o6h8",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/custommirror",
    "html": "See Also\nDescribing a Double\nvar description: String\nA textual representation of the value.\nvar debugDescription: String\nA textual representation of the value, suitable for debugging.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "sharedUnownedExecutor | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/mainactor/sharedunownedexecutor-1x66v",
    "html": "Discussion\n\nThe value of this property must be equivalent to shared.unownedExecutor."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "-(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/-(_:)-2wu3q",
    "html": "Parameters\noperand\n\nThe value to negate.\n\nDiscussion\n\nThe unary minus operator (prefix -) calculates the negation of its operand. The result is always exact.\n\nlet x = 21.5\nlet y = -x\n// y == -21.5\n"
  },
  {
    "title": "ulpOfOne | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/ulpofone-1s81x",
    "html": "Discussion\n\nThe positive difference between 1.0 and the next greater representable number. ulpOfOne corresponds to the value represented by the C macros FLT_EPSILON, DBL_EPSILON, etc, and is sometimes called epsilon or machine epsilon. Swift deliberately avoids using the term “epsilon” because:\n\nHistorically “epsilon” has been used to refer to several different concepts in different languages, leading to confusion and bugs.\n\nThe name “epsilon” suggests that this quantity is a good tolerance to choose for approximate comparisons, but it is almost always unsuitable for that purpose.\n\nSee also the ulp member property."
  },
  {
    "title": "radix | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/radix",
    "html": "Discussion\n\nThe magnitude of a floating-point value x of type F can be calculated by using the following formula, where ** is exponentiation:\n\nx.significand * (F.radix ** x.exponent)\n\n\nA conforming type may use any integer radix, but values other than 2 (for binary floating-point types) or 10 (for decimal floating-point types) are extraordinarily rare in practice.\n\nSee Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawSignificand\nA type that represents the encoded significand of a value.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "nan | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/nan",
    "html": "Discussion\n\nA NaN compares not equal, not greater than, and not less than every value, including itself. Passing a NaN to an operation generally results in NaN.\n\nlet x = 1.21\n// x > Double.nan == false\n// x < Double.nan == false\n// x == Double.nan == false\n\n\nBecause a NaN always compares not equal to itself, to test whether a floating-point value is NaN, use its isNaN property instead of the equal-to operator (==). In the following example, y is NaN.\n\nlet y = x + Double.nan\nprint(y == Double.nan)\n// Prints \"false\"\nprint(y.isNaN)\n// Prints \"true\"\n\nSee Also\nAccessing Numeric Constants\nstatic var pi: Double\nThe mathematical constant pi (π), approximately equal to 3.14159.\nstatic var infinity: Double\nPositive infinity.\nstatic var greatestFiniteMagnitude: Double\nThe greatest finite number representable by this type.\nstatic var signalingNaN: Double\nA signaling NaN (“not a number”).\nstatic var ulpOfOne: Double\nThe unit in the last place of 1.0.\nstatic var leastNonzeroMagnitude: Double\nThe least positive number.\nstatic var leastNormalMagnitude: Double\nThe least positive normal number.\nstatic var zero: Self\nThe zero value.\nAvailable when Self conforms to ExpressibleByIntegerLiteral."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/map(_:)-8rz0x",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "init(signOf:magnitudeOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/init(signof:magnitudeof:)-6i9uy",
    "html": "Parameters\nsignOf\n\nA value from which to use the sign. The result of the initializer has the same sign as signOf.\n\nmagnitudeOf\n\nA value from which to use the magnitude. The result of the initializer has the same magnitude as magnitudeOf.\n\nDiscussion\n\nThe following example uses this initializer to create a new Double instance with the sign of a and the magnitude of b:\n\nlet a = -21.5\nlet b = 305.15\nlet c = Double(signOf: a, magnitudeOf: b)\nprint(c)\n// Prints \"-305.15\"\n\n\nThis initializer implements the IEEE 754 copysign operation."
  },
  {
    "title": "/(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double//(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by.\n\nDiscussion\n\nThe division operator (/) calculates the quotient of the division if rhs is nonzero. If rhs is zero, the result of the division is infinity, with the sign of the result matching the sign of lhs.\n\nlet x = 16.875\nlet y = x / 2.25\n// y == 7.5\n\n\nlet z = x / 0\n// z.isInfinite == true\n\n\nThe / operator implements the division operation defined by the IEEE 754 specification."
  },
  {
    "title": "/=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double//=(_:_:)",
    "html": "Parameters\nlhs\n\nThe value to divide.\n\nrhs\n\nThe value to divide lhs by."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/-=(_:_:)-5gbj1",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asynccompactmapsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/flatmap(_:)-2hvfn",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/flatmap(_:)-86tec",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/map(_:)-8i9r9",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/map(_:)-2zjn",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingdropwhilesequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "maximum(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/maximum(_:_:)",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nThe greater of x and y, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the maximum of two values, preserving order and eliminating NaN when possible. For two values x and y, the result of maximum(x, y) is x if x > y, y if x <= y, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.maximum(10.0, -25.0)\n// 10.0\nDouble.maximum(10.0, .nan)\n// 10.0\nDouble.maximum(.nan, -25.0)\n// -25.0\nDouble.maximum(.nan, .nan)\n// nan\n\n\nThe maximum method implements the maxNum operation defined by the IEEE 754 specification.\n\nSee Also\nComparing Values\nFloating-Point Operators for Double\nPerform arithmetic and bitwise operations or compare values.\nfunc isEqual(to: Double) -> Bool\nReturns a Boolean value indicating whether this instance is equal to the given value.\nfunc isLess(than: Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than the given value.\nfunc isLessThanOrEqualTo(Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than or equal to the given value.\nfunc isTotallyOrdered(belowOrEqualTo: Self) -> Bool\nReturns a Boolean value indicating whether this instance should precede or tie positions with the given value in an ascending sort.\nstatic func minimum(Self, Self) -> Self\nReturns the lesser of the two given values.\nstatic func minimumMagnitude(Self, Self) -> Self\nReturns the value with lesser magnitude.\nstatic func maximumMagnitude(Self, Self) -> Self\nReturns the value with greater magnitude."
  },
  {
    "title": "minimumMagnitude(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/minimummagnitude(_:_:)",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nWhichever of x or y has lesser magnitude, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the value with lesser magnitude of the two given values, preserving order and eliminating NaN when possible. For two values x and y, the result of minimumMagnitude(x, y) is x if x.magnitude <= y.magnitude, y if y.magnitude < x.magnitude, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.minimumMagnitude(10.0, -25.0)\n// 10.0\nDouble.minimumMagnitude(10.0, .nan)\n// 10.0\nDouble.minimumMagnitude(.nan, -25.0)\n// -25.0\nDouble.minimumMagnitude(.nan, .nan)\n// nan\n\n\nThe minimumMagnitude method implements the minNumMag operation defined by the IEEE 754 specification.\n\nSee Also\nComparing Values\nFloating-Point Operators for Double\nPerform arithmetic and bitwise operations or compare values.\nfunc isEqual(to: Double) -> Bool\nReturns a Boolean value indicating whether this instance is equal to the given value.\nfunc isLess(than: Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than the given value.\nfunc isLessThanOrEqualTo(Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than or equal to the given value.\nfunc isTotallyOrdered(belowOrEqualTo: Self) -> Bool\nReturns a Boolean value indicating whether this instance should precede or tie positions with the given value in an ascending sort.\nstatic func minimum(Self, Self) -> Self\nReturns the lesser of the two given values.\nstatic func maximum(Self, Self) -> Self\nReturns the greater of the two given values.\nstatic func maximumMagnitude(Self, Self) -> Self\nReturns the value with greater magnitude."
  },
  {
    "title": "significandBitPattern | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/significandbitpattern",
    "html": "Discussion\n\nThe significandBitPattern property does not include the leading integral bit of the significand, even for types like Float80 that store it explicitly.\n\nSee Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawSignificand\nA type that represents the encoded significand of a value.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "isFinite | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/isfinite",
    "html": "Discussion\n\nAll values other than NaN and infinity are considered finite, whether normal or subnormal. For NaN, both isFinite and isInfinite are false.\n\nSee Also\nQuerying a Double’s State\nvar isZero: Bool\nA Boolean value indicating whether the instance is equal to zero.\nvar isInfinite: Bool\nA Boolean value indicating whether the instance is infinite.\nvar isNaN: Bool\nA Boolean value indicating whether the instance is NaN (“not a number”).\nvar isSignalingNaN: Bool\nA Boolean value indicating whether the instance is a signaling NaN.\nvar isNormal: Bool\nA Boolean value indicating whether this instance is normal.\nvar isSubnormal: Bool\nA Boolean value indicating whether the instance is subnormal.\nvar isCanonical: Bool\nA Boolean value indicating whether the instance’s representation is in its canonical form.\nvar floatingPointClass: FloatingPointClassification\nThe classification of this value."
  },
  {
    "title": "isInfinite | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/isinfinite",
    "html": "Discussion\n\nFor NaN, both isFinite and isInfinite are false.\n\nSee Also\nQuerying a Double’s State\nvar isZero: Bool\nA Boolean value indicating whether the instance is equal to zero.\nvar isFinite: Bool\nA Boolean value indicating whether this instance is finite.\nvar isNaN: Bool\nA Boolean value indicating whether the instance is NaN (“not a number”).\nvar isSignalingNaN: Bool\nA Boolean value indicating whether the instance is a signaling NaN.\nvar isNormal: Bool\nA Boolean value indicating whether this instance is normal.\nvar isSubnormal: Bool\nA Boolean value indicating whether the instance is subnormal.\nvar isCanonical: Bool\nA Boolean value indicating whether the instance’s representation is in its canonical form.\nvar floatingPointClass: FloatingPointClassification\nThe classification of this value."
  },
  {
    "title": "floatingPointClass | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/floatingpointclass",
    "html": "Discussion\n\nA value’s floatingPointClass property describes its “class” as described by the IEEE 754 specification.\n\nSee Also\nQuerying a Double’s State\nvar isZero: Bool\nA Boolean value indicating whether the instance is equal to zero.\nvar isFinite: Bool\nA Boolean value indicating whether this instance is finite.\nvar isInfinite: Bool\nA Boolean value indicating whether the instance is infinite.\nvar isNaN: Bool\nA Boolean value indicating whether the instance is NaN (“not a number”).\nvar isSignalingNaN: Bool\nA Boolean value indicating whether the instance is a signaling NaN.\nvar isNormal: Bool\nA Boolean value indicating whether this instance is normal.\nvar isSubnormal: Bool\nA Boolean value indicating whether the instance is subnormal.\nvar isCanonical: Bool\nA Boolean value indicating whether the instance’s representation is in its canonical form."
  },
  {
    "title": "isCanonical | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/iscanonical",
    "html": "Discussion\n\nThe IEEE 754 specification defines a canonical, or preferred, encoding of a floating-point value. On platforms that fully support IEEE 754, every Float or Double value is canonical, but non-canonical values can exist on other platforms or for other types. Some examples:\n\nOn platforms that flush subnormal numbers to zero (such as armv7 with the default floating-point environment), Swift interprets subnormal Float and Double values as non-canonical zeros. (In Swift 5.1 and earlier, isCanonical is true for these values, which is the incorrect value.)\n\nOn i386 and x86_64, Float80 has a number of non-canonical encodings. “Pseudo-NaNs”, “pseudo-infinities”, and “unnormals” are interpreted as non-canonical NaN encodings. “Pseudo-denormals” are interpreted as non-canonical encodings of subnormal values.\n\nDecimal floating-point types admit a large number of non-canonical encodings. Consult the IEEE 754 standard for additional details.\n\nSee Also\nQuerying a Double’s State\nvar isZero: Bool\nA Boolean value indicating whether the instance is equal to zero.\nvar isFinite: Bool\nA Boolean value indicating whether this instance is finite.\nvar isInfinite: Bool\nA Boolean value indicating whether the instance is infinite.\nvar isNaN: Bool\nA Boolean value indicating whether the instance is NaN (“not a number”).\nvar isSignalingNaN: Bool\nA Boolean value indicating whether the instance is a signaling NaN.\nvar isNormal: Bool\nA Boolean value indicating whether this instance is normal.\nvar isSubnormal: Bool\nA Boolean value indicating whether the instance is subnormal.\nvar floatingPointClass: FloatingPointClassification\nThe classification of this value."
  },
  {
    "title": "Double.FloatLiteralType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/floatliteraltype",
    "html": "Discussion\n\nValid types for FloatLiteralType are Float, Double, and Float80 where available.\n\nSee Also\nInfrequently Used Functionality\ninit()\ninit(floatLiteral: Double)\nCreates an instance initialized to the specified floating-point value.\ninit(integerLiteral: Int64)\nCreates an instance initialized to the specified integer value.\ninit(integerLiteral: Self)\nCreates an instance initialized to the specified integer value.\nAvailable when Self conforms to _ExpressibleByBuiltinIntegerLiteral.\ntypealias IntegerLiteralType\nA type that represents an integer literal.\nfunc advanced(by: Double) -> Double\nReturns a value that is offset the specified distance from this value.\nfunc distance(to: Double) -> Double\nReturns the distance from this value to the given value, expressed as a stride.\ntypealias Stride\nA type that represents the distance between two values.\nfunc write<Target>(to: inout Target)\nWrites a textual representation of this instance into the given output stream.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/init(integerliteral:)-605xp",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes.\n\nSee Also\nInfrequently Used Functionality\ninit()\ninit(floatLiteral: Double)\nCreates an instance initialized to the specified floating-point value.\ninit(integerLiteral: Self)\nCreates an instance initialized to the specified integer value.\nAvailable when Self conforms to _ExpressibleByBuiltinIntegerLiteral.\ntypealias FloatLiteralType\nA type that represents a floating-point literal.\ntypealias IntegerLiteralType\nA type that represents an integer literal.\nfunc advanced(by: Double) -> Double\nReturns a value that is offset the specified distance from this value.\nfunc distance(to: Double) -> Double\nReturns the distance from this value to the given value, expressed as a stride.\ntypealias Stride\nA type that represents the distance between two values.\nfunc write<Target>(to: inout Target)\nWrites a textual representation of this instance into the given output stream.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/==(_:_:)-4wfub",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "hash(into:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/hash(into:)",
    "html": "Parameters\nhasher\n\nThe hasher to use when combining the components of this instance.\n\nDiscussion\n\nImplement this method to conform to the Hashable protocol. The components used for hashing must be the same as the components compared in your type’s == operator implementation. Call hasher.combine(_:) with each of these components.\n\nImportant\n\nIn your implementation of hash(into:), don’t call finalize() on the hasher instance provided, or replace it with a different instance. Doing so may become a compile-time error in the future.\n\nSee Also\nDescribing a Double\nvar description: String\nA textual representation of the value.\nvar debugDescription: String\nA textual representation of the value, suitable for debugging.\nvar customMirror: Mirror\nA mirror that reflects the Double instance."
  },
  {
    "title": "init(integerLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/init(integerliteral:)-6hc7j",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using an integer literal. For example:\n\nlet x = 23\n\n\nIn this example, the assignment to the x constant calls this integer literal initializer behind the scenes.\n\nSee Also\nInfrequently Used Functionality\ninit()\ninit(floatLiteral: Double)\nCreates an instance initialized to the specified floating-point value.\ninit(integerLiteral: Int64)\nCreates an instance initialized to the specified integer value.\ntypealias FloatLiteralType\nA type that represents a floating-point literal.\ntypealias IntegerLiteralType\nA type that represents an integer literal.\nfunc advanced(by: Double) -> Double\nReturns a value that is offset the specified distance from this value.\nfunc distance(to: Double) -> Double\nReturns the distance from this value to the given value, expressed as a stride.\ntypealias Stride\nA type that represents the distance between two values.\nfunc write<Target>(to: inout Target)\nWrites a textual representation of this instance into the given output stream.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "-(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/-(_:)-41os0",
    "html": "Return Value\n\nThe additive inverse of the argument.\n\nDiscussion\n\nThe negation operator (prefix -) returns the additive inverse of its argument.\n\nlet x = 21\nlet y = -x\n// y == -21\n\n\nThe resulting value must be representable in the same type as the argument. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nlet z = -Int8.min\n// Overflow error\n"
  },
  {
    "title": "negate() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/negate()-jfhr",
    "html": "Discussion\n\nThe following example uses the negate() method to negate the value of an integer x:\n\nvar x = 21\nx.negate()\n// x == -21\n\n\nThe resulting value must be representable within the value’s type. In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.\n\nvar y = Int8.min\ny.negate()\n// Overflow error\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/_=(_:_:)-5yoz7",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "AsyncPrefixWhileSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixwhilesequence/element",
    "html": "Discussion\n\nThe prefix-while sequence produces whatever type of element its base iterator produces."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/_=(_:_:)-8lyh5",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "description | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/description",
    "html": "Discussion\n\nFor any finite value, this property provides a string that can be converted back to an instance of Double without rounding errors. That is, if x is an instance of Double, then Double(x.description) == x is always true. For any NaN value, the property’s value is “nan”, and for positive and negative infinity its value is “inf” and “-inf”.\n\nSee Also\nDescribing a Double\nvar debugDescription: String\nA textual representation of the value, suitable for debugging.\nvar customMirror: Mirror\nA mirror that reflects the Double instance.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/init(from:)-3crx3",
    "html": "Parameters\ndecoder\n\nThe decoder to read data from.\n\nDiscussion\n\nThis initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid.\n\nSee Also\nEncoding and Decoding Values\nfunc encode(to: Encoder) throws\nEncodes this value into the given encoder."
  },
  {
    "title": "ulpOfOne | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/ulpofone-5gc7y",
    "html": "Discussion\n\nThe positive difference between 1.0 and the next greater representable number. The ulpOfOne constant corresponds to the C macros FLT_EPSILON, DBL_EPSILON, and others with a similar purpose.\n\nSee Also\nAccessing Numeric Constants\nstatic var pi: Double\nThe mathematical constant pi (π), approximately equal to 3.14159.\nstatic var infinity: Double\nPositive infinity.\nstatic var greatestFiniteMagnitude: Double\nThe greatest finite number representable by this type.\nstatic var nan: Double\nA quiet NaN (“not a number”).\nstatic var signalingNaN: Double\nA signaling NaN (“not a number”).\nstatic var leastNonzeroMagnitude: Double\nThe least positive number.\nstatic var leastNormalMagnitude: Double\nThe least positive normal number.\nstatic var zero: Self\nThe zero value.\nAvailable when Self conforms to ExpressibleByIntegerLiteral."
  },
  {
    "title": "signalingNaN | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/signalingnan",
    "html": "Discussion\n\nThe default IEEE 754 behavior of operations involving a signaling NaN is to raise the Invalid flag in the floating-point environment and return a quiet NaN.\n\nOperations on types conforming to the FloatingPoint protocol should support this behavior, but they might also support other options. For example, it would be reasonable to implement alternative operations in which operating on a signaling NaN triggers a runtime error or results in a diagnostic for debugging purposes. Types that implement alternative behaviors for a signaling NaN must document the departure.\n\nOther than these signaling operations, a signaling NaN behaves in the same manner as a quiet NaN.\n\nSee Also\nAccessing Numeric Constants\nstatic var pi: Double\nThe mathematical constant pi (π), approximately equal to 3.14159.\nstatic var infinity: Double\nPositive infinity.\nstatic var greatestFiniteMagnitude: Double\nThe greatest finite number representable by this type.\nstatic var nan: Double\nA quiet NaN (“not a number”).\nstatic var ulpOfOne: Double\nThe unit in the last place of 1.0.\nstatic var leastNonzeroMagnitude: Double\nThe least positive number.\nstatic var leastNormalMagnitude: Double\nThe least positive normal number.\nstatic var zero: Self\nThe zero value.\nAvailable when Self conforms to ExpressibleByIntegerLiteral."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "greatestFiniteMagnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/greatestfinitemagnitude",
    "html": "Discussion\n\nThis value compares greater than or equal to all finite numbers, but less than infinity.\n\nThis value corresponds to type-specific C macros such as FLT_MAX and DBL_MAX. The naming of those macros is slightly misleading, because infinity is greater than this value.\n\nSee Also\nAccessing Numeric Constants\nstatic var pi: Double\nThe mathematical constant pi (π), approximately equal to 3.14159.\nstatic var infinity: Double\nPositive infinity.\nstatic var nan: Double\nA quiet NaN (“not a number”).\nstatic var signalingNaN: Double\nA signaling NaN (“not a number”).\nstatic var ulpOfOne: Double\nThe unit in the last place of 1.0.\nstatic var leastNonzeroMagnitude: Double\nThe least positive number.\nstatic var leastNormalMagnitude: Double\nThe least positive normal number.\nstatic var zero: Self\nThe zero value.\nAvailable when Self conforms to ExpressibleByIntegerLiteral."
  },
  {
    "title": "maximumMagnitude(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/maximummagnitude(_:_:)",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nWhichever of x or y has greater magnitude, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the value with greater magnitude of the two given values, preserving order and eliminating NaN when possible. For two values x and y, the result of maximumMagnitude(x, y) is x if x.magnitude > y.magnitude, y if x.magnitude <= y.magnitude, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.maximumMagnitude(10.0, -25.0)\n// -25.0\nDouble.maximumMagnitude(10.0, .nan)\n// 10.0\nDouble.maximumMagnitude(.nan, -25.0)\n// -25.0\nDouble.maximumMagnitude(.nan, .nan)\n// nan\n\n\nThe maximumMagnitude method implements the maxNumMag operation defined by the IEEE 754 specification.\n\nSee Also\nComparing Values\nFloating-Point Operators for Double\nPerform arithmetic and bitwise operations or compare values.\nfunc isEqual(to: Double) -> Bool\nReturns a Boolean value indicating whether this instance is equal to the given value.\nfunc isLess(than: Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than the given value.\nfunc isLessThanOrEqualTo(Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than or equal to the given value.\nfunc isTotallyOrdered(belowOrEqualTo: Self) -> Bool\nReturns a Boolean value indicating whether this instance should precede or tie positions with the given value in an ascending sort.\nstatic func minimum(Self, Self) -> Self\nReturns the lesser of the two given values.\nstatic func minimumMagnitude(Self, Self) -> Self\nReturns the value with lesser magnitude.\nstatic func maximum(Self, Self) -> Self\nReturns the greater of the two given values."
  },
  {
    "title": "significand | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/significand",
    "html": "Discussion\n\nThe magnitude of a floating-point value x of type F can be calculated by using the following formula, where ** is exponentiation:\n\nx.significand * (F.radix ** x.exponent)\n\n\nIn the next example, y has a value of 21.5, which is encoded as 1.34375 * 2 ** 4. The significand of y is therefore 1.34375.\n\nlet y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2\n\n\nIf a type’s radix is 2, then for finite nonzero numbers, the significand is in the range 1.0 ..< 2.0. For other values of x, x.significand is defined as follows:\n\nIf x is zero, then x.significand is 0.0.\n\nIf x is infinite, then x.significand is infinity.\n\nIf x is NaN, then x.significand is NaN.\n\nNote\n\nThe significand is frequently also called the mantissa, but significand is the preferred terminology in the IEEE 754 specification, to allay confusion with the use of mantissa for the fractional part of a logarithm.\n\nSee Also\nQuerying a Double\nvar ulp: Double\nThe unit in the last place of this value.\nvar exponent: Int\nThe exponent of the floating-point value.\nvar nextUp: Double\nThe least representable value that compares greater than this value.\nvar nextDown: Self\nThe greatest representable value that compares less than this value.\nvar binade: Double\nThe floating-point value with the same sign and exponent as this value, but with a significand of 1.0."
  },
  {
    "title": "sign | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/sign",
    "html": "Discussion\n\nThe sign property is .minus if the value’s signbit is set, and .plus otherwise. For example:\n\nlet x = -33.375\n// x.sign == .minus\n\n\nDon’t use this property to check whether a floating point value is negative. For a value x, the comparison x.sign == .minus is not necessarily the same as x < 0. In particular, x.sign == .minus if x is -0, and while x < 0 is always false if x is NaN, x.sign could be either .plus or .minus.\n\nSee Also\nFinding the Sign and Magnitude\nvar magnitude: Double\nThe magnitude of this value.\ntypealias Magnitude\nA type that can represent the absolute value of any possible value of the conforming type."
  },
  {
    "title": "ulp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/ulp",
    "html": "Discussion\n\nThis is the unit of the least significant digit in this value’s significand. For most numbers x, this is the difference between x and the next greater (in magnitude) representable number. There are some edge cases to be aware of:\n\nIf x is not a finite number, then x.ulp is NaN.\n\nIf x is very small in magnitude, then x.ulp may be a subnormal number. If a type does not support subnormals, x.ulp may be rounded to zero.\n\ngreatestFiniteMagnitude.ulp is a finite number, even though the next greater representable value is infinity.\n\nSee also the ulpOfOne static property.\n\nSee Also\nQuerying a Double\nvar significand: Double\nThe significand of the floating-point value.\nvar exponent: Int\nThe exponent of the floating-point value.\nvar nextUp: Double\nThe least representable value that compares greater than this value.\nvar nextDown: Self\nThe greatest representable value that compares less than this value.\nvar binade: Double\nThe floating-point value with the same sign and exponent as this value, but with a significand of 1.0."
  },
  {
    "title": "exponent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/exponent-swift.property",
    "html": "Discussion\n\nThe exponent of a floating-point value is the integer part of the logarithm of the value’s magnitude. For a value x of a floating-point type F, the magnitude can be calculated as the following, where ** is exponentiation:\n\nx.significand * (F.radix ** x.exponent)\n\n\nIn the next example, y has a value of 21.5, which is encoded as 1.34375 * 2 ** 4. The significand of y is therefore 1.34375.\n\nlet y: Double = 21.5\n// y.significand == 1.34375\n// y.exponent == 4\n// Double.radix == 2\n\n\nThe exponent property has the following edge cases:\n\nIf x is zero, then x.exponent is Int.min.\n\nIf x is +/-infinity or NaN, then x.exponent is Int.max\n\nThis property implements the logB operation defined by the IEEE 754 specification.\n\nSee Also\nQuerying a Double\nvar ulp: Double\nThe unit in the last place of this value.\nvar significand: Double\nThe significand of the floating-point value.\nvar nextUp: Double\nThe least representable value that compares greater than this value.\nvar nextDown: Self\nThe greatest representable value that compares less than this value.\nvar binade: Double\nThe floating-point value with the same sign and exponent as this value, but with a significand of 1.0."
  },
  {
    "title": "nextUp | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/nextup",
    "html": "Discussion\n\nFor any finite value x, x.nextUp is greater than x. For nan or infinity, x.nextUp is x itself. The following special cases also apply:\n\nIf x is -infinity, then x.nextUp is -greatestFiniteMagnitude.\n\nIf x is -leastNonzeroMagnitude, then x.nextUp is -0.0.\n\nIf x is zero, then x.nextUp is leastNonzeroMagnitude.\n\nIf x is greatestFiniteMagnitude, then x.nextUp is infinity.\n\nSee Also\nQuerying a Double\nvar ulp: Double\nThe unit in the last place of this value.\nvar significand: Double\nThe significand of the floating-point value.\nvar exponent: Int\nThe exponent of the floating-point value.\nvar nextDown: Self\nThe greatest representable value that compares less than this value.\nvar binade: Double\nThe floating-point value with the same sign and exponent as this value, but with a significand of 1.0."
  },
  {
    "title": "minimum(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/minimum(_:_:)",
    "html": "Parameters\nx\n\nA floating-point value.\n\ny\n\nAnother floating-point value.\n\nReturn Value\n\nThe minimum of x and y, or whichever is a number if the other is NaN.\n\nDiscussion\n\nThis method returns the minimum of two values, preserving order and eliminating NaN when possible. For two values x and y, the result of minimum(x, y) is x if x <= y, y if y < x, or whichever of x or y is a number if the other is a quiet NaN. If both x and y are NaN, or either x or y is a signaling NaN, the result is NaN.\n\nDouble.minimum(10.0, -25.0)\n// -25.0\nDouble.minimum(10.0, .nan)\n// 10.0\nDouble.minimum(.nan, -25.0)\n// -25.0\nDouble.minimum(.nan, .nan)\n// nan\n\n\nThe minimum method implements the minNum operation defined by the IEEE 754 specification.\n\nSee Also\nComparing Values\nFloating-Point Operators for Double\nPerform arithmetic and bitwise operations or compare values.\nfunc isEqual(to: Double) -> Bool\nReturns a Boolean value indicating whether this instance is equal to the given value.\nfunc isLess(than: Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than the given value.\nfunc isLessThanOrEqualTo(Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than or equal to the given value.\nfunc isTotallyOrdered(belowOrEqualTo: Self) -> Bool\nReturns a Boolean value indicating whether this instance should precede or tie positions with the given value in an ascending sort.\nstatic func minimumMagnitude(Self, Self) -> Self\nReturns the value with lesser magnitude.\nstatic func maximum(Self, Self) -> Self\nReturns the greater of the two given values.\nstatic func maximumMagnitude(Self, Self) -> Self\nReturns the value with greater magnitude."
  },
  {
    "title": "isLessThanOrEqualTo(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/islessthanorequalto(_:)",
    "html": "Parameters\nother\n\nThe value to compare with this value.\n\nReturn Value\n\ntrue if other is greater than this value; otherwise, false. If either this value or other is NaN, the result of this method is false.\n\nDiscussion\n\nThis method serves as the basis for the less-than-or-equal-to operator (<=) for floating-point values. Some special cases apply:\n\nBecause NaN is incomparable with any value, this method returns false when called on NaN or when NaN is passed as other.\n\n-infinity compares less than or equal to all values except NaN.\n\nEvery value except NaN compares less than or equal to +infinity.\n\nlet x = 15.0 x.isLessThanOrEqualTo(20.0) // true x.isLessThanOrEqualTo(.nan) // false Double.nan.isLessThanOrEqualTo(x) // false\n\nThe isLessThanOrEqualTo(_:) method implements the less-than-or-equal predicate defined by the IEEE 754 specification.\n\nSee Also\nComparing Values\nFloating-Point Operators for Double\nPerform arithmetic and bitwise operations or compare values.\nfunc isEqual(to: Double) -> Bool\nReturns a Boolean value indicating whether this instance is equal to the given value.\nfunc isLess(than: Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than the given value.\nfunc isTotallyOrdered(belowOrEqualTo: Self) -> Bool\nReturns a Boolean value indicating whether this instance should precede or tie positions with the given value in an ascending sort.\nstatic func minimum(Self, Self) -> Self\nReturns the lesser of the two given values.\nstatic func minimumMagnitude(Self, Self) -> Self\nReturns the value with lesser magnitude.\nstatic func maximum(Self, Self) -> Self\nReturns the greater of the two given values.\nstatic func maximumMagnitude(Self, Self) -> Self\nReturns the value with greater magnitude."
  },
  {
    "title": "isTotallyOrdered(belowOrEqualTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/istotallyordered(beloworequalto:)",
    "html": "Parameters\nother\n\nA floating-point value to compare to this value.\n\nReturn Value\n\ntrue if this value is ordered below or the same as other in a total ordering of the floating-point type; otherwise, false.\n\nDiscussion\n\nThis relation is a refinement of the less-than-or-equal-to operator (<=) that provides a total order on all values of the type, including signed zeros and NaNs.\n\nThe following example uses isTotallyOrdered(belowOrEqualTo:) to sort an array of floating-point values, including some that are NaN:\n\nvar numbers = [2.5, 21.25, 3.0, .nan, -9.5]\nnumbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }\nprint(numbers)\n// Prints \"[-9.5, 2.5, 3.0, 21.25, nan]\"\n\n\nThe isTotallyOrdered(belowOrEqualTo:) method implements the total order relation as defined by the IEEE 754 specification.\n\nSee Also\nComparing Values\nFloating-Point Operators for Double\nPerform arithmetic and bitwise operations or compare values.\nfunc isEqual(to: Double) -> Bool\nReturns a Boolean value indicating whether this instance is equal to the given value.\nfunc isLess(than: Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than the given value.\nfunc isLessThanOrEqualTo(Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than or equal to the given value.\nstatic func minimum(Self, Self) -> Self\nReturns the lesser of the two given values.\nstatic func minimumMagnitude(Self, Self) -> Self\nReturns the value with lesser magnitude.\nstatic func maximum(Self, Self) -> Self\nReturns the greater of the two given values.\nstatic func maximumMagnitude(Self, Self) -> Self\nReturns the value with greater magnitude."
  },
  {
    "title": "exponentBitPattern | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/exponentbitpattern",
    "html": "Discussion\n\nThis value is unadjusted by the type’s exponent bias.\n\nSee Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawSignificand\nA type that represents the encoded significand of a value.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "significandBitCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/significandbitcount",
    "html": "Discussion\n\nFor fixed-width floating-point types, this is the actual number of fractional significand bits.\n\nFor extensible floating-point types, significandBitCount should be the maximum allowed significand width (without counting any leading integral bit of the significand). If there is no upper limit, then significandBitCount should be Int.max.\n\nNote that Float80.significandBitCount is 63, even though 64 bits are used to store the significand in the memory representation of a Float80 (unlike other floating-point types, Float80 explicitly stores the leading integral significand bit, but the BinaryFloatingPoint APIs provide an abstraction so that users don’t need to be aware of this detail).\n\nSee Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawSignificand\nA type that represents the encoded significand of a value.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "exponentBitCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/exponentbitcount",
    "html": "Discussion\n\nA binary floating-point type’s exponentBitCount imposes a limit on the range of the exponent for normal, finite values. The exponent bias of a type F can be calculated as the following, where ** is exponentiation:\n\nlet bias = 2 ** (F.exponentBitCount - 1) - 1\n\n\nThe least normal exponent for values of the type F is 1 - bias, and the largest finite exponent is bias. An all-zeros exponent is reserved for subnormals and zeros, and an all-ones exponent is reserved for infinity and NaN.\n\nFor example, the Float type has an exponentBitCount of 8, which gives an exponent bias of 127 by the calculation above.\n\nlet bias = 2 ** (Float.exponentBitCount - 1) - 1\n// bias == 127\nprint(Float.greatestFiniteMagnitude.exponent)\n// Prints \"127\"\nprint(Float.leastNormalMagnitude.exponent)\n// Prints \"-126\"\n\nSee Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawSignificand\nA type that represents the encoded significand of a value.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "Double.RawSignificand | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/rawsignificand",
    "html": "See Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "Double.RawExponent | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/rawexponent",
    "html": "See Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawSignificand\nA type that represents the encoded significand of a value."
  },
  {
    "title": "significandWidth | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/significandwidth",
    "html": "Discussion\n\nIf this value is a finite nonzero number, significandWidth is the number of fractional bits required to represent the value of significand; otherwise, significandWidth is -1. The value of significandWidth is always -1 or between zero and significandBitCount. For example:\n\nFor any representable power of two, significandWidth is zero, because significand is 1.0.\n\nIf x is 10, x.significand is 1.01 in binary, so x.significandWidth is 2.\n\nIf x is Float.pi, x.significand is 1.10010010000111111011011 in binary, and x.significandWidth is 23.\n\nSee Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)\nCreates a new instance from the specified sign and bit patterns.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawSignificand\nA type that represents the encoded significand of a value.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "binade | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/binade",
    "html": "Discussion\n\nA binade is a set of binary floating-point values that all have the same sign and exponent. The binade property is a member of the same binade as this value, but with a unit significand.\n\nIn this example, x has a value of 21.5, which is stored as 1.34375 * 2**4, where ** is exponentiation. Therefore, x.binade is equal to 1.0 * 2**4, or 16.0.\n\nlet x = 21.5\n// x.significand == 1.34375\n// x.exponent == 4\n\n\nlet y = x.binade\n// y == 16.0\n// y.significand == 1.0\n// y.exponent == 4\n\nSee Also\nQuerying a Double\nvar ulp: Double\nThe unit in the last place of this value.\nvar significand: Double\nThe significand of the floating-point value.\nvar exponent: Int\nThe exponent of the floating-point value.\nvar nextUp: Double\nThe least representable value that compares greater than this value.\nvar nextDown: Self\nThe greatest representable value that compares less than this value."
  },
  {
    "title": "init(sign:exponentBitPattern:significandBitPattern:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/init(sign:exponentbitpattern:significandbitpattern:)",
    "html": "Parameters\nsign\n\nThe sign of the new value.\n\nexponentBitPattern\n\nThe bit pattern to use for the exponent field of the new value.\n\nsignificandBitPattern\n\nThe bit pattern to use for the significand field of the new value.\n\nDiscussion\n\nThe values passed as exponentBitPattern and significandBitPattern are interpreted in the binary interchange format defined by the IEEE 754 specification.\n\nSee Also\nWorking with Binary Representation\nvar bitPattern: UInt64\nThe bit pattern of the value’s encoding.\nvar significandBitPattern: UInt64\nThe raw encoding of the value’s significand field.\nvar significandWidth: Int\nThe number of bits required to represent the value’s significand.\nvar exponentBitPattern: UInt\nThe raw encoding of the value’s exponent field.\nstatic var significandBitCount: Int\nThe available number of fractional significand bits.\nstatic var exponentBitCount: Int\nThe number of bits used to represent the type’s exponent.\nstatic var radix: Int\nThe radix, or base of exponentiation, for a floating-point type.\ninit(bitPattern: UInt64)\nCreates a new value with the given bit pattern.\ninit(nan: Double.RawSignificand, signaling: Bool)\nCreates a NaN (“not a number”) value with the specified payload.\ntypealias Exponent\nA type that can represent any written exponent.\ntypealias RawSignificand\nA type that represents the encoded significand of a value.\ntypealias RawExponent\nA type that represents the encoded exponent of a value."
  },
  {
    "title": "zero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/zero",
    "html": "Discussion\n\nZero is the identity element for addition. For any value, x + .zero == x and .zero + x == x.\n\nSee Also\nAccessing Numeric Constants\nstatic var pi: Double\nThe mathematical constant pi (π), approximately equal to 3.14159.\nstatic var infinity: Double\nPositive infinity.\nstatic var greatestFiniteMagnitude: Double\nThe greatest finite number representable by this type.\nstatic var nan: Double\nA quiet NaN (“not a number”).\nstatic var signalingNaN: Double\nA signaling NaN (“not a number”).\nstatic var ulpOfOne: Double\nThe unit in the last place of 1.0.\nstatic var leastNonzeroMagnitude: Double\nThe least positive number.\nstatic var leastNormalMagnitude: Double\nThe least positive normal number."
  },
  {
    "title": "debugDescription | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/debugdescription",
    "html": "Discussion\n\nThis property has the same value as the description property, except that NaN values are printed in an extended format.\n\nSee Also\nDescribing a Double\nvar description: String\nA textual representation of the value.\nvar customMirror: Mirror\nA mirror that reflects the Double instance.\nfunc hash(into: inout Hasher)\nHashes the essential components of this value by feeding them into the given hasher."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/-=(_:_:)-2aqsq",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "init(floatLiteral:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/init(floatliteral:)",
    "html": "Parameters\nvalue\n\nThe value to create.\n\nDiscussion\n\nDo not call this initializer directly. Instead, initialize a variable or constant using a floating-point literal. For example:\n\nlet x = 21.5\n\n\nIn this example, the assignment to the x constant calls this floating-point literal initializer behind the scenes.\n\nSee Also\nInfrequently Used Functionality\ninit()\ninit(integerLiteral: Int64)\nCreates an instance initialized to the specified integer value.\ninit(integerLiteral: Self)\nCreates an instance initialized to the specified integer value.\nAvailable when Self conforms to _ExpressibleByBuiltinIntegerLiteral.\ntypealias FloatLiteralType\nA type that represents a floating-point literal.\ntypealias IntegerLiteralType\nA type that represents an integer literal.\nfunc advanced(by: Double) -> Double\nReturns a value that is offset the specified distance from this value.\nfunc distance(to: Double) -> Double\nReturns the distance from this value to the given value, expressed as a stride.\ntypealias Stride\nA type that represents the distance between two values.\nfunc write<Target>(to: inout Target)\nWrites a textual representation of this instance into the given output stream.\nvar hashValue: Int\nThe hash value."
  },
  {
    "title": "isSubnormal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/issubnormal",
    "html": "Discussion\n\nA subnormal value is a nonzero number that has a lesser magnitude than the smallest normal number. Subnormal values don’t use the full precision available to values of a type.\n\nZero is neither a normal nor a subnormal number. Subnormal numbers are often called denormal or denormalized—these are different names for the same concept.\n\nSee Also\nQuerying a Double’s State\nvar isZero: Bool\nA Boolean value indicating whether the instance is equal to zero.\nvar isFinite: Bool\nA Boolean value indicating whether this instance is finite.\nvar isInfinite: Bool\nA Boolean value indicating whether the instance is infinite.\nvar isNaN: Bool\nA Boolean value indicating whether the instance is NaN (“not a number”).\nvar isSignalingNaN: Bool\nA Boolean value indicating whether the instance is a signaling NaN.\nvar isNormal: Bool\nA Boolean value indicating whether this instance is normal.\nvar isCanonical: Bool\nA Boolean value indicating whether the instance’s representation is in its canonical form.\nvar floatingPointClass: FloatingPointClassification\nThe classification of this value."
  },
  {
    "title": "isZero | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/iszero",
    "html": "Discussion\n\nThe isZero property of a value x is true when x represents either -0.0 or +0.0. x.isZero is equivalent to the following comparison: x == 0.0.\n\nlet x = -0.0\nx.isZero        // true\nx == 0.0        // true\n\nSee Also\nQuerying a Double’s State\nvar isFinite: Bool\nA Boolean value indicating whether this instance is finite.\nvar isInfinite: Bool\nA Boolean value indicating whether the instance is infinite.\nvar isNaN: Bool\nA Boolean value indicating whether the instance is NaN (“not a number”).\nvar isSignalingNaN: Bool\nA Boolean value indicating whether the instance is a signaling NaN.\nvar isNormal: Bool\nA Boolean value indicating whether this instance is normal.\nvar isSubnormal: Bool\nA Boolean value indicating whether the instance is subnormal.\nvar isCanonical: Bool\nA Boolean value indicating whether the instance’s representation is in its canonical form.\nvar floatingPointClass: FloatingPointClassification\nThe classification of this value."
  },
  {
    "title": "encode(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/encode(to:)",
    "html": "Parameters\nencoder\n\nThe encoder to write data to.\n\nDiscussion\n\nThis function throws an error if any values are invalid for the given encoder’s format.\n\nSee Also\nEncoding and Decoding Values\ninit(from: Decoder) throws\nCreates a new instance by decoding from the given decoder."
  },
  {
    "title": "isSignalingNaN | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/issignalingnan",
    "html": "Discussion\n\nSignaling NaNs typically raise the Invalid flag when used in general computing operations.\n\nSee Also\nQuerying a Double’s State\nvar isZero: Bool\nA Boolean value indicating whether the instance is equal to zero.\nvar isFinite: Bool\nA Boolean value indicating whether this instance is finite.\nvar isInfinite: Bool\nA Boolean value indicating whether the instance is infinite.\nvar isNaN: Bool\nA Boolean value indicating whether the instance is NaN (“not a number”).\nvar isNormal: Bool\nA Boolean value indicating whether this instance is normal.\nvar isSubnormal: Bool\nA Boolean value indicating whether the instance is subnormal.\nvar isCanonical: Bool\nA Boolean value indicating whether the instance’s representation is in its canonical form.\nvar floatingPointClass: FloatingPointClassification\nThe classification of this value."
  },
  {
    "title": "isNaN | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/isnan",
    "html": "Discussion\n\nBecause NaN is not equal to any value, including NaN, use this property instead of the equal-to operator (==) or not-equal-to operator (!=) to test whether a value is or is not NaN. For example:\n\nlet x = 0.0\nlet y = x * .infinity\n// y is a NaN\n\n\n// Comparing with the equal-to operator never returns 'true'\nprint(x == Double.nan)\n// Prints \"false\"\nprint(y == Double.nan)\n// Prints \"false\"\n\n\n// Test with the 'isNaN' property instead\nprint(x.isNaN)\n// Prints \"false\"\nprint(y.isNaN)\n// Prints \"true\"\n\n\nThis property is true for both quiet and signaling NaNs.\n\nSee Also\nQuerying a Double’s State\nvar isZero: Bool\nA Boolean value indicating whether the instance is equal to zero.\nvar isFinite: Bool\nA Boolean value indicating whether this instance is finite.\nvar isInfinite: Bool\nA Boolean value indicating whether the instance is infinite.\nvar isSignalingNaN: Bool\nA Boolean value indicating whether the instance is a signaling NaN.\nvar isNormal: Bool\nA Boolean value indicating whether this instance is normal.\nvar isSubnormal: Bool\nA Boolean value indicating whether the instance is subnormal.\nvar isCanonical: Bool\nA Boolean value indicating whether the instance’s representation is in its canonical form.\nvar floatingPointClass: FloatingPointClassification\nThe classification of this value."
  },
  {
    "title": "isNormal | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/isnormal",
    "html": "Discussion\n\nA normal value is a finite number that uses the full precision available to values of a type. Zero is neither a normal nor a subnormal number.\n\nSee Also\nQuerying a Double’s State\nvar isZero: Bool\nA Boolean value indicating whether the instance is equal to zero.\nvar isFinite: Bool\nA Boolean value indicating whether this instance is finite.\nvar isInfinite: Bool\nA Boolean value indicating whether the instance is infinite.\nvar isNaN: Bool\nA Boolean value indicating whether the instance is NaN (“not a number”).\nvar isSignalingNaN: Bool\nA Boolean value indicating whether the instance is a signaling NaN.\nvar isSubnormal: Bool\nA Boolean value indicating whether the instance is subnormal.\nvar isCanonical: Bool\nA Boolean value indicating whether the instance’s representation is in its canonical form.\nvar floatingPointClass: FloatingPointClassification\nThe classification of this value."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/flatmap(_:)-98frp",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/map(_:)-gcmy",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "+(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/+(_:)",
    "html": "Return Value\n\nThe given argument without any changes.\n\nDiscussion\n\nYou can use the unary plus operator (+) to provide symmetry in your code for positive numbers when also using the unary minus operator.\n\nlet x = -21\nlet y = +21\n// x == -21\n// y == 21\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/flatmap(_:)-4v65l",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/map(_:)-5paur",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/zip2sequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "nextDown | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/nextdown",
    "html": "Discussion\n\nFor any finite value x, x.nextDown is less than x. For nan or -infinity, x.nextDown is x itself. The following special cases also apply:\n\nIf x is infinity, then x.nextDown is greatestFiniteMagnitude.\n\nIf x is leastNonzeroMagnitude, then x.nextDown is 0.0.\n\nIf x is zero, then x.nextDown is -leastNonzeroMagnitude.\n\nIf x is -greatestFiniteMagnitude, then x.nextDown is -infinity.\n\nSee Also\nQuerying a Double\nvar ulp: Double\nThe unit in the last place of this value.\nvar significand: Double\nThe significand of the floating-point value.\nvar exponent: Int\nThe exponent of the floating-point value.\nvar nextUp: Double\nThe least representable value that compares greater than this value.\nvar binade: Double\nThe floating-point value with the same sign and exponent as this value, but with a significand of 1.0."
  },
  {
    "title": "infinity | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/infinity",
    "html": "Discussion\n\nInfinity compares greater than all finite numbers and equal to other infinite values.\n\nlet x = Double.greatestFiniteMagnitude\nlet y = x * 2\n// y == Double.infinity\n// y > x\n\nSee Also\nAccessing Numeric Constants\nstatic var pi: Double\nThe mathematical constant pi (π), approximately equal to 3.14159.\nstatic var greatestFiniteMagnitude: Double\nThe greatest finite number representable by this type.\nstatic var nan: Double\nA quiet NaN (“not a number”).\nstatic var signalingNaN: Double\nA signaling NaN (“not a number”).\nstatic var ulpOfOne: Double\nThe unit in the last place of 1.0.\nstatic var leastNonzeroMagnitude: Double\nThe least positive number.\nstatic var leastNormalMagnitude: Double\nThe least positive normal number.\nstatic var zero: Self\nThe zero value.\nAvailable when Self conforms to ExpressibleByIntegerLiteral."
  },
  {
    "title": "pi | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/pi",
    "html": "Discussion\n\nWhen measuring an angle in radians, π is equivalent to a half-turn.\n\nThis value is rounded toward zero to keep user computations with angles from inadvertently ending up in the wrong quadrant. A type that conforms to the FloatingPoint protocol provides the value for pi at its best possible precision.\n\nprint(Double.pi)\n// Prints \"3.14159265358979\"\n\nSee Also\nAccessing Numeric Constants\nstatic var infinity: Double\nPositive infinity.\nstatic var greatestFiniteMagnitude: Double\nThe greatest finite number representable by this type.\nstatic var nan: Double\nA quiet NaN (“not a number”).\nstatic var signalingNaN: Double\nA signaling NaN (“not a number”).\nstatic var ulpOfOne: Double\nThe unit in the last place of 1.0.\nstatic var leastNonzeroMagnitude: Double\nThe least positive number.\nstatic var leastNormalMagnitude: Double\nThe least positive normal number.\nstatic var zero: Self\nThe zero value.\nAvailable when Self conforms to ExpressibleByIntegerLiteral."
  },
  {
    "title": "round(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/round(_:)",
    "html": "Parameters\nrule\n\nThe rounding rule to use.\n\nDiscussion\n\nThe following example rounds a value using four different rounding rules:\n\n// Equivalent to the C 'round' function:\nvar w = 6.5\nw.round(.toNearestOrAwayFromZero)\n// w == 7.0\n\n\n// Equivalent to the C 'trunc' function:\nvar x = 6.5\nx.round(.towardZero)\n// x == 6.0\n\n\n// Equivalent to the C 'ceil' function:\nvar y = 6.5\ny.round(.up)\n// y == 7.0\n\n\n// Equivalent to the C 'floor' function:\nvar z = 6.5\nz.round(.down)\n// z == 6.0\n\n\nFor more information about the available rounding rules, see the FloatingPointRoundingRule enumeration. To round a value using the default “schoolbook rounding”, you can use the shorter round() method instead.\n\nvar w1 = 6.5\nw1.round()\n// w1 == 7.0\n\nSee Also\nRounding Values\nfunc rounded() -> Self\nfunc rounded(FloatingPointRoundingRule) -> Self\nReturns this value rounded to an integral value using the specified rounding rule.\nfunc round()"
  },
  {
    "title": "*(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/*(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply.\n\nDiscussion\n\nThe multiplication operator (*) calculates the product of its two arguments. For example:\n\nlet x = 7.5\nlet y = x * 2.25\n// y == 16.875\n\n\nThe * operator implements the multiplication operation defined by the IEEE 754 specification."
  },
  {
    "title": "isEqual(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/isequal(to:)",
    "html": "Parameters\nother\n\nThe value to compare with this value.\n\nReturn Value\n\ntrue if other has the same value as this instance; otherwise, false. If either this value or other is NaN, the result of this method is false.\n\nDiscussion\n\nThis method serves as the basis for the equal-to operator (==) for floating-point values. When comparing two values with this method, -0 is equal to +0. NaN is not equal to any value, including itself. For example:\n\nlet x = 15.0\nx.isEqual(to: 15.0)\n// true\nx.isEqual(to: .nan)\n// false\nDouble.nan.isEqual(to: .nan)\n// false\n\n\nThe isEqual(to:) method implements the equality predicate defined by the IEEE 754 specification.\n\nSee Also\nComparing Values\nFloating-Point Operators for Double\nPerform arithmetic and bitwise operations or compare values.\nfunc isLess(than: Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than the given value.\nfunc isLessThanOrEqualTo(Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than or equal to the given value.\nfunc isTotallyOrdered(belowOrEqualTo: Self) -> Bool\nReturns a Boolean value indicating whether this instance should precede or tie positions with the given value in an ascending sort.\nstatic func minimum(Self, Self) -> Self\nReturns the lesser of the two given values.\nstatic func minimumMagnitude(Self, Self) -> Self\nReturns the value with lesser magnitude.\nstatic func maximum(Self, Self) -> Self\nReturns the greater of the two given values.\nstatic func maximumMagnitude(Self, Self) -> Self\nReturns the value with greater magnitude."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/+=(_:_:)-xp5w",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/'...(_:)-6ct5v",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nDiscussion\n\nUse the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.\n\nlet atLeastFive = 5.0...\n\n\natLeastFive.contains(4.0)     // false\natLeastFive.contains(5.0)     // true\natLeastFive.contains(6.0)     // true\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[3...])\n// Prints \"[40, 50, 60, 70]\"\n\n\nPrecondition\n\nminimum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/enumeratedsequence/iterator/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil."
  },
  {
    "title": "-(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/-(_:_:)",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs.\n\nDiscussion\n\nThe subtraction operator (-) calculates the difference of its two arguments. For example:\n\nlet x = 7.5\nlet y = x - 2.25\n// y == 5.25\n\n\nThe - operator implements the subtraction operation defined by the IEEE 754 specification."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/+(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add.\n\nDiscussion\n\nThe addition operator (+) calculates the sum of its two arguments. For example:\n\nlet x = 1.5\nlet y = x + 2.25\n// y == 3.75\n\n\nThe + operator implements the addition operation defined by the IEEE 754 specification."
  },
  {
    "title": "...(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/'...(_:)-4mm67",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.\n\nlet throughFive = ...5.0\n\n\nthroughFive.contains(4.0)     // true\nthroughFive.contains(5.0)     // true\nthroughFive.contains(6.0)     // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[...3])\n// Prints \"[10, 20, 30, 40]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "isLess(than:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/isless(than:)",
    "html": "Parameters\nother\n\nThe value to compare with this value.\n\nReturn Value\n\ntrue if this value is less than other; otherwise, false. If either this value or other is NaN, the result of this method is false.\n\nDiscussion\n\nThis method serves as the basis for the less-than operator (<) for floating-point values. Some special cases apply:\n\nBecause NaN compares not less than nor greater than any value, this method returns false when called on NaN or when NaN is passed as other.\n\n-infinity compares less than all values except for itself and NaN.\n\nEvery value except for NaN and +infinity compares less than +infinity.\n\nlet x = 15.0 x.isLess(than: 20.0) // true x.isLess(than: .nan) // false Double.nan.isLess(than: x) // false\n\nThe isLess(than:) method implements the less-than predicate defined by the IEEE 754 specification.\n\nSee Also\nComparing Values\nFloating-Point Operators for Double\nPerform arithmetic and bitwise operations or compare values.\nfunc isEqual(to: Double) -> Bool\nReturns a Boolean value indicating whether this instance is equal to the given value.\nfunc isLessThanOrEqualTo(Double) -> Bool\nReturns a Boolean value indicating whether this instance is less than or equal to the given value.\nfunc isTotallyOrdered(belowOrEqualTo: Self) -> Bool\nReturns a Boolean value indicating whether this instance should precede or tie positions with the given value in an ascending sort.\nstatic func minimum(Self, Self) -> Self\nReturns the lesser of the two given values.\nstatic func minimumMagnitude(Self, Self) -> Self\nReturns the value with lesser magnitude.\nstatic func maximum(Self, Self) -> Self\nReturns the greater of the two given values.\nstatic func maximumMagnitude(Self, Self) -> Self\nReturns the value with greater magnitude."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/==(_:_:)-12hdv",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "*=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/*=(_:_:)",
    "html": "Parameters\nlhs\n\nThe first value to multiply.\n\nrhs\n\nThe second value to multiply."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/withcontiguousstorageifavailable(_:)-1c2pv",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/flatmap(_:)-7hnem",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/map(_:)-75jtq",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/removefirst()",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/subscript(_:)-6liln",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "Substring.UTF8View.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "init(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/init(from:)-5gnqe",
    "html": "See Also\nUsing a Double as a Data Value\nvar dataValue: MLDataValue\nThe value of the conforming type’s instance wrapped in a data value.\nstatic var dataValueType: MLDataValue.ValueType\nThe underlying type the conforming type uses when it wraps itself in a data value."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/+=(_:_:)-5g9j0",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "Double.Magnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/magnitude-swift.typealias",
    "html": "See Also\nFinding the Sign and Magnitude\nvar magnitude: Double\nThe magnitude of this value.\nvar sign: FloatingPointSign\nThe sign of the floating-point value."
  },
  {
    "title": "magnitude | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/magnitude-swift.property",
    "html": "Discussion\n\nFor any numeric value x, x.magnitude is the absolute value of x. You can use the magnitude property in operations that are simpler to implement in terms of unsigned values, such as printing the value of an integer, which is just printing a ‘-’ character in front of an absolute value.\n\nlet x = -200\n// x.magnitude == 200\n\n\nThe global abs(_:) function provides more familiar syntax when you need to find an absolute value. In addition, because abs(_:) always returns a value of the same type, even in a generic context, using the function instead of the magnitude property is encouraged.\n\nSee Also\nFinding the Sign and Magnitude\nvar sign: FloatingPointSign\nThe sign of the floating-point value.\ntypealias Magnitude\nA type that can represent the absolute value of any possible value of the conforming type."
  },
  {
    "title": "dataValue | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/datavalue",
    "html": "See Also\nUsing a Double as a Data Value\ninit?(from: MLDataValue)\nCreates an instance of the conforming type from a data value.\nstatic var dataValueType: MLDataValue.ValueType\nThe underlying type the conforming type uses when it wraps itself in a data value."
  },
  {
    "title": "dataValueType | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/double/datavaluetype",
    "html": "Discussion\n\nSee MLDataValue/ValueType for a list of available options.\n\nSee Also\nUsing a Double as a Data Value\ninit?(from: MLDataValue)\nCreates an instance of the conforming type from a data value.\nvar dataValue: MLDataValue\nThe value of the conforming type’s instance wrapped in a data value."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/taskgroup/iterator/next()",
    "html": "Return Value\n\nThe value returned by the next child task that completes, or nil if there are no remaining child tasks,\n\nDiscussion\n\nThe elements returned from this method appear in the order that the tasks completed, not in the order that those tasks were added to the task group. After this method returns nil, this iterator is guaranteed to never produce more values.\n\nFor more information about the iteration order and semantics, see TaskGroup.next()."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/flatmap(_:)-3zvpt",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/startindex",
    "html": "Discussion\n\nIf the collection is empty, startIndex is equal to endIndex."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be nonuniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can result in an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/joined(separator:)-6sxlg",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/formindex(before:)-d9pr",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/formindex(before:)-8t0c6",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/withcontiguousstorageifavailable(_:)-7usx4",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/subscript(_:)-7hfz9",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nFor example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2..<5]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")!    // 4\nprint(streets[index])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "Substring.UTF8View.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/subscript(_:)-goc1",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nOverview\n\nThe following example accesses an element of an array through its subscript to print its value:\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nprint(streets[1])\n// Prints \"Bryant\"\n\n\nYou can subscript a collection with any valid index other than the collection’s end index. The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "Substring.UTF8View.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/removefirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "popFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/popfirst()",
    "html": "Return Value\n\nThe first element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/map(_:)-8dvkm",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "Unicode.Scalar.UTF16View.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removelast()-29ty4",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty. To remove the last element of a collection that might be empty, use the popLast() method instead.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/endindex",
    "html": "Discussion\n\nWhen you need a range that includes the last element of a collection, use the half-open range operator (..<) with endIndex. The ..< operator creates a range that doesn’t include the upper bound, so it’s always safe to use with endIndex. For example:\n\nlet numbers = [10, 20, 30, 40, 50]\nif let index = numbers.firstIndex(of: 30) {\n    print(numbers[index ..< numbers.endIndex])\n}\n// Prints \"[30, 40, 50]\"\n\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removelast(_:)-4ijd6",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to remove."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/poplast()-7zlp7",
    "html": "Return Value\n\nThe last element of the collection if the collection has one or more elements; otherwise, nil.\n\nDiscussion\n\nYou can use popLast() to remove the last element of a collection that might be empty. The removeLast() method must be used only on a nonempty collection.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/startindex",
    "html": "Discussion\n\nIn an empty collection, startIndex == endIndex."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/map(_:)-4ki2y",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "Unicode.Scalar.UTF16View.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "Unicode.Scalar.UTF16View.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Calculating count can be an O(n) operation.\n\nComplexity\n\nO(n)"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/flatmap(_:)-5r882",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/split(separator:maxsplits:omittingemptysubsequences:)-20tfq",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/map(_:)-1hqcj",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/flatmap(_:)-9p8z7",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "Substring.UTF16View.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/map(_:)-96pv6",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "AnyCollection.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "AnyCollection.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/endindex",
    "html": "Discussion\n\nendIndex is always reachable from startIndex by zero or more applications of index(after:)."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "popFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/popfirst()",
    "html": "Return Value\n\nThe first element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/map(_:)-1oqgs",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "AnyCollection.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/subscript(_:)-t0ed",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/startindex",
    "html": "Discussion\n\nIf the collection is empty, startIndex is equal to endIndex."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/subscript(_:)-vb3o",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nFor example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2..<5]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")!    // 4\nprint(streets[index])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/endindex",
    "html": "Discussion\n\nWhen you need a range that includes the last element of a collection, use the half-open range operator (..<) with endIndex. The ..< operator creates a range that doesn’t include the upper bound, so it’s always safe to use with endIndex. For example:\n\nlet numbers = [10, 20, 30, 40, 50]\nif let index = numbers.firstIndex(of: 30) {\n    print(numbers[index ..< numbers.endIndex])\n}\n// Prints \"[30, 40, 50]\"\n\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/joined(separator:)-476fl",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/map(_:)-861dy",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/joined(separator:)-3o2fu",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/withcontiguousstorageifavailable(_:)-76evi",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/subscript(_:)-2ljg7",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/removefirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/removefirst()",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "Substring.UTF16View.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "Substring.UTF16View.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/split(separator:maxsplits:omittingemptysubsequences:)-52osm",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/removefirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/removefirst()",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anycollection/subscript(_:)-87z1l",
    "html": "Overview\n\nPrecondition\n\nposition indicates a valid position in self and position != endIndex."
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/removelast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to remove."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/flatmap(_:)-8dzxi",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/poplast()",
    "html": "Return Value\n\nThe last element of the collection if the collection has one or more elements; otherwise, nil.\n\nDiscussion\n\nYou can use popLast() to remove the last element of a collection that might be empty. The removeLast() method must be used only on a nonempty collection.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/joined()-2byi",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/flatmap(_:)-45het",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/joined(separator:)-2rxv1",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/map(_:)-50dnw",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/joined(separator:)-3q8sb",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/withcontiguousstorageifavailable(_:)-n71z",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/split(separator:maxsplits:omittingemptysubsequences:)-533fk",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/map(_:)-xtjl",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "popFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/popfirst()",
    "html": "Return Value\n\nThe first element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/map(_:)-7a014",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/subscript(_:)-ketw",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nOverview\n\nThe following example accesses an element of an array through its subscript to print its value:\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nprint(streets[1])\n// Prints \"Bryant\"\n\n\nYou can subscript a collection with any valid index other than the collection’s end index. The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/endindex",
    "html": "Discussion\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/removelast()",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty. To remove the last element of a collection that might be empty, use the popLast() method instead.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/map(_:)-8lt3c",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/compactmap(_:)-33fyf",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/unicode/scalar/utf16view/subscript(_:)",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "removeAll(keepingCapacity:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removeall(keepingcapacity:)",
    "html": "Parameters\nkeepCapacity\n\nPass true to request that the collection avoid releasing its storage. Retaining the collection’s storage can be a useful optimization when you’re planning to grow the collection again. The default value is false.\n\nDiscussion\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf8view/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/map(_:)-23sio",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/map(_:)-4umsc",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/subscript(_:)-20thk",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint32/words-swift.struct/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint8/words-swift.struct/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint16/words-swift.struct/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "removeAll(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removeall(where:)-26lr3",
    "html": "Parameters\nshouldBeRemoved\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.\n\nDiscussion\n\nUse this method to remove every element in a collection that meets particular criteria. The order of the remaining elements is preserved. This example removes all the vowels from a string:\n\nvar phrase = \"The rain in Spain stays mainly in the plain.\"\n\n\nlet vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nphrase.removeAll(where: { vowels.contains($0) })\n// phrase == \"Th rn n Spn stys mnly n th pln.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removelast(_:)-75mgx",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(k), where k is the specified number of elements."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removefirst()-3eija",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/flatmap(_:)-2i1gn",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "reserveCapacity(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/reservecapacity(_:)",
    "html": "Parameters\nn\n\nThe requested number of elements to store.\n\nDiscussion\n\nIf you will be adding a known number of elements to a collection, use this method to avoid multiple reallocations. A type that conforms to RangeReplaceableCollection can choose how to respond when this method is called. Depending on the type, it may make sense to allocate more or less storage than requested or to take no action at all."
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/removelast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to remove."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/+(_:_:)-4resp",
    "html": "Parameters\nlhs\n\nA collection or finite sequence.\n\nrhs\n\nA range-replaceable collection.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of a Range<Int> instance and an integer array.\n\nlet numbers = [7, 8, 9, 10]\nlet moreNumbers = (1...6) + numbers\nprint(moreNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of argument on the right-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/replacesubrange(_:with:)-9le44",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, the complexity is O(m)."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/replacesubrange(_:with:)-8l6gb",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "replaceSubrange(_:with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/replacesubrange(_:with:)-zwfk",
    "html": "Parameters\nsubrange\n\nThe subrange of the collection to replace. The bounds of the range must be valid indices of the collection.\n\nnewElements\n\nThe new elements to add to the collection.\n\nDiscussion\n\nThis method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location. The number of new elements need not match the number of elements being removed.\n\nIn this example, three elements in the middle of an array of integers are replaced by the five elements of a Repeated<Int> instance.\n\n var nums = [10, 20, 30, 40, 50]\n nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))\n print(nums)\n // Prints \"[10, 1, 1, 1, 1, 1, 50]\"\n\n\nIf you pass a zero-length range as the subrange parameter, this method inserts the elements of newElements at subrange.startIndex. Calling the insert(contentsOf:at:) method instead is preferred.\n\nLikewise, if you pass a zero-length collection as the newElements parameter, this method removes the elements in the given subrange without replacement. Calling the removeSubrange(_:) method instead is preferred.\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If the call to this method simply appends the contents of newElements to the collection, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/+(_:_:)-298al",
    "html": "Parameters\nlhs\n\nA range-replaceable collection.\n\nrhs\n\nA collection or finite sequence.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of an integer array and a Range<Int> instance.\n\nlet numbers = [1, 2, 3, 4]\nlet moreNumbers = numbers + (5...10)\nprint(moreNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of the argument on the left-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": "+(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/+(_:_:)-99wuu",
    "html": "Parameters\nlhs\n\nA range-replaceable collection.\n\nrhs\n\nAnother range-replaceable collection.\n\nDiscussion\n\nThe two arguments must have the same Element type. For example, you can concatenate the elements of two integer arrays.\n\nlet lowerNumbers = [1, 2, 3, 4]\nlet higherNumbers: ContiguousArray = [5, 6, 7, 8, 9, 10]\nlet allNumbers = lowerNumbers + higherNumbers\nprint(allNumbers)\n// Prints \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\"\n\n\nThe resulting collection has the type of the argument on the left-hand side. In the example above, moreNumbers has the same type as numbers, which is [Int]."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/poplast()",
    "html": "Return Value\n\nThe last element of the collection if the collection has one or more elements; otherwise, nil.\n\nDiscussion\n\nYou can use popLast() to remove the last element of a collection that might be empty. The removeLast() method must be used only on a nonempty collection.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/removelast()",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty. To remove the last element of a collection that might be empty, use the popLast() method instead.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "Slice.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/init(_:)-4tbvj",
    "html": "Parameters\nelements\n\nThe sequence of elements for the new collection. elements must be finite."
  },
  {
    "title": "init(repeating:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/init(repeating:count:)-6ps4o",
    "html": "Parameters\nrepeatedValue\n\nThe element to repeat.\n\ncount\n\nThe number of times to repeat the value passed in the repeating parameter. count must be zero or greater.\n\nDiscussion\n\nThe following example creates an array initialized with five strings containing the letter Z.\n\nlet fiveZs = Array(repeating: \"Z\", count: 5)\nprint(fiveZs)\n// Prints \"[\"Z\", \"Z\", \"Z\", \"Z\", \"Z\"]\"\n"
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/+=(_:_:)",
    "html": "Parameters\nlhs\n\nThe array to append to.\n\nrhs\n\nA collection or finite sequence.\n\nDiscussion\n\nUse this operator to append the elements of a sequence to the end of range-replaceable collection with same Element type. This example appends the elements of a Range<Int> instance to an array of integers.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers += 10...15\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]\"\n\n\nComplexity\n\nO(m), where m is the length of the right-hand-side argument."
  },
  {
    "title": "append(contentsOf:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/append(contentsof:)",
    "html": "Parameters\nnewElements\n\nThe elements to append to the collection.\n\nDiscussion\n\nThe collection being appended to allocates any additional necessary storage to hold the new elements.\n\nThe following example appends the elements of a Range<Int> instance to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(contentsOf: 10...15)\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]\"\n\n\nComplexity\n\nO(m), where m is the length of newElements."
  },
  {
    "title": "init(repeating:count:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/init(repeating:count:)-6ps2q",
    "html": "Parameters\nrepeatedValue\n\nThe element to repeat.\n\ncount\n\nThe number of times to repeat the value passed in the repeating parameter. count must be zero or greater.\n\nDiscussion\n\nHere’s an example of creating an array initialized with five strings containing the letter Z.\n\nlet fiveZs = Array(repeating: \"Z\", count: 5)\nprint(fiveZs)\n// Prints \"[\"Z\", \"Z\", \"Z\", \"Z\", \"Z\"]\"\n"
  },
  {
    "title": "init(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/init(_:)-81eoy",
    "html": "Parameters\nelements\n\nThe sequence of elements for the new collection."
  },
  {
    "title": "applying(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/applying(_:)",
    "html": "Parameters\ndifference\n\nThe difference to be applied.\n\nReturn Value\n\nAn instance representing the state of the receiver with the difference applied, or nil if the difference is incompatible with the receiver’s state.\n\nDiscussion\n\nComplexity\n\nO(n + c), where n is self.count and c is the number of changes contained by the parameter."
  },
  {
    "title": "insert(contentsOf:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/insert(contentsof:at:)-25pep",
    "html": "Parameters\nnewElements\n\nThe new elements to insert into the collection.\n\ni\n\nThe position at which to insert the new elements. index must be a valid index of the collection.\n\nDiscussion\n\nThe new elements are inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new elements are appended to the collection.\n\nHere’s an example of inserting a range of integers into an array of the same type:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(contentsOf: 100...103, at: 3)\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 101, 102, 103, 4, 5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If i == endIndex, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "append(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/append(_:)",
    "html": "Parameters\nnewElement\n\nThe element to append to the collection.\n\nDiscussion\n\nIf the collection does not have sufficient capacity for another element, additional storage is allocated before appending newElement. The following example adds a new number to an array of integers:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.append(100)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 4, 5, 100]\"\n\n\nComplexity\n\nO(1) on average, over many calls to append(_:) on the same collection."
  },
  {
    "title": "insert(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/insert(_:at:)-8i1dc",
    "html": "Parameters\nnewElement\n\nThe new element to insert into the collection.\n\ni\n\nThe position at which to insert the new element. index must be a valid index into the collection.\n\nDiscussion\n\nThe new element is inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new element is appended to the collection.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(100, at: 3)\nnumbers.insert(200, at: numbers.endIndex)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 4, 5, 200]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection. If i == endIndex, this method is equivalent to append(_:)."
  },
  {
    "title": "insert(contentsOf:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/insert(contentsof:at:)-2xj4m",
    "html": "Parameters\nnewElements\n\nThe new elements to insert into the collection.\n\ni\n\nThe position at which to insert the new elements. index must be a valid index of the collection.\n\nDiscussion\n\nThe new elements are inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new elements are appended to the collection.\n\nHere’s an example of inserting a range of integers into an array of the same type:\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(contentsOf: 100...103, at: 3)\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 101, 102, 103, 4, 5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n + m), where n is length of this collection and m is the length of newElements. If i == endIndex, this method is equivalent to append(contentsOf:)."
  },
  {
    "title": "remove(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/remove(at:)-7xja6",
    "html": "Parameters\nposition\n\nThe position of the element to remove. position must be a valid index of the collection that is not equal to the collection’s end index.\n\nReturn Value\n\nThe removed element.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes the middle element from an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.6]\nlet removed = measurements.remove(at: 2)\nprint(measurements)\n// Prints \"[1.2, 1.5, 1.2, 1.6]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "remove(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/remove(at:)-7ep9e",
    "html": "Parameters\ni\n\nThe position of the element to remove. index must be a valid index of the collection that is not equal to the collection’s end index.\n\nReturn Value\n\nThe removed element.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes the middle element from an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.6]\nlet removed = measurements.remove(at: 2)\nprint(measurements)\n// Prints \"[1.2, 1.5, 1.2, 1.6]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removelast()-wsbc",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removefirst(_:)-7hjja",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst(3)\nprint(bugs)\n// Prints \"[\"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removelast()-5mmgh",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removelast(_:)-fxm2",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(k), where k is the specified number of elements."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removesubrange(_:)-1y2qo",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "sort(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/sort(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false. If areInIncreasingOrder throws an error during the sort, the elements may be in a different order, but none will be lost.\n\nDiscussion\n\nWhen you want to sort a collection of elements that don’t conform to the Comparable protocol, pass a closure to this method that returns true when the first element should be ordered before the second.\n\nIn the following example, the closure provides an ordering for an array of a custom enumeration that describes an HTTP response. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nvar responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nresponses.sort {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(responses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nAlternatively, use this method to sort a collection of elements that do conform to Comparable when you want the sort to be descending instead of ascending. Pass the greater-than operator (>) operator as the predicate.\n\nvar students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nstudents.sort(by: >)\nprint(students)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nareInIncreasingOrder must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/subscript(_:)-87kqd",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lastRange(of:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/lastrange(of:in:)",
    "html": "Discussion\n\nA default implementation is given in terms of self.regions."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/subscript(_:)-8pq5s",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removesubrange(_:)-7s7x9",
    "html": "Parameters\nbounds\n\nThe subrange of the collection to remove. The bounds of the range must be valid indices of the collection.\n\nDiscussion\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeSubrange(1...3)\nprint(bugs)\n// Prints \"[\"Aphid\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/partition(by:)-7n9yj",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "sort() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/sort()",
    "html": "Discussion\n\nYou can sort any mutable collection of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nvar students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nstudents.sort()\nprint(students)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your collection in descending order, pass the greater-than operator (>) to the sort(by:) method.\n\nstudents.sort(by: >)\nprint(students)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the collection."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/subscript(_:)-uq47",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nstreets[index!] = \"Eustace\"\nprint(streets[index!])\n// Prints \"Eustace\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/subscript(_:)-z7ny",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nOverview\n\nFor example, you can replace an element of an array by using its subscript.\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nstreets[1] = \"Butler\"\nprint(streets[1])\n// Prints \"Butler\"\n\n\nYou can subscript a collection with any valid index other than the collection’s end index. The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/substring/utf16view/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "removeSubrange(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removesubrange(_:)-8m66i",
    "html": "Parameters\nbounds\n\nThe range of the collection to be removed. The bounds of the range must be valid indices of the collection.\n\nDiscussion\n\nAll the elements following the specified position are moved to close the gap. This example removes three elements from the middle of an array of measurements.\n\nvar measurements = [1.2, 1.5, 2.9, 1.2, 1.5]\nmeasurements.removeSubrange(1..<4)\nprint(measurements)\n// Prints \"[1.2, 1.5]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/compactmap(_:)-188bn",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "withUnsafeBytes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/withunsafebytes(_:)",
    "html": "Discussion\n\nNote\n\nCalling withUnsafeBytes multiple times does not guarantee that the same buffer pointer will be passed in every time.\n\nWarning\n\nThe buffer argument to the body should not be stored or used outside of the lifetime of the call to the closure."
  },
  {
    "title": "Slice.Elements | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/elements-swift.typealias",
    "html": "Discussion\n\nSee also: elements"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "firstRange(of:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/firstrange(of:in:)",
    "html": "Discussion\n\nA default implementation is given in terms of self.regions."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/subscript(_:)-5pgrv",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nFor example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2..<5]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")!    // 4\nprint(streets[index])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/subscript(_:)-7bg96",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "Slice.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/subscript(_:)-5rdkr",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/subscript(_:)-1rloy",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property.\n\nOverview\n\nThe following example accesses an element of an array through its subscript to print its value:\n\nvar streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nprint(streets[1])\n// Prints \"Bryant\"\n\n\nYou can subscript a collection with any valid index other than the collection’s end index. The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/startindex",
    "html": "Discussion\n\nIf the collection is empty, startIndex is equal to endIndex."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be nonuniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can result in an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/endindex",
    "html": "Discussion\n\nWhen you need a range that includes the last element of a collection, use the half-open range operator (..<) with endIndex. The ..< operator creates a range that doesn’t include the upper bound, so it’s always safe to use with endIndex. For example:\n\nlet numbers = [10, 20, 30, 40, 50]\nif let index = numbers.firstIndex(of: 30) {\n    print(numbers[index ..< numbers.endIndex])\n}\n// Prints \"[30, 40, 50]\"\n\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "insert(_:at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/insert(_:at:)-6sg0",
    "html": "Parameters\nnewElement\n\nThe new element to insert into the collection.\n\ni\n\nThe position at which to insert the new element. index must be a valid index into the collection.\n\nDiscussion\n\nThe new element is inserted before the element currently at the specified index. If you pass the collection’s endIndex property as the index parameter, the new element is appended to the collection.\n\nvar numbers = [1, 2, 3, 4, 5]\nnumbers.insert(100, at: 3)\nnumbers.insert(200, at: numbers.endIndex)\n\n\nprint(numbers)\n// Prints \"[1, 2, 3, 100, 4, 5, 200]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection. If i == endIndex, this method is equivalent to append(_:)."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/poplast()-4rely",
    "html": "Return Value\n\nThe last element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/poplast()-30m9y",
    "html": "Return Value\n\nThe last element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeAll(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removeall(where:)-9u7g",
    "html": "Parameters\nshouldBeRemoved\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.\n\nDiscussion\n\nUse this method to remove every element in a collection that meets particular criteria. The order of the remaining elements is preserved. This example removes all the odd values from an array of numbers:\n\nvar numbers = [5, 6, 7, 8, 9, 10, 11]\nnumbers.removeAll(where: { $0 % 2 != 0 })\n// numbers == [6, 8, 10]\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "partition(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/partition(by:)-7efo8",
    "html": "Parameters\nbelongsInSecondPartition\n\nA predicate used to partition the collection. All elements satisfying this predicate are ordered after all elements not satisfying it.\n\nReturn Value\n\nThe index of the first element in the reordered collection that matches belongsInSecondPartition. If no elements in the collection match belongsInSecondPartition, the returned index is equal to the collection’s endIndex.\n\nDiscussion\n\nAfter partitioning a collection, there is a pivot index p where no element before p satisfies the belongsInSecondPartition predicate and every element at or after p satisfies belongsInSecondPartition. This operation isn’t guaranteed to be stable, so the relative ordering of elements within the partitions might change.\n\nIn the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.\n\nvar numbers = [30, 40, 20, 30, 30, 60, 10]\nlet p = numbers.partition(by: { $0 > 30 })\n// p == 5\n// numbers == [30, 10, 20, 30, 30, 60, 40]\n\n\nThe numbers array is now arranged in two partitions. The first partition, numbers[..<p], is made up of the elements that are not greater than 30. The second partition, numbers[p...], is made up of the elements that are greater than 30.\n\nlet first = numbers[..<p]\n// first == [30, 10, 20, 30, 30]\nlet second = numbers[p...]\n// second == [60, 40]\n\n\nNote that the order of elements in both partitions changed. That is, 40 appears before 60 in the original collection, but, after calling partition(by:), 60 appears before 40.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removefirst()-1iayr",
    "html": "Return Value\n\nThe removed element.\n\nDiscussion\n\nThe collection must not be empty.\n\nvar bugs = [\"Aphid\", \"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\nbugs.removeFirst()\nprint(bugs)\n// Prints \"[\"Bumblebee\", \"Cicada\", \"Damselfly\", \"Earwig\"]\"\n\n\nCalling this method may invalidate any existing indices for use with this collection.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removefirst(_:)-1pxgx",
    "html": "Parameters\nk\n\nThe number of elements to remove from the collection. k must be greater than or equal to zero and must not exceed the number of elements in the collection.\n\nDiscussion\n\nAttempting to remove more elements than exist in the collection triggers a runtime error.\n\nCalling this method may invalidate all saved indices of this collection. Do not rely on a previously stored index value after altering a collection with any operation that can change its length.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "shuffle(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/shuffle(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the collection.\n\nDiscussion\n\nYou use this method to randomize the elements of a collection when you are using a custom random number generator. For example, you can use the shuffle(using:) method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle(using: &myGenerator)\n// names == [\"Sofía\", \"Alejandro\", \"Camila\", \"Luis\", \"Diego\", \"Luciana\"]\n\n\nComplexity\n\nO(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to shuffle a collection may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "reverse() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/reverse()",
    "html": "Discussion\n\nThe following example reverses the elements of an array of characters:\n\nvar characters: [Character] = [\"C\", \"a\", \"f\", \"é\"]\ncharacters.reverse()\nprint(characters)\n// Prints \"[\"é\", \"f\", \"a\", \"C\"]\"\n\n\nComplexity\n\nO(n), where n is the number of elements in the collection."
  },
  {
    "title": "shuffle() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/shuffle()",
    "html": "Discussion\n\nUse the shuffle() method to randomly reorder the elements of an array.\n\nvar names = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofía\"]\nnames.shuffle()\n// names == [\"Luis\", \"Camila\", \"Luciana\", \"Sofía\", \"Alejandro\", \"Diego\"]\n\n\nThis method is equivalent to calling shuffle(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "swapAt(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/swapat(_:_:)",
    "html": "Parameters\ni\n\nThe index of the first value to swap.\n\nj\n\nThe index of the second value to swap.\n\nDiscussion\n\nBoth parameters must be valid indices of the collection that are not equal to endIndex. Calling swapAt(_:_:) with the same index as both i and j has no effect.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "withContiguousMutableStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/withcontiguousmutablestorageifavailable(_:)-2ual",
    "html": "Parameters\nbody\n\nA closure that receives an in-out UnsafeMutableBufferPointer to the collection’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the collection doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer provides access to the contiguous mutable storage of the entire collection. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in the form of contiguous mutable storage, this method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nAlways perform any necessary cleanup in the closure, because the method makes no guarantees about the state of the collection if the closure throws an error. Your changes to the collection may be absent from the collection after throwing the error, because the closure could receive a temporary copy rather than direct access to the collection’s storage.\n\nWarning\n\nYour body closure must not replace buffer. This leads to a crash in all implementations of this method within the standard library.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "popFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/popfirst()",
    "html": "Return Value\n\nThe first element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/map(_:)-4ucsu",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/split(separator:maxsplits:omittingemptysubsequences:)-5z4op",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/flatmap(_:)-1q7p9",
    "html": "Discussion\n\nUse this method to receive a single-level sequence when your transformation produces a sequence or collection for each element. Calling flatMap(_:) on a sequence s is equivalent to calling s.map(transform).joined().\n\nComplexity\n\nO(1)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/flatmap(_:)-6ng42",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "Slice.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "regions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/regions-swift.property",
    "html": "Discussion\n\nThe sum of the lengths of the associated regions must equal self.count (such that iterating regions and iterating self produces the same sequence of indices in the same number of index advancements)."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off the specified number of elements at the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/flatmap(_:)-91vkc",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/joined(separator:)-52o5k",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/joined(separator:)-6gaaw",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "makeIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/makeiterator()",
    "html": "Discussion\n\nComplexity\n\nO(1)."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removefirst(_:)-3pkd7",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/slice/removefirst()-2564w",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/flatmap(_:)-29w2n",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/joined(separator:)-1zt3c",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "makeIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/makeiterator()",
    "html": "Discussion\n\nComplexity\n\nO(1)."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/joined(separator:)-2hbtj",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/map(_:)-7osvp",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "Repeated.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "firstRange(of:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/firstrange(of:in:)",
    "html": "Discussion\n\nA default implementation is given in terms of self.regions."
  },
  {
    "title": "lastRange(of:in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/lastrange(of:in:)",
    "html": "Discussion\n\nA default implementation is given in terms of self.regions."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/endindex",
    "html": "Discussion\n\nIn a Repeated collection, endIndex is always equal to count. If the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/stridethrough/joined(separator:)-33ki",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/split(separator:maxsplits:omittingemptysubsequences:)-c1tr",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/map(_:)-7a356",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/compactmap(_:)-8k2p7",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/joined(separator:)-16xv3",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/joined(separator:)-6z11h",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/flatmap(_:)-4ktxw",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/split(separator:maxsplits:omittingemptysubsequences:)-4q9u4",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "regions | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/regions-swift.property",
    "html": "Discussion\n\nThe sum of the lengths of the associated regions must equal self.count (such that iterating regions and iterating self produces the same sequence of indices in the same number of index advancements)."
  },
  {
    "title": "Repeated.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/startindex",
    "html": "Discussion\n\nIn a Repeated collection, startIndex is always equal to zero. If the collection is empty, startIndex is equal to endIndex."
  },
  {
    "title": "Repeated.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/subscript(_:)",
    "html": "Parameters\nposition\n\nThe position of the element to access. position must be a valid index of the collection that is not equal to the endIndex property."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/joined(separator:)-4dqsr",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/next()",
    "html": "Return Value\n\nThe next element in the underlying sequence, if a next element exists; otherwise, nil.\n\nDiscussion\n\nRepeatedly calling this method returns, in order, all the elements of the underlying sequence. As soon as the sequence has run out of elements, all subsequent calls return nil.\n\nYou must not call this method if any other copy of this iterator has been advanced with a call to its next() method.\n\nThe following example shows how an iterator can be used explicitly to emulate a for-in loop. First, retrieve a sequence’s iterator, and then call the iterator’s next() method until it returns nil.\n\nlet numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\n\n\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints \"2\"\n// Prints \"3\"\n// Prints \"5\"\n// Prints \"7\"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/compactmap(_:)-4299z",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/flatmap(_:)-7x1zn",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/flatmap(_:)-39bbv",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/map(_:)-81b46",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/map(_:)-p3ci",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "AsyncThrowingFlatMapSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingflatmapsequence/element",
    "html": "Discussion\n\nThe flat map sequence produces the type of element in the asynchronous sequence produced by the transform closure."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/compactmap(_:)-1rx1n",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/flatmap(_:)-7lydm",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/flatmap(_:)-6iqg9",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/reversedcollection/iterator/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/joined(separator:)-2xbpw",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/compactmap(_:)-48ay0",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/map(_:)-845vf",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/flatmap(_:)-53stf",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/flatmap(_:)-6y5p5",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/map(_:)-9s7sb",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "AsyncThrowingMapSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/element",
    "html": "Discussion\n\nThe map sequence produces whatever type of element its the transforming closure produces."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/compactmap(_:)-4j12y",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/compactmap(_:)-2yntz",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/flatmap(_:)-67uer",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/flatmap(_:)-217io",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/map(_:)-wssh",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/map(_:)-5ncr2",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/repeated/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/joined(separator:)-14aab",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/joined(separator:)-86lij",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "AsyncPrefixSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/element",
    "html": "Discussion\n\nThe prefix sequence produces whatever type of element its base iterator produces."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/map(_:)-5kpov",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "AsyncFlatMapSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/element",
    "html": "Discussion\n\nThe flat map sequence produces the type of element in the asynchronous sequence produced by the transform closure."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/compactmap(_:)-1ecis",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/flatmap(_:)-1xasg",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/flatmap(_:)-6vpvp",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/map(_:)-98iwe",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "AsyncThrowingCompactMapSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/element",
    "html": "Discussion\n\nThe compact map sequence produces whatever type of element its transforming closure produces."
  },
  {
    "title": "AsyncStream.Continuation.BufferingPolicy.bufferingOldest(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncstream/continuation/bufferingpolicy/bufferingoldest(_:)",
    "html": "Discussion\n\nThis strategy enforces keeping at most the specified number of oldest values.\n\nSee Also\nBuffering Policies\ncase unbounded\nContinue to add to the buffer, without imposing a limit on the number of buffered elements.\ncase bufferingNewest(Int)\nWhen the buffer is full, discard the oldest element in the buffer."
  },
  {
    "title": "AsyncStream.Continuation.BufferingPolicy.unbounded | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncstream/continuation/bufferingpolicy/unbounded",
    "html": "See Also\nBuffering Policies\ncase bufferingOldest(Int)\nWhen the buffer is full, discard the newly received element.\ncase bufferingNewest(Int)\nWhen the buffer is full, discard the oldest element in the buffer."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/compactmap(_:)-91i6y",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingmapsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/compactmap(_:)-4o22y",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncflatmapsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/map(_:)-4lvqv",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/flatmap(_:)-1bs0d",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/flatmap(_:)-17yfv",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/map(_:)-3dlzg",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncthrowingcompactmapsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "AsyncMapSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/element",
    "html": "Discussion\n\nThe map sequence produces whatever type of element its transforming closure produces."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncstream/iterator/next()",
    "html": "Discussion\n\nWhen next() returns nil, this signifies the end of the AsyncStream.\n\nIt is a programmer error to invoke next() from a concurrent context that contends with another such call, which results in a call to fatalError().\n\nIf you cancel the task this iterator is running in while next() is awaiting a value, the AsyncStream terminates. In this case, next() might return nil immediately, or return nil on subsequent calls."
  },
  {
    "title": "customMirror | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/strideto/custommirror",
    "html": "Discussion\n\nIf this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance."
  },
  {
    "title": "AsyncStream.Continuation.BufferingPolicy.bufferingNewest(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncstream/continuation/bufferingpolicy/bufferingnewest(_:)",
    "html": "Discussion\n\nThis strategy enforces keeping at most the specified number of newest values.\n\nSee Also\nBuffering Policies\ncase unbounded\nContinue to add to the buffer, without imposing a limit on the number of buffered elements.\ncase bufferingOldest(Int)\nWhen the buffer is full, discard the newly received element."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/compactmap(_:)-7mqjp",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/compactmap(_:)-8mr7y",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/compactmap(_:)-uilo",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/compactmap(_:)-1ux9n",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Because there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n    \nlet stream = Counter(howHigh: 5)\n    .compactMap { romanNumeralDict[$0] }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III V \"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/compactmap(_:)-670wo",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. If transform throws an error, the sequence ends.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the non-nil elements produced by the transform closure. The sequence ends either when the base sequence ends or when transform throws an error.\n\nDiscussion\n\nUse the compactMap(_:) method to transform every element received from a base asynchronous sequence, while also discarding any nil results from the closure. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the compactMap(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. Since there is no key for 4, the closure returns nil in this case, which compactMap(_:) omits from the transformed asynchronous sequence. When the value is 5, the closure throws MyError, terminating the sequence.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .compactMap { (value) throws -> String? in\n            if value == 5 {\n                throw MyError()\n            }\n            return romanNumeralDict[value]\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/flatmap(_:)-5qysc",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/map(_:)-70w52",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/map(_:)-upx4",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/flatmap(_:)-4jt45",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The min() method returns the minimum value of the sequence.\n\nlet min = await Counter(howHigh: 10)\n    .min()\nprint(min ?? \"none\")\n// Prints \"1\"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/flatmap(_:)-kp0l",
    "html": "Parameters\ntransform\n\nAn error-throwing mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence. If transform throws an error, the sequence ends.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform. The sequence ends either when the last sequence created from the last element from base sequence ends, or when transform throws an error.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence. However, when the closure receives 4, it throws an error, terminating the sequence.\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .flatMap { (value) -> Counter in\n            if value == 4 {\n                throw MyError()\n            }\n            return Counter(howHigh: value)\n        }\n    for try await number in stream {\n        print(number, terminator: \" \")\n    }\n} catch {\n    print(error)\n}\n// Prints \"1 1 2 1 2 3 MyError() \"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/map(_:)-9wvb",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type. transform can also throw an error, which ends the transformed sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces. Also, the dictionary doesn’t provide a key for 4, and the closure throws an error for any key it can’t look up, so receiving this value from Counter ends the modified sequence with an error.\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ndo {\n    let stream = Counter(howHigh: 5)\n        .map { (value) throws -> String in\n            guard let roman = romanNumeralDict[value] else {\n                throw MyError()\n            }\n            return roman\n        }\n    for try await numeral in stream {\n        print(numeral, terminator: \" \")\n    }\n} catch {\n    print(\"Error: \\(error)\")\n}\n// Prints \"I II III Error: MyError() \"\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the max(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet max = await RankCounter()\n    .max { $0.rawValue < $1.rawValue }\nprint(max ?? \"none\")\n// Prints \"king\"\n"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/joined(separator:)-1jr9q",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nUse this method when the asynchronous sequence’s values don’t conform to Comparable, or when you want to apply a custom ordering to the sequence.\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe following example uses an enumeration of playing cards ranks, Rank, which ranges from ace (low) to king (high). An asynchronous sequence called RankCounter produces all elements of the array. The predicate provided to the min(by:) method sorts ranks based on their rawValue:\n\nenum Rank: Int {\n    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king\n}\n\n\nlet min = await RankCounter()\n    .min { $0.rawValue < $1.rawValue }\nprint(min ?? \"none\")\n// Prints \"ace\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/prefix(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of elements to return. The value of count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence starting at the beginning of the base sequence with at most count elements.\n\nDiscussion\n\nUse prefix(_:) to reduce the number of elements produced by the asynchronous sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(_:) method causes the modified sequence to pass through the first six values, then end.\n\nfor await number in Counter(howHigh: 10).prefix(6) {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 6 \"\n\n\nIf the count passed to prefix(_:) exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence."
  },
  {
    "title": "AsyncFilterSequence.Element | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/element",
    "html": "Discussion\n\nThe filter sequence produces whatever type of element its base sequence produces."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/flatmap(_:)-3c38d",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns an AsyncSequence.\n\nReturn Value\n\nA single, flattened asynchronous sequence that contains all elements in all the asynchronous sequences produced by transform.\n\nDiscussion\n\nUse this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The transforming closure takes the received Int and returns a new Counter that counts that high. For example, when the transform receives 3 from the base sequence, it creates a new Counter that produces the values 1, 2, and 3. The flatMap(_:) method “flattens” the resulting sequence-of-sequences into a single AsyncSequence.\n\nlet stream = Counter(howHigh: 5)\n    .flatMap { Counter(howHigh: $0) }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncprefixsequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence that skips over values from the base sequence until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an asynchronous sequence until the element received meets a condition you specify.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The drop(while:) method causes the modified sequence to ignore received values until it encounters one that is divisible by 3:\n\nlet stream = Counter(howHigh: 10)\n    .drop { $0 % 3 != 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"3 4 5 6 7 8 9 10 \"\n\n\nAfter the predicate returns false, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, or to find an element that satisfies a general condition.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(where:) method checks to see whether the sequence produces a value divisible by 3:\n\nlet containsDivisibleByThree = await Counter(howHigh: 10)\n    .contains { $0 % 3 == 0 }\nprint(containsDivisibleByThree)\n// Prints \"true\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/contains(_:)",
    "html": "Parameters\nsearch\n\nThe element to find in the asynchronous sequence.\n\nReturn Value\n\ntrue if the method found the element in the asynchronous sequence; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The contains(_:) method checks to see whether the sequence produces the value 5:\n\nlet containsFive = await Counter(howHigh: 10)\n    .contains(5)\nprint(containsFive)\n// Prints \"true\"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to drop from the beginning of the sequence. count must be greater than or equal to zero.\n\nReturn Value\n\nAn asynchronous sequence that drops the first count elements from the base sequence.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the base sequence and pass through the remaining elements.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The dropFirst(_:) method causes the modified sequence to ignore the values 1 through 3, and instead emit 4 through 10:\n\nfor await number in Counter(howHigh: 10).dropFirst(3) {\n    print(number, terminator: \" \")\n}\n// Prints \"4 5 6 7 8 9 10 \"\n\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The filter(_:) method returns true for even values and false for odd values, thereby filtering out the odd values:\n\nlet stream = Counter(howHigh: 10)\n    .filter { $0 % 2 == 0 }\nfor await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"2 4 6 8 10 \"\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The allSatisfy(_:) method checks to see whether all elements produced by the sequence are less than 10.\n\nlet allLessThanTen = await Counter(howHigh: 10)\n    .allSatisfy { $0 < 10 }\nprint(allLessThanTen)\n// Prints \"false\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate returns false or the sequence ends.\n\nIf the asynchronous sequence is empty, this method returns true."
  },
  {
    "title": "makeAsyncIterator() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/makeasynciterator()",
    "html": "Return Value\n\nAn instance of the AsyncIterator type used to produce elements of the asynchronous sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The first(where:) method returns the first member of the sequence that’s evenly divisible by both 2 and 3.\n\nlet divisibleBy2And3 = await Counter(howHigh: 10)\n    .first { $0 % 2 == 0 && $0 % 3 == 0 }\nprint(divisibleBy2And3 ?? \"none\")\n// Prints \"6\"\n\n\nThe predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.\n\nReturn Value\n\nAn asynchronous sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nUse prefix(while:) to produce values while elements from the base sequence meet a condition you specify. The modified sequence ends when the predicate closure returns false.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The prefix(while:) method causes the modified sequence to pass along values so long as they aren’t divisible by 2 and 3. Upon reaching 6, the sequence ends:\n\nlet stream = Counter(howHigh: 10)\n    .prefix { $0 % 2 != 0 || $0 % 3 != 0 }\nfor try await number in stream {\n    print(number, terminator: \" \")\n}\n// Prints \"1 2 3 4 5 \"\n"
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure executes.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on a sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nPrefer this method over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or Dictionary."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/map(_:)-ljd0",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn asynchronous sequence that contains, in order, the elements produced by the transform closure.\n\nDiscussion\n\nUse the map(_:) method to transform every element received from a base asynchronous sequence. Typically, you use this to transform from one type of element to another.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 5. The closure provided to the map(_:) method takes each Int and looks up a corresponding String from a romanNumeralDict dictionary. This means the outer for await in loop iterates over String instances instead of the underlying Int values that Counter produces:\n\nlet romanNumeralDict: [Int: String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\nlet stream = Counter(howHigh: 5)\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\nfor await numeral in stream {\n    print(numeral, terminator: \" \")\n}\n// Prints \"I II III (unknown) V \"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncmapsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. The nextPartialResult closure receives initialResult the first time the closure runs.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an sequence of numbers to find their sum or product.\n\nThe nextPartialResult closure executes sequentially with an accumulating value initialized to initialResult and each element of the sequence.\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 4. The reduce(_:_:) method sums the values received from the asynchronous sequence.\n\nlet sum = await Counter(howHigh: 4)\n    .reduce(0) {\n        $0 + $1\n    }\nprint(sum)\n// Prints \"10\"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/asyncfiltersequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nIn this example, an asynchronous sequence called Counter produces Int values from 1 to 10. The max() method returns the max value of the sequence.\n\nlet max = await Counter(howHigh: 10)\n    .max()\nprint(max ?? \"none\")\n// Prints \"10\"\n"
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/next()",
    "html": "Return Value\n\nThe next element in the underlying sequence if a next element exists; otherwise, nil.\n\nDiscussion\n\nRepeatedly calling this method returns all the elements of the underlying sequence in order. As soon as the sequence has run out of elements, all subsequent calls return nil.\n\nThis example shows how an iterator can be used explicitly to emulate a for-in loop. First, retrieve a sequence’s iterator, and then call the iterator’s next() method until it returns nil.\n\nlet numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\n\n\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints \"2\"\n// Prints \"3\"\n// Prints \"5\"\n// Prints \"7\"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/flatmap(_:)-1o4bm",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/joined(separator:)-4ve6o",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/joined(separator:)-2g7pm",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/joined(separator:)-4f0oy",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/flatmap(_:)-1oa76",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/flatmap(_:)-68zvx",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/joined(separator:)-5hdvf",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/joined(separator:)-p00z",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/flatmap(_:)-2rn7w",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/map(_:)-97aka",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/joined(separator:)-le98",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/iterator/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil.\n\nPrecondition\n\nnext() has not been applied to a copy of self since the copy was made."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/split(separator:maxsplits:omittingemptysubsequences:)-20oji",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/iterator/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil.\n\nPrecondition\n\nnext() has not been applied to a copy of self since the copy was made."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/emptycollection/iterator/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/flatmap(_:)-56mad",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/joined(separator:)-1nha1",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/flattensequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/joined(separator:)-72ztj",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/flatmap(_:)-25w04",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/joined(separator:)-8fii9",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/map(_:)-2wvos",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/flatmap(_:)-54urw",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/iteratorsequence/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil.\n\nPrecondition\n\nnext() has not been applied to a copy of self since the copy was made."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/joined(separator:)-6g78p",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/map(_:)-28mji",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/indexingiterator/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anysequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "DropWhileSequence.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/iterator",
    "html": "Topics\nDefault Implementations\nIteratorProtocol Implementations\nRelationships\nConforms To\nIteratorProtocol\nConforms when Base conforms to Sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/joined(separator:)-9nzkj",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropwhilesequence/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/joined(separator:)-1lfg6",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/map(_:)-7do5y",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "removeFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/removefirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the specified number of elements."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/flatmap(_:)-7kqh5",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/subscript(_:)-37hui",
    "html": "Overview\n\nPrecondition\n\nposition indicates a valid position in self and position != endIndex."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/subscript(_:)-6jydx",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. Always use the slice’s startIndex property instead of assuming that its indices start at a particular value.\n\nThis example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2 ..< streets.endIndex]\nprint(streetsSlice)\n// Prints \"[\"Channing\", \"Douglas\", \"Evarts\"]\"\n\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// Prints \"Evarts\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/index(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/distance(from:to:)",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/startindex",
    "html": "Discussion\n\nIn an empty collection, startIndex == endIndex."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/joined(separator:)-9vrqj",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/flatmap(_:)-66w5i",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/endindex",
    "html": "Discussion\n\nendIndex is always reachable from startIndex by zero or more applications of index(after:)."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/joined(separator:)-vj4v",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "popLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/poplast()",
    "html": "Return Value\n\nThe last element of the collection if the collection has one or more elements; otherwise, nil.\n\nDiscussion\n\nYou can use popLast() to remove the last element of a collection that might be empty. The removeLast() method must be used only on a nonempty collection.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/map(_:)-4dsas",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "removeLast() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/removelast()",
    "html": "Return Value\n\nThe last element of the collection.\n\nDiscussion\n\nThe collection must not be empty. To remove the last element of a collection that might be empty, use the popLast() method instead.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/count",
    "html": "Discussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "removeFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/removefirst()",
    "html": "Return Value\n\nThe first element of the collection.\n\nDiscussion\n\nThe collection must not be empty.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/split(separator:maxsplits:omittingemptysubsequences:)-2m0ih",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/subscript(_:)-9umyp",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/map(_:)-2jzdm",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/dropfirstsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int32/words-swift.struct/map(_:)-70jrg",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/flatmap(_:)-8dp2z",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "removeLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/removelast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to remove. k must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.\n\nDiscussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to remove."
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "popFirst() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/popfirst()",
    "html": "Return Value\n\nThe first element of the collection if the collection is not empty; otherwise, nil.\n\nDiscussion\n\nComplexity\n\nO(1)"
  },
  {
    "title": "AnyRandomAccessCollection.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "AnyRandomAccessCollection.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/iterator",
    "html": "Discussion\n\nBy default, a collection conforms to the Sequence protocol by supplying IndexingIterator as its associated Iterator type."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "AnyRandomAccessCollection.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the collection satisfying the isSeparator predicate. The default value is true.\n\nisSeparator\n\nA closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(maxSplits: 1, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == \" \" }))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int8/words-swift.struct/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/flatmap(_:)-5tf8l",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/map(_:)-56qte",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/map(_:)-2uinm",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false if it should be included. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/flatmap(_:)-4trs6",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/map(_:)-75w8a",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/map(_:)-6kmq0",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false if it should be excluded. Once the predicate returns false it will not be called again.\n\nDiscussion\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int16/words-swift.struct/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop from the beginning of the collection."
  },
  {
    "title": "first | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/first",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let firstNumber = numbers.first {\n    print(firstNumber)\n}\n// Prints \"10\"\n"
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/underestimatedcount",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/flatmap(_:)-6q8cl",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/joined(separator:)-1cqmc",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "merge(with:_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/merge(with:_:_:_:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nd\n\nA fourth publisher.\n\ne\n\nA fifth publisher.\n\nf\n\nA sixth publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:_:_:_:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:_:)-48buc. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:_:)-16rcy.\n\nIn this example, as merge(with:_:_:_:_:_:) receives input from the upstream publishers, it republishes the interleaved elements to the downstream:\n\nlet pubA = PassthroughSubject<Int, Never>()\nlet pubB = PassthroughSubject<Int, Never>()\nlet pubC = PassthroughSubject<Int, Never>()\nlet pubD = PassthroughSubject<Int, Never>()\nlet pubE = PassthroughSubject<Int, Never>()\nlet pubF = PassthroughSubject<Int, Never>()\n\n\ncancellable = pubA\n    .merge(with: pubB, pubC, pubD, pubE, pubF)\n    .sink { print(\"\\($0)\", terminator: \" \" ) }\n\n\npubA.send(1)\npubB.send(40)\npubC.send(90)\npubD.send(-1)\npubE.send(33)\npubF.send(44)\n\n\npubA.send(2)\npubB.send(50)\npubC.send(100)\npubD.send(-2)\npubE.send(33)\npubF.send(33)\n\n\n//Prints: \"1 40 90 -1 33 44 2 50 100 -2 33 33\"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/joined(separator:)-4wxky",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "tryCatch(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/trycatch(_:)",
    "html": "Parameters\nhandler\n\nA throwing closure that accepts the upstream failure as input. This closure can either replace the upstream publisher with a new one, or throw a new error to the downstream subscriber.\n\nReturn Value\n\nA publisher that handles errors from an upstream publisher by replacing the failed publisher with another publisher, or an error.\n\nDiscussion\n\nUse tryCatch(_:) to decide how to handle from an upstream publisher by either replacing the publisher with a new publisher, or throwing a new error.\n\nIn the example below, an array publisher emits values that a tryMap(_:) operator evaluates to ensure the values are greater than zero. If the values aren’t greater than zero, the operator throws an error to the downstream subscriber to let it know there was a problem. The subscriber, tryCatch(_:), replaces the error with a new publisher using Just to publish a final value before the stream ends normally.\n\nenum SimpleError: Error { case error }\nvar numbers = [5, 4, 3, 2, 1, -1, 7, 8, 9, 10]\n\n\ncancellable = numbers.publisher\n   .tryMap { v in\n        if v > 0 {\n            return v\n        } else {\n            throw SimpleError.error\n        }\n}\n  .tryCatch { error in\n      Just(0) // Send a final value before completing normally.\n              // Alternatively, throw a new error to terminate the stream.\n}\n  .sink(receiveCompletion: { print (\"Completion: \\($0).\") },\n        receiveValue: { print (\"Received \\($0).\") }\n  )\n//    Received 5.\n//    Received 4.\n//    Received 3.\n//    Received 2.\n//    Received 1.\n//    Received 0.\n//    Completion: finished.\n"
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence starting at the beginning of this collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to select from the beginning of the collection."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/formindex(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/map(_:)-3e4pu",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscribe(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/subscribe(_:)-70txi",
    "html": "Parameters\nsubscriber\n\nThe subscriber to attach to this publisher. After attaching, the subscriber can start to receive values.\n\nDiscussion\n\nAlways call this function instead of receive(subscriber:). Adopters of Result.Publisher must implement receive(subscriber:). The implementation of Publisher/subscribe(_:)-4u8kn provided by Result.Publisher calls through to receive(subscriber:)."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/flatmap(_:)-2c332",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/map(_:)-twhs",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/joined(separator:)-81k3e",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/joined(separator:)-8fdgx",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "merge(with:_:_:_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/merge(with:_:_:_:_:_:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nd\n\nA fourth publisher.\n\ne\n\nA fifth publisher.\n\nf\n\nA sixth publisher.\n\ng\n\nA seventh publisher.\n\nh\n\nAn eighth publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:_:_:_:_:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:_:)-48buc. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:_:)-16rcy.\n\nIn this example, as merge(with:_:_:_:_:_:_:) receives input from the upstream publishers, it republishes the interleaved elements to the downstream:\n\nlet pubA = PassthroughSubject<Int, Never>()\nlet pubB = PassthroughSubject<Int, Never>()\nlet pubC = PassthroughSubject<Int, Never>()\nlet pubD = PassthroughSubject<Int, Never>()\nlet pubE = PassthroughSubject<Int, Never>()\nlet pubF = PassthroughSubject<Int, Never>()\nlet pubG = PassthroughSubject<Int, Never>()\nlet pubH = PassthroughSubject<Int, Never>()\n\n\ncancellable = pubA\n    .merge(with: pubB, pubC, pubD, pubE, pubF, pubG, pubH)\n    .sink { print(\"\\($0)\", terminator: \" \" ) }\n\n\npubA.send(1)\npubB.send(40)\npubC.send(90)\npubD.send(-1)\npubE.send(33)\npubF.send(44)\npubG.send(54)\npubH.send(1000)\n\n\npubA.send(2)\npubB.send(50)\npubC.send(100)\npubD.send(-2)\npubE.send(33)\npubF.send(33)\npubG.send(54)\npubH.send(1001)\n\n\n//Prints: \"1 40 90 -1 33 44 54 1000 2 50 100 -2 33 33 54 1001\"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "merge(with:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/merge(with:_:_:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nd\n\nA fourth publisher.\n\ne\n\nA fifth publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:_:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:_:)-48buc. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:_:)-16rcy.\n\nIn this example, as merge(with:_:_:_:) receives input from the upstream publishers, it republishes the interleaved elements to the downstream:\n\n let pubA = PassthroughSubject<Int, Never>()\n let pubB = PassthroughSubject<Int, Never>()\n let pubC = PassthroughSubject<Int, Never>()\n let pubD = PassthroughSubject<Int, Never>()\n let pubE = PassthroughSubject<Int, Never>()\n\n\n cancellable = pubA\n     .merge(with: pubB, pubC, pubD, pubE)\n     .sink { print(\"\\($0)\", terminator: \" \" ) }\n\n\n pubA.send(1)\n pubB.send(40)\n pubC.send(90)\n pubD.send(-1)\n pubE.send(33)\n pubA.send(2)\n pubB.send(50)\n pubC.send(100)\n pubD.send(-2)\n pubE.send(33)\n\n\n // Prints: \"1 40 90 -1 33 2 50 100 -2 33\"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "mapError(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/maperror(_:)-48hc7",
    "html": "Parameters\ntransform\n\nA closure that takes the upstream failure as a parameter and returns a new error for the publisher to terminate with.\n\nReturn Value\n\nA publisher that replaces any upstream failure with a new error produced by the transform closure.\n\nDiscussion\n\nUse the mapError(_:) operator when you need to replace one error type with another, or where a downstream operator needs the error types of its inputs to match.\n\nThe following example uses a tryMap(_:) operator to divide 1 by each element produced by a sequence publisher. When the publisher produces a 0, the tryMap(_:) fails with a DivisionByZeroError. The mapError(_:) operator converts this into a MyGenericError.\n\nstruct DivisionByZeroError: Error {}\nstruct MyGenericError: Error { var wrappedError: Error }\n\n\nfunc myDivide(_ dividend: Double, _ divisor: Double) throws -> Double {\n       guard divisor != 0 else { throw DivisionByZeroError() }\n       return dividend / divisor\n   }\n\n\nlet divisors: [Double] = [5, 4, 3, 2, 1, 0]\ndivisors.publisher\n    .tryMap { try myDivide(1, $0) }\n    .mapError { MyGenericError(wrappedError: $0) }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\") ,\n        receiveValue: { print (\"value: \\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"0.2 0.25 0.3333333333333333 0.5 1.0 completion: failure(MyGenericError(wrappedError: DivisionByZeroError()))\"\n"
  },
  {
    "title": "map(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/map(_:_:)",
    "html": "Parameters\nkeyPath0\n\nThe key path of a property on Output.\n\nkeyPath1\n\nThe key path of another property on Output.\n\nReturn Value\n\nA publisher that publishes the values of two key paths as a tuple.\n\nDiscussion\n\nIn the following example, the map(_:_:) operator uses the Swift key path syntax to access the die1 and die2 members of the DiceRoll structure published by the Just publisher.\n\nThe downstream sink subscriber receives only these two values (as an (Int, Int) tuple), not the entire DiceRoll.\n\nstruct DiceRoll {\n    let die1: Int\n    let die2: Int\n}\n\n\ncancellable = Just(DiceRoll(die1:Int.random(in:1...6),\n                            die2: Int.random(in:1...6)))\n    .map(\\.die1, \\.die2)\n    .sink { values in\n        print (\"Rolled: \\(values.0), \\(values.1) (total: \\(values.0 + values.1))\")\n    }\n// Prints \"Rolled: 6, 4 (total: 10)\" (or other random values).\n"
  },
  {
    "title": "tryFilter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/tryfilter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes one element and returns a Boolean value that indicated whether to republish the element or throws an error.\n\nReturn Value\n\nA publisher that republishes all elements that satisfy the closure.\n\nDiscussion\n\nUse tryFilter(_:) to filter elements evaluated in an error-throwing closure. If the isIncluded closure throws an error, the publisher fails with that error.\n\nIn the example below, tryFilter(_:) checks to see if the element provided by the publisher is zero, and throws a ZeroError before terminating the publisher with the thrown error. Otherwise, it republishes the element only if it’s even:\n\nstruct ZeroError: Error {}\n\n\nlet numbers: [Int] = [1, 2, 3, 4, 0, 5]\ncancellable = numbers.publisher\n    .tryFilter{\n        if $0 == 0 {\n            throw ZeroError()\n        } else {\n            return $0 % 2 == 0\n        }\n    }\n    .sink(\n        receiveCompletion: { print (\"\\($0)\") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"2 4 failure(DivisionByZeroError())\".\n"
  },
  {
    "title": "zip(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/zip(_:_:)-2ujx7",
    "html": "Parameters\nother\n\nAnother publisher.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that uses the transform closure to emit new elements, produced by combining the most recent value from two upstream publishers.\n\nDiscussion\n\nUse Publisher/zip(_:_:)-4xn21 to return a new publisher that combines the elements from two publishers using a transformation you specify to publish a new value to the downstream. The returned publisher waits until both publishers have emitted an event, then delivers the oldest unconsumed event from each publisher together that the operator uses in the transformation.\n\nIn this example, PassthroughSubject instances numbersPub and lettersPub emit values; Publisher/zip(_:_:)-4xn21 receives the oldest value from each publisher, uses the Int from numbersPub and publishes a string that repeats the String from lettersPub that many times.\n\nlet numbersPub = PassthroughSubject<Int, Never>()\nlet lettersPub = PassthroughSubject<String, Never>()\ncancellable = numbersPub\n    .zip(lettersPub) { anInt, aLetter in\n        String(repeating: aLetter, count: anInt)\n    }\n    .sink { print(\"\\($0)\") }\nnumbersPub.send(1)     // numbersPub: 1      lettersPub:       zip output: <none>\nnumbersPub.send(2)     // numbersPub: 1,2    lettersPub:       zip output: <none>\nnumbersPub.send(3)     // numbersPub: 1,2,3  lettersPub:       zip output: <none>\nlettersPub.send(\"A\")   // numbersPub: 1,2,3  lettersPub: \"A\"   zip output: \"A\"\nlettersPub.send(\"B\")   // numbersPub: 2,3    lettersPub: \"B\"   zip output: \"BB\"\n// Prints:\n//  A\n//  BB\n\n\nIf either upstream publisher finishes successfully or fails with an error, the zipped publisher does the same."
  },
  {
    "title": "timeout(_:scheduler:options:customError:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/timeout(_:scheduler:options:customerror:)",
    "html": "Parameters\ninterval\n\nThe maximum time interval the publisher can go without emitting an element, expressed in the time system of the scheduler.\n\nscheduler\n\nThe scheduler on which to deliver events.\n\noptions\n\nScheduler options that customize the delivery of elements.\n\ncustomError\n\nA closure that executes if the publisher times out. The publisher sends the failure returned by this closure to the subscriber as the reason for termination.\n\nReturn Value\n\nA publisher that terminates if the specified interval elapses with no events received from the upstream publisher.\n\nDiscussion\n\nUse timeout(_:scheduler:options:customError:) to terminate a publisher if an element isn’t delivered within a timeout interval you specify.\n\nIn the example below, a PassthroughSubject publishes String elements and is configured to time out if no new elements are received within its TIME_OUT window of 5 seconds. A single value is published after the specified 2-second WAIT_TIME, after which no more elements are available; the publisher then times out and completes normally.\n\nvar WAIT_TIME : Int = 2\nvar TIMEOUT_TIME : Int = 5\n\n\nlet subject = PassthroughSubject<String, Never>()\nlet cancellable = subject\n    .timeout(.seconds(TIMEOUT_TIME), scheduler: DispatchQueue.main, options: nil, customError:nil)\n    .sink(\n          receiveCompletion: { print (\"completion: \\($0) at \\(Date())\") },\n          receiveValue: { print (\"value: \\($0) at \\(Date())\") }\n     )\n\n\nDispatchQueue.main.asyncAfter(deadline: .now() + .seconds(WAIT_TIME),\n                              execute: { subject.send(\"Some data - sent after a delay of \\(WAIT_TIME) seconds\") } )\n\n\n// Prints: value: Some data - sent after a delay of 2 seconds at 2020-03-10 23:47:59 +0000\n//         completion: finished at 2020-03-10 23:48:04 +0000\n\n\nIf customError is nil, the publisher completes normally; if you provide a closure for the customError argument, the upstream publisher is instead terminated upon timeout, and the error is delivered to the downstream."
  },
  {
    "title": "tryFirst(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/tryfirst(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value that indicates whether to publish the element.\n\nReturn Value\n\nA publisher that only publishes the first element of a stream that satisfies the predicate.\n\nDiscussion\n\nUse tryFirst(where:) when you need to republish only the first element of a stream that satisfies an error-throwing closure you specify. The publisher ignores all elements after the first. If this publisher doesn’t receive any elements, it finishes without publishing. If the predicate closure throws an error, the publisher fails.\n\nIn the example below, a range publisher emits the first element in the range then finishes normally:\n\nlet numberRange: ClosedRange<Int> = (-1...50)\nnumberRange.publisher\n    .tryFirst {\n        guard $0 < 99 else {throw RangeError()}\n        return true\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\", terminator: \" \") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"-1 completion: finished\"\n// If instead the number range were ClosedRange<Int> = (100...200), the tryFirst operator would terminate publishing with a RangeError.\n"
  },
  {
    "title": "tryDrop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/trydrop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the publisher’s output.\n\nReturn Value\n\nA publisher that skips over elements until the provided closure returns false, and then republishes all remaining elements. If the predicate closure throws, the publisher fails with an error.\n\nDiscussion\n\nUse tryDrop(while:) to omit elements from an upstream until an error-throwing closure you provide returns false, after which the remaining items in the stream are published. If the closure throws, no elements are emitted and the publisher fails with an error.\n\nIn the example below, elements are ignored until -1 is encountered in the stream and the closure returns false. The publisher then republishes the remaining elements and finishes normally. Conversely, if the guard value in the closure had been encountered, the closure would throw and the publisher would fail with an error.\n\nstruct RangeError: Error {}\nvar numbers = [1, 2, 3, 4, 5, 6, -1, 7, 8, 9, 10]\nlet range: CountableClosedRange<Int> = (1...100)\ncancellable = numbers.publisher\n    .tryDrop {\n        guard $0 != 0 else { throw RangeError() }\n        return range.contains($0)\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\") },\n        receiveValue: { print (\"value: \\($0)\") }\n    )\n\n\n// Prints: \"-1 7 8 9 10 completion: finished\"\n// If instead numbers was [1, 2, 3, 4, 5, 6, 0, -1, 7, 8, 9, 10], tryDrop(while:) would fail with a RangeError.\n"
  },
  {
    "title": "tryCompactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/trycompactmap(_:)",
    "html": "Parameters\ntransform\n\nAn error-throwing closure that receives a value and returns an optional value.\n\nReturn Value\n\nAny non-nil optional results of calling the supplied closure.\n\nDiscussion\n\nUse tryCompactMap(_:) to remove nil elements from a publisher’s stream based on an error-throwing closure you provide. If the closure throws an error, the publisher cancels the upstream publisher and sends the thrown error to the downstream subscriber as a Publisher/Failure.\n\nThe following example uses an array of numbers as the source for a collection-based publisher. A tryCompactMap(_:) operator consumes each integer from the publisher and uses a dictionary to transform the numbers from its Arabic to Roman numerals, as an optional String.\n\nIf the closure called by tryCompactMap(_:) fails to look up a Roman numeral, it returns the optional String (unknown).\n\nIf the closure called by tryCompactMap(_:) determines the input is 0, it throws an error. The tryCompactMap(_:) operator catches this error and stops publishing, sending a Subscribers/Completion/failure(_:) that wraps the error.\n\nstruct ParseError: Error {}\nfunc romanNumeral(from: Int) throws -> String? {\n    let romanNumeralDict: [Int : String] =\n        [1: \"I\", 2: \"II\", 3: \"III\", 4: \"IV\", 5: \"V\"]\n    guard from != 0 else { throw ParseError() }\n    return romanNumeralDict[from]\n}\nlet numbers = [6, 5, 4, 3, 2, 1, 0]\ncancellable = numbers.publisher\n    .tryCompactMap { try romanNumeral(from: $0) }\n    .sink(\n          receiveCompletion: { print (\"\\($0)\") },\n          receiveValue: { print (\"\\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"(Unknown) V IV III II I failure(ParseError())\"\n"
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/index(_:offsetby:)-2sa3c",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "throttle(for:scheduler:latest:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/throttle(for:scheduler:latest:)",
    "html": "Parameters\ninterval\n\nThe interval at which to find and emit either the most recent or the first element, expressed in the time system of the scheduler.\n\nscheduler\n\nThe scheduler on which to publish elements.\n\nlatest\n\nA Boolean value that indicates whether to publish the most recent element. If false, the publisher emits the first element received during the interval.\n\nReturn Value\n\nA publisher that emits either the most-recent or first element received during the specified interval.\n\nDiscussion\n\nUse throttle(for:scheduler:latest:) to selectively republish elements from an upstream publisher during an interval you specify. Other elements received from the upstream in the throttling interval aren’t republished.\n\nIn the example below, a Timer.TimerPublisher produces elements on one-second intervals; the throttle(for:scheduler:latest:) operator delivers the first event, then republishes only the latest event in the following ten second intervals:\n\ncancellable = Timer.publish(every: 3.0, on: .main, in: .default)\n    .autoconnect()\n    .print(\"\\(Date().description)\")\n    .throttle(for: 10.0, scheduler: RunLoop.main, latest: true)\n    .sink(\n        receiveCompletion: { print (\"Completion: \\($0).\") },\n        receiveValue: { print(\"Received Timestamp \\($0).\") }\n     )\n\n\n// Prints:\n //    Publish at: 2020-03-19 18:26:54 +0000: receive value: (2020-03-19 18:26:57 +0000)\n //    Received Timestamp 2020-03-19 18:26:57 +0000.\n //    Publish at: 2020-03-19 18:26:54 +0000: receive value: (2020-03-19 18:27:00 +0000)\n //    Publish at: 2020-03-19 18:26:54 +0000: receive value: (2020-03-19 18:27:03 +0000)\n //    Publish at: 2020-03-19 18:26:54 +0000: receive value: (2020-03-19 18:27:06 +0000)\n //    Publish at: 2020-03-19 18:26:54 +0000: receive value: (2020-03-19 18:27:09 +0000)\n //    Received Timestamp 2020-03-19 18:27:09 +0000.\n"
  },
  {
    "title": "subscribe(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/subscribe(_:)-7c5ul",
    "html": "Parameters\nsubject\n\nThe subject to attach to this publisher."
  },
  {
    "title": "switchToLatest() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/switchtolatest()",
    "html": "Discussion\n\nThis operator works with an upstream publisher of publishers, flattening the stream of elements to appear as if they were coming from a single stream of elements. It switches the inner publisher as new ones arrive but keeps the outer publisher constant for downstream subscribers.\n\nWhen this operator receives a new publisher from the upstream publisher, it cancels its previous subscription. Use this feature to prevent earlier publishers from performing unnecessary work, such as creating network request publishers from frequently updating user interface publishers."
  },
  {
    "title": "subscribe(on:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/subscribe(on:options:)",
    "html": "Parameters\nscheduler\n\nThe scheduler used to send messages to upstream publishers.\n\noptions\n\nOptions that customize the delivery of elements.\n\nReturn Value\n\nA publisher which performs upstream operations on the specified scheduler.\n\nDiscussion\n\nIn contrast with receive(on:options:), which affects downstream messages, subscribe(on:options:) changes the execution context of upstream messages.\n\nIn the following example, the subscribe(on:options:) operator causes ioPerformingPublisher to receive requests on backgroundQueue, while the receive(on:options:) causes uiUpdatingSubscriber to receive elements and completion on RunLoop.main.\n\nlet ioPerformingPublisher == // Some publisher.\nlet uiUpdatingSubscriber == // Some subscriber that updates the UI.\n\n\nioPerformingPublisher\n    .subscribe(on: backgroundQueue)\n    .receive(on: RunLoop.main)\n    .subscribe(uiUpdatingSubscriber)\n\n\nUsing subscribe(on:options:) also causes the upstream publisher to perform Cancellable/cancel() using the specfied scheduler."
  },
  {
    "title": "scan(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/scan(_:_:)-6pykh",
    "html": "Parameters\ninitialResult\n\nThe previous result returned by the nextPartialResult closure.\n\nnextPartialResult\n\nA closure that takes as its arguments the previous value returned by the closure and the next element emitted from the upstream publisher.\n\nReturn Value\n\nA publisher that transforms elements by applying a closure that receives its previous return value and the next element from the upstream publisher.\n\nDiscussion\n\nUse scan(_:_:) to accumulate all previously-published values into a single value, which you then combine with each newly-published value.\n\nThe following example logs a running total of all values received from the sequence publisher.\n\nlet range = (0...5)\ncancellable = range.publisher\n    .scan(0) { return $0 + $1 }\n    .sink { print (\"\\($0)\", terminator: \" \") }\n // Prints: \"0 1 3 6 10 15 \".\n"
  },
  {
    "title": "sink(receiveCompletion:receiveValue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/sink(receivecompletion:receivevalue:)",
    "html": "Parameters\nreceiveComplete\n\nThe closure to execute on completion.\n\nreceiveValue\n\nThe closure to execute on receipt of a value.\n\nReturn Value\n\nA cancellable instance, which you use when you end assignment of the received value. Deallocation of the result will tear down the subscription stream.\n\nDiscussion\n\nUse sink(receiveCompletion:receiveValue:) to observe values received by the publisher and process them using a closure you specify.\n\nIn this example, a Range publisher publishes integers to a sink(receiveCompletion:receiveValue:) operator’s receiveValue closure that prints them to the console. Upon completion the sink(receiveCompletion:receiveValue:) operator’s receiveCompletion closure indicates the successful termination of the stream.\n\nlet myRange = (0...3)\ncancellable = myRange.publisher\n    .sink(receiveCompletion: { print (\"completion: \\($0)\") },\n          receiveValue: { print (\"value: \\($0)\") })\n\n\n// Prints:\n//  value: 0\n//  value: 1\n//  value: 2\n//  value: 3\n//  completion: finished\n\n\nThis method creates the subscriber and immediately requests an unlimited number of values, prior to returning the subscriber. The return value should be held, otherwise the stream will be canceled."
  },
  {
    "title": "sink(receiveValue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/sink(receivevalue:)",
    "html": "Parameters\nreceiveValue\n\nThe closure to execute on receipt of a value.\n\nReturn Value\n\nA cancellable instance, which you use when you end assignment of the received value. Deallocation of the result will tear down the subscription stream.\n\nDiscussion\n\nUse sink(receiveValue:) to observe values received by the publisher and print them to the console. This operator can only be used when the stream doesn’t fail, that is, when the publisher’s Publisher/Failure type is Never.\n\nIn this example, a Range publisher publishes integers to a sink(receiveValue:) operator’s receiveValue closure that prints them to the console:\n\nlet integers = (0...3)\nintegers.publisher\n    .sink { print(\"Received \\($0)\") }\n\n\n// Prints:\n//  Received 0\n//  Received 1\n//  Received 2\n//  Received 3\n\n\nThis method creates the subscriber and immediately requests an unlimited number of values, prior to returning the subscriber. The return value should be held, otherwise the stream will be canceled."
  },
  {
    "title": "removeDuplicates() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/removeduplicates()-avx0",
    "html": "Return Value\n\nA publisher that consumes — rather than publishes — duplicate elements.\n\nDiscussion\n\nUse removeDuplicates() to remove repeating elements from an upstream publisher. This operator has a two-element memory: the operator uses the current and previously published elements as the basis for its comparison.\n\nIn the example below, removeDuplicates() triggers on the doubled, tripled, and quadrupled occurrences of 1, 3, and 4 respectively. Because the two-element memory considers only the current element and the previous element, the operator prints the final 0 in the example data since its immediate predecessor is 4.\n\nlet numbers = [0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 0]\ncancellable = numbers.publisher\n    .removeDuplicates()\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"0 1 2 3 4 0\"\n"
  },
  {
    "title": "replaceNil(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/replacenil(with:)",
    "html": "Parameters\noutput\n\nThe element to use when replacing nil.\n\nReturn Value\n\nA publisher that replaces nil elements from the upstream publisher with the provided element.\n\nDiscussion\n\nThe replaceNil(with:) operator enables replacement of nil values in a stream with a substitute value. In the example below, a collection publisher contains a nil value. The replaceNil(with:) operator replaces this with 0.0.\n\nlet numbers: [Double?] = [1.0, 2.0, nil, 3.0]\nnumbers.publisher\n    .replaceNil(with: 0.0)\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"Optional(1.0) Optional(2.0) Optional(0.0) Optional(3.0)\"\n"
  },
  {
    "title": "setFailureType(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/setfailuretype(to:)-29p8s",
    "html": "Parameters\nfailureType\n\nThe Failure type presented by this publisher.\n\nReturn Value\n\nA publisher that appears to send the specified failure type.\n\nDiscussion\n\nUse setFailureType(to:) when you need set the error type of a publisher that cannot fail.\n\nConversely, if the upstream can fail, you would use mapError(_:) to provide instructions on converting the error types to needed by the downstream publisher’s inputs.\n\nThe following example has two publishers with mismatched error types: pub1’s error type is Never, and pub2’s error type is Error. Because of the mismatch, the combineLatest(_:) operator requires that pub1 use setFailureType(to:) to make it appear that pub1 can produce the Error type, like pub2 can.\n\nlet pub1 = [0, 1, 2, 3, 4, 5].publisher\nlet pub2 = CurrentValueSubject<Int, Error>(0)\nlet cancellable = pub1\n    .setFailureType(to: Error.self)\n    .combineLatest(pub2)\n    .sink(\n        receiveCompletion: { print (\"completed: \\($0)\") },\n        receiveValue: { print (\"value: \\($0)\")}\n     )\n\n\n// Prints: \"value: (5, 0)\".\n"
  },
  {
    "title": "print(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/print(_:to:)",
    "html": "Parameters\nprefix\n\nA string —- which defaults to empty -— with which to prefix all log messages.\n\nstream\n\nA stream for text output that receives messages, and which directs output to the console by default. A custom stream can be used to log messages to other destinations.\n\nReturn Value\n\nA publisher that prints log messages for all publishing events.\n\nDiscussion\n\nUse print(_:to:) to log messages the console.\n\nIn the example below, log messages are printed on the console:\n\nlet integers = (1...2)\ncancellable = integers.publisher\n   .print(\"Logged a message\", to: nil)\n   .sink { _ in }\n\n\n// Prints:\n//  Logged a message: receive subscription: (1..<2)\n//  Logged a message: request unlimited\n//  Logged a message: receive value: (1)\n//  Logged a message: receive finished\n"
  },
  {
    "title": "share() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/share()",
    "html": "Return Value\n\nA class instance that shares elements received from its upstream to multiple subscribers.\n\nDiscussion\n\nThe publisher returned by this operator supports multiple subscribers, all of whom receive unchanged elements and completion states from the upstream publisher.\n\nTip\n\nPublishers/Share is effectively a combination of the Publishers/Multicast and PassthroughSubject publishers, with an implicit ConnectablePublisher/autoconnect().\n\nThe following example uses a sequence publisher as a counter to publish three random numbers, generated by a Publisher/map(_:)-99evh operator. It uses a share() operator to share the same random number to each of two subscribers. This example uses a delay(for:tolerance:scheduler:options:) operator only to prevent the first subscriber from exhausting the sequence publisher immediately; an asynchronous publisher wouldn’t need this.\n\nlet pub = (1...3).publisher\n    .delay(for: 1, scheduler: DispatchQueue.main)\n    .map( { _ in return Int.random(in: 0...100) } )\n    .print(\"Random\")\n    .share()\n\n\ncancellable1 = pub\n    .sink { print (\"Stream 1 received: \\($0)\")}\ncancellable2 = pub\n    .sink { print (\"Stream 2 received: \\($0)\")}\n\n\n// Prints:\n// Random: receive value: (20)\n// Stream 1 received: 20\n// Stream 2 received: 20\n// Random: receive value: (85)\n// Stream 1 received: 85\n// Stream 2 received: 85\n// Random: receive value: (98)\n// Stream 1 received: 98\n// Stream 2 received: 98\n\n\nWithout the share() operator, stream 1 receives three random values, followed by stream 2 receiving three different random values.\n\nAlso note that Publishers/Share is a class rather than a structure like most other publishers. This means you can use this operator to create a publisher instance that uses reference semantics."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/reduce(_:_:)-2f2qa",
    "html": "Parameters\ninitialResult\n\nThe value that the closure receives the first time it’s called.\n\nnextPartialResult\n\nA closure that produces a new value by taking the previously-accumulated value and the next element it receives from the upstream publisher.\n\nReturn Value\n\nA publisher that applies the closure to all received elements and produces an accumulated value when the upstream publisher finishes. If reduce(_:_:) receives an error from the upstream publisher, the operator delivers it to the downstream subscriber, the publisher terminates and publishes no value.\n\nDiscussion\n\nUse reduce(_:_:) to collect a stream of elements and produce an accumulated value based on a closure you provide.\n\nIn the following example, the reduce(_:_:) operator collects all the integer values it receives from its upstream publisher:\n\nlet numbers = (0...10)\ncancellable = numbers.publisher\n    .reduce(0, { accum, next in accum + next })\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"55\"\n"
  },
  {
    "title": "receive(on:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/receive(on:options:)",
    "html": "Parameters\nscheduler\n\nThe scheduler the publisher uses for element delivery.\n\noptions\n\nScheduler options used to customize element delivery.\n\nReturn Value\n\nA publisher that delivers elements using the specified scheduler.\n\nDiscussion\n\nYou use the receive(on:options:) operator to receive results and completion on a specific scheduler, such as performing UI work on the main run loop. In contrast with subscribe(on:options:), which affects upstream messages, receive(on:options:) changes the execution context of downstream messages.\n\nIn the following example, the subscribe(on:options:) operator causes jsonPublisher to receive requests on backgroundQueue, while the receive(on:options:) causes labelUpdater to receive elements and completion on RunLoop.main.\n\nlet jsonPublisher = MyJSONLoaderPublisher() // Some publisher.\nlet labelUpdater = MyLabelUpdateSubscriber() // Some subscriber that updates the UI.\n\n\njsonPublisher\n    .subscribe(on: backgroundQueue)\n    .receive(on: RunLoop.main)\n    .subscribe(labelUpdater)\n\n\nPrefer receive(on:options:) over explicit use of dispatch queues when performing work in subscribers. For example, instead of the following pattern:\n\npub.sink {\n    DispatchQueue.main.async {\n        // Do something.\n    }\n}\n\n\nUse this pattern instead:\n\npub.receive(on: DispatchQueue.main).sink {\n    // Do something.\n}\n\n\nNote\n\nreceive(on:options:) doesn’t affect the scheduler used to call the subscriber’s Subscriber/receive(subscription:) method."
  },
  {
    "title": "prepend(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/prepend(_:)",
    "html": "Parameters\nelements\n\nThe elements to publish before this publisher’s elements.\n\nReturn Value\n\nA publisher that prefixes the specified elements prior to this publisher’s elements.\n\nDiscussion\n\nUse Publisher/prepend(_:)-7wk5l when you need to prepend specific elements before the output of a publisher.\n\nIn the example below, the Publisher/prepend(_:)-7wk5l operator publishes the provided elements before republishing all elements from dataElements:\n\nlet dataElements = (0...10)\ncancellable = dataElements.publisher\n    .prepend(0, 1, 255)\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"0 1 255 0 1 2 3 4 5 6 7 8 9 10\"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its parameter and returns a Boolean value that indicates whether publishing should continue.\n\nReturn Value\n\nA publisher that passes through elements until the predicate indicates publishing should finish.\n\nDiscussion\n\nUse prefix(while:) to emit values while elements from the upstream publisher meet a condition you specify. The publisher finishes when the closure returns false.\n\nIn the example below, the prefix(while:) operator emits values while the element it receives is less than five:\n\nlet numbers = (0...10)\nnumbers.publisher\n    .prefix { $0 < 5 }\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"0 1 2 3 4\"\n"
  },
  {
    "title": "prefix(untilOutputFrom:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/prefix(untiloutputfrom:)",
    "html": "Parameters\npublisher\n\nA second publisher.\n\nReturn Value\n\nA publisher that republishes elements until the second publisher publishes an element.\n\nDiscussion\n\nAfter the second publisher publishes an element, the publisher returned by this method finishes."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "zip(_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/zip(_:_:_:_:)",
    "html": "Parameters\npublisher1\n\nA second publisher.\n\npublisher2\n\nA third publisher.\n\npublisher3\n\nA fourth publisher.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that uses the transform closure to emit new elements, produced by combining the most recent value from four upstream publishers.\n\nDiscussion\n\nUse zip(_:_:_:_:) to return a new publisher that combines the elements from three other publishers using a transformation you specify to publish a new value to the downstream subscriber. The returned publisher waits until all four publishers have emitted an event, then delivers the oldest unconsumed event from each publisher together that the operator uses in the transformation.\n\nIn this example, the PassthroughSubject publishers, numbersPub, fractionsPub, lettersPub, and emojiPub emit values. The zip(_:_:_:_:) operator receives the oldest value from each publisher and uses the Int from numbersPub and publishes a string that repeats the String from lettersPub and emojiPub that many times and prints out the value in fractionsPub.\n\nlet numbersPub = PassthroughSubject<Int, Never>()      // first publisher\nlet lettersPub = PassthroughSubject<String, Never>()   // second\nlet emojiPub = PassthroughSubject<String, Never>()     // third\nlet fractionsPub  = PassthroughSubject<Double, Never>()// fourth\n\n\ncancellable = numbersPub\n    .zip(lettersPub, emojiPub, fractionsPub) { anInt, aLetter, anEmoji, aFraction  in\n        (\"\\(String(repeating: anEmoji, count: anInt)) \\(String(repeating: aLetter, count: anInt)) \\(aFraction)\")\n    }\n    .sink { print(\"\\($0)\") }\n\n\nnumbersPub.send(1)         // numbersPub: 1       lettersPub:          emojiPub:          zip output: <none>\nnumbersPub.send(2)         // numbersPub: 1,2     lettersPub:          emojiPub:          zip output: <none>\nnumbersPub.send(3)         // numbersPub: 1,2,3   lettersPub:          emojiPub:          zip output: <none>\nfractionsPub.send(0.1)     // numbersPub: 1,2,3   lettersPub: \"A\"      emojiPub:          zip output: <none>\nlettersPub.send(\"A\")       // numbersPub: 1,2,3   lettersPub: \"A\"      emojiPub:          zip output: <none>\nemojiPub.send(\"😀\")        // numbersPub: 1,2,3   lettersPub: \"A\"      emojiPub:\"😀\"      zip output: \"😀 A\"\nlettersPub.send(\"B\")       // numbersPub: 2,3     lettersPub: \"B\"      emojiPub:          zip output: <none>\nfractionsPub.send(0.8)     // numbersPub: 2,3     lettersPub: \"A\"      emojiPub:          zip output: <none>\nemojiPub.send(\"🥰\")        // numbersPub: 3       lettersPub: \"B\"      emojiPub:          zip output: \"🥰🥰 BB\"\n// Prints:\n//1 😀 A 0.1\n//2 🥰🥰 BB 0.8\n\n\nIf any upstream publisher finishes successfully or fails with an error, so too does the zipped publisher."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/split(separator:maxsplits:omittingemptysubsequences:)-84bnf",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/int64/words-swift.struct/index(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "zip(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/zip(_:_:_:)-5dx7l",
    "html": "Parameters\npublisher1\n\nA second publisher.\n\npublisher2\n\nA third publisher.\n\npublisher3\n\nA fourth publisher.\n\nReturn Value\n\nA publisher that emits groups of elements from the upstream publishers as tuples.\n\nDiscussion\n\nUse Publisher/zip(_:_:_:)-16rcy to return a new publisher that combines the elements from three other publishers to publish a tuple to the downstream subscriber. The returned publisher waits until all four publishers have emitted an event, then delivers the oldest unconsumed event from each publisher as a tuple to the subscriber.\n\nIn this example, several PassthroughSubject instances emit values; Publisher/zip(_:_:_:)-16rcy receives the oldest unconsumed value from each publisher and combines them into a tuple that it republishes to the downstream:\n\nlet numbersPub = PassthroughSubject<Int, Never>()\nlet lettersPub = PassthroughSubject<String, Never>()\nlet emojiPub = PassthroughSubject<String, Never>()\nlet fractionsPub  = PassthroughSubject<Double, Never>()\n\n\ncancellable = numbersPub\n    .zip(lettersPub, emojiPub, fractionsPub)\n    .sink { print(\"\\($0)\") }\nnumbersPub.send(1)         // numbersPub: 1       lettersPub:        emojiPub:       fractionsPub:         zip output: <none>\nnumbersPub.send(2)         // numbersPub: 1,2     lettersPub:        emojiPub:       fractionsPub:         zip output: <none>\nnumbersPub.send(3)         // numbersPub: 1,2,3   lettersPub:        emojiPub:       fractionsPub:         zip output: <none>\nfractionsPub.send(0.1)     // numbersPub: 1,2,3   lettersPub: \"A\"    emojiPub:       fractionsPub: 0.1     zip output: <none>\nlettersPub.send(\"A\")       // numbersPub: 1,2,3   lettersPub: \"A\"    emojiPub:       fractionsPub: 0.1     zip output: <none>\nemojiPub.send(\"😀\")        // numbersPub: 2,3     lettersPub: \"A\"    emojiPub: \"😀\"  fractionsPub: 0.1     zip output: (1, \"A\", \"😀\", 0.1)\nlettersPub.send(\"B\")       // numbersPub: 2,3     lettersPub: \"B\"    emojiPub:       fractionsPub:         zip output: <none>\nfractionsPub.send(0.8)     // numbersPub: 2,3     lettersPub: \"B\"    emojiPub:       fractionsPub: 0.8     zip output: <none>\nemojiPub.send(\"🥰\")        // numbersPub: 3       lettersPub: \"B\"    emojiPub:       fractionsPub: 0.8     zip output: (2, \"B\", \"🥰\", 0.8)\n// Prints:\n//  (1, \"A\", \"😀\", 0.1)\n//  (2, \"B\", \"🥰\", 0.8)\n\n\nIf any upstream publisher finishes successfully or fails with an error, so too does the zipped publisher."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyrandomaccesscollection/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyiterator/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil."
  },
  {
    "title": "combineLatest(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/combinelatest(_:_:)-8hngz",
    "html": "Parameters\nother\n\nAnother publisher to combine with this one.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that receives and combines elements from this and another publisher.\n\nDiscussion\n\nUse combineLatest<P,T>(_:) to combine the current and one additional publisher and transform them using a closure you specify to publish a new value to the downstream.\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t .unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer.\n\nIn the example below, combineLatest() receives the most-recent values published by the two publishers, it multiplies them together, and republishes the result:\n\nlet pub1 = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub1\n    .combineLatest(pub2) { (first, second) in\n        return first * second\n    }\n    .sink { print(\"Result: \\($0).\") }\n\n\npub1.send(1)\npub1.send(2)\npub2.send(2)\npub1.send(9)\npub1.send(3)\npub2.send(12)\npub1.send(13)\n//\n// Prints:\n//Result: 4.    (pub1 latest = 2, pub2 latest = 2)\n//Result: 18.   (pub1 latest = 9, pub2 latest = 2)\n//Result: 6.    (pub1 latest = 3, pub2 latest = 2)\n//Result: 36.   (pub1 latest = 3, pub2 latest = 12)\n//Result: 156.  (pub1 latest = 13, pub2 latest = 12)\n\n\nAll upstream publishers need to finish for this publisher to finish. If an upstream publisher never publishes a value, this publisher never finishes. If any of the combined publishers terminates with a failure, this publisher also fails."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the publisher’s output.\n\nReturn Value\n\nA publisher that skips over elements until the provided closure returns false.\n\nDiscussion\n\nUse drop(while:) to omit elements from an upstream publisher until the element received meets a condition you specify.\n\nIn the example below, the operator omits all elements in the stream until the first element arrives that’s a positive integer, after which the operator publishes all remaining elements:\n\nlet numbers = [-62, -1, 0, 10, 0, 22, 41, -1, 5]\ncancellable = numbers.publisher\n    .drop { $0 <= 0 }\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"10 0, 22 41 -1 5\"\n"
  },
  {
    "title": "eraseToAnyPublisher() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/erasetoanypublisher()",
    "html": "Return Value\n\nAn AnyPublisher wrapping this publisher.\n\nDiscussion\n\nUse eraseToAnyPublisher() to expose an instance of AnyPublisher to the downstream subscriber, rather than this publisher’s actual type. This form of type erasure preserves abstraction across API boundaries, such as different modules. When you expose your publishers as the AnyPublisher type, you can change the underlying implementation over time without affecting existing clients.\n\nThe following example shows two types that each have a publisher property. TypeWithSubject exposes this property as its actual type, PassthroughSubject, while TypeWithErasedSubject uses eraseToAnyPublisher() to expose it as an AnyPublisher. As seen in the output, a caller from another module can access TypeWithSubject.publisher as its native type. This means you can’t change your publisher to a different type without breaking the caller. By comparison, TypeWithErasedSubject.publisher appears to callers as an AnyPublisher, so you can change the underlying publisher type at will.\n\npublic class TypeWithSubject {\n    public let publisher: some Publisher = PassthroughSubject<Int,Never>()\n}\npublic class TypeWithErasedSubject {\n    public let publisher: some Publisher = PassthroughSubject<Int,Never>()\n        .eraseToAnyPublisher()\n}\n\n\n// In another module:\nlet nonErased = TypeWithSubject()\nif let subject = nonErased.publisher as? PassthroughSubject<Int,Never> {\n    print(\"Successfully cast nonErased.publisher.\")\n}\nlet erased = TypeWithErasedSubject()\nif let subject = erased.publisher as? PassthroughSubject<Int,Never> {\n    print(\"Successfully cast erased.publisher.\")\n}\n\n\n// Prints \"Successfully cast nonErased.publisher.\"\n"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence terminating at the end of the collection with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the collection, the result contains the entire collection.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is equal to maxLength."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to republish.\n\nReturn Value\n\nA publisher that publishes up to the specified number of elements.\n\nDiscussion\n\nUse prefix(_:) to limit the number of elements republished to the downstream subscriber.\n\nIn the example below, the prefix(_:) operator limits its output to the first two elements before finishing normally:\n\nlet numbers = (0...10)\ncancellable = numbers.publisher\n    .prefix(2)\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"0 1\"\n"
  },
  {
    "title": "merge(with:_:_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/merge(with:_:_:_:_:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nd\n\nA fourth publisher.\n\ne\n\nA fifth publisher.\n\nf\n\nA sixth publisher.\n\ng\n\nA seventh publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:_:_:_:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:_:)-48buc. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:_:)-16rcy.\n\nIn this example, as merge(with:_:_:_:_:_:) receives input from the upstream publishers; it republishes the interleaved elements to the downstream:\n\nlet pubA = PassthroughSubject<Int, Never>()\nlet pubB = PassthroughSubject<Int, Never>()\nlet pubC = PassthroughSubject<Int, Never>()\nlet pubD = PassthroughSubject<Int, Never>()\nlet pubE = PassthroughSubject<Int, Never>()\nlet pubF = PassthroughSubject<Int, Never>()\nlet pubG = PassthroughSubject<Int, Never>()\n\n\ncancellable = pubA\n    .merge(with: pubB, pubC, pubD, pubE, pubE, pubG)\n    .sink { print(\"\\($0)\", terminator: \" \" ) }\n\n\npubA.send(1)\npubB.send(40)\npubC.send(90)\npubD.send(-1)\npubE.send(33)\npubF.send(44)\npubG.send(54)\n\n\npubA.send(2)\npubB.send(50)\npubC.send(100)\npubD.send(-2)\npubE.send(33)\npubF.send(33)\npubG.send(54)\n\n\n//Prints: \"1 40 90 -1 33 44 54 2 50 100 -2 33 33 54\"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "output(at:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/output(at:)",
    "html": "Parameters\nindex\n\nThe index that indicates the element to publish.\n\nReturn Value\n\nA publisher that publishes a specific indexed element.\n\nDiscussion\n\nUse output(at:) when you need to republish a specific element specified by its position in the stream. If the publisher completes normally or with an error before publishing the specified element, then the publisher doesn’t produce any elements.\n\nIn the example below, the array publisher emits the fifth element in the sequence of published elements:\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumbers.publisher\n    .output(at: 5)\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"6\"\n"
  },
  {
    "title": "multicast(subject:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/multicast(subject:)",
    "html": "Parameters\nsubject\n\nA subject to deliver elements to downstream subscribers.\n\nDiscussion\n\nUse a multicast publisher when you have multiple downstream subscribers, but you want upstream publishers to only process one Subscriber/receive(_:) call per event. This is useful when upstream publishers are doing expensive work you don’t want to duplicate, like performing network requests.\n\nIn contrast with multicast(_:), this method produces a publisher that shares the provided Subject among all the downstream subscribers.\n\nThe following example uses a sequence publisher as a counter to publish three random numbers, generated by a Publisher/map(_:)-99evh operator. It uses a multicast(subject:) operator with a PassthroughSubject to share the same random number to each of two subscribers. Because the multicast publisher is a ConnectablePublisher, publishing only begins after a call to ConnectablePublisher/connect().\n\nlet pub = [\"First\", \"Second\", \"Third\"].publisher\n    .map( { return ($0, Int.random(in: 0...100)) } )\n    .print(\"Random\")\n    .multicast(subject: PassthroughSubject<(String, Int), Never>())\n\n\ncancellable1 = pub\n    .sink { print (\"Stream 1 received: \\($0)\")}\ncancellable2 = pub\n    .sink { print (\"Stream 2 received: \\($0)\")}\npub.connect()\n\n\n// Prints:\n// Random: receive value: ((\"First\", 78))\n// Stream 2 received: (\"First\", 78)\n// Stream 1 received: (\"First\", 78)\n// Random: receive value: ((\"Second\", 98))\n// Stream 2 received: (\"Second\", 98)\n// Stream 1 received: (\"Second\", 98)\n// Random: receive value: ((\"Third\", 61))\n// Stream 2 received: (\"Third\", 61)\n// Stream 1 received: (\"Third\", 61)\n\n\nIn this example, the output shows that the print(_:to:) operator receives each random value only one time, and then sends the value to both subscribers."
  },
  {
    "title": "merge(with:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/merge(with:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:)-5crqg. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:)-8d7k7.\n\nIn this example, as merge(with:_:) receives input from the upstream publishers, it republishes the interleaved elements to the downstream:\n\nlet pubA = PassthroughSubject<Int, Never>()\nlet pubB = PassthroughSubject<Int, Never>()\nlet pubC = PassthroughSubject<Int, Never>()\n\n\ncancellable = pubA\n    .merge(with: pubB, pubC)\n    .sink { print(\"\\($0)\", terminator: \" \" )}\n\n\npubA.send(1)\npubB.send(40)\npubC.send(90)\npubA.send(2)\npubB.send(50)\npubC.send(100)\n\n\n// Prints: \"1 40 90 2 50 100\"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/max()-1vow5",
    "html": "Return Value\n\nA publisher that publishes the maximum value received from the upstream publisher, after the upstream publisher finishes.\n\nDiscussion\n\nUse max() to determine the maximum value in the stream of elements from an upstream publisher.\n\nIn the example below, the max() operator emits a value when the publisher finishes, that value is the maximum of the values received from upstream, which is 10.\n\nlet numbers = [0, 10, 5]\ncancellable = numbers.publisher\n    .max()\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"10\"\n\n\nAfter this publisher receives a request for more than 0 items, it requests unlimited items from its upstream publisher."
  },
  {
    "title": "output(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/output(in:)",
    "html": "Parameters\nrange\n\nA range that indicates which elements to publish.\n\nReturn Value\n\nA publisher that publishes elements specified by a range.\n\nDiscussion\n\nUse output(in:) to republish a range indices you specify in the published stream. After publishing all elements, the publisher finishes normally. If the publisher completes normally or with an error before producing all the elements in the range, it doesn’t publish the remaining elements.\n\nIn the example below, an array publisher emits the subset of elements at the indices in the specified range:\n\nlet numbers = [1, 1, 2, 2, 2, 3, 4, 5, 6]\nnumbers.publisher\n    .output(in: (3...5))\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"2 2 3\"\n"
  },
  {
    "title": "merge(with:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/merge(with:_:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nd\n\nA fourth publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:_:)-48buc. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:_:)-16rcy.\n\nIn this example, as merge(with:_:_:) receives input from the upstream publishers, it republishes the interleaved elements to the downstream:\n\nlet pubA = PassthroughSubject<Int, Never>()\nlet pubB = PassthroughSubject<Int, Never>()\nlet pubC = PassthroughSubject<Int, Never>()\nlet pubD = PassthroughSubject<Int, Never>()\n\n\ncancellable = pubA\n    .merge(with: pubB, pubC, pubD)\n    .sink { print(\"\\($0)\", terminator: \" \" )}\n\n\npubA.send(1)\npubB.send(40)\npubC.send(90)\npubD.send(-1)\npubA.send(2)\npubB.send(50)\npubC.send(100)\npubD.send(-2)\n\n\n// Prints: \"1 40 90 -1 2 50 100 -2 \"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "multicast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/multicast(_:)",
    "html": "Parameters\ncreateSubject\n\nA closure to create a new Subject each time a subscriber attaches to the multicast publisher.\n\nDiscussion\n\nUse a multicast publisher when you have multiple downstream subscribers, but you want upstream publishers to only process one Subscriber/receive(_:) call per event. This is useful when upstream publishers are doing expensive work you don’t want to duplicate, like performing network requests.\n\nIn contrast with multicast(subject:), this method produces a publisher that creates a separate Subject for each subscriber.\n\nThe following example uses a sequence publisher as a counter to publish three random numbers, generated by a Publisher/map(_:)-99evh operator. It uses a multicast(_:) operator whose closure creates a PassthroughSubject to share the same random number to each of two subscribers. Because the multicast publisher is a ConnectablePublisher, publishing only begins after a call to ConnectablePublisher/connect().\n\nlet pub = [\"First\", \"Second\", \"Third\"].publisher\n    .map( { return ($0, Int.random(in: 0...100)) } )\n    .print(\"Random\")\n    .multicast { PassthroughSubject<(String, Int), Never>() }\n\n\ncancellable1 = pub\n   .sink { print (\"Stream 1 received: \\($0)\")}\ncancellable2 = pub\n   .sink { print (\"Stream 2 received: \\($0)\")}\npub.connect()\n\n\n// Prints:\n// Random: receive value: ((\"First\", 9))\n// Stream 2 received: (\"First\", 9)\n// Stream 1 received: (\"First\", 9)\n// Random: receive value: ((\"Second\", 46))\n// Stream 2 received: (\"Second\", 46)\n// Stream 1 received: (\"Second\", 46)\n// Random: receive value: ((\"Third\", 26))\n// Stream 2 received: (\"Third\", 26)\n// Stream 1 received: (\"Third\", 26)\n\n\nIn this example, the output shows that the print(_:to:) operator receives each random value only one time, and then sends the value to both subscribers."
  },
  {
    "title": "measureInterval(using:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/measureinterval(using:options:)",
    "html": "Parameters\nscheduler\n\nA scheduler to use for tracking the timing of events.\n\noptions\n\nOptions that customize the delivery of elements.\n\nReturn Value\n\nA publisher that emits elements representing the time interval between the elements it receives.\n\nDiscussion\n\nUse measureInterval(using:options:) to measure the time between events delivered from an upstream publisher.\n\nIn the example below, a 1-second Timer is used as the data source for an event publisher; the measureInterval(using:options:) operator reports the elapsed time between the reception of events on the main run loop:\n\ncancellable = Timer.publish(every: 1, on: .main, in: .default)\n    .autoconnect()\n    .measureInterval(using: RunLoop.main)\n    .sink { print(\"\\($0)\", terminator: \"\\n\") }\n\n\n// Prints:\n//      Stride(magnitude: 1.0013610124588013)\n//      Stride(magnitude: 0.9992760419845581)\n\n\nThe output type of the returned publisher is the time interval of the provided scheduler.\n\nThis operator uses the provided scheduler’s Scheduler/now property to measure intervals between events."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/min()-69qqr",
    "html": "Return Value\n\nA publisher that publishes the minimum value received from the upstream publisher, after the upstream publisher finishes.\n\nDiscussion\n\nUse min(by:) to find the minimum value in a stream of elements from an upstream publisher.\n\nIn the example below, the min(by:) operator emits a value when the publisher finishes, that value is the minimum of the values received from upstream, which is -1.\n\nlet numbers = [-1, 0, 10, 5]\nnumbers.publisher\n    .min()\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"-1\"\n\n\nAfter this publisher receives a request for more than 0 items, it requests unlimited items from its upstream publisher."
  },
  {
    "title": "map(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/map(_:_:_:)",
    "html": "Parameters\nkeyPath0\n\nThe key path of a property on Output.\n\nkeyPath1\n\nThe key path of a second property on Output.\n\nkeyPath2\n\nThe key path of a third property on Output.\n\nReturn Value\n\nA publisher that publishes the values of three key paths as a tuple.\n\nDiscussion\n\nIn the following example, the map(_:_:_:) operator uses the Swift key path syntax to access the die1, die2, and die3 members of the DiceRoll structure published by the Just publisher.\n\nThe downstream sink subscriber receives only these three values (as an (Int, Int, Int) tuple), not the entire DiceRoll.\n\nstruct DiceRoll {\n    let die1: Int\n    let die2: Int\n    let die3: Int\n}\n\n\ncancellable = Just(DiceRoll(die1:Int.random(in:1...6),\n                            die2: Int.random(in:1...6),\n                            die3: Int.random(in:1...6)))\n    .map(\\.die1, \\.die2, \\.die3)\n    .sink { values in\n        print (\"Rolled: \\(values.0), \\(values.1), \\(values.2) (total \\(values.0 + values.1 + values.2))\")\n    }\n// Prints \"Rolled: 5, 4, 2 (total 11)\" (or other random values).\n"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/map(_:)-re9c",
    "html": "Parameters\nkeyPath\n\nThe key path of a property on Output.\n\nReturn Value\n\nA publisher that publishes the value of the key path.\n\nDiscussion\n\nIn the following example, the Publisher/map(_:)-6sm0a operator uses the Swift key path syntax to access the die member of the DiceRoll structure published by the Just publisher.\n\nThe downstream sink subscriber receives only the value of this Int, not the entire DiceRoll.\n\nstruct DiceRoll {\n    let die: Int\n}\n\n\ncancellable = Just(DiceRoll(die:Int.random(in:1...6)))\n    .map(\\.die)\n    .sink {\n        print (\"Rolled: \\($0)\")\n    }\n// Prints \"Rolled: 3\" (or some other random value).\n"
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its parameter and returns a Boolean value that indicates whether to publish the element.\n\nReturn Value\n\nA publisher that only publishes the last element satisfying the given predicate.\n\nDiscussion\n\nUse last(where:) when you need to republish only the last element of a stream that satisfies a closure you specify.\n\nIn the example below, a range publisher emits the last element that satisfies the closure’s criteria, then finishes normally:\n\nlet numbers = (-10...10)\ncancellable = numbers.publisher\n    .last { $0 < 6 }\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"5\"\n"
  },
  {
    "title": "flatMap(maxPublishers:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/flatmap(maxpublishers:_:)-9ddzt",
    "html": "Parameters\nmaxPublishers\n\nSpecifies the maximum number of concurrent publisher subscriptions, or Combine/Subscribers/Demand/unlimited if unspecified.\n\ntransform\n\nA closure that takes an element as a parameter and returns a publisher that produces elements of that type.\n\nReturn Value\n\nA publisher that transforms elements from an upstream publisher into a publisher of that element’s type.\n\nDiscussion\n\nCombine‘s flatMap(maxPublishers:_:) operator performs a similar function to the doc://com.apple.documentation/documentation/Swift/Sequence/2905332-flatmap operator in the Swift standard library, but turns the elements from one kind of publisher into a new publisher that is sent to subscribers. Use flatMap(maxPublishers:_:) when you want to create a new series of events for downstream subscribers based on the received value. The closure creates the new Result.Publisher based on the received value. The new Result.Publisher can emit more than one event, and successful completion of the new Result.Publisher does not complete the overall stream. Failure of the new Result.Publisher causes the overall stream to fail.\n\nIn the example below, a PassthroughSubject publishes WeatherStation elements. The flatMap(maxPublishers:_:) receives each element, creates a URL from it, and produces a new URLSession.DataTaskPublisher, which will publish the data loaded from that URL.\n\npublic struct WeatherStation {\n    public let stationID: String\n}\n\n\nvar weatherPublisher = PassthroughSubject<WeatherStation, URLError>()\n\n\ncancellable = weatherPublisher.flatMap { station -> URLSession.DataTaskPublisher in\n    let url = URL(string:\"https://weatherapi.example.com/stations/\\(station.stationID)/observations/latest\")!\n    return URLSession.shared.dataTaskPublisher(for: url)\n}\n.sink(\n    receiveCompletion: { completion in\n        // Handle publisher completion (normal or error).\n    },\n    receiveValue: {\n        // Process the received data.\n    }\n )\n\n\nweatherPublisher.send(WeatherStation(stationID: \"KSFO\")) // San Francisco, CA\nweatherPublisher.send(WeatherStation(stationID: \"EGLC\")) // London, UK\nweatherPublisher.send(WeatherStation(stationID: \"ZBBB\")) // Beijing, CN\n"
  },
  {
    "title": "makeConnectable() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/makeconnectable()",
    "html": "Return Value\n\nA ConnectablePublisher wrapping this publisher.\n\nDiscussion\n\nIn the following example, makeConnectable() wraps its upstream publisher (an instance of Publishers/Share) with a ConnectablePublisher. Without this, the first sink subscriber would receive all the elements from the sequence publisher and cause it to complete before the second subscriber attaches. By making the publisher connectable, the publisher doesn’t produce any elements until after the ConnectablePublisher/connect() call.\n\n let subject = Just<String>(\"Sent\")\n let pub = subject\n     .share()\n     .makeConnectable()\n cancellable1 = pub.sink { print (\"Stream 1 received: \\($0)\")  }\n\n\n // For example purposes, use DispatchQueue to add a second subscriber\n // a second later, and then connect to the publisher a second after that.\n DispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n     self.cancellable2 = pub.sink { print (\"Stream 2 received: \\($0)\") }\n }\n DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n     self.connectable = pub.connect()\n }\n // Prints:\n // Stream 2 received: Sent\n // Stream 1 received: Sent\n\n\nNote\n\nThe ConnectablePublisher/connect() operator returns a Cancellable instance that you must retain. You can also use this instance to cancel publishing."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/map(_:)-4pr1v",
    "html": "Parameters\ntransform\n\nA closure that takes one element as its parameter and returns a new element.\n\nReturn Value\n\nA publisher that uses the provided closure to map elements from the upstream publisher to new elements that it then publishes.\n\nDiscussion\n\nCombine’s Publisher/map(_:)-99evh operator performs a function similar to that of doc://com.apple.documentation/documentation/Swift/Sequence/3018373-map in the Swift standard library: it uses a closure to transform each element it receives from the upstream publisher. You use Publisher/map(_:)-99evh to transform from one kind of element to another.\n\nThe following example uses an array of numbers as the source for a collection based publisher. A Publisher/map(_:)-99evh operator consumes each integer from the publisher and uses a dictionary to transform it from its Arabic numeral to a Roman equivalent, as a String. If the Publisher/map(_:)-99evh’s closure fails to look up a Roman numeral, it returns the string (unknown).\n\nlet numbers = [5, 4, 3, 2, 1, 0]\nlet romanNumeralDict: [Int : String] =\n   [1:\"I\", 2:\"II\", 3:\"III\", 4:\"IV\", 5:\"V\"]\ncancellable = numbers.publisher\n    .map { romanNumeralDict[$0] ?? \"(unknown)\" }\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"V IV III II I (unknown)\"\n\n\nIf your closure can throw an error, use Combine’s tryMap(_:) operator instead."
  },
  {
    "title": "handleEvents(receiveSubscription:receiveOutput:receiveCompletion:receiveCancel:receiveRequest:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/handleevents(receivesubscription:receiveoutput:receivecompletion:receivecancel:receiverequest:)",
    "html": "Parameters\nreceiveSubscription\n\nAn optional closure that executes when the publisher receives the subscription from the upstream publisher. This value defaults to nil.\n\nreceiveOutput\n\nAn optional closure that executes when the publisher receives a value from the upstream publisher. This value defaults to nil.\n\nreceiveCompletion\n\nAn optional closure that executes when the upstream publisher finishes normally or terminates with an error. This value defaults to nil.\n\nreceiveCancel\n\nAn optional closure that executes when the downstream receiver cancels publishing. This value defaults to nil.\n\nreceiveRequest\n\nAn optional closure that executes when the publisher receives a request for more elements. This value defaults to nil.\n\nReturn Value\n\nA publisher that performs the specified closures when publisher events occur.\n\nDiscussion\n\nUse handleEvents(receiveSubscription:receiveOutput:receiveCompletion:receiveCancel:receiveRequest:) when you want to examine elements as they progress through the stages of the publisher’s lifecycle.\n\nIn the example below, a publisher of integers shows the effect of printing debugging information at each stage of the element-processing lifecycle:\n\nlet integers = (0...2)\ncancellable = integers.publisher\n    .handleEvents(receiveSubscription: { subs in\n        print(\"Subscription: \\(subs.combineIdentifier)\")\n    }, receiveOutput: { anInt in\n        print(\"in output handler, received \\(anInt)\")\n    }, receiveCompletion: { _ in\n        print(\"in completion handler\")\n    }, receiveCancel: {\n        print(\"received cancel\")\n    }, receiveRequest: { (demand) in\n        print(\"received demand: \\(demand.description)\")\n    })\n    .sink { _ in return }\n\n\n// Prints:\n//   received demand: unlimited\n//   Subscription: 0x7f81284734c0\n//   in output handler, received 0\n//   in output handler, received 1\n//   in output handler, received 2\n//   in completion handler\n"
  },
  {
    "title": "tryLast(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/trylast(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its parameter and returns a Boolean value that indicates whether to publish the element.\n\nReturn Value\n\nA publisher that only publishes the last element satisfying the given predicate.\n\nDiscussion\n\nUse tryLast(where:) when you need to republish the last element that satisfies an error-throwing closure you specify. If the predicate closure throws an error, the publisher fails.\n\nIn the example below, a publisher emits the last element that satisfies the error-throwing closure, then finishes normally:\n\nstruct RangeError: Error {}\n\n\nlet numbers = [-62, 1, 6, 10, 9, 22, 41, -1, 5]\ncancellable = numbers.publisher\n    .tryLast {\n        guard 0 != 0  else {throw RangeError()}\n        return true\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\", terminator: \" \") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n    )\n// Prints: \"5 completion: finished\"\n// If instead the numbers array had contained a `0`, the `tryLast` operator would terminate publishing with a RangeError.\"\n"
  },
  {
    "title": "flatMap(maxPublishers:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/flatmap(maxpublishers:_:)-53wvm",
    "html": "Parameters\nmaxPublishers\n\nSpecifies the maximum number of concurrent publisher subscriptions, or Combine/Subscribers/Demand/unlimited if unspecified.\n\ntransform\n\nA closure that takes an element as a parameter and returns a publisher that produces elements of that type.\n\nReturn Value\n\nA publisher that transforms elements from an upstream publisher into a publisher of that element’s type."
  },
  {
    "title": "flatMap(maxPublishers:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/flatmap(maxpublishers:_:)-3jisi",
    "html": "Parameters\nmaxPublishers\n\nSpecifies the maximum number of concurrent publisher subscriptions, or Combine/Subscribers/Demand/unlimited if unspecified.\n\ntransform\n\nA closure that takes an element as a parameter and returns a publisher that produces elements of that type.\n\nReturn Value\n\nA publisher that transforms elements from an upstream publisher into a publisher of that element’s type."
  },
  {
    "title": "flatMap(maxPublishers:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/flatmap(maxpublishers:_:)-4wm8q",
    "html": "Parameters\nmaxPublishers\n\nSpecifies the maximum number of concurrent publisher subscriptions, or Combine/Subscribers/Demand/unlimited if unspecified.\n\ntransform\n\nA closure that takes an element as a parameter and returns a publisher that produces elements of that type.\n\nReturn Value\n\nA publisher that transforms elements from an upstream publisher into a publisher of that element’s type."
  },
  {
    "title": "values | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/values",
    "html": "Discussion\n\nThis property provides an AsyncThrowingPublisher, which allows you to use the Swift async-await syntax to receive the publisher’s elements. Because AsyncPublisher conforms to AsyncSequence, you iterate over its elements with a for-await-in loop, rather than attaching a subscriber. If the publisher terminates with an error, the awaiting caller receives the error as a throw.\n\nThe following example shows how to use the values property to receive elements asynchronously. The example adapts a code snippet from the tryFilter(_:) operator’s documentation, which filters a sequence to only emit even integers, and terminate with an error on a 0. This example replaces the Subscribers/Sink subscriber with a for-await-in loop that iterates over the AsyncPublisher provided by the values property. With this approach, the error handling previously provided in the sink subscriber’s Subscribers/Sink/receiveCompletion closure goes instead in a catch block.\n\nlet numbers: [Int] = [1, 2, 3, 4, 0, 5]\nlet filterPublisher = numbers.publisher\n    .tryFilter{\n        if $0 == 0 {\n            throw ZeroError()\n        } else {\n            return $0 % 2 == 0\n        }\n    }\n\n\ndo {\n    for try await number in filterPublisher.values {\n        print (\"\\(number)\", terminator: \" \")\n    }\n} catch {\n    print (\"\\(error)\")\n}\n"
  },
  {
    "title": "zip(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/zip(_:_:_:)-55kzt",
    "html": "Parameters\npublisher1\n\nA second publisher.\n\npublisher2\n\nA third publisher.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that uses the transform closure to emit new elements, produced by combining the most recent value from three upstream publishers.\n\nDiscussion\n\nUse Publisher/zip(_:_:_:)-9yqi1 to return a new publisher that combines the elements from two other publishers using a transformation you specify to publish a new value to the downstream subscriber. The returned publisher waits until all three publishers have emitted an event, then delivers the oldest unconsumed event from each publisher together that the operator uses in the transformation.\n\nIn this example, numbersPub, lettersPub and emojiPub are each a PassthroughSubject that emit values; Publisher/zip(_:_:_:)-9yqi1 receives the oldest value from each publisher and uses the Int from numbersPub and publishes a string that repeats the String from lettersPub and emojiPub that many times.\n\nlet numbersPub = PassthroughSubject<Int, Never>()\nlet lettersPub = PassthroughSubject<String, Never>()\nlet emojiPub = PassthroughSubject<String, Never>()\n\n\ncancellable = numbersPub\n    .zip(letters, emoji) { anInt, aLetter, anEmoji in\n        (\"\\(String(repeating: anEmoji, count: anInt)) \\(String(repeating: aLetter, count: anInt))\")\n    }\n    .sink { print(\"\\($0)\") }\n\n\nnumbersPub.send(1)     // numbersPub: 1      lettersPub:        emojiPub:            zip output: <none>\nnumbersPub.send(2)     // numbersPub: 1,2    lettersPub:        emojiPub:            zip output: <none>\nnumbersPub.send(3)     // numbersPub: 1,2,3  lettersPub:        emojiPub:            zip output: <none>\nlettersPub.send(\"A\")   // numbersPub: 1,2,3  lettersPub: \"A\"    emojiPub:            zip output: <none>\nemojiPub.send(\"😀\")    // numbersPub: 2,3    lettersPub: \"A\"    emojiPub:\"😀\"        zip output: \"😀 A\"\nlettersPub.send(\"B\")   // numbersPub: 2,3    lettersPub: \"B\"    emojiPub:            zip output: <none>\nemojiPub.send(\"🥰\")    // numbersPub: 3      lettersPub:        emojiPub:\"😀\", \"🥰\"  zip output: \"🥰🥰 BB\"\n\n\n// Prints:\n// 😀 A\n// 🥰🥰 BB\n\n\nIf any upstream publisher finishes successfully or fails with an error, so too does the zipped publisher."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value that indicates whether to publish the element.\n\nReturn Value\n\nA publisher that only publishes the first element of a stream that satisfies the predicate.\n\nDiscussion\n\nUse first(where:) to republish only the first element of a stream that satisfies a closure you specify. The publisher ignores all elements after the first element that satisfies the closure and finishes normally. If this publisher doesn’t receive any elements, it finishes without publishing.\n\nIn the example below, the provided closure causes the Publishers/FirstWhere publisher to republish the first received element that’s greater than 0, then finishes normally.\n\nlet numbers = (-10...10)\ncancellable = numbers.publisher\n    .first { $0 > 0 }\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"1\"\n"
  },
  {
    "title": "tryPrefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/tryprefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its parameter and returns a Boolean value indicating whether publishing should continue.\n\nReturn Value\n\nA publisher that passes through elements until the predicate throws or indicates publishing should finish.\n\nDiscussion\n\nUse tryPrefix(while:) to emit values from the upstream publisher that meet a condition you specify in an error-throwing closure. The publisher finishes when the closure returns false. If the closure throws an error, the publisher fails with that error.\n\nstruct OutOfRangeError: Error {}\n\n\nlet numbers = (0...10).reversed()\ncancellable = numbers.publisher\n    .tryPrefix {\n        guard $0 != 0 else {throw OutOfRangeError()}\n        return $0 <= numbers.max()!\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\", terminator: \" \") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n    )\n\n\n// Prints: \"10 9 8 7 6 5 4 3 2 1 completion: failure(OutOfRangeError()) \"\n"
  },
  {
    "title": "tryScan(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/tryscan(_:_:)-1pgp5",
    "html": "Parameters\ninitialResult\n\nThe previous result returned by the nextPartialResult closure.\n\nnextPartialResult\n\nAn error-throwing closure that takes as its arguments the previous value returned by the closure and the next element emitted from the upstream publisher.\n\nReturn Value\n\nA publisher that transforms elements by applying a closure that receives its previous return value and the next element from the upstream publisher.\n\nDiscussion\n\nUse tryScan(_:_:) to accumulate all previously-published values into a single value, which you then combine with each newly-published value. If your accumulator closure throws an error, the publisher terminates with the error.\n\nIn the example below, tryScan(_:_:) calls a division function on elements of a collection publisher. The Publishers/TryScan publisher publishes each result until the function encounters a DivisionByZeroError, which terminates the publisher.\n\nstruct DivisionByZeroError: Error {}\n\n\n/// A function that throws a DivisionByZeroError if `current` provided by the TryScan publisher is zero.\nfunc myThrowingFunction(_ lastValue: Int, _ currentValue: Int) throws -> Int {\n    guard currentValue != 0 else { throw DivisionByZeroError() }\n    return (lastValue + currentValue) / currentValue\n }\n\n\nlet numbers = [1,2,3,4,5,0,6,7,8,9]\ncancellable = numbers.publisher\n    .tryScan(10) { try myThrowingFunction($0, $1) }\n    .sink(\n        receiveCompletion: { print (\"\\($0)\") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"11 6 3 1 1 -1 failure(DivisionByZeroError())\".\n\n\nIf the closure throws an error, the publisher fails with the error."
  },
  {
    "title": "zip(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/zip(_:)",
    "html": "Parameters\nother\n\nAnother publisher.\n\nReturn Value\n\nA publisher that emits pairs of elements from the upstream publishers as tuples.\n\nDiscussion\n\nUse zip(_:) to combine the latest elements from two publishers and emit a tuple to the downstream. The returned publisher waits until both publishers have emitted an event, then delivers the oldest unconsumed event from each publisher together as a tuple to the subscriber.\n\nMuch like a zipper or zip fastener on a piece of clothing pulls together rows of teeth to link the two sides, zip(_:) combines streams from two different publishers by linking pairs of elements from each side.\n\nIn this example, numbers and letters are PassthroughSubjects that emit values; once zip(_:) receives one value from each, it publishes the pair as a tuple to the downstream subscriber. It then waits for the next pair of values.\n\n let numbersPub = PassthroughSubject<Int, Never>()\n let lettersPub = PassthroughSubject<String, Never>()\n\n\n cancellable = numbersPub\n     .zip(lettersPub)\n     .sink { print(\"\\($0)\") }\n numbersPub.send(1)    // numbersPub: 1      lettersPub:        zip output: <none>\n numbersPub.send(2)    // numbersPub: 1,2    lettersPub:        zip output: <none>\n letters.send(\"A\")     // numbers: 1,2       letters:\"A\"        zip output: <none>\n numbers.send(3)       // numbers: 1,2,3     letters:           zip output: (1,\"A\")\n letters.send(\"B\")     // numbers: 1,2,3     letters: \"B\"       zip output: (2,\"B\")\n\n\n // Prints:\n //  (1, \"A\")\n //  (2, \"B\")\n\n\nIf either upstream publisher finishes successfully or fails with an error, the zipped publisher does the same."
  },
  {
    "title": "append(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/append(_:)",
    "html": "Parameters\nelements\n\nElements to publish after this publisher’s elements.\n\nReturn Value\n\nA publisher that appends the specifiecd elements after this publisher’s elements.\n\nDiscussion\n\nUse Publisher/append(_:)-1qb8d when you need to prepend specific elements after the output of a publisher.\n\nIn the example below, the Publisher/append(_:)-1qb8d operator publishes the provided elements after republishing all elements from dataElements:\n\nlet dataElements = (0...10)\ncancellable = dataElements.publisher\n    .append(0, 1, 255)\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"0 1 2 3 4 5 6 7 8 9 10 0 1 255\"\n"
  },
  {
    "title": "zip(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/zip(_:_:)-8pfav",
    "html": "Parameters\npublisher1\n\nA second publisher.\n\npublisher2\n\nA third publisher.\n\nReturn Value\n\nA publisher that emits groups of elements from the upstream publishers as tuples.\n\nDiscussion\n\nUse Publisher/zip(_:_:)-8d7k7 to return a new publisher that combines the elements from two additional publishers to publish a tuple to the downstream. The returned publisher waits until all three publishers have emitted an event, then delivers the oldest unconsumed event from each publisher as a tuple to the subscriber.\n\nIn this example, numbersPub, lettersPub and emojiPub are each a PassthroughSubject; Publisher/zip(_:_:)-8d7k7 receives the oldest unconsumed value from each publisher and combines them into a tuple that it republishes to the downstream:\n\nlet numbersPub = PassthroughSubject<Int, Never>()\nlet lettersPub = PassthroughSubject<String, Never>()\nlet emojiPub = PassthroughSubject<String, Never>()\n\n\ncancellable = numbersPub\n    .zip(lettersPub, emojiPub)\n    .sink { print(\"\\($0)\") }\nnumbersPub.send(1)     // numbersPub: 1      lettersPub:          emojiPub:        zip output: <none>\nnumbersPub.send(2)     // numbersPub: 1,2    lettersPub:          emojiPub:        zip output: <none>\nnumbersPub.send(3)     // numbersPub: 1,2,3  lettersPub:          emojiPub:        zip output: <none>\nlettersPub.send(\"A\")   // numbersPub: 1,2,3  lettersPub: \"A\"      emojiPub:        zip output: <none>\nemojiPub.send(\"😀\")    // numbersPub: 2,3    lettersPub: \"A\"      emojiPub: \"😀\"   zip output: (1, \"A\", \"😀\")\nlettersPub.send(\"B\")   // numbersPub: 2,3    lettersPub: \"B\"      emojiPub:        zip output: <none>\nemojiPub.send(\"🥰\")    // numbersPub: 3      lettersPub:          emojiPub:        zip output: (2, \"B\", \"🥰\")\n\n\n// Prints:\n//  (1, \"A\", \"😀\")\n//  (2, \"B\", \"🥰\")\n\n\nIf any upstream publisher finishes successfully or fails with an error, so too does the zipped publisher."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/formindex(_:offsetby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "tryReduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/tryreduce(_:_:)-3837a",
    "html": "Parameters\ninitialResult\n\nThe value that the closure receives the first time it’s called.\n\nnextPartialResult\n\nAn error-throwing closure that takes the previously-accumulated value and the next element from the upstream publisher to produce a new value.\n\nReturn Value\n\nA publisher that applies the closure to all received elements and produces an accumulated value when the upstream publisher finishes.\n\nDiscussion\n\nUse tryReduce(_:_:) to collect a stream of elements and produce an accumulated value based on an error-throwing closure you provide. If the closure throws an error, the publisher fails and passes the error to its subscriber.\n\nIn the example below, the publisher’s 0 element causes the myDivide(_:_:) function to throw an error and publish the doc://com.apple.documentation/documentation/Swift/Double/1641611-nan result:\n\nstruct DivisionByZeroError: Error {}\nfunc myDivide(_ dividend: Double, _ divisor: Double) throws -> Double {\n    guard divisor != 0 else { throw DivisionByZeroError() }\n    return dividend / divisor\n}\n\n\nvar numbers: [Double] = [5, 4, 3, 2, 1, 0]\nnumbers.publisher\n    .tryReduce(numbers.first!, { accum, next in try myDivide(accum, next) })\n    .catch({ _ in Just(Double.nan) })\n    .sink { print(\"\\($0)\") }\n"
  },
  {
    "title": "tryMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/trymap(_:)-16sv7",
    "html": "Parameters\ntransform\n\nA closure that takes one element as its parameter and returns a new element. If the closure throws an error, the publisher fails with the thrown error.\n\nReturn Value\n\nA publisher that uses the provided closure to map elements from the upstream publisher to new elements that it then publishes.\n\nDiscussion\n\nCombine’s tryMap(_:) operator performs a function similar to that of doc://com.apple.documentation/documentation/Swift/Sequence/3018373-map in the Swift standard library: it uses a closure to transform each element it receives from the upstream publisher. You use tryMap(_:) to transform from one kind of element to another, and to terminate publishing when the map’s closure throws an error.\n\nThe following example uses an array of numbers as the source for a collection based publisher. A tryMap(_:) operator consumes each integer from the publisher and uses a dictionary to transform it from its Arabic numeral to a Roman equivalent, as a String. If the tryMap(_:)’s closure fails to look up a Roman numeral, it throws an error. The tryMap(_:) operator catches this error and terminates publishing, sending a Subscribers/Completion/failure(_:) that wraps the error.\n\nstruct ParseError: Error {}\nfunc romanNumeral(from:Int) throws -> String {\n    let romanNumeralDict: [Int : String] =\n        [1:\"I\", 2:\"II\", 3:\"III\", 4:\"IV\", 5:\"V\"]\n    guard let numeral = romanNumeralDict[from] else {\n        throw ParseError()\n    }\n    return numeral\n}\nlet numbers = [5, 4, 3, 2, 1, 0]\ncancellable = numbers.publisher\n    .tryMap { try romanNumeral(from: $0) }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"V IV III II I completion: failure(ParseError())\"\n\n\nIf your closure doesn’t throw, use Publisher/map(_:)-99evh instead."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/subscript(_:)-4syjt",
    "html": "Overview\n\nPrecondition\n\nposition is a valid position in self and position != endIndex."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/split(separator:maxsplits:omittingemptysubsequences:)-f04l",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/endindex",
    "html": "Discussion\n\nendIndex is always reachable from startIndex by zero or more applications of index(after:)."
  },
  {
    "title": "assign(to:on:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/assign(to:on:)",
    "html": "Parameters\nkeyPath\n\nA key path that indicates the property to assign. See Key-Path Expression in The Swift Programming Language to learn how to use key paths to specify a property of an object.\n\nobject\n\nThe object that contains the property. The subscriber assigns the object’s property every time it receives a new value.\n\nReturn Value\n\nAn AnyCancellable instance. Call Cancellable/cancel() on this instance when you no longer want the publisher to automatically assign the property. Deinitializing this instance will also cancel automatic assignment.\n\nDiscussion\n\nUse the assign(to:on:) subscriber when you want to set a given property each time a publisher produces a value.\n\nIn this example, the assign(to:on:) sets the value of the anInt property on an instance of MyClass:\n\nclass MyClass {\n    var anInt: Int = 0 {\n        didSet {\n            print(\"anInt was set to: \\(anInt)\", terminator: \"; \")\n        }\n    }\n}\n\n\nvar myObject = MyClass()\nlet myRange = (0...2)\ncancellable = myRange.publisher\n    .assign(to: \\.anInt, on: myObject)\n\n\n// Prints: \"anInt was set to: 0; anInt was set to: 1; anInt was set to: 2\"\n\n\nImportant\n\nThe Subscribers/Assign instance created by this operator maintains a strong reference to object, and sets it to nil when the upstream publisher completes (either normally or with an error)."
  },
  {
    "title": "assign(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/assign(to:)",
    "html": "Parameters\npublished\n\nA property marked with the @Published attribute, which receives and republishes all elements received from the upstream publisher.\n\nDiscussion\n\nUse this operator when you want to receive elements from a publisher and republish them through a property marked with the @Published attribute. The assign(to:) operator manages the life cycle of the subscription, canceling the subscription automatically when the Published instance deinitializes. Because of this, the assign(to:) operator doesn’t return an AnyCancellable that you’re responsible for like assign(to:on:) does.\n\nThe example below shows a model class that receives elements from an internal Timer.TimerPublisher, and assigns them to a @Published property called lastUpdated. Because the to parameter has the inout keyword, you need to use the & operator when calling this method.\n\nclass MyModel: ObservableObject {\n    @Published var lastUpdated: Date = Date()\n    init() {\n         Timer.publish(every: 1.0, on: .main, in: .common)\n             .autoconnect()\n             .assign(to: &$lastUpdated)\n    }\n}\n\n\nIf you instead implemented MyModel with assign(to: lastUpdated, on: self), storing the returned AnyCancellable instance could cause a reference cycle, because the Subscribers/Assign subscriber would hold a strong reference to self. Using assign(to:) solves this problem.\n\nWhile the to parameter uses the inout keyword, this method doesn’t replace a reference type passed to it. Instead, this notation indicates that the operator may modify members of the assigned object, as seen in the following example:\n\n    class MyModel2: ObservableObject {\n        @Published var id: Int = 0\n    }\n    let model2 = MyModel2()\n    Just(100).assign(to: &model2.$id)\n"
  },
  {
    "title": "breakpoint(receiveSubscription:receiveOutput:receiveCompletion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/breakpoint(receivesubscription:receiveoutput:receivecompletion:)",
    "html": "Parameters\nreceiveSubscription\n\nA closure that executes when the publisher receives a subscription. Return true from this closure to raise SIGTRAP, or false to continue.\n\nreceiveOutput\n\nA closure that executes when the publisher receives a value. Return true from this closure to raise SIGTRAP, or false to continue.\n\nreceiveCompletion\n\nA closure that executes when the publisher receives a completion. Return true from this closure to raise SIGTRAP, or false to continue.\n\nReturn Value\n\nA publisher that raises a debugger signal when one of the provided closures returns true.\n\nDiscussion\n\nUse breakpoint(receiveSubscription:receiveOutput:receiveCompletion:) to examine one or more stages of the subscribe/publish/completion process and stop in the debugger, based on conditions you specify. When any of the provided closures returns true, this operator raises the SIGTRAP signal to stop the process in the debugger. Otherwise, this publisher passes through values and completions as-is.\n\nIn the example below, a PassthroughSubject publishes strings to a breakpoint republisher. When the breakpoint receives the string “DEBUGGER”, it returns true, which stops the app in the debugger.\n\nlet publisher = PassthroughSubject<String?, Never>()\ncancellable = publisher\n    .breakpoint(\n        receiveOutput: { value in return value == \"DEBUGGER\" }\n    )\n    .sink { print(\"\\(String(describing: $0))\" , terminator: \" \") }\n\n\npublisher.send(\"DEBUGGER\")\n\n\n// Prints: \"error: Execution was interrupted, reason: signal SIGTRAP.\"\n// Depending on your specific environment, the console messages may\n// also include stack trace information, which is not shown here.\n"
  },
  {
    "title": "collect(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/collect(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of received elements to buffer before publishing.\n\nReturn Value\n\nA publisher that collects up to the specified number of elements, and then publishes them as an array.\n\nDiscussion\n\nUse collect(_:) to emit arrays of at most count elements from an upstream publisher. If the upstream publisher finishes before collecting the specified number of elements, the publisher sends an array of only the items it received. This may be fewer than count elements.\n\nIf the upstream publisher fails with an error, this publisher forwards the error to the downstream receiver instead of sending its output.\n\nIn the example below, the collect(_:) operator emits one partial and two full arrays based on the requested collection size of 5:\n\nlet numbers = (0...10)\ncancellable = numbers.publisher\n    .collect(5)\n    .sink { print(\"\\($0), terminator: \" \"\") }\n\n\n// Prints \"[0, 1, 2, 3, 4] [5, 6, 7, 8, 9] [10] \"\n\n\nNote\n\nWhen this publisher receives a request for .max(n) elements, it requests .max(count * n) from the upstream publisher."
  },
  {
    "title": "buffer(size:prefetch:whenFull:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/buffer(size:prefetch:whenfull:)",
    "html": "Parameters\nsize\n\nThe maximum number of elements to store.\n\nprefetch\n\nThe strategy to initially populate the buffer.\n\nwhenFull\n\nThe action to take when the buffer becomes full.\n\nReturn Value\n\nA publisher that buffers elements received from an upstream publisher.\n\nDiscussion\n\nUse buffer(size:prefetch:whenFull:) to collect a specific number of elements from an upstream publisher before republishing them to the downstream subscriber according to the Publishers/BufferingStrategy and Publishers/PrefetchStrategy strategy you specify.\n\nIf the publisher completes before reaching the size threshold, it buffers the elements and publishes them downstream prior to completion."
  },
  {
    "title": "catch(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/catch(_:)",
    "html": "Parameters\nhandler\n\nA closure that accepts the upstream failure as input and returns a publisher to replace the upstream publisher.\n\nReturn Value\n\nA publisher that handles errors from an upstream publisher by replacing the failed publisher with another publisher.\n\nDiscussion\n\nUse catch() to replace an error from an upstream publisher with a new publisher.\n\nIn the example below, the catch() operator handles the SimpleError thrown by the upstream publisher by replacing the error with a Just publisher. This continues the stream by publishing a single value and completing normally.\n\nstruct SimpleError: Error {}\nlet numbers = [5, 4, 3, 2, 1, 0, 9, 8, 7, 6]\ncancellable = numbers.publisher\n    .tryLast(where: {\n        guard $0 != 0 else {throw SimpleError()}\n        return true\n    })\n    .catch({ (error) in\n        Just(-1)\n    })\n    .sink { print(\"\\($0)\") }\n    // Prints: -1\n\n\nBackpressure note: This publisher passes through request and cancel to the upstream. After receiving an error, the publisher sends sends any unfulfilled demand to the new Publisher. SeeAlso: replaceError"
  },
  {
    "title": "breakpointOnError() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/breakpointonerror()",
    "html": "Return Value\n\nA publisher that raises a debugger signal upon receiving a failure.\n\nDiscussion\n\nWhen the upstream publisher fails with an error, this publisher raises the SIGTRAP signal, which stops the process in the debugger. Otherwise, this publisher passes through values and completions as-is.\n\nIn this example a PassthroughSubject publishes strings, but its downstream tryMap(_:) operator throws an error. This sends the error downstream as a Subscribers/Completion/failure(_:). The breakpointOnError() operator receives this completion and stops the app in the debugger.\n\n struct CustomError : Error {}\n let publisher = PassthroughSubject<String?, Error>()\n cancellable = publisher\n     .tryMap { stringValue in\n         throw CustomError()\n     }\n     .breakpointOnError()\n     .sink(\n         receiveCompletion: { completion in print(\"Completion: \\(String(describing: completion))\") },\n         receiveValue: { aValue in print(\"Result: \\(String(describing: aValue))\") }\n     )\n\n\n publisher.send(\"TEST DATA\")\n\n\n // Prints: \"error: Execution was interrupted, reason: signal SIGTRAP.\"\n // Depending on your specific environment, the console messages may\n // also include stack trace information, which is not shown here.\n"
  },
  {
    "title": "collect(_:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/collect(_:options:)",
    "html": "Parameters\nstrategy\n\nThe timing group strategy used by the operator to collect and publish elements.\n\noptions\n\nScheduler options to use for the strategy.\n\nReturn Value\n\nA publisher that collects elements by a given strategy, and emits a single array of the collection.\n\nDiscussion\n\nUse collect(_:options:) to emit arrays of elements on a schedule specified by a Scheduler and Stride that you provide. At the end of each scheduled interval, the publisher sends an array that contains the items it collected. If the upstream publisher finishes before filling the buffer, the publisher sends an array that contains items it received. This may be fewer than the number of elements specified in the requested Stride.\n\nIf the upstream publisher fails with an error, this publisher forwards the error to the downstream receiver instead of sending its output.\n\nThe example above collects timestamps generated on a one-second Timer in groups (Stride) of five.\n\nlet sub = Timer.publish(every: 1, on: .main, in: .default)\n    .autoconnect()\n    .collect(.byTime(RunLoop.main, .seconds(5)))\n    .sink { print(\"\\($0)\", terminator: \"\\n\\n\") }\n\n\n// Prints: \"[2020-01-24 00:54:46 +0000, 2020-01-24 00:54:47 +0000,\n//          2020-01-24 00:54:48 +0000, 2020-01-24 00:54:49 +0000,\n//          2020-01-24 00:54:50 +0000]\"\n\n\nNote\n\nWhen this publisher receives a request for .max(n) elements, it requests .max(count * n) from the upstream publisher."
  },
  {
    "title": "combineLatest(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/combinelatest(_:_:_:)-20old",
    "html": "Parameters\npublisher1\n\nA second publisher to combine with the first publisher.\n\npublisher2\n\nA third publisher to combine with the first publisher.\n\npublisher3\n\nA fourth publisher to combine with the first publisher.\n\nReturn Value\n\nA publisher that receives and combines elements from this publisher and three other publishers.\n\nDiscussion\n\nUse Publisher/combineLatest(_:_:_:)-48buc when you want the downstream subscriber to receive a tuple of the most-recent element from multiple publishers when any of them emit a value. To combine elements from multiple publishers, use Publisher/zip(_:_:_:)-16rcy instead. To receive just the most-recent element from multiple publishers rather than tuples, use merge(with:_:_:).\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t Subscribers/Demand/unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer.\n\nAll upstream publishers need to finish for this publisher to finish. If an upstream publisher never publishes a value, this publisher never finishes.\n\nIn the example below, Publisher/combineLatest(_:_:_:)-48buc receives input from any of the publishers, combines the latest value from each publisher into a tuple and publishes it:\n\nlet pub = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\nlet pub3 = PassthroughSubject<Int, Never>()\nlet pub4 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub\n    .combineLatest(pub2, pub3, pub4)\n    .sink { print(\"Result: \\($0).\") }\n\n\npub.send(1)\npub.send(2)\npub2.send(2)\npub3.send(9)\npub4.send(1)\n\n\npub.send(3)\npub2.send(12)\npub.send(13)\npub3.send(19)\n//\n// Prints:\n//  Result: (2, 2, 9, 1).\n//  Result: (3, 2, 9, 1).\n//  Result: (3, 12, 9, 1).\n//  Result: (13, 12, 9, 1).\n//  Result: (13, 12, 19, 1).\n\n\nIf any individual publisher of the combined set terminates with a failure, this publisher also fails."
  },
  {
    "title": "combineLatest(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/combinelatest(_:)",
    "html": "Parameters\nother\n\nAnother publisher to combine with this one.\n\nReturn Value\n\nA publisher that receives and combines elements from this and another publisher.\n\nDiscussion\n\nUse combineLatest(_:) when you want the downstream subscriber to receive a tuple of the most-recent element from multiple publishers when any of them emit a value. To pair elements from multiple publishers, use zip(_:) instead. To receive just the most-recent element from multiple publishers rather than tuples, use Publisher/merge(with:)-7qt71.\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t Subscribers/Demand/unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer.\n\nIn this example, PassthroughSubject pub1 and also pub2 emit values; as combineLatest(_:) receives input from either upstream publisher, it combines the latest value from each publisher into a tuple and publishes it.\n\nlet pub1 = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub1\n    .combineLatest(pub2)\n    .sink { print(\"Result: \\($0).\") }\n\n\npub1.send(1)\npub1.send(2)\npub2.send(2)\npub1.send(3)\npub1.send(45)\npub2.send(22)\n\n\n// Prints:\n//    Result: (2, 2).    // pub1 latest = 2, pub2 latest = 2\n//    Result: (3, 2).    // pub1 latest = 3, pub2 latest = 2\n//    Result: (45, 2).   // pub1 latest = 45, pub2 latest = 2\n//    Result: (45, 22).  // pub1 latest = 45, pub2 latest = 22\n\n\nWhen all upstream publishers finish, this publisher finishes. If an upstream publisher never publishes a value, this publisher never finishes."
  },
  {
    "title": "combineLatest(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/combinelatest(_:_:)-7cw12",
    "html": "Parameters\npublisher1\n\nA second publisher to combine with the first publisher.\n\npublisher2\n\nA third publisher to combine with the first publisher.\n\nReturn Value\n\nA publisher that receives and combines elements from this publisher and two other publishers.\n\nDiscussion\n\nUse Publisher/combineLatest(_:_:)-5crqg when you want the downstream subscriber to receive a tuple of the most-recent element from multiple publishers when any of them emit a value. To combine elements from multiple publishers, use Publisher/zip(_:_:)-8d7k7 instead. To receive just the most-recent element from multiple publishers rather than tuples, use merge(with:_:).\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t Subscribers/Demand/unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer.\n\nAll upstream publishers need to finish for this publisher to finish. If an upstream publisher never publishes a value, this publisher never finishes.\n\nIn this example, three instances of PassthroughSubject emit values; as Publisher/combineLatest(_:_:)-5crqg receives input from any of the upstream publishers, it combines the latest value from each publisher into a tuple and publishes it:\n\nlet pub = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\nlet pub3 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub\n    .combineLatest(pub2, pub3)\n    .sink { print(\"Result: \\($0).\") }\n\n\npub.send(1)\npub.send(2)\npub2.send(2)\npub3.send(9)\n\n\npub.send(3)\npub2.send(12)\npub.send(13)\npub3.send(19)\n\n\n// Prints:\n//  Result: (2, 2, 9).\n//  Result: (3, 2, 9).\n//  Result: (3, 12, 9).\n//  Result: (13, 12, 9).\n//  Result: (13, 12, 19).\n\n\nIf any of the combined publishers terminates with a failure, this publisher also fails."
  },
  {
    "title": "combineLatest(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/combinelatest(_:_:_:)-9bqz",
    "html": "Parameters\npublisher1\n\nA second publisher to combine with the first publisher.\n\npublisher2\n\nA third publisher to combine with the first publisher.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that receives and combines elements from this publisher and two other publishers.\n\nDiscussion\n\nUse combineLatest<P, Q>(_:,_:) to combine the current and two additional publishers and transform them using a closure you specify to publish a new value to the downstream.\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t .unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer. All upstream publishers need to finish for this publisher to finish. If an upstream publisher never publishes a value, this publisher never finishes. If any of the combined publishers terminates with a failure, this publisher also fails.\n\nIn the example below, combineLatest() receives the most-recent values published by three publishers, multiplies them together, and republishes the result:\n\nlet pub = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\nlet pub3 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub\n    .combineLatest(pub2, pub3) { firstValue, secondValue, thirdValue in\n        return firstValue * secondValue * thirdValue\n    }\n    .sink { print(\"Result: \\($0).\") }\n\n\npub.send(1)\npub.send(2)\npub2.send(2)\npub3.send(10)\n\n\npub.send(9)\npub3.send(4)\npub2.send(12)\n\n\n// Prints:\n//  Result: 40.     // pub = 2, pub2 = 2, pub3 = 10\n//  Result: 180.    // pub = 9, pub2 = 2, pub3 = 10\n//  Result: 72.     // pub = 9, pub2 = 2, pub3 = 4\n//  Result: 432.    // pub = 9, pub2 = 12, pub3 = 4\n"
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that receives a value and returns an optional value.\n\nReturn Value\n\nAny non-nil optional results of the calling the supplied closure.\n\nDiscussion\n\nCombine’s compactMap(_:) operator performs a function similar to that of doc://com.apple.documentation/documentation/Swift/Sequence/2950916-compactmap in the Swift standard library: the compactMap(_:) operator in Combine removes nil elements in a publisher’s stream and republishes non-nil elements to the downstream subscriber.\n\nThe example below uses a range of numbers as the source for a collection based publisher. The compactMap(_:) operator consumes each element from the numbers publisher attempting to access the dictionary using the element as the key. If the example’s dictionary returns a nil, due to a non-existent key, compactMap(_:) filters out the nil (missing) elements.\n\nlet numbers = (0...5)\nlet romanNumeralDict: [Int : String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ncancellable = numbers.publisher\n    .compactMap { romanNumeralDict[$0] }\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"I II III V\"\n"
  },
  {
    "title": "combineLatest(_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/combinelatest(_:_:_:_:)",
    "html": "Parameters\npublisher1\n\nA second publisher to combine with the first publisher.\n\npublisher2\n\nA third publisher to combine with the first publisher.\n\npublisher3\n\nA fourth publisher to combine with the first publisher.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that receives and combines elements from this publisher and three other publishers.\n\nDiscussion\n\nUse combineLatest(_:_:_:_:) when you need to combine the current and 3 additional publishers and transform the values using a closure in which you specify the published elements, to publish a new element.\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t Subscribers/Demand/unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer.\n\nAll upstream publishers need to finish for this publisher to finish. If an upstream publisher never publishes a value, this publisher never finishes.\n\nIn the example below, as combineLatest(_:_:_:_:) receives the most-recent values published by four publishers, multiplies them together, and republishes the result:\n\nlet pub = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\nlet pub3 = PassthroughSubject<Int, Never>()\nlet pub4 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub\n    .combineLatest(pub2, pub3, pub4) { firstValue, secondValue, thirdValue, fourthValue in\n        return firstValue * secondValue * thirdValue * fourthValue\n    }\n    .sink { print(\"Result: \\($0).\") }\n\n\npub.send(1)\npub.send(2)\npub2.send(2)\npub3.send(9)\npub4.send(1)\n\n\npub.send(3)\npub2.send(12)\npub.send(13)\npub3.send(19)\n\n\n// Prints:\n//  Result: 36.     // pub = 2,  pub2 = 2,   pub3 = 9,  pub4 = 1\n//  Result: 54.     // pub = 3,  pub2 = 2,   pub3 = 9,  pub4 = 1\n//  Result: 324.    // pub = 3,  pub2 = 12,  pub3 = 9,  pub4 = 1\n//  Result: 1404.   // pub = 13, pub2 = 12,  pub3 = 9,  pub4 = 1\n//  Result: 2964.   // pub = 13, pub2 = 12,  pub3 = 19, pub4 = 1\n"
  },
  {
    "title": "delay(for:tolerance:scheduler:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/delay(for:tolerance:scheduler:options:)",
    "html": "Parameters\ninterval\n\nThe amount of time to delay.\n\ntolerance\n\nThe allowed tolerance in delivering delayed events. The Delay publisher may deliver elements this much sooner or later than the interval specifies.\n\nscheduler\n\nThe scheduler to deliver the delayed events.\n\noptions\n\nOptions relevant to the scheduler’s behavior.\n\nReturn Value\n\nA publisher that delays delivery of elements and completion to the downstream receiver.\n\nDiscussion\n\nUse delay(for:tolerance:scheduler:options:) when you need to delay the delivery of elements to a downstream by a specified amount of time.\n\nIn this example, a Timer publishes an event every second. The delay(for:tolerance:scheduler:options:) operator holds the delivery of the initial element for 3 seconds (±0.5 seconds), after which each element is delivered to the downstream on the main run loop after the specified delay:\n\nlet df = DateFormatter()\ndf.dateStyle = .none\ndf.timeStyle = .long\ncancellable = Timer.publish(every: 1.0, on: .main, in: .default)\n    .autoconnect()\n    .handleEvents(receiveOutput: { date in\n        print (\"Sending Timestamp \\'\\(df.string(from: date))\\' to delay()\")\n    })\n    .delay(for: .seconds(3), scheduler: RunLoop.main, options: .none)\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\", terminator: \"\\n\") },\n        receiveValue: { value in\n            let now = Date()\n            print (\"At \\(df.string(from: now)) received  Timestamp \\'\\(df.string(from: value))\\' sent: \\(String(format: \"%.2f\", now.timeIntervalSince(value))) secs ago\", terminator: \"\\n\")\n        }\n    )\n\n\n// Prints:\n//    Sending Timestamp '5:02:33 PM PDT' to delay()\n//    Sending Timestamp '5:02:34 PM PDT' to delay()\n//    Sending Timestamp '5:02:35 PM PDT' to delay()\n//    Sending Timestamp '5:02:36 PM PDT' to delay()\n//    At 5:02:36 PM PDT received  Timestamp '5:02:33 PM PDT' sent: 3.00 secs ago\n//    Sending Timestamp '5:02:37 PM PDT' to delay()\n//    At 5:02:37 PM PDT received  Timestamp '5:02:34 PM PDT' sent: 3.00 secs ago\n//    Sending Timestamp '5:02:38 PM PDT' to delay()\n//    At 5:02:38 PM PDT received  Timestamp '5:02:35 PM PDT' sent: 3.00 secs ago\n\n\nThe delay affects the delivery of elements and completion, but not of the original subscription."
  },
  {
    "title": "drop(untilOutputFrom:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/drop(untiloutputfrom:)",
    "html": "Parameters\npublisher\n\nA publisher to monitor for its first emitted element.\n\nReturn Value\n\nA publisher that drops elements from the upstream publisher until the other publisher produces a value.\n\nDiscussion\n\nUse drop(untilOutputFrom:) to ignore elements from the upstream publisher until another, second, publisher delivers its first element. This publisher requests a single value from the second publisher, and it ignores (drops) all elements from the upstream publisher until the second publisher produces a value. After the second publisher produces an element, drop(untilOutputFrom:) cancels its subscription to the second publisher, and allows events from the upstream publisher to pass through.\n\nAfter this publisher receives a subscription from the upstream publisher, it passes through backpressure requests from downstream to the upstream publisher. If the upstream publisher acts on those requests before the other publisher produces an item, this publisher drops the elements it receives from the upstream publisher.\n\nIn the example below, the pub1 publisher defers publishing its elements until the pub2 publisher delivers its first element:\n\nlet upstream = PassthroughSubject<Int,Never>()\nlet second = PassthroughSubject<String,Never>()\ncancellable = upstream\n    .drop(untilOutputFrom: second)\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\nupstream.send(1)\nupstream.send(2)\nsecond.send(\"A\")\nupstream.send(3)\nupstream.send(4)\n// Prints \"3 4\"\n"
  },
  {
    "title": "decode(type:decoder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/decode(type:decoder:)",
    "html": "Parameters\ntype\n\nThe encoded data to decode into a struct that conforms to the Decodable protocol.\n\ndecoder\n\nA decoder that implements the TopLevelDecoder protocol.\n\nReturn Value\n\nA publisher that decodes a given type using a specified decoder and publishes the result.\n\nDiscussion\n\nUse decode(type:decoder:) with a JSONDecoder (or a PropertyListDecoder for property lists) to decode data received from a URLSession.DataTaskPublisher or other data source using the Decodable protocol.\n\nIn this example, a PassthroughSubject publishes a JSON string. The JSON decoder parses the string, converting its fields according to the Decodable protocol implemented by Article, and successfully populating a new Article. The Publishers/Decode publisher then publishes the Article to the downstream. If a decoding operation fails, which happens in the case of missing or malformed data in the source JSON string, the stream terminates and passes the error to the downstream subscriber.\n\nstruct Article: Codable {\n    let title: String\n    let author: String\n    let pubDate: Date\n}\n\n\nlet dataProvider = PassthroughSubject<Data, Never>()\ncancellable = dataProvider\n    .decode(type: Article.self, decoder: JSONDecoder())\n    .sink(receiveCompletion: { print (\"Completion: \\($0)\")},\n          receiveValue: { print (\"value: \\($0)\") })\n\n\ndataProvider.send(Data(\"{\\\"pubDate\\\":1574273638.575666, \\\"title\\\" : \\\"My First Article\\\", \\\"author\\\" : \\\"Gita Kumar\\\" }\".utf8))\n\n\n// Prints: \".sink() data received Article(title: \"My First Article\", author: \"Gita Kumar\", pubDate: 2050-11-20 18:13:58 +0000)\"\n"
  },
  {
    "title": "encode(encoder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/encode(encoder:)",
    "html": "Parameters\nencoder\n\nAn encoder that implements the TopLevelEncoder protocol.\n\nReturn Value\n\nA publisher that encodes received elements using a specified encoder, and publishes the resulting data.\n\nDiscussion\n\nUse encode(encoder:) with a JSONDecoder (or a PropertyListDecoder for property lists) to encode an Encodable struct into Data that could be used to make a JSON string (or written to disk as a binary plist in the case of property lists).\n\nIn this example, a PassthroughSubject publishes an Article. The encode(encoder:) operator encodes the properties of the Article struct into a new JSON string according to the Codable protocol adopted by Article. The operator publishes the resulting JSON string to the downstream subscriber. If the encoding operation fails, which can happen in the case of complex properties that can’t be directly transformed into JSON, the stream terminates and the error is passed to the downstream subscriber.\n\nstruct Article: Codable {\n    let title: String\n    let author: String\n    let pubDate: Date\n}\n\n\nlet dataProvider = PassthroughSubject<Article, Never>()\nlet cancellable = dataProvider\n    .encode(encoder: JSONEncoder())\n    .sink(receiveCompletion: { print (\"Completion: \\($0)\") },\n          receiveValue: {  data in\n            guard let stringRepresentation = String(data: data, encoding: .utf8) else { return }\n            print(\"Data received \\(data) string representation: \\(stringRepresentation)\")\n    })\n\n\ndataProvider.send(Article(title: \"My First Article\", author: \"Gita Kumar\", pubDate: Date()))\n\n\n// Prints: \"Data received 86 bytes string representation: {\"title\":\"My First Article\",\"author\":\"Gita Kumar\",\"pubDate\":606211803.279603}\"\n"
  },
  {
    "title": "debounce(for:scheduler:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/debounce(for:scheduler:options:)",
    "html": "Parameters\ndueTime\n\nThe time the publisher should wait before publishing an element.\n\nscheduler\n\nThe scheduler on which this publisher delivers elements\n\noptions\n\nScheduler options that customize this publisher’s delivery of elements.\n\nReturn Value\n\nA publisher that publishes events only after a specified time elapses.\n\nDiscussion\n\nUse the debounce(for:scheduler:options:) operator to control the number of values and time between delivery of values from the upstream publisher. This operator is useful to process bursty or high-volume event streams where you need to reduce the number of values delivered to the downstream to a rate you specify.\n\nIn this example, a PassthroughSubject publishes elements on a schedule defined by the bounces array. The array is composed of tuples representing a value sent by the PassthroughSubject, and a TimeInterval ranging from one-quarter second up to 2 seconds that drives a delivery timer. As the queue builds, elements arriving faster than one-half second debounceInterval are discarded, while elements arriving at a rate slower than debounceInterval are passed through to the sink(receiveValue:) operator.\n\nlet bounces:[(Int,TimeInterval)] = [\n    (0, 0),\n    (1, 0.25),  // 0.25s interval since last index\n    (2, 1),     // 0.75s interval since last index\n    (3, 1.25),  // 0.25s interval since last index\n    (4, 1.5),   // 0.25s interval since last index\n    (5, 2)      // 0.5s interval since last index\n]\n\n\nlet subject = PassthroughSubject<Int, Never>()\ncancellable = subject\n    .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n    .sink { index in\n        print (\"Received index \\(index)\")\n    }\n\n\nfor bounce in bounces {\n    DispatchQueue.main.asyncAfter(deadline: .now() + bounce.1) {\n        subject.send(bounce.0)\n    }\n}\n\n\n// Prints:\n//  Received index 1\n//  Received index 4\n//  Received index 5\n\n\n//  Here is the event flow shown from the perspective of time, showing value delivery through the `debounce()` operator:\n\n\n//  Time 0: Send index 0.\n//  Time 0.25: Send index 1. Index 0 was waiting and is discarded.\n//  Time 0.75: Debounce period ends, publish index 1.\n//  Time 1: Send index 2.\n//  Time 1.25: Send index 3. Index 2 was waiting and is discarded.\n//  Time 1.5: Send index 4. Index 3 was waiting and is discarded.\n//  Time 2: Debounce period ends, publish index 4. Also, send index 5.\n//  Time 2.5: Debounce period ends, publish index 5.\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/dropfirst(_:)",
    "html": "Parameters\ncount\n\nThe number of elements to omit. The default is 1.\n\nReturn Value\n\nA publisher that doesn’t republish the first count elements.\n\nDiscussion\n\nUse dropFirst(_:) when you want to drop the first n elements from the upstream publisher, and republish the remaining elements.\n\nThe example below drops the first five elements from the stream:\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ncancellable = numbers.publisher\n    .dropFirst(5)\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"6 7 8 9 10 \"\n"
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/contains(_:)-895n0",
    "html": "Parameters\noutput\n\nAn element to match against.\n\nReturn Value\n\nA publisher that emits the Boolean value true when the upstream publisher emits a matching value.\n\nDiscussion\n\nUse contains(_:) to find the first element in an upstream that’s equal to the supplied argument. The contains publisher consumes all received elements until the upstream publisher produces a matching element. Upon finding the first match, it emits true and finishes normally. If the upstream finishes normally without producing a matching element, this publisher emits false and finishes.\n\nIn the example below, the contains(_:) operator emits true the first time it receives the value 5 from the numbers.publisher, and then finishes normally.\n\nlet numbers = [-1, 5, 10, 5]\nnumbers.publisher\n    .contains(5)\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"true\"\n"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes one element and returns a Boolean value indicating whether to republish the element.\n\nReturn Value\n\nA publisher that republishes all elements that satisfy the closure.\n\nDiscussion\n\nCombine’s filter(_:) operator performs an operation similar to that of doc://com.apple.documentation/documentation/Swift/Sequence/3018365-filter in the Swift Standard Library: it uses a closure to test each element to determine whether to republish the element to the downstream subscriber.\n\nThe following example, uses a filter operation that receives an Int and only republishes a value if it’s even.\n\nlet numbers: [Int] = [1, 2, 3, 4, 5]\ncancellable = numbers.publisher\n    .filter { $0 % 2 == 0 }\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"2 4\"\n"
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/formindex(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/droplast(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop off the end of the collection. k must be greater than or equal to zero.\n\nReturn Value\n\nA subsequence that leaves off k elements from the end.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the number of elements to drop."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/reversed()",
    "html": "Discussion\n\nYou can reverse a collection without allocating new space for its elements by calling this reversed() method. A ReversedCollection instance wraps an underlying collection and provides access to its elements in reverse order. This example prints the characters of a string in reverse order:\n\nlet word = \"Backwards\"\nfor char in word.reversed() {\n    print(char, terminator: \"\")\n}\n// Prints \"sdrawkcaB\"\n\n\nIf you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer. For example, to get the reversed version of a string, reverse its characters and initialize a new String instance from the result.\n\nlet reversedWord = String(word.reversed())\nprint(reversedWord)\n// Prints \"sdrawkcaB\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "merge(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/result/publisher-swift.struct/merge(with:)",
    "html": "Parameters\nother\n\nAnother publisher of this publisher’s type.\n\nReturn Value\n\nA publisher that emits an event when either upstream publisher emits an event."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/index(_:offsetby:limitedby:)-5uiel",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/subscript(_:)-4caas",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nFor example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2..<5]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")!    // 4\nprint(streets[index])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/index(_:offsetby:limitedby:)-29l06",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/isempty",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/index(_:offsetby:limitedby:)-6rs60",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/formindex(after:)-40uaw",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/distance(from:to:)-19nbj",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "formIndex(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/formindex(_:offsetby:)-4fulw",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/formindex(_:offsetby:limitedby:)-94oyz",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/distance(from:to:)-64w60",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "LazyMapSequence.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/count-5qqod",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/count-1u1qn",
    "html": "Discussion\n\nTo check whether the collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if Index conforms to RandomAccessIndex; O(n) otherwise."
  },
  {
    "title": "count | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/count",
    "html": "Discussion\n\nTo check whether a collection is empty, use its isEmpty property instead of comparing count to zero. Unless the collection guarantees random-access performance, calculating count can be an O(n) operation.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "isEmpty | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/isempty-75pes",
    "html": "Discussion\n\nWhen you need to check whether your collection is empty, use the isEmpty property instead of checking that the count property is equal to zero. For collections that don’t conform to RandomAccessCollection, accessing the count property iterates through the elements of the collection.\n\nlet horseName = \"Silver\"\nif horseName.isEmpty {\n    print(\"My horse has no name.\")\n} else {\n    print(\"Hi ho, \\(horseName)!\")\n}\n// Prints \"Hi ho, Silver!\")\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "endIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/endindex",
    "html": "Discussion\n\nWhen you need a range that includes the last element of a collection, use the half-open range operator (..<) with endIndex. The ..< operator creates a range that doesn’t include the upper bound, so it’s always safe to use with endIndex. For example:\n\nlet numbers = [10, 20, 30, 40, 50]\nif let index = numbers.firstIndex(of: 30) {\n    print(numbers[index ..< numbers.endIndex])\n}\n// Prints \"[30, 40, 50]\"\n\n\nIf the collection is empty, endIndex is equal to startIndex."
  },
  {
    "title": "indices | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/indices-swift.property",
    "html": "Discussion\n\nA collection’s indices property can hold a strong reference to the collection itself, causing the collection to be nonuniquely referenced. If you mutate the collection while iterating over its indices, a strong reference can result in an unexpected copy of the collection. To avoid the unexpected copy, use the index(after:) method starting with startIndex to produce indices instead.\n\nvar c = MyFancyCollection([10, 20, 30, 40, 50])\nvar i = c.startIndex\nwhile i != c.endIndex {\n    c[i] /= 5\n    i = c.index(after: i)\n}\n// c == MyFancyCollection([2, 4, 6, 8, 10])\n"
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/uint64/words-swift.struct/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/next()",
    "html": "Return Value\n\nThe next element in the underlying sequence, if a next element exists; otherwise, nil.\n\nDiscussion\n\nRepeatedly calling this method returns, in order, all the elements of the underlying sequence. As soon as the sequence has run out of elements, all subsequent calls return nil.\n\nYou must not call this method if any other copy of this iterator has been advanced with a call to its next() method.\n\nThe following example shows how an iterator can be used explicitly to emulate a for-in loop. First, retrieve a sequence’s iterator, and then call the iterator’s next() method until it returns nil.\n\nlet numbers = [2, 3, 5, 7]\nvar numbersIterator = numbers.makeIterator()\n\n\nwhile let num = numbersIterator.next() {\n    print(num)\n}\n// Prints \"2\"\n// Prints \"3\"\n// Prints \"5\"\n// Prints \"7\"\n"
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/distance(from:to:)-3i820",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "distance(from:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/distance(from:to:)-3of9q",
    "html": "Parameters\nstart\n\nA valid index of the collection.\n\nend\n\nAnother valid index of the collection. If end is equal to start, the result is zero.\n\nReturn Value\n\nThe distance between start and end. The result can be negative only if the collection conforms to the BidirectionalCollection protocol.\n\nDiscussion\n\nUnless the collection conforms to the BidirectionalCollection protocol, start must be less than or equal to end.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the resulting distance."
  },
  {
    "title": "firstIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/firstindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe first index where element is found. If element is not found in the collection, returns nil.\n\nDiscussion\n\nAfter using firstIndex(of:) to find the position of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Maxime\"]\nif let i = students.firstIndex(of: \"Maxime\") {\n    students[i] = \"Max\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "formIndex(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/formindex(_:offsetby:limitedby:)",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\ntrue if i has been offset by exactly distance steps without going beyond limit; otherwise, false. When the return value is false, the value of i is equal to limit.\n\nDiscussion\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/formindex(after:)-6932e",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/index(_:offsetby:)-2louz",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/index(_:offsetby:limitedby:)-9dlbr",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, a limit that is less than i has no effect. Likewise, if distance < 0, a limit that is greater than i has no effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position. The operation doesn’t require going beyond the limiting s.endIndex value, so it succeeds.\n\nlet s = \"Swift\"\nif let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {\n    print(s[i])\n}\n// Prints \"t\"\n\n\nThe next example attempts to retrieve an index six positions from s.startIndex but fails, because that distance is beyond the index passed as limit.\n\nlet j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/index(_:offsetby:)-78pdz",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "index(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/index(after:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex.\n\nReturn Value\n\nThe index value immediately after i.\n\nDiscussion\n\nThe successor of an index must be well defined. For an index i into a collection c, calling c.index(after: i) returns the same index every time."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/map(_:)-8kdmg",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "prefix(through:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/prefix(through:)",
    "html": "Parameters\nposition\n\nThe index of the last element to include in the resulting subsequence. position must be a valid index of the collection that is not equal to the endIndex property.\n\nReturn Value\n\nA subsequence up to, and including, the given position.\n\nDiscussion\n\nThe resulting subsequence includes the element at the position specified by the through parameter. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, and including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(through: i))\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nUsing the prefix(through:) method is equivalent to using a partial closed range as the collection’s subscript. The subscript notation is preferred over prefix(through:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[...i])\n}\n// Prints \"[10, 20, 30, 40]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "randomElement() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/randomelement()",
    "html": "Return Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement() to select a random element from an array or another collection. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement()!\n// randomName == \"Amani\"\n\n\nThis method is equivalent to calling randomElement(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/split(separator:maxsplits:omittingemptysubsequences:)-5eafc",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the collection, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original collection containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the collection and for each instance of separator at the start or end of the collection. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this collection’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the collection are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \"))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "randomElement(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/randomelement(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when choosing a random element.\n\nReturn Value\n\nA random element from the collection. If the collection is empty, the method returns nil.\n\nDiscussion\n\nCall randomElement(using:) to select a random element from an array or another collection when you are using a custom random number generator. This example picks a name at random from an array:\n\nlet names = [\"Zoey\", \"Chloe\", \"Amani\", \"Amaia\"]\nlet randomName = names.randomElement(using: &myGenerator)!\n// randomName == \"Amani\"\n\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection.\n\nNote\n\nThe algorithm used to select a random element may change in a future version of Swift. If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "suffix(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/suffix(from:)",
    "html": "Parameters\nstart\n\nThe index at which to start the resulting subsequence. start must be a valid index of the collection.\n\nReturn Value\n\nA subsequence starting at the start position.\n\nDiscussion\n\nThe following example searches for the index of the number 40 in an array of integers, and then prints the suffix of the array starting at that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.suffix(from: i))\n}\n// Prints \"[40, 50, 60]\"\n\n\nPassing the collection’s endIndex as the start parameter results in an empty subsequence.\n\nprint(numbers.suffix(from: numbers.endIndex))\n// Prints \"[]\"\n\n\nUsing the suffix(from:) method is equivalent to using a partial range from the index as the collection’s subscript. The subscript notation is preferred over suffix(from:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[i...])\n}\n// Prints \"[40, 50, 60]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/subscript(_:)-4qmx0",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nFor example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2..<5]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")!    // 4\nprint(streets[index])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/subscript(_:)-3hxz5",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/subscript(_:)-36b2w",
    "html": "Overview\n\nPrecondition\n\nposition is a valid position in self and position != endIndex."
  },
  {
    "title": "LazyMapSequence.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "LazyFilterSequence.SubSequence | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/subsequence",
    "html": "Discussion\n\nThe default subsequence type for collections that don’t define their own is Slice."
  },
  {
    "title": "subscript(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/subscript(_:)-lelz",
    "html": "Parameters\nbounds\n\nA range of the collection’s indices. The bounds of the range must be valid indices of the collection.\n\nOverview\n\nThe range expression is converted to a concrete subrange relative to this collection. For example, using a PartialRangeFrom range expression with an array accesses the subrange from the start of the range expression until the end of the array.\n\nlet streets = [\"Adams\", \"Bryant\", \"Channing\", \"Douglas\", \"Evarts\"]\nlet streetsSlice = streets[2...]\nprint(streetsSlice)\n// [\"Channing\", \"Douglas\", \"Evarts\"]\n\n\nThe accessed slice uses the same indices for the same elements as the original collection uses. This example searches streetsSlice for one of the strings in the slice, and then uses that index in the original array.\n\nlet index = streetsSlice.firstIndex(of: \"Evarts\")    // 4\nprint(streets[index!])\n// \"Evarts\"\n\n\nAlways use the slice’s startIndex property instead of assuming that its indices start at a particular value. Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.\n\nprint(streetsSlice.startIndex)\n// 2\nprint(streetsSlice[2])\n// \"Channing\"\n\n\nprint(streetsSlice[0])\n// error: Index out of bounds\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "LazyFilterSequence.Index | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/index",
    "html": "Discussion\n\nValid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/map(_:)-91yy7",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n"
  },
  {
    "title": "index(_:offsetBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/index(_:offsetby:)-ghrd",
    "html": "Parameters\ni\n\nA valid index of the collection.\n\ndistance\n\nThe distance to offset i. distance must not be negative unless the collection conforms to the BidirectionalCollection protocol.\n\nReturn Value\n\nAn index offset by distance from the index i. If distance is positive, this is the same value as the result of distance calls to index(after:). If distance is negative, this is the same value as the result of abs(distance) calls to index(before:).\n\nDiscussion\n\nThe following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.\n\nlet s = \"Swift\"\nlet i = s.index(s.startIndex, offsetBy: 4)\nprint(s[i])\n// Prints \"t\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection.\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(k), where k is the absolute value of distance."
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/formindex(after:)-8eya1",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "firstIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/firstindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the first element for which predicate returns true. If no elements in the collection satisfy the given predicate, returns nil.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. Here’s an example that finds a student name that begins with the letter “A”:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.firstIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Abena starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/startindex",
    "html": "Discussion\n\nIn an empty collection, startIndex == endIndex.\n\nComplexity\n\nO(n), where n is the ratio between unfiltered and filtered collection counts."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/joined(separator:)-1k8f6",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/compactmap(_:)-72vhr",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/flatmap(_:)-7mh64",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "prefix(upTo:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/prefix(upto:)",
    "html": "Parameters\nend\n\nThe “past the end” index of the resulting subsequence. end must be a valid index of the collection.\n\nReturn Value\n\nA subsequence up to, but not including, the end position.\n\nDiscussion\n\nThe resulting subsequence does not include the element at the position end. The following example searches for the index of the number 40 in an array of integers, and then prints the prefix of the array up to, but not including, that index:\n\nlet numbers = [10, 20, 30, 40, 50, 60]\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers.prefix(upTo: i))\n}\n// Prints \"[10, 20, 30]\"\n\n\nPassing the collection’s starting index as the end parameter results in an empty subsequence.\n\nprint(numbers.prefix(upTo: numbers.startIndex))\n// Prints \"[]\"\n\n\nUsing the prefix(upTo:) method is equivalent to using a partial half-open range as the collection’s subscript. The subscript notation is preferred over prefix(upTo:).\n\nif let i = numbers.firstIndex(of: 40) {\n    print(numbers[..<i])\n}\n// Prints \"[10, 20, 30]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(after:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/formindex(after:)-58ngy",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be less than endIndex."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/joined(separator:)-2obj0",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "PrefixSequence.Iterator | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/iterator",
    "html": "Topics\nDefault Implementations\nIteratorProtocol Implementations\nRelationships\nConforms To\nIteratorProtocol\nConforms when Base conforms to Sequence."
  },
  {
    "title": "startIndex | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/startindex",
    "html": "Discussion\n\nIf the collection is empty, startIndex is equal to endIndex."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/joinedsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/formindex(before:)-8yoxx",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/formindex(before:)-3ipbn",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/index(before:)",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex.\n\nReturn Value\n\nThe index value immediately before i."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false otherwise. Once predicate returns false it will not be called again."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/flatmap(_:)-5g3dt",
    "html": "Discussion\n\nUse this method to receive a single-level sequence when your transformation produces a sequence or collection for each element. Calling flatMap(_:) on a sequence s is equivalent to calling s.map(transform).joined().\n\nComplexity\n\nO(1)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/flatmap(_:)-5pe4l",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "LazyFilterSequence.Elements | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/elements-swift.typealias",
    "html": "Discussion\n\nSee also: elements"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false otherwise. Once predicate returns false it will not be called again."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/joined(separator:)-1x0ue",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyprefixwhilesequence/iterator/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/formindex(before:)-6lxu7",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "lastIndex(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/lastindex(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\nThe index of the last element in the collection that matches predicate, or nil if no elements match.\n\nDiscussion\n\nYou can use the predicate to find an element of a type that doesn’t conform to the Equatable protocol or to find an element that matches particular criteria. This example finds the index of the last name that begins with the letter A:\n\nlet students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nif let i = students.lastIndex(where: { $0.hasPrefix(\"A\") }) {\n    print(\"\\(students[i]) starts with 'A'!\")\n}\n// Prints \"Akosua starts with 'A'!\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/reduce(_:_:)-4f16k",
    "html": "Parameters\ninitialResult\n\nThe value that the closure receives the first time it’s called.\n\nnextPartialResult\n\nA closure that produces a new value by taking the previously-accumulated value and the next element it receives from the upstream publisher.\n\nReturn Value\n\nA publisher that applies the closure to all received elements and produces an accumulated value when the upstream publisher finishes. If reduce(_:_:) receives an error from the upstream publisher, the operator delivers it to the downstream subscriber, the publisher terminates and publishes no value.\n\nDiscussion\n\nUse reduce(_:_:) to collect a stream of elements and produce an accumulated value based on a closure you provide.\n\nIn the following example, the reduce(_:_:) operator collects all the integer values it receives from its upstream publisher:\n\nlet numbers = (0...10)\ncancellable = numbers.publisher\n    .reduce(0, { accum, next in accum + next })\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"55\"\n"
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/flatmap(_:)-57e0w",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/joined(separator:)-1qaxa",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/joined(separator:)-81kwg",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/split(separator:maxsplits:omittingemptysubsequences:)-4wnc3",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazyfiltersequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "tryRemoveDuplicates(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/tryremoveduplicates(by:)",
    "html": "Parameters\npredicate\n\nA closure to evaluate whether two elements are equivalent, for purposes of filtering. Return true from this closure to indicate that the second element is a duplicate of the first. If this closure throws an error, the publisher terminates with the thrown error.\n\nReturn Value\n\nA publisher that consumes — rather than publishes — duplicate elements.\n\nDiscussion\n\nUse tryRemoveDuplicates(by:) to remove repeating elements from an upstream publisher based upon the evaluation of elements using an error-throwing closure you provide. If your closure throws an error, the publisher terminates with the error.\n\nIn the example below, the closure provided to tryRemoveDuplicates(by:) returns true when two consecutive elements are equal, thereby filtering out 0, 1, 2, and 3. However, the closure throws an error when it encounters 4. The publisher then terminates with this error.\n\nstruct BadValuesError: Error {}\nlet numbers = [0, 0, 0, 0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\ncancellable = numbers.publisher\n    .tryRemoveDuplicates { first, second -> Bool in\n        if (first == 4 && second == 4) {\n            throw BadValuesError()\n        }\n        return first == second\n    }\n    .sink(\n        receiveCompletion: { print (\"\\($0)\") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n     )\n\n\n // Prints: \"0 1 2 3 4 failure(BadValuesError()\"\n"
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be included or false otherwise. Once predicate returns false it will not be called again."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "difference(from:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/difference(from:by:)",
    "html": "Parameters\nother\n\nThe base state.\n\nareEquivalent\n\nA closure that returns a Boolean value indicating whether two elements are equivalent.\n\nReturn Value\n\nThe difference needed to produce the receiver’s state from the parameter’s state.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/joined(separator:)-4i6uz",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "difference(from:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/difference(from:)",
    "html": "Parameters\nother\n\nThe base state.\n\nReturn Value\n\nThe difference needed to produce this collection’s ordered elements from the given collection.\n\nDiscussion\n\nThis function does not infer element moves. If you need to infer moves, call the inferringMoves() method on the resulting difference.\n\nComplexity\n\nWorst case performance is O(n * m), where n is the count of this collection and m is other.count. You can expect faster execution when the collections share many common elements, or if Element conforms to Hashable."
  },
  {
    "title": "last(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/last(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe last element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThis example uses the last(where:) method to find the last negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let lastNegative = numbers.last(where: { $0 < 0 }) {\n    print(\"The last negative number is \\(lastNegative).\")\n}\n// Prints \"The last negative number is -6.\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "index(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/index(before:)",
    "html": "Discussion\n\nComplexity\n\nO(1) if the collection conforms to RandomAccessCollection; otherwise, O(n), where n is the length of the collection."
  },
  {
    "title": "last | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/last",
    "html": "Discussion\n\nIf the collection is empty, the value of this property is nil.\n\nlet numbers = [10, 20, 30, 40, 50]\nif let lastNumber = numbers.last {\n    print(lastNumber)\n}\n// Prints \"50\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "formIndex(before:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/formindex(before:)-8rmvx",
    "html": "Parameters\ni\n\nA valid index of the collection. i must be greater than startIndex."
  },
  {
    "title": "lastIndex(of:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/lastindex(of:)",
    "html": "Parameters\nelement\n\nAn element to search for in the collection.\n\nReturn Value\n\nThe last index where element is found. If element is not found in the collection, this method returns nil.\n\nDiscussion\n\nAfter using lastIndex(of:) to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting. This example shows how you can modify one of the names in an array of students.\n\nvar students = [\"Ben\", \"Ivy\", \"Jordell\", \"Ben\", \"Maxime\"]\nif let i = students.lastIndex(of: \"Ben\") {\n    students[i] = \"Benjamin\"\n}\nprint(students)\n// Prints \"[\"Ben\", \"Ivy\", \"Jordell\", \"Benjamin\", \"Max\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the collection."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns true if the element should be skipped or false otherwise. Once predicate returns false it will not be called again."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/compactmap(_:)-9pvcf",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/flatmap(_:)-94qg",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nDiscussion\n\nUse this method to receive a sequence of non-optional values when your transformation produces an optional value.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/prefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence of the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the prefix(while:) method to find the positive numbers at the beginning of the numbers array. Every element of numbers up to, but not including, the first negative value is included in the result.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet positivePrefix = numbers.prefix(while: { $0 > 0 })\n// positivePrefix == [3, 7, 4]\n\n\nIf predicate matches every element in the sequence, the resulting sequence contains every element of the sequence.\n\nComplexity\n\nO(k), where k is the length of the result."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "min(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/min(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s minimum element, according to areInIncreasingOrder. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the min(by:) method on a dictionary to find the key-value pair with the lowest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet leastHue = hues.min { a, b in a.value < b.value }\nprint(leastHue)\n// Prints \"Optional((key: \"Coral\", value: 16))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "split(separator:maxSplits:omittingEmptySubsequences:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/split(separator:maxsplits:omittingemptysubsequences:)",
    "html": "Parameters\nseparator\n\nThe element that should be split upon.\n\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each consecutive pair of separator elements in the sequence and for each instance of separator at the start or end of the sequence. If true, only nonempty subsequences are returned. The default value is true.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe resulting array consists of at most maxSplits + 1 subsequences. Elements that are used to split the sequence are not returned as part of any subsequence.\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string at each space character (” “). The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(separator: \" \")\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(line.split(separator: \" \", maxSplits: 1)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes false for the omittingEmptySubsequences parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(line.split(separator: \" \", omittingEmptySubsequences: false)\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "prefix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/prefix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting at the beginning of this sequence with at most maxLength elements.\n\nDiscussion\n\nIf the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.prefix(2))\n// Prints \"[1, 2]\"\nprint(numbers.prefix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/prefixsequence/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "timeout(_:scheduler:options:customError:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/timeout(_:scheduler:options:customerror:)",
    "html": "Parameters\ninterval\n\nThe maximum time interval the publisher can go without emitting an element, expressed in the time system of the scheduler.\n\nscheduler\n\nThe scheduler on which to deliver events.\n\noptions\n\nScheduler options that customize the delivery of elements.\n\ncustomError\n\nA closure that executes if the publisher times out. The publisher sends the failure returned by this closure to the subscriber as the reason for termination.\n\nReturn Value\n\nA publisher that terminates if the specified interval elapses with no events received from the upstream publisher.\n\nDiscussion\n\nUse timeout(_:scheduler:options:customError:) to terminate a publisher if an element isn’t delivered within a timeout interval you specify.\n\nIn the example below, a PassthroughSubject publishes String elements and is configured to time out if no new elements are received within its TIME_OUT window of 5 seconds. A single value is published after the specified 2-second WAIT_TIME, after which no more elements are available; the publisher then times out and completes normally.\n\nvar WAIT_TIME : Int = 2\nvar TIMEOUT_TIME : Int = 5\n\n\nlet subject = PassthroughSubject<String, Never>()\nlet cancellable = subject\n    .timeout(.seconds(TIMEOUT_TIME), scheduler: DispatchQueue.main, options: nil, customError:nil)\n    .sink(\n          receiveCompletion: { print (\"completion: \\($0) at \\(Date())\") },\n          receiveValue: { print (\"value: \\($0) at \\(Date())\") }\n     )\n\n\nDispatchQueue.main.asyncAfter(deadline: .now() + .seconds(WAIT_TIME),\n                              execute: { subject.send(\"Some data - sent after a delay of \\(WAIT_TIME) seconds\") } )\n\n\n// Prints: value: Some data - sent after a delay of 2 seconds at 2020-03-10 23:47:59 +0000\n//         completion: finished at 2020-03-10 23:48:04 +0000\n\n\nIf customError is nil, the publisher completes normally; if you provide a closure for the customError argument, the upstream publisher is instead terminated upon timeout, and the error is delivered to the downstream."
  },
  {
    "title": "subscribe(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/subscribe(_:)-5aq7t",
    "html": "Parameters\nsubject\n\nThe subject to attach to this publisher."
  },
  {
    "title": "sink(receiveCompletion:receiveValue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/sink(receivecompletion:receivevalue:)",
    "html": "Parameters\nreceiveComplete\n\nThe closure to execute on completion.\n\nreceiveValue\n\nThe closure to execute on receipt of a value.\n\nReturn Value\n\nA cancellable instance, which you use when you end assignment of the received value. Deallocation of the result will tear down the subscription stream.\n\nDiscussion\n\nUse sink(receiveCompletion:receiveValue:) to observe values received by the publisher and process them using a closure you specify.\n\nIn this example, a Range publisher publishes integers to a sink(receiveCompletion:receiveValue:) operator’s receiveValue closure that prints them to the console. Upon completion the sink(receiveCompletion:receiveValue:) operator’s receiveCompletion closure indicates the successful termination of the stream.\n\nlet myRange = (0...3)\ncancellable = myRange.publisher\n    .sink(receiveCompletion: { print (\"completion: \\($0)\") },\n          receiveValue: { print (\"value: \\($0)\") })\n\n\n// Prints:\n//  value: 0\n//  value: 1\n//  value: 2\n//  value: 3\n//  completion: finished\n\n\nThis method creates the subscriber and immediately requests an unlimited number of values, prior to returning the subscriber. The return value should be held, otherwise the stream will be canceled."
  },
  {
    "title": "sink(receiveValue:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/sink(receivevalue:)",
    "html": "Parameters\nreceiveValue\n\nThe closure to execute on receipt of a value.\n\nReturn Value\n\nA cancellable instance, which you use when you end assignment of the received value. Deallocation of the result will tear down the subscription stream.\n\nDiscussion\n\nUse sink(receiveValue:) to observe values received by the publisher and print them to the console. This operator can only be used when the stream doesn’t fail, that is, when the publisher’s Optional.Publisher.Failure type is Never.\n\nIn this example, a Range publisher publishes integers to a sink(receiveValue:) operator’s receiveValue closure that prints them to the console:\n\nlet integers = (0...3)\nintegers.publisher\n    .sink { print(\"Received \\($0)\") }\n\n\n// Prints:\n//  Received 0\n//  Received 1\n//  Received 2\n//  Received 3\n\n\nThis method creates the subscriber and immediately requests an unlimited number of values, prior to returning the subscriber. The return value should be held, otherwise the stream will be canceled."
  },
  {
    "title": "setFailureType(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/setfailuretype(to:)",
    "html": "Parameters\nfailureType\n\nThe Failure type presented by this publisher.\n\nReturn Value\n\nA publisher that appears to send the specified failure type.\n\nDiscussion\n\nUse setFailureType(to:) when you need set the error type of a publisher that cannot fail.\n\nConversely, if the upstream can fail, you would use mapError(_:) to provide instructions on converting the error types to needed by the downstream publisher’s inputs.\n\nThe following example has two publishers with mismatched error types: pub1’s error type is Never, and pub2’s error type is Error. Because of the mismatch, the combineLatest(_:) operator requires that pub1 use setFailureType(to:) to make it appear that pub1 can produce the Error type, like pub2 can.\n\nlet pub1 = [0, 1, 2, 3, 4, 5].publisher\nlet pub2 = CurrentValueSubject<Int, Error>(0)\nlet cancellable = pub1\n    .setFailureType(to: Error.self)\n    .combineLatest(pub2)\n    .sink(\n        receiveCompletion: { print (\"completed: \\($0)\") },\n        receiveValue: { print (\"value: \\($0)\")}\n     )\n\n\n// Prints: \"value: (5, 0)\".\n"
  },
  {
    "title": "share() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/share()",
    "html": "Return Value\n\nA class instance that shares elements received from its upstream to multiple subscribers.\n\nDiscussion\n\nThe publisher returned by this operator supports multiple subscribers, all of whom receive unchanged elements and completion states from the upstream publisher.\n\nTip\n\nPublishers/Share is effectively a combination of the Publishers/Multicast and PassthroughSubject publishers, with an implicit ConnectablePublisher/autoconnect().\n\nThe following example uses a sequence publisher as a counter to publish three random numbers, generated by a Publisher/map(_:)-99evh operator. It uses a share() operator to share the same random number to each of two subscribers. This example uses a delay(for:tolerance:scheduler:options:) operator only to prevent the first subscriber from exhausting the sequence publisher immediately; an asynchronous publisher wouldn’t need this.\n\nlet pub = (1...3).publisher\n    .delay(for: 1, scheduler: DispatchQueue.main)\n    .map( { _ in return Int.random(in: 0...100) } )\n    .print(\"Random\")\n    .share()\n\n\ncancellable1 = pub\n    .sink { print (\"Stream 1 received: \\($0)\")}\ncancellable2 = pub\n    .sink { print (\"Stream 2 received: \\($0)\")}\n\n\n// Prints:\n// Random: receive value: (20)\n// Stream 1 received: 20\n// Stream 2 received: 20\n// Random: receive value: (85)\n// Stream 1 received: 85\n// Stream 2 received: 85\n// Random: receive value: (98)\n// Stream 1 received: 98\n// Stream 2 received: 98\n\n\nWithout the share() operator, stream 1 receives three random values, followed by stream 2 receiving three different random values.\n\nAlso note that Publishers/Share is a class rather than a structure like most other publishers. This means you can use this operator to create a publisher instance that uses reference semantics."
  },
  {
    "title": "scan(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/scan(_:_:)-9m67o",
    "html": "Parameters\ninitialResult\n\nThe previous result returned by the nextPartialResult closure.\n\nnextPartialResult\n\nA closure that takes as its arguments the previous value returned by the closure and the next element emitted from the upstream publisher.\n\nReturn Value\n\nA publisher that transforms elements by applying a closure that receives its previous return value and the next element from the upstream publisher.\n\nDiscussion\n\nUse scan(_:_:) to accumulate all previously-published values into a single value, which you then combine with each newly-published value.\n\nThe following example logs a running total of all values received from the sequence publisher.\n\nlet range = (0...5)\ncancellable = range.publisher\n    .scan(0) { return $0 + $1 }\n    .sink { print (\"\\($0)\", terminator: \" \") }\n // Prints: \"0 1 3 6 10 15 \".\n"
  },
  {
    "title": "replaceNil(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/replacenil(with:)",
    "html": "Parameters\noutput\n\nThe element to use when replacing nil.\n\nReturn Value\n\nA publisher that replaces nil elements from the upstream publisher with the provided element.\n\nDiscussion\n\nThe replaceNil(with:) operator enables replacement of nil values in a stream with a substitute value. In the example below, a collection publisher contains a nil value. The replaceNil(with:) operator replaces this with 0.0.\n\nlet numbers: [Double?] = [1.0, 2.0, nil, 3.0]\nnumbers.publisher\n    .replaceNil(with: 0.0)\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"Optional(1.0) Optional(2.0) Optional(0.0) Optional(3.0)\"\n"
  },
  {
    "title": "removeDuplicates() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/removeduplicates()-2r77a",
    "html": "Return Value\n\nA publisher that consumes — rather than publishes — duplicate elements.\n\nDiscussion\n\nUse removeDuplicates() to remove repeating elements from an upstream publisher. This operator has a two-element memory: the operator uses the current and previously published elements as the basis for its comparison.\n\nIn the example below, removeDuplicates() triggers on the doubled, tripled, and quadrupled occurrences of 1, 3, and 4 respectively. Because the two-element memory considers only the current element and the previous element, the operator prints the final 0 in the example data since its immediate predecessor is 4.\n\nlet numbers = [0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 0]\ncancellable = numbers.publisher\n    .removeDuplicates()\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"0 1 2 3 4 0\"\n"
  },
  {
    "title": "combineLatest(_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/combinelatest(_:_:_:_:)",
    "html": "Parameters\npublisher1\n\nA second publisher to combine with the first publisher.\n\npublisher2\n\nA third publisher to combine with the first publisher.\n\npublisher3\n\nA fourth publisher to combine with the first publisher.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that receives and combines elements from this publisher and three other publishers.\n\nDiscussion\n\nUse combineLatest(_:_:_:_:) when you need to combine the current and 3 additional publishers and transform the values using a closure in which you specify the published elements, to publish a new element.\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t Subscribers/Demand/unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer.\n\nAll upstream publishers need to finish for this publisher to finish. If an upstream publisher never publishes a value, this publisher never finishes.\n\nIn the example below, as combineLatest(_:_:_:_:) receives the most-recent values published by four publishers, multiplies them together, and republishes the result:\n\nlet pub = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\nlet pub3 = PassthroughSubject<Int, Never>()\nlet pub4 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub\n    .combineLatest(pub2, pub3, pub4) { firstValue, secondValue, thirdValue, fourthValue in\n        return firstValue * secondValue * thirdValue * fourthValue\n    }\n    .sink { print(\"Result: \\($0).\") }\n\n\npub.send(1)\npub.send(2)\npub2.send(2)\npub3.send(9)\npub4.send(1)\n\n\npub.send(3)\npub2.send(12)\npub.send(13)\npub3.send(19)\n\n\n// Prints:\n//  Result: 36.     // pub = 2,  pub2 = 2,   pub3 = 9,  pub4 = 1\n//  Result: 54.     // pub = 3,  pub2 = 2,   pub3 = 9,  pub4 = 1\n//  Result: 324.    // pub = 3,  pub2 = 12,  pub3 = 9,  pub4 = 1\n//  Result: 1404.   // pub = 13, pub2 = 12,  pub3 = 9,  pub4 = 1\n//  Result: 2964.   // pub = 13, pub2 = 12,  pub3 = 19, pub4 = 1\n"
  },
  {
    "title": "allSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/allsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.\n\nReturn Value\n\ntrue if the sequence contains only elements that satisfy predicate; otherwise, false.\n\nDiscussion\n\nThe following code uses this method to test whether all the names in an array have at least five characters:\n\nlet names = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nlet allHaveAtLeastFive = names.allSatisfy({ $0.count >= 5 })\n// allHaveAtLeastFive == true\n\n\nIf the sequence is empty, this method returns true.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/min()",
    "html": "Return Value\n\nThe sequence’s minimum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the smallest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet lowestHeight = heights.min()\nprint(lowestHeight)\n// Prints \"Optional(58.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "lexicographicallyPrecedes(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/lexicographicallyprecedes(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering; otherwise, false.\n\nDiscussion\n\nThis example uses the lexicographicallyPrecedes method to test which array of integers comes first in a lexicographical ordering.\n\nlet a = [1, 2, 2, 2]\nlet b = [1, 2, 3, 4]\n\n\nprint(a.lexicographicallyPrecedes(b))\n// Prints \"true\"\nprint(b.lexicographicallyPrecedes(b))\n// Prints \"false\"\n\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/max()",
    "html": "Return Value\n\nThe sequence’s maximum element. If the sequence has no elements, returns nil.\n\nDiscussion\n\nThis example finds the largest value in an array of height measurements.\n\nlet heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]\nlet greatestHeight = heights.max()\nprint(greatestHeight)\n// Prints \"Optional(67.5)\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/joined(separator:)-9ijwh",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/joined(separator:)-1kop",
    "html": "Parameters\nseparator\n\nA sequence to insert between each of this sequence’s elements.\n\nReturn Value\n\nThe joined sequence of elements.\n\nDiscussion\n\nThis example shows how an array of [Int] instances can be joined, using another [Int] instance as the separator:\n\nlet nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nlet joined = nestedNumbers.joined(separator: [-1, -2])\nprint(Array(joined))\n// Prints \"[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]\"\n"
  },
  {
    "title": "forEach(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/foreach(_:)",
    "html": "Parameters\nbody\n\nA closure that takes an element of the sequence as a parameter.\n\nDiscussion\n\nThe two loops in the following example produce the same output:\n\nlet numberWords = [\"one\", \"two\", \"three\"]\nfor word in numberWords {\n    print(word)\n}\n// Prints \"one\"\n// Prints \"two\"\n// Prints \"three\"\n\n\nnumberWords.forEach { word in\n    print(word)\n}\n// Same as above\n\n\nUsing the forEach method is distinct from a for-in loop in two important ways:\n\nYou cannot use a break or continue statement to exit the current call of the body closure or skip subsequent calls.\n\nUsing the return statement in the body closure will exit only from the current call to body, not from any outer scope, and won’t skip subsequent calls."
  },
  {
    "title": "joined() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/joined()",
    "html": "Return Value\n\nA flattened view of the elements of this sequence of sequences.\n\nDiscussion\n\nIn this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.\n\nlet ranges = [0..<3, 8..<10, 15..<17]\n\n\n// A for-in loop over 'ranges' accesses each range:\nfor range in ranges {\n  print(range)\n}\n// Prints \"0..<3\"\n// Prints \"8..<10\"\n// Prints \"15..<17\"\n\n\n// Use 'joined()' to access each element of each range:\nfor index in ranges.joined() {\n    print(index, terminator: \" \")\n}\n// Prints: \"0 1 2 8 9 15 16\"\n"
  },
  {
    "title": "first(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/first(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.\n\nReturn Value\n\nThe first element of the sequence that satisfies predicate, or nil if there is no element that satisfies predicate.\n\nDiscussion\n\nThe following example uses the first(where:) method to find the first negative number in an array of integers:\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nif let firstNegative = numbers.first(where: { $0 < 0 }) {\n    print(\"The first negative number is \\(firstNegative).\")\n}\n// Prints \"The first negative number is -2.\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/flatmap(_:)-1shiq",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns a sequence or collection.\n\nReturn Value\n\nThe resulting flattened array.\n\nDiscussion\n\nUse this method to receive a single-level collection when your transformation produces a sequence or collection for each element.\n\nIn this example, note the difference in the result of using map and flatMap with a transformation that returns an array.\n\nlet numbers = [1, 2, 3, 4]\n\n\nlet mapped = numbers.map { Array(repeating: $0, count: $0) }\n// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]\n\n\nlet flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }\n// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\nIn fact, s.flatMap(transform) is equivalent to Array(s.map(transform).joined()).\n\nComplexity\n\nO(m + n), where n is the length of this sequence and m is the length of the result."
  },
  {
    "title": "elementsEqual(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/elementsequal(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if this sequence and other contain equivalent items, using areEquivalent as the equivalence test; otherwise, false.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/filter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.\n\nReturn Value\n\nAn array of the elements that isIncluded allowed.\n\nDiscussion\n\nIn this example, filter(_:) is used to include only names shorter than five characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet shortNames = cast.filter { $0.count < 5 }\nprint(shortNames)\n// Prints \"[\"Kim\", \"Karl\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "elementsEqual(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/elementsequal(_:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if this sequence and other contain the same elements in the same order.\n\nDiscussion\n\nAt least one of the sequences must be finite.\n\nThis example tests whether one countable range shares the same elements as another countable range and an array.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(a.elementsEqual(b))\n// Prints \"false\"\nprint(a.elementsEqual([1, 2, 3]))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "enumerated() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/enumerated()",
    "html": "Return Value\n\nA sequence of pairs enumerating the sequence.\n\nDiscussion\n\nThis example enumerates the characters of the string “Swift” and prints each character along with its place in the string.\n\nfor (n, c) in \"Swift\".enumerated() {\n    print(\"\\(n): '\\(c)'\")\n}\n// Prints \"0: 'S'\"\n// Prints \"1: 'w'\"\n// Prints \"2: 'i'\"\n// Prints \"3: 'f'\"\n// Prints \"4: 't'\"\n\n\nWhen you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value. These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as Array and ContiguousArray. For other collections the counters may be out of range or of the wrong type to use as an index. To iterate over the elements of a collection with its indices, use the zip(_:_:) function.\n\nThis example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.\n\nlet names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]\nvar shorterIndices: [Set<String>.Index] = []\nfor (i, name) in zip(names.indices, names) {\n    if name.count <= 5 {\n        shorterIndices.append(i)\n    }\n}\n\n\nNow that the shorterIndices array holds the indices of the shorter names in the names set, you can use those indices to access elements in the set.\n\nfor i in shorterIndices {\n    print(names[i])\n}\n// Prints \"Sofia\"\n// Prints \"Mateo\"\n\n\nComplexity\n\nO(1)"
  },
  {
    "title": "dropLast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/droplast(_:)",
    "html": "Parameters\nn\n\nThe number of elements to drop off the end of the sequence. n must be greater than or equal to zero.\n\nReturn Value\n\nA sequence leaving off the specified number of elements.\n\nDiscussion\n\nThe sequence must be finite. If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropLast(2))\n// Prints \"[1, 2, 3]\"\nprint(numbers.dropLast(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "drop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/drop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.\n\nReturn Value\n\nA sequence starting after the initial, consecutive elements that satisfy predicate.\n\nDiscussion\n\nThe following example uses the drop(while:) method to skip over the positive numbers at the beginning of the numbers array. The result begins with the first element of numbers that does not satisfy predicate.\n\nlet numbers = [3, 7, 4, -2, 9, -6, 10, 1]\nlet startingWithNegative = numbers.drop(while: { $0 > 0 })\n// startingWithNegative == [-2, 9, -6, 10, 1]\n\n\nIf predicate matches every element in the sequence, the result is an empty sequence.\n\nComplexity\n\nO(k), where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "contains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/contains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.\n\nReturn Value\n\ntrue if the sequence contains an element that satisfies predicate; otherwise, false.\n\nDiscussion\n\nYou can use the predicate to check for an element of a type that doesn’t conform to the Equatable protocol, such as the HTTPResponse enumeration in this example.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]\nlet hadError = lastThreeResponses.contains { element in\n    if case .error = element {\n        return true\n    } else {\n        return false\n    }\n}\n// 'hadError' == true\n\n\nAlternatively, a predicate can be satisfied by a range of Equatable elements or a general condition. This example shows how you can check an array for an expense greater than $100.\n\nlet expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]\nlet hasBigPurchase = expenses.contains { $0 > 100 }\n// 'hasBigPurchase' == true\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "dropFirst(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/dropfirst(_:)",
    "html": "Parameters\nk\n\nThe number of elements to drop from the beginning of the sequence. k must be greater than or equal to zero.\n\nReturn Value\n\nA sequence starting after the specified number of elements.\n\nDiscussion\n\nIf the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.dropFirst(2))\n// Prints \"[3, 4, 5]\"\nprint(numbers.dropFirst(10))\n// Prints \"[]\"\n\n\nComplexity\n\nO(1), with O(k) deferred to each iteration of the result, where k is the number of elements to drop from the beginning of the sequence."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/compactmap(_:)",
    "html": "Parameters\ntransform\n\nA closure that accepts an element of this sequence as its argument and returns an optional value.\n\nReturn Value\n\nAn array of the non-nil results of calling transform with each element of the sequence.\n\nDiscussion\n\nUse this method to receive an array of non-optional values when your transformation produces an optional value.\n\nIn this example, note the difference in the result of using map and compactMap with a transformation that returns an optional Int value.\n\nlet possibleNumbers = [\"1\", \"2\", \"three\", \"///4///\", \"5\"]\n\n\nlet mapped: [Int?] = possibleNumbers.map { str in Int(str) }\n// [1, 2, nil, nil, 5]\n\n\nlet compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }\n// [1, 2, 5]\n\n\nComplexity\n\nO(n), where n is the length of this sequence."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/contains(_:)",
    "html": "Parameters\nelement\n\nThe element to find in the sequence.\n\nReturn Value\n\ntrue if the element was found in the sequence; otherwise, false.\n\nDiscussion\n\nThis example checks to see whether a favorite actor is in an array storing a movie’s cast.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nprint(cast.contains(\"Marlon\"))\n// Prints \"true\"\nprint(cast.contains(\"James\"))\n// Prints \"false\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "zip(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/zip(_:_:)-51qq9",
    "html": "Parameters\nother\n\nAnother publisher.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that uses the transform closure to emit new elements, produced by combining the most recent value from two upstream publishers.\n\nDiscussion\n\nUse Publisher/zip(_:_:)-4xn21 to return a new publisher that combines the elements from two publishers using a transformation you specify to publish a new value to the downstream. The returned publisher waits until both publishers have emitted an event, then delivers the oldest unconsumed event from each publisher together that the operator uses in the transformation.\n\nIn this example, PassthroughSubject instances numbersPub and lettersPub emit values; Publisher/zip(_:_:)-4xn21 receives the oldest value from each publisher, uses the Int from numbersPub and publishes a string that repeats the String from lettersPub that many times.\n\nlet numbersPub = PassthroughSubject<Int, Never>()\nlet lettersPub = PassthroughSubject<String, Never>()\ncancellable = numbersPub\n    .zip(lettersPub) { anInt, aLetter in\n        String(repeating: aLetter, count: anInt)\n    }\n    .sink { print(\"\\($0)\") }\nnumbersPub.send(1)     // numbersPub: 1      lettersPub:       zip output: <none>\nnumbersPub.send(2)     // numbersPub: 1,2    lettersPub:       zip output: <none>\nnumbersPub.send(3)     // numbersPub: 1,2,3  lettersPub:       zip output: <none>\nlettersPub.send(\"A\")   // numbersPub: 1,2,3  lettersPub: \"A\"   zip output: \"A\"\nlettersPub.send(\"B\")   // numbersPub: 2,3    lettersPub: \"B\"   zip output: \"BB\"\n// Prints:\n//  A\n//  BB\n\n\nIf either upstream publisher finishes successfully or fails with an error, the zipped publisher does the same."
  },
  {
    "title": "zip(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/zip(_:_:_:)-2g0n4",
    "html": "Parameters\npublisher1\n\nA second publisher.\n\npublisher2\n\nA third publisher.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that uses the transform closure to emit new elements, produced by combining the most recent value from three upstream publishers.\n\nDiscussion\n\nUse Publisher/zip(_:_:_:)-9yqi1 to return a new publisher that combines the elements from two other publishers using a transformation you specify to publish a new value to the downstream subscriber. The returned publisher waits until all three publishers have emitted an event, then delivers the oldest unconsumed event from each publisher together that the operator uses in the transformation.\n\nIn this example, numbersPub, lettersPub and emojiPub are each a PassthroughSubject that emit values; Publisher/zip(_:_:_:)-9yqi1 receives the oldest value from each publisher and uses the Int from numbersPub and publishes a string that repeats the String from lettersPub and emojiPub that many times.\n\nlet numbersPub = PassthroughSubject<Int, Never>()\nlet lettersPub = PassthroughSubject<String, Never>()\nlet emojiPub = PassthroughSubject<String, Never>()\n\n\ncancellable = numbersPub\n    .zip(letters, emoji) { anInt, aLetter, anEmoji in\n        (\"\\(String(repeating: anEmoji, count: anInt)) \\(String(repeating: aLetter, count: anInt))\")\n    }\n    .sink { print(\"\\($0)\") }\n\n\nnumbersPub.send(1)     // numbersPub: 1      lettersPub:        emojiPub:            zip output: <none>\nnumbersPub.send(2)     // numbersPub: 1,2    lettersPub:        emojiPub:            zip output: <none>\nnumbersPub.send(3)     // numbersPub: 1,2,3  lettersPub:        emojiPub:            zip output: <none>\nlettersPub.send(\"A\")   // numbersPub: 1,2,3  lettersPub: \"A\"    emojiPub:            zip output: <none>\nemojiPub.send(\"😀\")    // numbersPub: 2,3    lettersPub: \"A\"    emojiPub:\"😀\"        zip output: \"😀 A\"\nlettersPub.send(\"B\")   // numbersPub: 2,3    lettersPub: \"B\"    emojiPub:            zip output: <none>\nemojiPub.send(\"🥰\")    // numbersPub: 3      lettersPub:        emojiPub:\"😀\", \"🥰\"  zip output: \"🥰🥰 BB\"\n\n\n// Prints:\n// 😀 A\n// 🥰🥰 BB\n\n\nIf any upstream publisher finishes successfully or fails with an error, so too does the zipped publisher."
  },
  {
    "title": "tryReduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/tryreduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value that the closure receives the first time it’s called.\n\nnextPartialResult\n\nAn error-throwing closure that takes the previously-accumulated value and the next element from the upstream publisher to produce a new value.\n\nReturn Value\n\nA publisher that applies the closure to all received elements and produces an accumulated value when the upstream publisher finishes.\n\nDiscussion\n\nUse tryReduce(_:_:) to collect a stream of elements and produce an accumulated value based on an error-throwing closure you provide. If the closure throws an error, the publisher fails and passes the error to its subscriber.\n\nIn the example below, the publisher’s 0 element causes the myDivide(_:_:) function to throw an error and publish the doc://com.apple.documentation/documentation/Swift/Double/1641611-nan result:\n\nstruct DivisionByZeroError: Error {}\nfunc myDivide(_ dividend: Double, _ divisor: Double) throws -> Double {\n    guard divisor != 0 else { throw DivisionByZeroError() }\n    return dividend / divisor\n}\n\n\nvar numbers: [Double] = [5, 4, 3, 2, 1, 0]\nnumbers.publisher\n    .tryReduce(numbers.first!, { accum, next in try myDivide(accum, next) })\n    .catch({ _ in Just(Double.nan) })\n    .sink { print(\"\\($0)\") }\n"
  },
  {
    "title": "zip(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/zip(_:_:)-67luv",
    "html": "Parameters\npublisher1\n\nA second publisher.\n\npublisher2\n\nA third publisher.\n\nReturn Value\n\nA publisher that emits groups of elements from the upstream publishers as tuples.\n\nDiscussion\n\nUse Publisher/zip(_:_:)-8d7k7 to return a new publisher that combines the elements from two additional publishers to publish a tuple to the downstream. The returned publisher waits until all three publishers have emitted an event, then delivers the oldest unconsumed event from each publisher as a tuple to the subscriber.\n\nIn this example, numbersPub, lettersPub and emojiPub are each a PassthroughSubject; Publisher/zip(_:_:)-8d7k7 receives the oldest unconsumed value from each publisher and combines them into a tuple that it republishes to the downstream:\n\nlet numbersPub = PassthroughSubject<Int, Never>()\nlet lettersPub = PassthroughSubject<String, Never>()\nlet emojiPub = PassthroughSubject<String, Never>()\n\n\ncancellable = numbersPub\n    .zip(lettersPub, emojiPub)\n    .sink { print(\"\\($0)\") }\nnumbersPub.send(1)     // numbersPub: 1      lettersPub:          emojiPub:        zip output: <none>\nnumbersPub.send(2)     // numbersPub: 1,2    lettersPub:          emojiPub:        zip output: <none>\nnumbersPub.send(3)     // numbersPub: 1,2,3  lettersPub:          emojiPub:        zip output: <none>\nlettersPub.send(\"A\")   // numbersPub: 1,2,3  lettersPub: \"A\"      emojiPub:        zip output: <none>\nemojiPub.send(\"😀\")    // numbersPub: 2,3    lettersPub: \"A\"      emojiPub: \"😀\"   zip output: (1, \"A\", \"😀\")\nlettersPub.send(\"B\")   // numbersPub: 2,3    lettersPub: \"B\"      emojiPub:        zip output: <none>\nemojiPub.send(\"🥰\")    // numbersPub: 3      lettersPub:          emojiPub:        zip output: (2, \"B\", \"🥰\")\n\n\n// Prints:\n//  (1, \"A\", \"😀\")\n//  (2, \"B\", \"🥰\")\n\n\nIf any upstream publisher finishes successfully or fails with an error, so too does the zipped publisher."
  },
  {
    "title": "tryMin(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/trymin(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA throwing closure that receives two elements and returns true if they’re in increasing order. If this closure throws, the publisher terminates with a Subscribers/Completion/failure(_:).\n\nReturn Value\n\nA publisher that publishes the minimum value received from the upstream publisher, after the upstream publisher finishes.\n\nDiscussion\n\nUse tryMin(by:) to determine the minimum value of elements received from the upstream publisher using an error-throwing closure you specify.\n\nIn the example below, an array publishes elements. The tryMin(by:) operator executes the error-throwing closure that throws when the first element is an odd number, terminating the publisher.\n\nstruct IllegalValueError: Error {}\n\n\nlet numbers: [Int]  = [0, 10, 6, 13, 22, 22]\nnumbers.publisher\n    .tryMin { first, second -> Bool in\n        if (first % 2 != 0) {\n            throw IllegalValueError()\n        }\n        return first < second\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\") },\n        receiveValue: { print (\"value: \\($0)\") }\n    )\n\n\n// Prints: \"completion: failure(IllegalValueError())\"\n\n\nAfter this publisher receives a request for more than 0 items, it requests unlimited items from its upstream publisher."
  },
  {
    "title": "tryMax(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/trymax(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA throwing closure that receives two elements and returns true if they’re in increasing order. If this closure throws, the publisher terminates with a Subscribers/Completion/failure(_:).\n\nReturn Value\n\nA publisher that publishes the maximum value received from the upstream publisher, after the upstream publisher finishes.\n\nDiscussion\n\nUse tryMax(by:) to determine the maximum value of elements received from the upstream publisher using an error-throwing closure you specify.\n\nIn the example below, an array publishes elements. The tryMax(by:) operator executes the error-throwing closure that throws when the first element is an odd number, terminating the publisher.\n\nstruct IllegalValueError: Error {}\n\n\nlet numbers: [Int]  = [0, 10, 6, 13, 22, 22]\ncancellable = numbers.publisher\n    .tryMax { first, second -> Bool in\n        if (first % 2 != 0) {\n            throw IllegalValueError()\n        }\n        return first > second\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\") },\n        receiveValue: { print (\"value: \\($0)\") }\n    )\n\n\n// Prints: completion: failure(IllegalValueError())\n\n\nAfter this publisher receives a request for more than 0 items, it requests unlimited items from its upstream publisher."
  },
  {
    "title": "tryLast(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/trylast(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its parameter and returns a Boolean value that indicates whether to publish the element.\n\nReturn Value\n\nA publisher that only publishes the last element satisfying the given predicate.\n\nDiscussion\n\nUse tryLast(where:) when you need to republish the last element that satisfies an error-throwing closure you specify. If the predicate closure throws an error, the publisher fails.\n\nIn the example below, a publisher emits the last element that satisfies the error-throwing closure, then finishes normally:\n\nstruct RangeError: Error {}\n\n\nlet numbers = [-62, 1, 6, 10, 9, 22, 41, -1, 5]\ncancellable = numbers.publisher\n    .tryLast {\n        guard 0 != 0  else {throw RangeError()}\n        return true\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\", terminator: \" \") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n    )\n// Prints: \"5 completion: finished\"\n// If instead the numbers array had contained a `0`, the `tryLast` operator would terminate publishing with a RangeError.\"\n"
  },
  {
    "title": "tryScan(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/tryscan(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe previous result returned by the nextPartialResult closure.\n\nnextPartialResult\n\nAn error-throwing closure that takes as its arguments the previous value returned by the closure and the next element emitted from the upstream publisher.\n\nReturn Value\n\nA publisher that transforms elements by applying a closure that receives its previous return value and the next element from the upstream publisher.\n\nDiscussion\n\nUse tryScan(_:_:) to accumulate all previously-published values into a single value, which you then combine with each newly-published value. If your accumulator closure throws an error, the publisher terminates with the error.\n\nIn the example below, tryScan(_:_:) calls a division function on elements of a collection publisher. The Publishers/TryScan publisher publishes each result until the function encounters a DivisionByZeroError, which terminates the publisher.\n\nstruct DivisionByZeroError: Error {}\n\n\n/// A function that throws a DivisionByZeroError if `current` provided by the TryScan publisher is zero.\nfunc myThrowingFunction(_ lastValue: Int, _ currentValue: Int) throws -> Int {\n    guard currentValue != 0 else { throw DivisionByZeroError() }\n    return (lastValue + currentValue) / currentValue\n }\n\n\nlet numbers = [1,2,3,4,5,0,6,7,8,9]\ncancellable = numbers.publisher\n    .tryScan(10) { try myThrowingFunction($0, $1) }\n    .sink(\n        receiveCompletion: { print (\"\\($0)\") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"11 6 3 1 1 -1 failure(DivisionByZeroError())\".\n\n\nIf the closure throws an error, the publisher fails with the error."
  },
  {
    "title": "zip(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/zip(_:)",
    "html": "Parameters\nother\n\nAnother publisher.\n\nReturn Value\n\nA publisher that emits pairs of elements from the upstream publishers as tuples.\n\nDiscussion\n\nUse zip(_:) to combine the latest elements from two publishers and emit a tuple to the downstream. The returned publisher waits until both publishers have emitted an event, then delivers the oldest unconsumed event from each publisher together as a tuple to the subscriber.\n\nMuch like a zipper or zip fastener on a piece of clothing pulls together rows of teeth to link the two sides, zip(_:) combines streams from two different publishers by linking pairs of elements from each side.\n\nIn this example, numbers and letters are PassthroughSubjects that emit values; once zip(_:) receives one value from each, it publishes the pair as a tuple to the downstream subscriber. It then waits for the next pair of values.\n\n let numbersPub = PassthroughSubject<Int, Never>()\n let lettersPub = PassthroughSubject<String, Never>()\n\n\n cancellable = numbersPub\n     .zip(lettersPub)\n     .sink { print(\"\\($0)\") }\n numbersPub.send(1)    // numbersPub: 1      lettersPub:        zip output: <none>\n numbersPub.send(2)    // numbersPub: 1,2    lettersPub:        zip output: <none>\n letters.send(\"A\")     // numbers: 1,2       letters:\"A\"        zip output: <none>\n numbers.send(3)       // numbers: 1,2,3     letters:           zip output: (1,\"A\")\n letters.send(\"B\")     // numbers: 1,2,3     letters: \"B\"       zip output: (2,\"B\")\n\n\n // Prints:\n //  (1, \"A\")\n //  (2, \"B\")\n\n\nIf either upstream publisher finishes successfully or fails with an error, the zipped publisher does the same."
  },
  {
    "title": "tryPrefix(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/tryprefix(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its parameter and returns a Boolean value indicating whether publishing should continue.\n\nReturn Value\n\nA publisher that passes through elements until the predicate throws or indicates publishing should finish.\n\nDiscussion\n\nUse tryPrefix(while:) to emit values from the upstream publisher that meet a condition you specify in an error-throwing closure. The publisher finishes when the closure returns false. If the closure throws an error, the publisher fails with that error.\n\nstruct OutOfRangeError: Error {}\n\n\nlet numbers = (0...10).reversed()\ncancellable = numbers.publisher\n    .tryPrefix {\n        guard $0 != 0 else {throw OutOfRangeError()}\n        return $0 <= numbers.max()!\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\", terminator: \" \") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n    )\n\n\n// Prints: \"10 9 8 7 6 5 4 3 2 1 completion: failure(OutOfRangeError()) \"\n"
  },
  {
    "title": "tryMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/trymap(_:)",
    "html": "Parameters\ntransform\n\nA closure that takes one element as its parameter and returns a new element. If the closure throws an error, the publisher fails with the thrown error.\n\nReturn Value\n\nA publisher that uses the provided closure to map elements from the upstream publisher to new elements that it then publishes.\n\nDiscussion\n\nCombine’s tryMap(_:) operator performs a function similar to that of doc://com.apple.documentation/documentation/Swift/Sequence/3018373-map in the Swift standard library: it uses a closure to transform each element it receives from the upstream publisher. You use tryMap(_:) to transform from one kind of element to another, and to terminate publishing when the map’s closure throws an error.\n\nThe following example uses an array of numbers as the source for a collection based publisher. A tryMap(_:) operator consumes each integer from the publisher and uses a dictionary to transform it from its Arabic numeral to a Roman equivalent, as a String. If the tryMap(_:)’s closure fails to look up a Roman numeral, it throws an error. The tryMap(_:) operator catches this error and terminates publishing, sending a Subscribers/Completion/failure(_:) that wraps the error.\n\nstruct ParseError: Error {}\nfunc romanNumeral(from:Int) throws -> String {\n    let romanNumeralDict: [Int : String] =\n        [1:\"I\", 2:\"II\", 3:\"III\", 4:\"IV\", 5:\"V\"]\n    guard let numeral = romanNumeralDict[from] else {\n        throw ParseError()\n    }\n    return numeral\n}\nlet numbers = [5, 4, 3, 2, 1, 0]\ncancellable = numbers.publisher\n    .tryMap { try romanNumeral(from: $0) }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"V IV III II I completion: failure(ParseError())\"\n\n\nIf your closure doesn’t throw, use Publisher/map(_:)-99evh instead."
  },
  {
    "title": "measureInterval(using:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/measureinterval(using:options:)",
    "html": "Parameters\nscheduler\n\nA scheduler to use for tracking the timing of events.\n\noptions\n\nOptions that customize the delivery of elements.\n\nReturn Value\n\nA publisher that emits elements representing the time interval between the elements it receives.\n\nDiscussion\n\nUse measureInterval(using:options:) to measure the time between events delivered from an upstream publisher.\n\nIn the example below, a 1-second Timer is used as the data source for an event publisher; the measureInterval(using:options:) operator reports the elapsed time between the reception of events on the main run loop:\n\ncancellable = Timer.publish(every: 1, on: .main, in: .default)\n    .autoconnect()\n    .measureInterval(using: RunLoop.main)\n    .sink { print(\"\\($0)\", terminator: \"\\n\") }\n\n\n// Prints:\n//      Stride(magnitude: 1.0013610124588013)\n//      Stride(magnitude: 0.9992760419845581)\n\n\nThe output type of the returned publisher is the time interval of the provided scheduler.\n\nThis operator uses the provided scheduler’s Scheduler/now property to measure intervals between events."
  },
  {
    "title": "eraseToAnyPublisher() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/erasetoanypublisher()",
    "html": "Return Value\n\nAn AnyPublisher wrapping this publisher.\n\nDiscussion\n\nUse eraseToAnyPublisher() to expose an instance of AnyPublisher to the downstream subscriber, rather than this publisher’s actual type. This form of type erasure preserves abstraction across API boundaries, such as different modules. When you expose your publishers as the AnyPublisher type, you can change the underlying implementation over time without affecting existing clients.\n\nThe following example shows two types that each have a publisher property. TypeWithSubject exposes this property as its actual type, PassthroughSubject, while TypeWithErasedSubject uses eraseToAnyPublisher() to expose it as an AnyPublisher. As seen in the output, a caller from another module can access TypeWithSubject.publisher as its native type. This means you can’t change your publisher to a different type without breaking the caller. By comparison, TypeWithErasedSubject.publisher appears to callers as an AnyPublisher, so you can change the underlying publisher type at will.\n\npublic class TypeWithSubject {\n    public let publisher: some Publisher = PassthroughSubject<Int,Never>()\n}\npublic class TypeWithErasedSubject {\n    public let publisher: some Publisher = PassthroughSubject<Int,Never>()\n        .eraseToAnyPublisher()\n}\n\n\n// In another module:\nlet nonErased = TypeWithSubject()\nif let subject = nonErased.publisher as? PassthroughSubject<Int,Never> {\n    print(\"Successfully cast nonErased.publisher.\")\n}\nlet erased = TypeWithErasedSubject()\nif let subject = erased.publisher as? PassthroughSubject<Int,Never> {\n    print(\"Successfully cast erased.publisher.\")\n}\n\n\n// Prints \"Successfully cast nonErased.publisher.\"\n"
  },
  {
    "title": "tryFirst(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/tryfirst(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value that indicates whether to publish the element.\n\nReturn Value\n\nA publisher that only publishes the first element of a stream that satisfies the predicate.\n\nDiscussion\n\nUse tryFirst(where:) when you need to republish only the first element of a stream that satisfies an error-throwing closure you specify. The publisher ignores all elements after the first. If this publisher doesn’t receive any elements, it finishes without publishing. If the predicate closure throws an error, the publisher fails.\n\nIn the example below, a range publisher emits the first element in the range then finishes normally:\n\nlet numberRange: ClosedRange<Int> = (-1...50)\nnumberRange.publisher\n    .tryFirst {\n        guard $0 < 99 else {throw RangeError()}\n        return true\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\", terminator: \" \") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"-1 completion: finished\"\n// If instead the number range were ClosedRange<Int> = (100...200), the tryFirst operator would terminate publishing with a RangeError.\n"
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "filter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/filter(_:)",
    "html": "Discussion\n\nNote\n\nThe elements of the result are computed on-demand, as the result is used. No buffering storage is allocated and each traversal step invokes predicate on one or more underlying elements."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "withContiguousStorageIfAvailable(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/withcontiguousstorageifavailable(_:)",
    "html": "Parameters\nbody\n\nA closure that receives an UnsafeBufferPointer to the sequence’s contiguous storage.\n\nReturn Value\n\nThe value returned from body, unless the sequence doesn’t support contiguous storage, in which case the method ignores body and returns nil.\n\nDiscussion\n\nThis method calls body(buffer), where buffer is a pointer to the collection’s contiguous storage. If the contiguous storage doesn’t exist, the collection creates it. If the collection doesn’t support an internal representation in a form of contiguous storage, the method doesn’t call body — it immediately returns nil.\n\nThe optimizer can often eliminate bounds- and uniqueness-checking within an algorithm. When that fails, however, invoking the same algorithm on the buffer argument may let you trade safety for speed.\n\nSuccessive calls to this method may provide a different pointer on each call. Don’t store buffer outside of this method.\n\nA Collection that provides its own implementation of this method must provide contiguous storage to its elements in the same order as they appear in the collection. This guarantees that it’s possible to generate contiguous mutable storage to any of its subsequences by slicing buffer with a range formed from the distances to the subsequence’s startIndex and endIndex, respectively."
  },
  {
    "title": "index(_:offsetBy:limitedBy:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/index(_:offsetby:limitedby:)-x8kk",
    "html": "Parameters\ni\n\nA valid index of the array.\n\ndistance\n\nThe distance to offset i.\n\nlimit\n\nA valid index of the collection to use as a limit. If distance > 0, limit should be greater than i to have any effect. Likewise, if distance < 0, limit should be less than i to have any effect.\n\nReturn Value\n\nAn index offset by distance from the index i, unless that index would be beyond limit in the direction of movement. In that case, the method returns nil.\n\nDiscussion\n\nThe following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position. The operation doesn’t require going beyond the limiting numbers.endIndex value, so it succeeds.\n\nlet numbers = [10, 20, 30, 40, 50]\nlet i = numbers.index(numbers.startIndex, offsetBy: 4)\nprint(numbers[i])\n// Prints \"50\"\n\n\nThe next example attempts to retrieve an index ten positions from numbers.startIndex, but fails, because that distance is beyond the index passed as limit.\n\nlet j = numbers.index(numbers.startIndex,\n                      offsetBy: 10,\n                      limitedBy: numbers.endIndex)\nprint(j)\n// Prints \"nil\"\n\n\nThe value passed as distance must not offset i beyond the bounds of the collection, unless the index passed as limit prevents offsetting beyond those bounds.\n\nComplexity\n\nO(1)"
  },
  {
    "title": "flatMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/flatmap(_:)-q9wd",
    "html": "Discussion\n\nUse this method to receive a single-level sequence when your transformation produces a sequence or collection for each element. Calling flatMap(_:) on a sequence s is equivalent to calling s.map(transform).joined().\n\nComplexity\n\nO(1)"
  },
  {
    "title": "<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyindex/_(_:_:)-44wte",
    "html": "Parameters\nlhs\n\nAn index to compare.\n\nrhs\n\nAnother index to compare.\n\nDiscussion\n\nThe types of the two underlying indices must be identical."
  },
  {
    "title": "throttle(for:scheduler:latest:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/throttle(for:scheduler:latest:)",
    "html": "Parameters\ninterval\n\nThe interval at which to find and emit either the most recent or the first element, expressed in the time system of the scheduler.\n\nscheduler\n\nThe scheduler on which to publish elements.\n\nlatest\n\nA Boolean value that indicates whether to publish the most recent element. If false, the publisher emits the first element received during the interval.\n\nReturn Value\n\nA publisher that emits either the most-recent or first element received during the specified interval.\n\nDiscussion\n\nUse throttle(for:scheduler:latest:) to selectively republish elements from an upstream publisher during an interval you specify. Other elements received from the upstream in the throttling interval aren’t republished.\n\nIn the example below, a Timer.TimerPublisher produces elements on one-second intervals; the throttle(for:scheduler:latest:) operator delivers the first event, then republishes only the latest event in the following ten second intervals:\n\ncancellable = Timer.publish(every: 3.0, on: .main, in: .default)\n    .autoconnect()\n    .print(\"\\(Date().description)\")\n    .throttle(for: 10.0, scheduler: RunLoop.main, latest: true)\n    .sink(\n        receiveCompletion: { print (\"Completion: \\($0).\") },\n        receiveValue: { print(\"Received Timestamp \\($0).\") }\n     )\n\n\n// Prints:\n //    Publish at: 2020-03-19 18:26:54 +0000: receive value: (2020-03-19 18:26:57 +0000)\n //    Received Timestamp 2020-03-19 18:26:57 +0000.\n //    Publish at: 2020-03-19 18:26:54 +0000: receive value: (2020-03-19 18:27:00 +0000)\n //    Publish at: 2020-03-19 18:26:54 +0000: receive value: (2020-03-19 18:27:03 +0000)\n //    Publish at: 2020-03-19 18:26:54 +0000: receive value: (2020-03-19 18:27:06 +0000)\n //    Publish at: 2020-03-19 18:26:54 +0000: receive value: (2020-03-19 18:27:09 +0000)\n //    Received Timestamp 2020-03-19 18:27:09 +0000.\n"
  },
  {
    "title": "tryContains(where:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/trycontains(where:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as its parameter and returns a Boolean value that indicates whether the element satisfies the closure’s comparison logic.\n\nReturn Value\n\nA publisher that emits the Boolean value true when the upstream publisher emits a matching value.\n\nDiscussion\n\nUse tryContains(where:) to find the first element in an upstream that satisfies the error-throwing closure you provide.\n\nThis operator consumes elements produced from the upstream publisher until the upstream publisher either:\n\nProduces a matching element, after which it emits true and the publisher finishes normally.\n\nEmits false if no matching element is found and the publisher finishes normally.\n\nIf the predicate throws an error, the publisher fails, passing the error to its downstream.\n\nIn the example below, the tryContains(where:) operator tests values to find an element less than 10; when the closure finds an odd number, like 3, the publisher terminates with an IllegalValueError.\n\nstruct IllegalValueError: Error {}\n\n\nlet numbers = [3, 2, 10, 5, 0, 9]\nnumbers.publisher\n    .tryContains {\n        if ($0 % 2 != 0) {\n            throw IllegalValueError()\n        }\n       return $0 < 10\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\") },\n        receiveValue: { print (\"value: \\($0)\") }\n    )\n\n\n// Prints: \"completion: failure(IllegalValueError())\"\n"
  },
  {
    "title": "subscribe(on:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/subscribe(on:options:)",
    "html": "Parameters\nscheduler\n\nThe scheduler used to send messages to upstream publishers.\n\noptions\n\nOptions that customize the delivery of elements.\n\nReturn Value\n\nA publisher which performs upstream operations on the specified scheduler.\n\nDiscussion\n\nIn contrast with receive(on:options:), which affects downstream messages, subscribe(on:options:) changes the execution context of upstream messages.\n\nIn the following example, the subscribe(on:options:) operator causes ioPerformingPublisher to receive requests on backgroundQueue, while the receive(on:options:) causes uiUpdatingSubscriber to receive elements and completion on RunLoop.main.\n\nlet ioPerformingPublisher == // Some publisher.\nlet uiUpdatingSubscriber == // Some subscriber that updates the UI.\n\n\nioPerformingPublisher\n    .subscribe(on: backgroundQueue)\n    .receive(on: RunLoop.main)\n    .subscribe(uiUpdatingSubscriber)\n\n\nUsing subscribe(on:options:) also causes the upstream publisher to perform Cancellable/cancel() using the specfied scheduler."
  },
  {
    "title": "subscribe(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/subscribe(_:)-7rqjc",
    "html": "Parameters\nsubscriber\n\nThe subscriber to attach to this publisher. After attaching, the subscriber can start to receive values.\n\nDiscussion\n\nAlways call this function instead of receive(subscriber:). Adopters of Optional.Publisher must implement receive(subscriber:). The implementation of Publisher/subscribe(_:)-4u8kn provided by Optional.Publisher calls through to receive(subscriber:)."
  },
  {
    "title": "switchToLatest() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/switchtolatest()",
    "html": "Discussion\n\nThis operator works with an upstream publisher of publishers, flattening the stream of elements to appear as if they were coming from a single stream of elements. It switches the inner publisher as new ones arrive but keeps the outer publisher constant for downstream subscribers.\n\nWhen this operator receives a new publisher from the upstream publisher, it cancels its previous subscription. Use this feature to prevent earlier publishers from performing unnecessary work, such as creating network request publishers from frequently updating user interface publishers."
  },
  {
    "title": "print(_:to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/print(_:to:)",
    "html": "Parameters\nprefix\n\nA string —- which defaults to empty -— with which to prefix all log messages.\n\nstream\n\nA stream for text output that receives messages, and which directs output to the console by default. A custom stream can be used to log messages to other destinations.\n\nReturn Value\n\nA publisher that prints log messages for all publishing events.\n\nDiscussion\n\nUse print(_:to:) to log messages the console.\n\nIn the example below, log messages are printed on the console:\n\nlet integers = (1...2)\ncancellable = integers.publisher\n   .print(\"Logged a message\", to: nil)\n   .sink { _ in }\n\n\n// Prints:\n//  Logged a message: receive subscription: (1..<2)\n//  Logged a message: request unlimited\n//  Logged a message: receive value: (1)\n//  Logged a message: receive finished\n"
  },
  {
    "title": "receive(on:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/receive(on:options:)",
    "html": "Parameters\nscheduler\n\nThe scheduler the publisher uses for element delivery.\n\noptions\n\nScheduler options used to customize element delivery.\n\nReturn Value\n\nA publisher that delivers elements using the specified scheduler.\n\nDiscussion\n\nYou use the receive(on:options:) operator to receive results and completion on a specific scheduler, such as performing UI work on the main run loop. In contrast with subscribe(on:options:), which affects upstream messages, receive(on:options:) changes the execution context of downstream messages.\n\nIn the following example, the subscribe(on:options:) operator causes jsonPublisher to receive requests on backgroundQueue, while the receive(on:options:) causes labelUpdater to receive elements and completion on RunLoop.main.\n\nlet jsonPublisher = MyJSONLoaderPublisher() // Some publisher.\nlet labelUpdater = MyLabelUpdateSubscriber() // Some subscriber that updates the UI.\n\n\njsonPublisher\n    .subscribe(on: backgroundQueue)\n    .receive(on: RunLoop.main)\n    .subscribe(labelUpdater)\n\n\nPrefer receive(on:options:) over explicit use of dispatch queues when performing work in subscribers. For example, instead of the following pattern:\n\npub.sink {\n    DispatchQueue.main.async {\n        // Do something.\n    }\n}\n\n\nUse this pattern instead:\n\npub.receive(on: DispatchQueue.main).sink {\n    // Do something.\n}\n\n\nNote\n\nreceive(on:options:) doesn’t affect the scheduler used to call the subscriber’s Subscriber/receive(subscription:) method."
  },
  {
    "title": "prepend(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/prepend(_:)",
    "html": "Parameters\nelements\n\nThe elements to publish before this publisher’s elements.\n\nReturn Value\n\nA publisher that prefixes the specified elements prior to this publisher’s elements.\n\nDiscussion\n\nUse Publisher/prepend(_:)-7wk5l when you need to prepend specific elements before the output of a publisher.\n\nIn the example below, the Publisher/prepend(_:)-7wk5l operator publishes the provided elements before republishing all elements from dataElements:\n\nlet dataElements = (0...10)\ncancellable = dataElements.publisher\n    .prepend(0, 1, 255)\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"0 1 255 0 1 2 3 4 5 6 7 8 9 10\"\n"
  },
  {
    "title": "assign(to:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/assign(to:)",
    "html": "Parameters\npublished\n\nA property marked with the @Published attribute, which receives and republishes all elements received from the upstream publisher.\n\nDiscussion\n\nUse this operator when you want to receive elements from a publisher and republish them through a property marked with the @Published attribute. The assign(to:) operator manages the life cycle of the subscription, canceling the subscription automatically when the Published instance deinitializes. Because of this, the assign(to:) operator doesn’t return an AnyCancellable that you’re responsible for like assign(to:on:) does.\n\nThe example below shows a model class that receives elements from an internal Timer.TimerPublisher, and assigns them to a @Published property called lastUpdated. Because the to parameter has the inout keyword, you need to use the & operator when calling this method.\n\nclass MyModel: ObservableObject {\n    @Published var lastUpdated: Date = Date()\n    init() {\n         Timer.publish(every: 1.0, on: .main, in: .common)\n             .autoconnect()\n             .assign(to: &$lastUpdated)\n    }\n}\n\n\nIf you instead implemented MyModel with assign(to: lastUpdated, on: self), storing the returned AnyCancellable instance could cause a reference cycle, because the Subscribers/Assign subscriber would hold a strong reference to self. Using assign(to:) solves this problem.\n\nWhile the to parameter uses the inout keyword, this method doesn’t replace a reference type passed to it. Instead, this notation indicates that the operator may modify members of the assigned object, as seen in the following example:\n\n    class MyModel2: ObservableObject {\n        @Published var id: Int = 0\n    }\n    let model2 = MyModel2()\n    Just(100).assign(to: &model2.$id)\n"
  },
  {
    "title": "collect(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/collect(_:)",
    "html": "Parameters\ncount\n\nThe maximum number of received elements to buffer before publishing.\n\nReturn Value\n\nA publisher that collects up to the specified number of elements, and then publishes them as an array.\n\nDiscussion\n\nUse collect(_:) to emit arrays of at most count elements from an upstream publisher. If the upstream publisher finishes before collecting the specified number of elements, the publisher sends an array of only the items it received. This may be fewer than count elements.\n\nIf the upstream publisher fails with an error, this publisher forwards the error to the downstream receiver instead of sending its output.\n\nIn the example below, the collect(_:) operator emits one partial and two full arrays based on the requested collection size of 5:\n\nlet numbers = (0...10)\ncancellable = numbers.publisher\n    .collect(5)\n    .sink { print(\"\\($0), terminator: \" \"\") }\n\n\n// Prints \"[0, 1, 2, 3, 4] [5, 6, 7, 8, 9] [10] \"\n\n\nNote\n\nWhen this publisher receives a request for .max(n) elements, it requests .max(count * n) from the upstream publisher."
  },
  {
    "title": "catch(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/catch(_:)",
    "html": "Parameters\nhandler\n\nA closure that accepts the upstream failure as input and returns a publisher to replace the upstream publisher.\n\nReturn Value\n\nA publisher that handles errors from an upstream publisher by replacing the failed publisher with another publisher.\n\nDiscussion\n\nUse catch() to replace an error from an upstream publisher with a new publisher.\n\nIn the example below, the catch() operator handles the SimpleError thrown by the upstream publisher by replacing the error with a Just publisher. This continues the stream by publishing a single value and completing normally.\n\nstruct SimpleError: Error {}\nlet numbers = [5, 4, 3, 2, 1, 0, 9, 8, 7, 6]\ncancellable = numbers.publisher\n    .tryLast(where: {\n        guard $0 != 0 else {throw SimpleError()}\n        return true\n    })\n    .catch({ (error) in\n        Just(-1)\n    })\n    .sink { print(\"\\($0)\") }\n    // Prints: -1\n\n\nBackpressure note: This publisher passes through request and cancel to the upstream. After receiving an error, the publisher sends sends any unfulfilled demand to the new Publisher. SeeAlso: replaceError"
  },
  {
    "title": "combineLatest(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/combinelatest(_:)",
    "html": "Parameters\nother\n\nAnother publisher to combine with this one.\n\nReturn Value\n\nA publisher that receives and combines elements from this and another publisher.\n\nDiscussion\n\nUse combineLatest(_:) when you want the downstream subscriber to receive a tuple of the most-recent element from multiple publishers when any of them emit a value. To pair elements from multiple publishers, use zip(_:) instead. To receive just the most-recent element from multiple publishers rather than tuples, use Publisher/merge(with:)-7qt71.\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t Subscribers/Demand/unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer.\n\nIn this example, PassthroughSubject pub1 and also pub2 emit values; as combineLatest(_:) receives input from either upstream publisher, it combines the latest value from each publisher into a tuple and publishes it.\n\nlet pub1 = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub1\n    .combineLatest(pub2)\n    .sink { print(\"Result: \\($0).\") }\n\n\npub1.send(1)\npub1.send(2)\npub2.send(2)\npub1.send(3)\npub1.send(45)\npub2.send(22)\n\n\n// Prints:\n//    Result: (2, 2).    // pub1 latest = 2, pub2 latest = 2\n//    Result: (3, 2).    // pub1 latest = 3, pub2 latest = 2\n//    Result: (45, 2).   // pub1 latest = 45, pub2 latest = 2\n//    Result: (45, 22).  // pub1 latest = 45, pub2 latest = 22\n\n\nWhen all upstream publishers finish, this publisher finishes. If an upstream publisher never publishes a value, this publisher never finishes."
  },
  {
    "title": "combineLatest(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/combinelatest(_:_:)-4m4xt",
    "html": "Parameters\nother\n\nAnother publisher to combine with this one.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that receives and combines elements from this and another publisher.\n\nDiscussion\n\nUse combineLatest<P,T>(_:) to combine the current and one additional publisher and transform them using a closure you specify to publish a new value to the downstream.\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t .unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer.\n\nIn the example below, combineLatest() receives the most-recent values published by the two publishers, it multiplies them together, and republishes the result:\n\nlet pub1 = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub1\n    .combineLatest(pub2) { (first, second) in\n        return first * second\n    }\n    .sink { print(\"Result: \\($0).\") }\n\n\npub1.send(1)\npub1.send(2)\npub2.send(2)\npub1.send(9)\npub1.send(3)\npub2.send(12)\npub1.send(13)\n//\n// Prints:\n//Result: 4.    (pub1 latest = 2, pub2 latest = 2)\n//Result: 18.   (pub1 latest = 9, pub2 latest = 2)\n//Result: 6.    (pub1 latest = 3, pub2 latest = 2)\n//Result: 36.   (pub1 latest = 3, pub2 latest = 12)\n//Result: 156.  (pub1 latest = 13, pub2 latest = 12)\n\n\nAll upstream publishers need to finish for this publisher to finish. If an upstream publisher never publishes a value, this publisher never finishes. If any of the combined publishers terminates with a failure, this publisher also fails."
  },
  {
    "title": "collect(_:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/collect(_:options:)",
    "html": "Parameters\nstrategy\n\nThe timing group strategy used by the operator to collect and publish elements.\n\noptions\n\nScheduler options to use for the strategy.\n\nReturn Value\n\nA publisher that collects elements by a given strategy, and emits a single array of the collection.\n\nDiscussion\n\nUse collect(_:options:) to emit arrays of elements on a schedule specified by a Scheduler and Stride that you provide. At the end of each scheduled interval, the publisher sends an array that contains the items it collected. If the upstream publisher finishes before filling the buffer, the publisher sends an array that contains items it received. This may be fewer than the number of elements specified in the requested Stride.\n\nIf the upstream publisher fails with an error, this publisher forwards the error to the downstream receiver instead of sending its output.\n\nThe example above collects timestamps generated on a one-second Timer in groups (Stride) of five.\n\nlet sub = Timer.publish(every: 1, on: .main, in: .default)\n    .autoconnect()\n    .collect(.byTime(RunLoop.main, .seconds(5)))\n    .sink { print(\"\\($0)\", terminator: \"\\n\\n\") }\n\n\n// Prints: \"[2020-01-24 00:54:46 +0000, 2020-01-24 00:54:47 +0000,\n//          2020-01-24 00:54:48 +0000, 2020-01-24 00:54:49 +0000,\n//          2020-01-24 00:54:50 +0000]\"\n\n\nNote\n\nWhen this publisher receives a request for .max(n) elements, it requests .max(count * n) from the upstream publisher."
  },
  {
    "title": "combineLatest(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/combinelatest(_:_:)-8c1cs",
    "html": "Parameters\npublisher1\n\nA second publisher to combine with the first publisher.\n\npublisher2\n\nA third publisher to combine with the first publisher.\n\nReturn Value\n\nA publisher that receives and combines elements from this publisher and two other publishers.\n\nDiscussion\n\nUse Publisher/combineLatest(_:_:)-5crqg when you want the downstream subscriber to receive a tuple of the most-recent element from multiple publishers when any of them emit a value. To combine elements from multiple publishers, use Publisher/zip(_:_:)-8d7k7 instead. To receive just the most-recent element from multiple publishers rather than tuples, use merge(with:_:).\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t Subscribers/Demand/unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer.\n\nAll upstream publishers need to finish for this publisher to finish. If an upstream publisher never publishes a value, this publisher never finishes.\n\nIn this example, three instances of PassthroughSubject emit values; as Publisher/combineLatest(_:_:)-5crqg receives input from any of the upstream publishers, it combines the latest value from each publisher into a tuple and publishes it:\n\nlet pub = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\nlet pub3 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub\n    .combineLatest(pub2, pub3)\n    .sink { print(\"Result: \\($0).\") }\n\n\npub.send(1)\npub.send(2)\npub2.send(2)\npub3.send(9)\n\n\npub.send(3)\npub2.send(12)\npub.send(13)\npub3.send(19)\n\n\n// Prints:\n//  Result: (2, 2, 9).\n//  Result: (3, 2, 9).\n//  Result: (3, 12, 9).\n//  Result: (13, 12, 9).\n//  Result: (13, 12, 19).\n\n\nIf any of the combined publishers terminates with a failure, this publisher also fails."
  },
  {
    "title": "zip(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/zip(_:_:_:)-8n2fy",
    "html": "Parameters\npublisher1\n\nA second publisher.\n\npublisher2\n\nA third publisher.\n\npublisher3\n\nA fourth publisher.\n\nReturn Value\n\nA publisher that emits groups of elements from the upstream publishers as tuples.\n\nDiscussion\n\nUse Publisher/zip(_:_:_:)-16rcy to return a new publisher that combines the elements from three other publishers to publish a tuple to the downstream subscriber. The returned publisher waits until all four publishers have emitted an event, then delivers the oldest unconsumed event from each publisher as a tuple to the subscriber.\n\nIn this example, several PassthroughSubject instances emit values; Publisher/zip(_:_:_:)-16rcy receives the oldest unconsumed value from each publisher and combines them into a tuple that it republishes to the downstream:\n\nlet numbersPub = PassthroughSubject<Int, Never>()\nlet lettersPub = PassthroughSubject<String, Never>()\nlet emojiPub = PassthroughSubject<String, Never>()\nlet fractionsPub  = PassthroughSubject<Double, Never>()\n\n\ncancellable = numbersPub\n    .zip(lettersPub, emojiPub, fractionsPub)\n    .sink { print(\"\\($0)\") }\nnumbersPub.send(1)         // numbersPub: 1       lettersPub:        emojiPub:       fractionsPub:         zip output: <none>\nnumbersPub.send(2)         // numbersPub: 1,2     lettersPub:        emojiPub:       fractionsPub:         zip output: <none>\nnumbersPub.send(3)         // numbersPub: 1,2,3   lettersPub:        emojiPub:       fractionsPub:         zip output: <none>\nfractionsPub.send(0.1)     // numbersPub: 1,2,3   lettersPub: \"A\"    emojiPub:       fractionsPub: 0.1     zip output: <none>\nlettersPub.send(\"A\")       // numbersPub: 1,2,3   lettersPub: \"A\"    emojiPub:       fractionsPub: 0.1     zip output: <none>\nemojiPub.send(\"😀\")        // numbersPub: 2,3     lettersPub: \"A\"    emojiPub: \"😀\"  fractionsPub: 0.1     zip output: (1, \"A\", \"😀\", 0.1)\nlettersPub.send(\"B\")       // numbersPub: 2,3     lettersPub: \"B\"    emojiPub:       fractionsPub:         zip output: <none>\nfractionsPub.send(0.8)     // numbersPub: 2,3     lettersPub: \"B\"    emojiPub:       fractionsPub: 0.8     zip output: <none>\nemojiPub.send(\"🥰\")        // numbersPub: 3       lettersPub: \"B\"    emojiPub:       fractionsPub: 0.8     zip output: (2, \"B\", \"🥰\", 0.8)\n// Prints:\n//  (1, \"A\", \"😀\", 0.1)\n//  (2, \"B\", \"🥰\", 0.8)\n\n\nIf any upstream publisher finishes successfully or fails with an error, so too does the zipped publisher."
  },
  {
    "title": "combineLatest(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/combinelatest(_:_:_:)-5odx7",
    "html": "Parameters\npublisher1\n\nA second publisher to combine with the first publisher.\n\npublisher2\n\nA third publisher to combine with the first publisher.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that receives and combines elements from this publisher and two other publishers.\n\nDiscussion\n\nUse combineLatest<P, Q>(_:,_:) to combine the current and two additional publishers and transform them using a closure you specify to publish a new value to the downstream.\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t .unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer. All upstream publishers need to finish for this publisher to finish. If an upstream publisher never publishes a value, this publisher never finishes. If any of the combined publishers terminates with a failure, this publisher also fails.\n\nIn the example below, combineLatest() receives the most-recent values published by three publishers, multiplies them together, and republishes the result:\n\nlet pub = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\nlet pub3 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub\n    .combineLatest(pub2, pub3) { firstValue, secondValue, thirdValue in\n        return firstValue * secondValue * thirdValue\n    }\n    .sink { print(\"Result: \\($0).\") }\n\n\npub.send(1)\npub.send(2)\npub2.send(2)\npub3.send(10)\n\n\npub.send(9)\npub3.send(4)\npub2.send(12)\n\n\n// Prints:\n//  Result: 40.     // pub = 2, pub2 = 2, pub3 = 10\n//  Result: 180.    // pub = 9, pub2 = 2, pub3 = 10\n//  Result: 72.     // pub = 9, pub2 = 2, pub3 = 4\n//  Result: 432.    // pub = 9, pub2 = 12, pub3 = 4\n"
  },
  {
    "title": "combineLatest(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/combinelatest(_:_:_:)-50chd",
    "html": "Parameters\npublisher1\n\nA second publisher to combine with the first publisher.\n\npublisher2\n\nA third publisher to combine with the first publisher.\n\npublisher3\n\nA fourth publisher to combine with the first publisher.\n\nReturn Value\n\nA publisher that receives and combines elements from this publisher and three other publishers.\n\nDiscussion\n\nUse Publisher/combineLatest(_:_:_:)-48buc when you want the downstream subscriber to receive a tuple of the most-recent element from multiple publishers when any of them emit a value. To combine elements from multiple publishers, use Publisher/zip(_:_:_:)-16rcy instead. To receive just the most-recent element from multiple publishers rather than tuples, use merge(with:_:_:).\n\nTip\n\nThe combined publisher doesn’t produce elements until each of its upstream publishers publishes at least one element.\n\nThe combined publisher passes through any requests to all upstream publishers. However, it still obeys the demand-fulfilling rule of only sending the request amount downstream. If the demand isn’t Subscribers/Demand/unlimited, it drops values from upstream publishers. It implements this by using a buffer size of 1 for each upstream, and holds the most-recent value in each buffer.\n\nAll upstream publishers need to finish for this publisher to finish. If an upstream publisher never publishes a value, this publisher never finishes.\n\nIn the example below, Publisher/combineLatest(_:_:_:)-48buc receives input from any of the publishers, combines the latest value from each publisher into a tuple and publishes it:\n\nlet pub = PassthroughSubject<Int, Never>()\nlet pub2 = PassthroughSubject<Int, Never>()\nlet pub3 = PassthroughSubject<Int, Never>()\nlet pub4 = PassthroughSubject<Int, Never>()\n\n\ncancellable = pub\n    .combineLatest(pub2, pub3, pub4)\n    .sink { print(\"Result: \\($0).\") }\n\n\npub.send(1)\npub.send(2)\npub2.send(2)\npub3.send(9)\npub4.send(1)\n\n\npub.send(3)\npub2.send(12)\npub.send(13)\npub3.send(19)\n//\n// Prints:\n//  Result: (2, 2, 9, 1).\n//  Result: (3, 2, 9, 1).\n//  Result: (3, 12, 9, 1).\n//  Result: (13, 12, 9, 1).\n//  Result: (13, 12, 19, 1).\n\n\nIf any individual publisher of the combined set terminates with a failure, this publisher also fails."
  },
  {
    "title": "compactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/compactmap(_:)-rpwq",
    "html": "Parameters\ntransform\n\nA closure that receives a value and returns an optional value.\n\nReturn Value\n\nAny non-nil optional results of the calling the supplied closure.\n\nDiscussion\n\nCombine’s compactMap(_:) operator performs a function similar to that of doc://com.apple.documentation/documentation/Swift/Sequence/2950916-compactmap in the Swift standard library: the compactMap(_:) operator in Combine removes nil elements in a publisher’s stream and republishes non-nil elements to the downstream subscriber.\n\nThe example below uses a range of numbers as the source for a collection based publisher. The compactMap(_:) operator consumes each element from the numbers publisher attempting to access the dictionary using the element as the key. If the example’s dictionary returns a nil, due to a non-existent key, compactMap(_:) filters out the nil (missing) elements.\n\nlet numbers = (0...5)\nlet romanNumeralDict: [Int : String] =\n    [1: \"I\", 2: \"II\", 3: \"III\", 5: \"V\"]\n\n\ncancellable = numbers.publisher\n    .compactMap { romanNumeralDict[$0] }\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"I II III V\"\n"
  },
  {
    "title": "delay(for:tolerance:scheduler:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/delay(for:tolerance:scheduler:options:)",
    "html": "Parameters\ninterval\n\nThe amount of time to delay.\n\ntolerance\n\nThe allowed tolerance in delivering delayed events. The Delay publisher may deliver elements this much sooner or later than the interval specifies.\n\nscheduler\n\nThe scheduler to deliver the delayed events.\n\noptions\n\nOptions relevant to the scheduler’s behavior.\n\nReturn Value\n\nA publisher that delays delivery of elements and completion to the downstream receiver.\n\nDiscussion\n\nUse delay(for:tolerance:scheduler:options:) when you need to delay the delivery of elements to a downstream by a specified amount of time.\n\nIn this example, a Timer publishes an event every second. The delay(for:tolerance:scheduler:options:) operator holds the delivery of the initial element for 3 seconds (±0.5 seconds), after which each element is delivered to the downstream on the main run loop after the specified delay:\n\nlet df = DateFormatter()\ndf.dateStyle = .none\ndf.timeStyle = .long\ncancellable = Timer.publish(every: 1.0, on: .main, in: .default)\n    .autoconnect()\n    .handleEvents(receiveOutput: { date in\n        print (\"Sending Timestamp \\'\\(df.string(from: date))\\' to delay()\")\n    })\n    .delay(for: .seconds(3), scheduler: RunLoop.main, options: .none)\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\", terminator: \"\\n\") },\n        receiveValue: { value in\n            let now = Date()\n            print (\"At \\(df.string(from: now)) received  Timestamp \\'\\(df.string(from: value))\\' sent: \\(String(format: \"%.2f\", now.timeIntervalSince(value))) secs ago\", terminator: \"\\n\")\n        }\n    )\n\n\n// Prints:\n//    Sending Timestamp '5:02:33 PM PDT' to delay()\n//    Sending Timestamp '5:02:34 PM PDT' to delay()\n//    Sending Timestamp '5:02:35 PM PDT' to delay()\n//    Sending Timestamp '5:02:36 PM PDT' to delay()\n//    At 5:02:36 PM PDT received  Timestamp '5:02:33 PM PDT' sent: 3.00 secs ago\n//    Sending Timestamp '5:02:37 PM PDT' to delay()\n//    At 5:02:37 PM PDT received  Timestamp '5:02:34 PM PDT' sent: 3.00 secs ago\n//    Sending Timestamp '5:02:38 PM PDT' to delay()\n//    At 5:02:38 PM PDT received  Timestamp '5:02:35 PM PDT' sent: 3.00 secs ago\n\n\nThe delay affects the delivery of elements and completion, but not of the original subscription."
  },
  {
    "title": "decode(type:decoder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/decode(type:decoder:)",
    "html": "Parameters\ntype\n\nThe encoded data to decode into a struct that conforms to the Decodable protocol.\n\ndecoder\n\nA decoder that implements the TopLevelDecoder protocol.\n\nReturn Value\n\nA publisher that decodes a given type using a specified decoder and publishes the result.\n\nDiscussion\n\nUse decode(type:decoder:) with a JSONDecoder (or a PropertyListDecoder for property lists) to decode data received from a URLSession.DataTaskPublisher or other data source using the Decodable protocol.\n\nIn this example, a PassthroughSubject publishes a JSON string. The JSON decoder parses the string, converting its fields according to the Decodable protocol implemented by Article, and successfully populating a new Article. The Publishers/Decode publisher then publishes the Article to the downstream. If a decoding operation fails, which happens in the case of missing or malformed data in the source JSON string, the stream terminates and passes the error to the downstream subscriber.\n\nstruct Article: Codable {\n    let title: String\n    let author: String\n    let pubDate: Date\n}\n\n\nlet dataProvider = PassthroughSubject<Data, Never>()\ncancellable = dataProvider\n    .decode(type: Article.self, decoder: JSONDecoder())\n    .sink(receiveCompletion: { print (\"Completion: \\($0)\")},\n          receiveValue: { print (\"value: \\($0)\") })\n\n\ndataProvider.send(Data(\"{\\\"pubDate\\\":1574273638.575666, \\\"title\\\" : \\\"My First Article\\\", \\\"author\\\" : \\\"Gita Kumar\\\" }\".utf8))\n\n\n// Prints: \".sink() data received Article(title: \"My First Article\", author: \"Gita Kumar\", pubDate: 2050-11-20 18:13:58 +0000)\"\n"
  },
  {
    "title": "debounce(for:scheduler:options:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/debounce(for:scheduler:options:)",
    "html": "Parameters\ndueTime\n\nThe time the publisher should wait before publishing an element.\n\nscheduler\n\nThe scheduler on which this publisher delivers elements\n\noptions\n\nScheduler options that customize this publisher’s delivery of elements.\n\nReturn Value\n\nA publisher that publishes events only after a specified time elapses.\n\nDiscussion\n\nUse the debounce(for:scheduler:options:) operator to control the number of values and time between delivery of values from the upstream publisher. This operator is useful to process bursty or high-volume event streams where you need to reduce the number of values delivered to the downstream to a rate you specify.\n\nIn this example, a PassthroughSubject publishes elements on a schedule defined by the bounces array. The array is composed of tuples representing a value sent by the PassthroughSubject, and a TimeInterval ranging from one-quarter second up to 2 seconds that drives a delivery timer. As the queue builds, elements arriving faster than one-half second debounceInterval are discarded, while elements arriving at a rate slower than debounceInterval are passed through to the sink(receiveValue:) operator.\n\nlet bounces:[(Int,TimeInterval)] = [\n    (0, 0),\n    (1, 0.25),  // 0.25s interval since last index\n    (2, 1),     // 0.75s interval since last index\n    (3, 1.25),  // 0.25s interval since last index\n    (4, 1.5),   // 0.25s interval since last index\n    (5, 2)      // 0.5s interval since last index\n]\n\n\nlet subject = PassthroughSubject<Int, Never>()\ncancellable = subject\n    .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n    .sink { index in\n        print (\"Received index \\(index)\")\n    }\n\n\nfor bounce in bounces {\n    DispatchQueue.main.asyncAfter(deadline: .now() + bounce.1) {\n        subject.send(bounce.0)\n    }\n}\n\n\n// Prints:\n//  Received index 1\n//  Received index 4\n//  Received index 5\n\n\n//  Here is the event flow shown from the perspective of time, showing value delivery through the `debounce()` operator:\n\n\n//  Time 0: Send index 0.\n//  Time 0.25: Send index 1. Index 0 was waiting and is discarded.\n//  Time 0.75: Debounce period ends, publish index 1.\n//  Time 1: Send index 2.\n//  Time 1.25: Send index 3. Index 2 was waiting and is discarded.\n//  Time 1.5: Send index 4. Index 3 was waiting and is discarded.\n//  Time 2: Debounce period ends, publish index 4. Also, send index 5.\n//  Time 2.5: Debounce period ends, publish index 5.\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "contains(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/contains(_:)-417r7",
    "html": "Parameters\noutput\n\nAn element to match against.\n\nReturn Value\n\nA publisher that emits the Boolean value true when the upstream publisher emits a matching value.\n\nDiscussion\n\nUse contains(_:) to find the first element in an upstream that’s equal to the supplied argument. The contains publisher consumes all received elements until the upstream publisher produces a matching element. Upon finding the first match, it emits true and finishes normally. If the upstream finishes normally without producing a matching element, this publisher emits false and finishes.\n\nIn the example below, the contains(_:) operator emits true the first time it receives the value 5 from the numbers.publisher, and then finishes normally.\n\nlet numbers = [-1, 5, 10, 5]\nnumbers.publisher\n    .contains(5)\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"true\"\n"
  },
  {
    "title": "drop(untilOutputFrom:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/drop(untiloutputfrom:)",
    "html": "Parameters\npublisher\n\nA publisher to monitor for its first emitted element.\n\nReturn Value\n\nA publisher that drops elements from the upstream publisher until the other publisher produces a value.\n\nDiscussion\n\nUse drop(untilOutputFrom:) to ignore elements from the upstream publisher until another, second, publisher delivers its first element. This publisher requests a single value from the second publisher, and it ignores (drops) all elements from the upstream publisher until the second publisher produces a value. After the second publisher produces an element, drop(untilOutputFrom:) cancels its subscription to the second publisher, and allows events from the upstream publisher to pass through.\n\nAfter this publisher receives a subscription from the upstream publisher, it passes through backpressure requests from downstream to the upstream publisher. If the upstream publisher acts on those requests before the other publisher produces an item, this publisher drops the elements it receives from the upstream publisher.\n\nIn the example below, the pub1 publisher defers publishing its elements until the pub2 publisher delivers its first element:\n\nlet upstream = PassthroughSubject<Int,Never>()\nlet second = PassthroughSubject<String,Never>()\ncancellable = upstream\n    .drop(untilOutputFrom: second)\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\nupstream.send(1)\nupstream.send(2)\nsecond.send(\"A\")\nupstream.send(3)\nupstream.send(4)\n// Prints \"3 4\"\n"
  },
  {
    "title": "encode(encoder:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/encode(encoder:)",
    "html": "Parameters\nencoder\n\nAn encoder that implements the TopLevelEncoder protocol.\n\nReturn Value\n\nA publisher that encodes received elements using a specified encoder, and publishes the resulting data.\n\nDiscussion\n\nUse encode(encoder:) with a JSONDecoder (or a PropertyListDecoder for property lists) to encode an Encodable struct into Data that could be used to make a JSON string (or written to disk as a binary plist in the case of property lists).\n\nIn this example, a PassthroughSubject publishes an Article. The encode(encoder:) operator encodes the properties of the Article struct into a new JSON string according to the Codable protocol adopted by Article. The operator publishes the resulting JSON string to the downstream subscriber. If the encoding operation fails, which can happen in the case of complex properties that can’t be directly transformed into JSON, the stream terminates and the error is passed to the downstream subscriber.\n\nstruct Article: Codable {\n    let title: String\n    let author: String\n    let pubDate: Date\n}\n\n\nlet dataProvider = PassthroughSubject<Article, Never>()\nlet cancellable = dataProvider\n    .encode(encoder: JSONEncoder())\n    .sink(receiveCompletion: { print (\"Completion: \\($0)\") },\n          receiveValue: {  data in\n            guard let stringRepresentation = String(data: data, encoding: .utf8) else { return }\n            print(\"Data received \\(data) string representation: \\(stringRepresentation)\")\n    })\n\n\ndataProvider.send(Article(title: \"My First Article\", author: \"Gita Kumar\", pubDate: Date()))\n\n\n// Prints: \"Data received 86 bytes string representation: {\"title\":\"My First Article\",\"author\":\"Gita Kumar\",\"pubDate\":606211803.279603}\"\n"
  },
  {
    "title": "max(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/max(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nThe sequence’s maximum element if the sequence is not empty; otherwise, nil.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThis example shows how to use the max(by:) method on a dictionary to find the key-value pair with the highest value.\n\nlet hues = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\nlet greatestHue = hues.max { a, b in a.value < b.value }\nprint(greatestHue)\n// Prints \"Optional((key: \"Heliotrope\", value: 296))\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "map(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/map(_:)",
    "html": "Parameters\ntransform\n\nA mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\nReturn Value\n\nAn array containing the transformed elements of this sequence.\n\nDiscussion\n\nIn this example, map is used first to convert the names in the array to lowercase strings and then to count their characters.\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet lowercaseNames = cast.map { $0.lowercased() }\n// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]\nlet letterCounts = cast.map { $0.count }\n// 'letterCounts' == [6, 6, 3, 4]\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "zip(_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/zip(_:_:_:_:)",
    "html": "Parameters\npublisher1\n\nA second publisher.\n\npublisher2\n\nA third publisher.\n\npublisher3\n\nA fourth publisher.\n\ntransform\n\nA closure that receives the most-recent value from each publisher and returns a new value to publish.\n\nReturn Value\n\nA publisher that uses the transform closure to emit new elements, produced by combining the most recent value from four upstream publishers.\n\nDiscussion\n\nUse zip(_:_:_:_:) to return a new publisher that combines the elements from three other publishers using a transformation you specify to publish a new value to the downstream subscriber. The returned publisher waits until all four publishers have emitted an event, then delivers the oldest unconsumed event from each publisher together that the operator uses in the transformation.\n\nIn this example, the PassthroughSubject publishers, numbersPub, fractionsPub, lettersPub, and emojiPub emit values. The zip(_:_:_:_:) operator receives the oldest value from each publisher and uses the Int from numbersPub and publishes a string that repeats the String from lettersPub and emojiPub that many times and prints out the value in fractionsPub.\n\nlet numbersPub = PassthroughSubject<Int, Never>()      // first publisher\nlet lettersPub = PassthroughSubject<String, Never>()   // second\nlet emojiPub = PassthroughSubject<String, Never>()     // third\nlet fractionsPub  = PassthroughSubject<Double, Never>()// fourth\n\n\ncancellable = numbersPub\n    .zip(lettersPub, emojiPub, fractionsPub) { anInt, aLetter, anEmoji, aFraction  in\n        (\"\\(String(repeating: anEmoji, count: anInt)) \\(String(repeating: aLetter, count: anInt)) \\(aFraction)\")\n    }\n    .sink { print(\"\\($0)\") }\n\n\nnumbersPub.send(1)         // numbersPub: 1       lettersPub:          emojiPub:          zip output: <none>\nnumbersPub.send(2)         // numbersPub: 1,2     lettersPub:          emojiPub:          zip output: <none>\nnumbersPub.send(3)         // numbersPub: 1,2,3   lettersPub:          emojiPub:          zip output: <none>\nfractionsPub.send(0.1)     // numbersPub: 1,2,3   lettersPub: \"A\"      emojiPub:          zip output: <none>\nlettersPub.send(\"A\")       // numbersPub: 1,2,3   lettersPub: \"A\"      emojiPub:          zip output: <none>\nemojiPub.send(\"😀\")        // numbersPub: 1,2,3   lettersPub: \"A\"      emojiPub:\"😀\"      zip output: \"😀 A\"\nlettersPub.send(\"B\")       // numbersPub: 2,3     lettersPub: \"B\"      emojiPub:          zip output: <none>\nfractionsPub.send(0.8)     // numbersPub: 2,3     lettersPub: \"A\"      emojiPub:          zip output: <none>\nemojiPub.send(\"🥰\")        // numbersPub: 3       lettersPub: \"B\"      emojiPub:          zip output: \"🥰🥰 BB\"\n// Prints:\n//1 😀 A 0.1\n//2 🥰🥰 BB 0.8\n\n\nIf any upstream publisher finishes successfully or fails with an error, so too does the zipped publisher."
  },
  {
    "title": "next() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/next()",
    "html": "Discussion\n\nOnce nil has been returned, all subsequent calls return nil.\n\nPrecondition\n\nnext() has not been applied to a copy of self since the copy was made."
  },
  {
    "title": "underestimatedCount | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/iterator/underestimatedcount",
    "html": "Discussion\n\nThe default implementation returns 0. If you provide your own implementation, make sure to compute the value nondestructively.\n\nComplexity\n\nO(1), except if the sequence also conforms to Collection. In this case, see the documentation of Collection.underestimatedCount."
  },
  {
    "title": "flatMap(maxPublishers:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/flatmap(maxpublishers:_:)-74vyg",
    "html": "Parameters\nmaxPublishers\n\nSpecifies the maximum number of concurrent publisher subscriptions, or Combine/Subscribers/Demand/unlimited if unspecified.\n\ntransform\n\nA closure that takes an element as a parameter and returns a publisher that produces elements of that type.\n\nReturn Value\n\nA publisher that transforms elements from an upstream publisher into a publisher of that element’s type."
  },
  {
    "title": "flatMap(maxPublishers:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/flatmap(maxpublishers:_:)-7xp41",
    "html": "Parameters\nmaxPublishers\n\nSpecifies the maximum number of concurrent publisher subscriptions, or Combine/Subscribers/Demand/unlimited if unspecified.\n\ntransform\n\nA closure that takes an element as a parameter and returns a publisher that produces elements of that type.\n\nReturn Value\n\nA publisher that transforms elements from an upstream publisher into a publisher of that element’s type."
  },
  {
    "title": "flatMap(maxPublishers:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/flatmap(maxpublishers:_:)-6qqrd",
    "html": "Parameters\nmaxPublishers\n\nSpecifies the maximum number of concurrent publisher subscriptions, or Combine/Subscribers/Demand/unlimited if unspecified.\n\ntransform\n\nA closure that takes an element as a parameter and returns a publisher that produces elements of that type.\n\nReturn Value\n\nA publisher that transforms elements from an upstream publisher into a publisher of that element’s type.\n\nDiscussion\n\nCombine‘s flatMap(maxPublishers:_:) operator performs a similar function to the doc://com.apple.documentation/documentation/Swift/Sequence/2905332-flatmap operator in the Swift standard library, but turns the elements from one kind of publisher into a new publisher that is sent to subscribers. Use flatMap(maxPublishers:_:) when you want to create a new series of events for downstream subscribers based on the received value. The closure creates the new Optional.Publisher based on the received value. The new Optional.Publisher can emit more than one event, and successful completion of the new Optional.Publisher does not complete the overall stream. Failure of the new Optional.Publisher causes the overall stream to fail.\n\nIn the example below, a PassthroughSubject publishes WeatherStation elements. The flatMap(maxPublishers:_:) receives each element, creates a URL from it, and produces a new URLSession.DataTaskPublisher, which will publish the data loaded from that URL.\n\npublic struct WeatherStation {\n    public let stationID: String\n}\n\n\nvar weatherPublisher = PassthroughSubject<WeatherStation, URLError>()\n\n\ncancellable = weatherPublisher.flatMap { station -> URLSession.DataTaskPublisher in\n    let url = URL(string:\"https://weatherapi.example.com/stations/\\(station.stationID)/observations/latest\")!\n    return URLSession.shared.dataTaskPublisher(for: url)\n}\n.sink(\n    receiveCompletion: { completion in\n        // Handle publisher completion (normal or error).\n    },\n    receiveValue: {\n        // Process the received data.\n    }\n )\n\n\nweatherPublisher.send(WeatherStation(stationID: \"KSFO\")) // San Francisco, CA\nweatherPublisher.send(WeatherStation(stationID: \"EGLC\")) // London, UK\nweatherPublisher.send(WeatherStation(stationID: \"ZBBB\")) // Beijing, CN\n"
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "flatMap(maxPublishers:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/flatmap(maxpublishers:_:)-9dqz0",
    "html": "Parameters\nmaxPublishers\n\nSpecifies the maximum number of concurrent publisher subscriptions, or Combine/Subscribers/Demand/unlimited if unspecified.\n\ntransform\n\nA closure that takes an element as a parameter and returns a publisher that produces elements of that type.\n\nReturn Value\n\nA publisher that transforms elements from an upstream publisher into a publisher of that element’s type."
  },
  {
    "title": "map(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/map(_:_:)",
    "html": "Parameters\nkeyPath0\n\nThe key path of a property on Output.\n\nkeyPath1\n\nThe key path of another property on Output.\n\nReturn Value\n\nA publisher that publishes the values of two key paths as a tuple.\n\nDiscussion\n\nIn the following example, the map(_:_:) operator uses the Swift key path syntax to access the die1 and die2 members of the DiceRoll structure published by the Just publisher.\n\nThe downstream sink subscriber receives only these two values (as an (Int, Int) tuple), not the entire DiceRoll.\n\nstruct DiceRoll {\n    let die1: Int\n    let die2: Int\n}\n\n\ncancellable = Just(DiceRoll(die1:Int.random(in:1...6),\n                            die2: Int.random(in:1...6)))\n    .map(\\.die1, \\.die2)\n    .sink { values in\n        print (\"Rolled: \\(values.0), \\(values.1) (total: \\(values.0 + values.1))\")\n    }\n// Prints \"Rolled: 6, 4 (total: 10)\" (or other random values).\n"
  },
  {
    "title": "handleEvents(receiveSubscription:receiveOutput:receiveCompletion:receiveCancel:receiveRequest:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/handleevents(receivesubscription:receiveoutput:receivecompletion:receivecancel:receiverequest:)",
    "html": "Parameters\nreceiveSubscription\n\nAn optional closure that executes when the publisher receives the subscription from the upstream publisher. This value defaults to nil.\n\nreceiveOutput\n\nAn optional closure that executes when the publisher receives a value from the upstream publisher. This value defaults to nil.\n\nreceiveCompletion\n\nAn optional closure that executes when the upstream publisher finishes normally or terminates with an error. This value defaults to nil.\n\nreceiveCancel\n\nAn optional closure that executes when the downstream receiver cancels publishing. This value defaults to nil.\n\nreceiveRequest\n\nAn optional closure that executes when the publisher receives a request for more elements. This value defaults to nil.\n\nReturn Value\n\nA publisher that performs the specified closures when publisher events occur.\n\nDiscussion\n\nUse handleEvents(receiveSubscription:receiveOutput:receiveCompletion:receiveCancel:receiveRequest:) when you want to examine elements as they progress through the stages of the publisher’s lifecycle.\n\nIn the example below, a publisher of integers shows the effect of printing debugging information at each stage of the element-processing lifecycle:\n\nlet integers = (0...2)\ncancellable = integers.publisher\n    .handleEvents(receiveSubscription: { subs in\n        print(\"Subscription: \\(subs.combineIdentifier)\")\n    }, receiveOutput: { anInt in\n        print(\"in output handler, received \\(anInt)\")\n    }, receiveCompletion: { _ in\n        print(\"in completion handler\")\n    }, receiveCancel: {\n        print(\"received cancel\")\n    }, receiveRequest: { (demand) in\n        print(\"received demand: \\(demand.description)\")\n    })\n    .sink { _ in return }\n\n\n// Prints:\n//   received demand: unlimited\n//   Subscription: 0x7f81284734c0\n//   in output handler, received 0\n//   in output handler, received 1\n//   in output handler, received 2\n//   in completion handler\n"
  },
  {
    "title": "makeConnectable() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/makeconnectable()",
    "html": "Return Value\n\nA ConnectablePublisher wrapping this publisher.\n\nDiscussion\n\nIn the following example, makeConnectable() wraps its upstream publisher (an instance of Publishers/Share) with a ConnectablePublisher. Without this, the first sink subscriber would receive all the elements from the sequence publisher and cause it to complete before the second subscriber attaches. By making the publisher connectable, the publisher doesn’t produce any elements until after the ConnectablePublisher/connect() call.\n\n let subject = Just<String>(\"Sent\")\n let pub = subject\n     .share()\n     .makeConnectable()\n cancellable1 = pub.sink { print (\"Stream 1 received: \\($0)\")  }\n\n\n // For example purposes, use DispatchQueue to add a second subscriber\n // a second later, and then connect to the publisher a second after that.\n DispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n     self.cancellable2 = pub.sink { print (\"Stream 2 received: \\($0)\") }\n }\n DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n     self.connectable = pub.connect()\n }\n // Prints:\n // Stream 2 received: Sent\n // Stream 1 received: Sent\n\n\nNote\n\nThe ConnectablePublisher/connect() operator returns a Cancellable instance that you must retain. You can also use this instance to cancel publishing."
  },
  {
    "title": "merge(with:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/merge(with:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:)-5crqg. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:)-8d7k7.\n\nIn this example, as merge(with:_:) receives input from the upstream publishers, it republishes the interleaved elements to the downstream:\n\nlet pubA = PassthroughSubject<Int, Never>()\nlet pubB = PassthroughSubject<Int, Never>()\nlet pubC = PassthroughSubject<Int, Never>()\n\n\ncancellable = pubA\n    .merge(with: pubB, pubC)\n    .sink { print(\"\\($0)\", terminator: \" \" )}\n\n\npubA.send(1)\npubB.send(40)\npubC.send(90)\npubA.send(2)\npubB.send(50)\npubC.send(100)\n\n\n// Prints: \"1 40 90 2 50 100\"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "map(_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/map(_:_:_:)",
    "html": "Parameters\nkeyPath0\n\nThe key path of a property on Output.\n\nkeyPath1\n\nThe key path of a second property on Output.\n\nkeyPath2\n\nThe key path of a third property on Output.\n\nReturn Value\n\nA publisher that publishes the values of three key paths as a tuple.\n\nDiscussion\n\nIn the following example, the map(_:_:_:) operator uses the Swift key path syntax to access the die1, die2, and die3 members of the DiceRoll structure published by the Just publisher.\n\nThe downstream sink subscriber receives only these three values (as an (Int, Int, Int) tuple), not the entire DiceRoll.\n\nstruct DiceRoll {\n    let die1: Int\n    let die2: Int\n    let die3: Int\n}\n\n\ncancellable = Just(DiceRoll(die1:Int.random(in:1...6),\n                            die2: Int.random(in:1...6),\n                            die3: Int.random(in:1...6)))\n    .map(\\.die1, \\.die2, \\.die3)\n    .sink { values in\n        print (\"Rolled: \\(values.0), \\(values.1), \\(values.2) (total \\(values.0 + values.1 + values.2))\")\n    }\n// Prints \"Rolled: 5, 4, 2 (total 11)\" (or other random values).\n"
  },
  {
    "title": "mapError(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/maperror(_:)",
    "html": "Parameters\ntransform\n\nA closure that takes the upstream failure as a parameter and returns a new error for the publisher to terminate with.\n\nReturn Value\n\nA publisher that replaces any upstream failure with a new error produced by the transform closure.\n\nDiscussion\n\nUse the mapError(_:) operator when you need to replace one error type with another, or where a downstream operator needs the error types of its inputs to match.\n\nThe following example uses a tryMap(_:) operator to divide 1 by each element produced by a sequence publisher. When the publisher produces a 0, the tryMap(_:) fails with a DivisionByZeroError. The mapError(_:) operator converts this into a MyGenericError.\n\nstruct DivisionByZeroError: Error {}\nstruct MyGenericError: Error { var wrappedError: Error }\n\n\nfunc myDivide(_ dividend: Double, _ divisor: Double) throws -> Double {\n       guard divisor != 0 else { throw DivisionByZeroError() }\n       return dividend / divisor\n   }\n\n\nlet divisors: [Double] = [5, 4, 3, 2, 1, 0]\ndivisors.publisher\n    .tryMap { try myDivide(1, $0) }\n    .mapError { MyGenericError(wrappedError: $0) }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\") ,\n        receiveValue: { print (\"value: \\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"0.2 0.25 0.3333333333333333 0.5 1.0 completion: failure(MyGenericError(wrappedError: DivisionByZeroError()))\"\n"
  },
  {
    "title": "max() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/max()-4k93p",
    "html": "Return Value\n\nA publisher that publishes the maximum value received from the upstream publisher, after the upstream publisher finishes.\n\nDiscussion\n\nUse max() to determine the maximum value in the stream of elements from an upstream publisher.\n\nIn the example below, the max() operator emits a value when the publisher finishes, that value is the maximum of the values received from upstream, which is 10.\n\nlet numbers = [0, 10, 5]\ncancellable = numbers.publisher\n    .max()\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"10\"\n\n\nAfter this publisher receives a request for more than 0 items, it requests unlimited items from its upstream publisher."
  },
  {
    "title": ">(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyindex/_(_:_:)-2ln36",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the greater-than operator (>) for any type that conforms to Comparable."
  },
  {
    "title": "merge(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/merge(with:)",
    "html": "Parameters\nother\n\nAnother publisher of this publisher’s type.\n\nReturn Value\n\nA publisher that emits an event when either upstream publisher emits an event."
  },
  {
    "title": "merge(with:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/merge(with:_:_:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nd\n\nA fourth publisher.\n\ne\n\nA fifth publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:_:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:_:)-48buc. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:_:)-16rcy.\n\nIn this example, as merge(with:_:_:_:) receives input from the upstream publishers, it republishes the interleaved elements to the downstream:\n\n let pubA = PassthroughSubject<Int, Never>()\n let pubB = PassthroughSubject<Int, Never>()\n let pubC = PassthroughSubject<Int, Never>()\n let pubD = PassthroughSubject<Int, Never>()\n let pubE = PassthroughSubject<Int, Never>()\n\n\n cancellable = pubA\n     .merge(with: pubB, pubC, pubD, pubE)\n     .sink { print(\"\\($0)\", terminator: \" \" ) }\n\n\n pubA.send(1)\n pubB.send(40)\n pubC.send(90)\n pubD.send(-1)\n pubE.send(33)\n pubA.send(2)\n pubB.send(50)\n pubC.send(100)\n pubD.send(-2)\n pubE.send(33)\n\n\n // Prints: \"1 40 90 -1 33 2 50 100 -2 33\"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "merge(with:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/merge(with:_:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nd\n\nA fourth publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:_:)-48buc. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:_:)-16rcy.\n\nIn this example, as merge(with:_:_:) receives input from the upstream publishers, it republishes the interleaved elements to the downstream:\n\nlet pubA = PassthroughSubject<Int, Never>()\nlet pubB = PassthroughSubject<Int, Never>()\nlet pubC = PassthroughSubject<Int, Never>()\nlet pubD = PassthroughSubject<Int, Never>()\n\n\ncancellable = pubA\n    .merge(with: pubB, pubC, pubD)\n    .sink { print(\"\\($0)\", terminator: \" \" )}\n\n\npubA.send(1)\npubB.send(40)\npubC.send(90)\npubD.send(-1)\npubA.send(2)\npubB.send(50)\npubC.send(100)\npubD.send(-2)\n\n\n// Prints: \"1 40 90 -1 2 50 100 -2 \"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "merge(with:_:_:_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/merge(with:_:_:_:_:_:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nd\n\nA fourth publisher.\n\ne\n\nA fifth publisher.\n\nf\n\nA sixth publisher.\n\ng\n\nA seventh publisher.\n\nh\n\nAn eighth publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:_:_:_:_:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:_:)-48buc. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:_:)-16rcy.\n\nIn this example, as merge(with:_:_:_:_:_:_:) receives input from the upstream publishers, it republishes the interleaved elements to the downstream:\n\nlet pubA = PassthroughSubject<Int, Never>()\nlet pubB = PassthroughSubject<Int, Never>()\nlet pubC = PassthroughSubject<Int, Never>()\nlet pubD = PassthroughSubject<Int, Never>()\nlet pubE = PassthroughSubject<Int, Never>()\nlet pubF = PassthroughSubject<Int, Never>()\nlet pubG = PassthroughSubject<Int, Never>()\nlet pubH = PassthroughSubject<Int, Never>()\n\n\ncancellable = pubA\n    .merge(with: pubB, pubC, pubD, pubE, pubF, pubG, pubH)\n    .sink { print(\"\\($0)\", terminator: \" \" ) }\n\n\npubA.send(1)\npubB.send(40)\npubC.send(90)\npubD.send(-1)\npubE.send(33)\npubF.send(44)\npubG.send(54)\npubH.send(1000)\n\n\npubA.send(2)\npubB.send(50)\npubC.send(100)\npubD.send(-2)\npubE.send(33)\npubF.send(33)\npubG.send(54)\npubH.send(1001)\n\n\n//Prints: \"1 40 90 -1 33 44 54 1000 2 50 100 -2 33 33 54 1001\"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "merge(with:_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/merge(with:_:_:_:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nd\n\nA fourth publisher.\n\ne\n\nA fifth publisher.\n\nf\n\nA sixth publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:_:_:_:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:_:)-48buc. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:_:)-16rcy.\n\nIn this example, as merge(with:_:_:_:_:_:) receives input from the upstream publishers, it republishes the interleaved elements to the downstream:\n\nlet pubA = PassthroughSubject<Int, Never>()\nlet pubB = PassthroughSubject<Int, Never>()\nlet pubC = PassthroughSubject<Int, Never>()\nlet pubD = PassthroughSubject<Int, Never>()\nlet pubE = PassthroughSubject<Int, Never>()\nlet pubF = PassthroughSubject<Int, Never>()\n\n\ncancellable = pubA\n    .merge(with: pubB, pubC, pubD, pubE, pubF)\n    .sink { print(\"\\($0)\", terminator: \" \" ) }\n\n\npubA.send(1)\npubB.send(40)\npubC.send(90)\npubD.send(-1)\npubE.send(33)\npubF.send(44)\n\n\npubA.send(2)\npubB.send(50)\npubC.send(100)\npubD.send(-2)\npubE.send(33)\npubF.send(33)\n\n\n//Prints: \"1 40 90 -1 33 44 2 50 100 -2 33 33\"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "merge(with:_:_:_:_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/merge(with:_:_:_:_:_:)",
    "html": "Parameters\nb\n\nA second publisher.\n\nc\n\nA third publisher.\n\nd\n\nA fourth publisher.\n\ne\n\nA fifth publisher.\n\nf\n\nA sixth publisher.\n\ng\n\nA seventh publisher.\n\nReturn Value\n\nA publisher that emits an event when any upstream publisher emits an event.\n\nDiscussion\n\nUse merge(with:_:_:_:_:_:) when you want to receive a new element whenever any of the upstream publishers emits an element. To receive tuples of the most-recent value from all the upstream publishers whenever any of them emit a value, use Publisher/combineLatest(_:_:_:)-48buc. To combine elements from multiple upstream publishers, use Publisher/zip(_:_:_:)-16rcy.\n\nIn this example, as merge(with:_:_:_:_:_:) receives input from the upstream publishers; it republishes the interleaved elements to the downstream:\n\nlet pubA = PassthroughSubject<Int, Never>()\nlet pubB = PassthroughSubject<Int, Never>()\nlet pubC = PassthroughSubject<Int, Never>()\nlet pubD = PassthroughSubject<Int, Never>()\nlet pubE = PassthroughSubject<Int, Never>()\nlet pubF = PassthroughSubject<Int, Never>()\nlet pubG = PassthroughSubject<Int, Never>()\n\n\ncancellable = pubA\n    .merge(with: pubB, pubC, pubD, pubE, pubE, pubG)\n    .sink { print(\"\\($0)\", terminator: \" \" ) }\n\n\npubA.send(1)\npubB.send(40)\npubC.send(90)\npubD.send(-1)\npubE.send(33)\npubF.send(44)\npubG.send(54)\n\n\npubA.send(2)\npubB.send(50)\npubC.send(100)\npubD.send(-2)\npubE.send(33)\npubF.send(33)\npubG.send(54)\n\n\n//Prints: \"1 40 90 -1 33 44 54 2 50 100 -2 33 33 54\"\n\n\nThe merged publisher continues to emit elements until all upstream publishers finish. If an upstream publisher produces an error, the merged publisher fails with that error."
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyindex/_=(_:_:)-8jql0",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nThis is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable."
  },
  {
    "title": "==(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/==(_:_:)",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nDiscussion\n\nEquality is the inverse of inequality. For any values a and b, a == b implies that a != b is false."
  },
  {
    "title": ">=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyindex/_=(_:_:)-76rr2",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare.\n\nReturn Value\n\ntrue if lhs is greater than or equal to rhs; otherwise, false.\n\nDiscussion\n\nThis is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyindex/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "..<(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/anyindex/'.._(_:)",
    "html": "Parameters\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.\n\nlet upToFive = ..<5.0\n\n\nupToFive.contains(3.14)       // true\nupToFive.contains(6.28)       // false\nupToFive.contains(5.0)        // false\n\n\nYou can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.\n\nlet numbers = [10, 20, 30, 40, 50, 60, 70]\nprint(numbers[..<3])\n// Prints \"[10, 20, 30]\"\n\n\nPrecondition\n\nmaximum must compare equal to itself (i.e. cannot be NaN)."
  },
  {
    "title": "tryCatch(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/trycatch(_:)",
    "html": "Parameters\nhandler\n\nA throwing closure that accepts the upstream failure as input. This closure can either replace the upstream publisher with a new one, or throw a new error to the downstream subscriber.\n\nReturn Value\n\nA publisher that handles errors from an upstream publisher by replacing the failed publisher with another publisher, or an error.\n\nDiscussion\n\nUse tryCatch(_:) to decide how to handle from an upstream publisher by either replacing the publisher with a new publisher, or throwing a new error.\n\nIn the example below, an array publisher emits values that a tryMap(_:) operator evaluates to ensure the values are greater than zero. If the values aren’t greater than zero, the operator throws an error to the downstream subscriber to let it know there was a problem. The subscriber, tryCatch(_:), replaces the error with a new publisher using Just to publish a final value before the stream ends normally.\n\nenum SimpleError: Error { case error }\nvar numbers = [5, 4, 3, 2, 1, -1, 7, 8, 9, 10]\n\n\ncancellable = numbers.publisher\n   .tryMap { v in\n        if v > 0 {\n            return v\n        } else {\n            throw SimpleError.error\n        }\n}\n  .tryCatch { error in\n      Just(0) // Send a final value before completing normally.\n              // Alternatively, throw a new error to terminate the stream.\n}\n  .sink(receiveCompletion: { print (\"Completion: \\($0).\") },\n        receiveValue: { print (\"Received \\($0).\") }\n  )\n//    Received 5.\n//    Received 4.\n//    Received 3.\n//    Received 2.\n//    Received 1.\n//    Received 0.\n//    Completion: finished.\n"
  },
  {
    "title": "tryDrop(while:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/trydrop(while:)",
    "html": "Parameters\npredicate\n\nA closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the publisher’s output.\n\nReturn Value\n\nA publisher that skips over elements until the provided closure returns false, and then republishes all remaining elements. If the predicate closure throws, the publisher fails with an error.\n\nDiscussion\n\nUse tryDrop(while:) to omit elements from an upstream until an error-throwing closure you provide returns false, after which the remaining items in the stream are published. If the closure throws, no elements are emitted and the publisher fails with an error.\n\nIn the example below, elements are ignored until -1 is encountered in the stream and the closure returns false. The publisher then republishes the remaining elements and finishes normally. Conversely, if the guard value in the closure had been encountered, the closure would throw and the publisher would fail with an error.\n\nstruct RangeError: Error {}\nvar numbers = [1, 2, 3, 4, 5, 6, -1, 7, 8, 9, 10]\nlet range: CountableClosedRange<Int> = (1...100)\ncancellable = numbers.publisher\n    .tryDrop {\n        guard $0 != 0 else { throw RangeError() }\n        return range.contains($0)\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\") },\n        receiveValue: { print (\"value: \\($0)\") }\n    )\n\n\n// Prints: \"-1 7 8 9 10 completion: finished\"\n// If instead numbers was [1, 2, 3, 4, 5, 6, 0, -1, 7, 8, 9, 10], tryDrop(while:) would fail with a RangeError.\n"
  },
  {
    "title": "tryFilter(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/tryfilter(_:)",
    "html": "Parameters\nisIncluded\n\nA closure that takes one element and returns a Boolean value that indicated whether to republish the element or throws an error.\n\nReturn Value\n\nA publisher that republishes all elements that satisfy the closure.\n\nDiscussion\n\nUse tryFilter(_:) to filter elements evaluated in an error-throwing closure. If the isIncluded closure throws an error, the publisher fails with that error.\n\nIn the example below, tryFilter(_:) checks to see if the element provided by the publisher is zero, and throws a ZeroError before terminating the publisher with the thrown error. Otherwise, it republishes the element only if it’s even:\n\nstruct ZeroError: Error {}\n\n\nlet numbers: [Int] = [1, 2, 3, 4, 0, 5]\ncancellable = numbers.publisher\n    .tryFilter{\n        if $0 == 0 {\n            throw ZeroError()\n        } else {\n            return $0 % 2 == 0\n        }\n    }\n    .sink(\n        receiveCompletion: { print (\"\\($0)\") },\n        receiveValue: { print (\"\\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"2 4 failure(DivisionByZeroError())\".\n"
  },
  {
    "title": "<=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/_=(_:_:)-5nd54",
    "html": "Parameters\nlhs\n\nA value to compare.\n\nrhs\n\nAnother value to compare."
  },
  {
    "title": "tryAllSatisfy(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/tryallsatisfy(_:)",
    "html": "Parameters\npredicate\n\nA closure that evaluates each received element. Return true to continue, or false to cancel the upstream and complete. The closure may throw an error, in which case the publisher cancels the upstream publisher and fails with the thrown error.\n\nReturn Value\n\nA publisher that publishes a Boolean value that indicates whether all received elements pass a given predicate.\n\nDiscussion\n\nUse the tryAllSatisfy(_:) operator to determine if all elements in a stream satisfy a criteria in an error-throwing predicate you provide. When this publisher receives an element, it runs the predicate against the element. If the predicate returns false, the publisher produces a false value and finishes. If the upstream publisher finishes normally, this publisher produces a true value and finishes. If the predicate throws an error, the publisher fails and passes the error to its downstream subscriber.\n\nIn the example below, an error-throwing predicate tests if each of an integer array publisher’s elements fall into the targetRange; the predicate throws an error if an element is zero and terminates the stream.\n\nlet targetRange = (-1...100)\nlet numbers = [-1, 10, 5, 0]\n\n\nnumbers.publisher\n    .tryAllSatisfy { anInt in\n        guard anInt != 0 else { throw RangeError() }\n        return targetRange.contains(anInt)\n    }\n    .sink(\n        receiveCompletion: { print (\"completion: \\($0)\") },\n        receiveValue: { print (\"value: \\($0)\") }\n    )\n\n\n// Prints: \"completion: failure(RangeError())\"\n\n\nWith operators similar to reduce(_:_:), this publisher produces at most one value.\n\nNote\n\nUpon receiving any request greater than zero, this publisher requests unlimited elements from the upstream publisher."
  },
  {
    "title": "tryCompactMap(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/trycompactmap(_:)",
    "html": "Parameters\ntransform\n\nAn error-throwing closure that receives a value and returns an optional value.\n\nReturn Value\n\nAny non-nil optional results of calling the supplied closure.\n\nDiscussion\n\nUse tryCompactMap(_:) to remove nil elements from a publisher’s stream based on an error-throwing closure you provide. If the closure throws an error, the publisher cancels the upstream publisher and sends the thrown error to the downstream subscriber as a Optional.Publisher.Failure.\n\nThe following example uses an array of numbers as the source for a collection-based publisher. A tryCompactMap(_:) operator consumes each integer from the publisher and uses a dictionary to transform the numbers from its Arabic to Roman numerals, as an optional String.\n\nIf the closure called by tryCompactMap(_:) fails to look up a Roman numeral, it returns the optional String (unknown).\n\nIf the closure called by tryCompactMap(_:) determines the input is 0, it throws an error. The tryCompactMap(_:) operator catches this error and stops publishing, sending a Subscribers/Completion/failure(_:) that wraps the error.\n\nstruct ParseError: Error {}\nfunc romanNumeral(from: Int) throws -> String? {\n    let romanNumeralDict: [Int : String] =\n        [1: \"I\", 2: \"II\", 3: \"III\", 4: \"IV\", 5: \"V\"]\n    guard from != 0 else { throw ParseError() }\n    return romanNumeralDict[from]\n}\nlet numbers = [6, 5, 4, 3, 2, 1, 0]\ncancellable = numbers.publisher\n    .tryCompactMap { try romanNumeral(from: $0) }\n    .sink(\n          receiveCompletion: { print (\"\\($0)\") },\n          receiveValue: { print (\"\\($0)\", terminator: \" \") }\n     )\n\n\n// Prints: \"(Unknown) V IV III II I failure(ParseError())\"\n"
  },
  {
    "title": "output(in:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/output(in:)-9lez7",
    "html": "Parameters\nrange\n\nA range that indicates which elements to publish.\n\nReturn Value\n\nA publisher that publishes elements specified by a range.\n\nDiscussion\n\nUse output(in:) to republish a range indices you specify in the published stream. After publishing all elements, the publisher finishes normally. If the publisher completes normally or with an error before producing all the elements in the range, it doesn’t publish the remaining elements.\n\nIn the example below, an array publisher emits the subset of elements at the indices in the specified range:\n\nlet numbers = [1, 1, 2, 2, 2, 3, 4, 5, 6]\nnumbers.publisher\n    .output(in: (3...5))\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"2 2 3\"\n"
  },
  {
    "title": "prefix(untilOutputFrom:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/prefix(untiloutputfrom:)",
    "html": "Parameters\npublisher\n\nA second publisher.\n\nReturn Value\n\nA publisher that republishes elements until the second publisher publishes an element.\n\nDiscussion\n\nAfter the second publisher publishes an element, the publisher returned by this method finishes."
  },
  {
    "title": "multicast(subject:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/multicast(subject:)",
    "html": "Parameters\nsubject\n\nA subject to deliver elements to downstream subscribers.\n\nDiscussion\n\nUse a multicast publisher when you have multiple downstream subscribers, but you want upstream publishers to only process one Subscriber/receive(_:) call per event. This is useful when upstream publishers are doing expensive work you don’t want to duplicate, like performing network requests.\n\nIn contrast with multicast(_:), this method produces a publisher that shares the provided Subject among all the downstream subscribers.\n\nThe following example uses a sequence publisher as a counter to publish three random numbers, generated by a Publisher/map(_:)-99evh operator. It uses a multicast(subject:) operator with a PassthroughSubject to share the same random number to each of two subscribers. Because the multicast publisher is a ConnectablePublisher, publishing only begins after a call to ConnectablePublisher/connect().\n\nlet pub = [\"First\", \"Second\", \"Third\"].publisher\n    .map( { return ($0, Int.random(in: 0...100)) } )\n    .print(\"Random\")\n    .multicast(subject: PassthroughSubject<(String, Int), Never>())\n\n\ncancellable1 = pub\n    .sink { print (\"Stream 1 received: \\($0)\")}\ncancellable2 = pub\n    .sink { print (\"Stream 2 received: \\($0)\")}\npub.connect()\n\n\n// Prints:\n// Random: receive value: ((\"First\", 78))\n// Stream 2 received: (\"First\", 78)\n// Stream 1 received: (\"First\", 78)\n// Random: receive value: ((\"Second\", 98))\n// Stream 2 received: (\"Second\", 98)\n// Stream 1 received: (\"Second\", 98)\n// Random: receive value: ((\"Third\", 61))\n// Stream 2 received: (\"Third\", 61)\n// Stream 1 received: (\"Third\", 61)\n\n\nIn this example, the output shows that the print(_:to:) operator receives each random value only one time, and then sends the value to both subscribers."
  },
  {
    "title": "assign(to:on:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/assign(to:on:)",
    "html": "Parameters\nkeyPath\n\nA key path that indicates the property to assign. See Key-Path Expression in The Swift Programming Language to learn how to use key paths to specify a property of an object.\n\nobject\n\nThe object that contains the property. The subscriber assigns the object’s property every time it receives a new value.\n\nReturn Value\n\nAn AnyCancellable instance. Call Cancellable/cancel() on this instance when you no longer want the publisher to automatically assign the property. Deinitializing this instance will also cancel automatic assignment.\n\nDiscussion\n\nUse the assign(to:on:) subscriber when you want to set a given property each time a publisher produces a value.\n\nIn this example, the assign(to:on:) sets the value of the anInt property on an instance of MyClass:\n\nclass MyClass {\n    var anInt: Int = 0 {\n        didSet {\n            print(\"anInt was set to: \\(anInt)\", terminator: \"; \")\n        }\n    }\n}\n\n\nvar myObject = MyClass()\nlet myRange = (0...2)\ncancellable = myRange.publisher\n    .assign(to: \\.anInt, on: myObject)\n\n\n// Prints: \"anInt was set to: 0; anInt was set to: 1; anInt was set to: 2\"\n\n\nImportant\n\nThe Subscribers/Assign instance created by this operator maintains a strong reference to object, and sets it to nil when the upstream publisher completes (either normally or with an error)."
  },
  {
    "title": "breakpoint(receiveSubscription:receiveOutput:receiveCompletion:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/breakpoint(receivesubscription:receiveoutput:receivecompletion:)",
    "html": "Parameters\nreceiveSubscription\n\nA closure that executes when the publisher receives a subscription. Return true from this closure to raise SIGTRAP, or false to continue.\n\nreceiveOutput\n\nA closure that executes when the publisher receives a value. Return true from this closure to raise SIGTRAP, or false to continue.\n\nreceiveCompletion\n\nA closure that executes when the publisher receives a completion. Return true from this closure to raise SIGTRAP, or false to continue.\n\nReturn Value\n\nA publisher that raises a debugger signal when one of the provided closures returns true.\n\nDiscussion\n\nUse breakpoint(receiveSubscription:receiveOutput:receiveCompletion:) to examine one or more stages of the subscribe/publish/completion process and stop in the debugger, based on conditions you specify. When any of the provided closures returns true, this operator raises the SIGTRAP signal to stop the process in the debugger. Otherwise, this publisher passes through values and completions as-is.\n\nIn the example below, a PassthroughSubject publishes strings to a breakpoint republisher. When the breakpoint receives the string “DEBUGGER”, it returns true, which stops the app in the debugger.\n\nlet publisher = PassthroughSubject<String?, Never>()\ncancellable = publisher\n    .breakpoint(\n        receiveOutput: { value in return value == \"DEBUGGER\" }\n    )\n    .sink { print(\"\\(String(describing: $0))\" , terminator: \" \") }\n\n\npublisher.send(\"DEBUGGER\")\n\n\n// Prints: \"error: Execution was interrupted, reason: signal SIGTRAP.\"\n// Depending on your specific environment, the console messages may\n// also include stack trace information, which is not shown here.\n"
  },
  {
    "title": "assertNoFailure(_:file:line:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/assertnofailure(_:file:line:)",
    "html": "Parameters\nprefix\n\nA string used at the beginning of the fatal error message.\n\nfile\n\nA filename used in the error message. This defaults to #file.\n\nline\n\nA line number used in the error message. This defaults to #line.\n\nReturn Value\n\nA publisher that raises a fatal error when its upstream publisher fails.\n\nDiscussion\n\nUse assertNoFailure() for internal integrity checks that are active during testing. However, it is important to note that, like its Swift counterpart fatalError(_:), the assertNoFailure() operator asserts a fatal exception when triggered during development and testing, and in shipping versions of code.\n\nIn the example below, a CurrentValueSubject publishes the initial and second values successfully. The third value, containing a genericSubjectError, causes the assertNoFailure() operator to assert a fatal exception stopping the process:\n\npublic enum SubjectError: Error {\n    case genericSubjectError\n}\n\n\nlet subject = CurrentValueSubject<String, Error>(\"initial value\")\nsubject\n    .assertNoFailure()\n    .sink(receiveCompletion: { print (\"completion: \\($0)\") },\n          receiveValue: { print (\"value: \\($0).\") }\n    )\n\n\nsubject.send(\"second value\")\nsubject.send(completion: Subscribers.Completion<Error>.failure(SubjectError.genericSubjectError))\n\n\n// Prints:\n//  value: initial value.\n//  value: second value.\n//  The process then terminates in the debugger as the assertNoFailure operator catches the genericSubjectError.\n"
  },
  {
    "title": "breakpointOnError() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/breakpointonerror()",
    "html": "Return Value\n\nA publisher that raises a debugger signal upon receiving a failure.\n\nDiscussion\n\nWhen the upstream publisher fails with an error, this publisher raises the SIGTRAP signal, which stops the process in the debugger. Otherwise, this publisher passes through values and completions as-is.\n\nIn this example a PassthroughSubject publishes strings, but its downstream tryMap(_:) operator throws an error. This sends the error downstream as a Subscribers/Completion/failure(_:). The breakpointOnError() operator receives this completion and stops the app in the debugger.\n\n struct CustomError : Error {}\n let publisher = PassthroughSubject<String?, Error>()\n cancellable = publisher\n     .tryMap { stringValue in\n         throw CustomError()\n     }\n     .breakpointOnError()\n     .sink(\n         receiveCompletion: { completion in print(\"Completion: \\(String(describing: completion))\") },\n         receiveValue: { aValue in print(\"Result: \\(String(describing: aValue))\") }\n     )\n\n\n publisher.send(\"TEST DATA\")\n\n\n // Prints: \"error: Execution was interrupted, reason: signal SIGTRAP.\"\n // Depending on your specific environment, the console messages may\n // also include stack trace information, which is not shown here.\n"
  },
  {
    "title": "multicast(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/multicast(_:)",
    "html": "Parameters\ncreateSubject\n\nA closure to create a new Subject each time a subscriber attaches to the multicast publisher.\n\nDiscussion\n\nUse a multicast publisher when you have multiple downstream subscribers, but you want upstream publishers to only process one Subscriber/receive(_:) call per event. This is useful when upstream publishers are doing expensive work you don’t want to duplicate, like performing network requests.\n\nIn contrast with multicast(subject:), this method produces a publisher that creates a separate Subject for each subscriber.\n\nThe following example uses a sequence publisher as a counter to publish three random numbers, generated by a Publisher/map(_:)-99evh operator. It uses a multicast(_:) operator whose closure creates a PassthroughSubject to share the same random number to each of two subscribers. Because the multicast publisher is a ConnectablePublisher, publishing only begins after a call to ConnectablePublisher/connect().\n\nlet pub = [\"First\", \"Second\", \"Third\"].publisher\n    .map( { return ($0, Int.random(in: 0...100)) } )\n    .print(\"Random\")\n    .multicast { PassthroughSubject<(String, Int), Never>() }\n\n\ncancellable1 = pub\n   .sink { print (\"Stream 1 received: \\($0)\")}\ncancellable2 = pub\n   .sink { print (\"Stream 2 received: \\($0)\")}\npub.connect()\n\n\n// Prints:\n// Random: receive value: ((\"First\", 9))\n// Stream 2 received: (\"First\", 9)\n// Stream 1 received: (\"First\", 9)\n// Random: receive value: ((\"Second\", 46))\n// Stream 2 received: (\"Second\", 46)\n// Stream 1 received: (\"Second\", 46)\n// Random: receive value: ((\"Third\", 26))\n// Stream 2 received: (\"Third\", 26)\n// Stream 1 received: (\"Third\", 26)\n\n\nIn this example, the output shows that the print(_:to:) operator receives each random value only one time, and then sends the value to both subscribers."
  },
  {
    "title": "values | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/values",
    "html": "Discussion\n\nThis property provides an AsyncPublisher, which allows you to use the Swift async-await syntax to receive the publisher’s elements. Because AsyncPublisher conforms to AsyncSequence, you iterate over its elements with a for-await-in loop, rather than attaching a subscriber.\n\nThe following example shows how to use the values property to receive elements asynchronously. The example adapts a code snippet from the filter(_:) operator’s documentation, which filters a sequence to only emit even integers. This example replaces the Subscribers/Sink subscriber with a for-await-in loop that iterates over the AsyncPublisher provided by the values property.\n\nlet numbers: [Int] = [1, 2, 3, 4, 5]\nlet filtered = numbers.publisher\n    .filter { $0 % 2 == 0 }\n\n\nfor await number in filtered.values\n{\n    print(\"\\(number)\", terminator: \" \")\n}\n"
  },
  {
    "title": "min() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/min()-4ls63",
    "html": "Return Value\n\nA publisher that publishes the minimum value received from the upstream publisher, after the upstream publisher finishes.\n\nDiscussion\n\nUse min(by:) to find the minimum value in a stream of elements from an upstream publisher.\n\nIn the example below, the min(by:) operator emits a value when the publisher finishes, that value is the minimum of the values received from upstream, which is -1.\n\nlet numbers = [-1, 0, 10, 5]\nnumbers.publisher\n    .min()\n    .sink { print(\"\\($0)\") }\n\n\n// Prints: \"-1\"\n\n\nAfter this publisher receives a request for more than 0 items, it requests unlimited items from its upstream publisher."
  },
  {
    "title": "append(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/append(_:)",
    "html": "Parameters\nelements\n\nElements to publish after this publisher’s elements.\n\nReturn Value\n\nA publisher that appends the specifiecd elements after this publisher’s elements.\n\nDiscussion\n\nUse Publisher/append(_:)-1qb8d when you need to prepend specific elements after the output of a publisher.\n\nIn the example below, the Publisher/append(_:)-1qb8d operator publishes the provided elements after republishing all elements from dataElements:\n\nlet dataElements = (0...10)\ncancellable = dataElements.publisher\n    .append(0, 1, 255)\n    .sink { print(\"\\($0)\", terminator: \" \") }\n\n\n// Prints: \"0 1 2 3 4 5 6 7 8 9 10 0 1 255\"\n"
  },
  {
    "title": "buffer(size:prefetch:whenFull:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/optional/publisher-swift.struct/buffer(size:prefetch:whenfull:)",
    "html": "Parameters\nsize\n\nThe maximum number of elements to store.\n\nprefetch\n\nThe strategy to initially populate the buffer.\n\nwhenFull\n\nThe action to take when the buffer becomes full.\n\nReturn Value\n\nA publisher that buffers elements received from an upstream publisher.\n\nDiscussion\n\nUse buffer(size:prefetch:whenFull:) to collect a specific number of elements from an upstream publisher before republishing them to the downstream subscriber according to the Publishers/BufferingStrategy and Publishers/PrefetchStrategy strategy you specify.\n\nIf the publisher completes before reaching the size threshold, it buffers the elements and publishes them downstream prior to completion."
  },
  {
    "title": "joined(separator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/joined(separator:)-8ylyk",
    "html": "Parameters\nseparator\n\nA string to insert between each of the elements in this sequence. The default separator is an empty string.\n\nReturn Value\n\nA single, concatenated string.\n\nDiscussion\n\nThe following example shows how an array of strings can be joined to a single, comma-separated string:\n\nlet cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]\nlet list = cast.joined(separator: \", \")\nprint(list)\n// Prints \"Vivien, Marlon, Kim, Karl\"\n"
  },
  {
    "title": "lexicographicallyPrecedes(_:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/lexicographicallyprecedes(_:by:)",
    "html": "Parameters\nother\n\nA sequence to compare to this sequence.\n\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\ntrue if this sequence precedes other in a dictionary ordering as ordered by areInIncreasingOrder; otherwise, false.\n\nDiscussion\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nNote\n\nThis method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode. If you are sorting strings to present to the end user, use String APIs that perform localized comparison instead.\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of other."
  },
  {
    "title": "Sequence Implementations | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/sequence-implementations",
    "html": "Topics\nStructures\nstruct Iterator\nAn iterator over the elements traversed by a base iterator that follow the initial consecutive elements that satisfy a given predicate.\nAvailable when Base conforms to Sequence.\nInstance Properties\nvar underestimatedCount: Int\nA value less than or equal to the number of elements in the sequence, calculated nondestructively.\nInstance Methods\nfunc allSatisfy((Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether every element of a sequence satisfies a given predicate.\nfunc compactMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nReturns an array containing the non-nil results of calling the given transformation with each element of this sequence.\nfunc contains(Self.Element) -> Bool\nReturns a Boolean value indicating whether the sequence contains the given element.\nAvailable when Element conforms to Equatable.\nfunc contains(where: (Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.\nfunc dropFirst(Int) -> DropFirstSequence<Self>\nReturns a sequence containing all but the given number of initial elements.\nfunc dropLast(Int) -> [Self.Element]\nReturns a sequence containing all but the given number of final elements.\nfunc elementsEqual<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.\nAvailable when Element conforms to Equatable.\nfunc elementsEqual<OtherSequence>(OtherSequence, by: (Self.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.\nfunc enumerated() -> EnumeratedSequence<Self>\nReturns a sequence of pairs (n, x), where n represents a consecutive integer starting at zero and x represents an element of the sequence.\nfunc first(where: (Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the first element of the sequence that satisfies the given predicate.\nfunc flatMap<ElementOfResult>((Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\nfunc flatMap<SegmentOfResult>((Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element]\nReturns an array containing the concatenated results of calling the given transformation with each element of this sequence.\nfunc forEach((Self.Element) throws -> Void) rethrows\nCalls the given closure on each element in the sequence in the same order as a for-in loop.\nfunc joined() -> FlattenSequence<Self>\nReturns the elements of this sequence of sequences, concatenated.\nfunc joined(separator: String) -> String\nReturns a new string by concatenating the elements of the sequence, adding the given separator between each element.\nAvailable when Element conforms to StringProtocol.\nfunc joined<Separator>(separator: Separator) -> JoinedSequence<Self>\nReturns the concatenated elements of this sequence of sequences, inserting the given separator between each element.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence) -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<) to compare elements.\nAvailable when Element conforms to Comparable.\nfunc lexicographicallyPrecedes<OtherSequence>(OtherSequence, by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.\nfunc makeIterator() -> LazyDropWhileSequence<Base>.Iterator\nReturns an iterator over the elements of this sequence.\nAvailable when Base conforms to Sequence.\nfunc map<T>((Self.Element) throws -> T) rethrows -> [T]\nReturns an array containing the results of mapping the given closure over the sequence’s elements.\nfunc max() -> Self.Element?\nReturns the maximum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc max(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the maximum element in the sequence, using the given predicate as the comparison between elements.\nfunc min() -> Self.Element?\nReturns the minimum element in the sequence.\nAvailable when Element conforms to Comparable.\nfunc min(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?\nReturns the minimum element in the sequence, using the given predicate as the comparison between elements.\nfunc prefix(Int) -> PrefixSequence<Self>\nReturns a sequence, up to the specified maximum length, containing the initial elements of the sequence.\nfunc reduce<Result>(Result, (Result, Self.Element) throws -> Result) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reduce<Result>(into: Result, (inout Result, Self.Element) throws -> ()) rethrows -> Result\nReturns the result of combining the elements of the sequence using the given closure.\nfunc reversed() -> [Self.Element]\nReturns an array containing the elements of this sequence in reverse order.\nfunc shuffled() -> [Self.Element]\nReturns the elements of the sequence, shuffled.\nfunc shuffled<T>(using: inout T) -> [Self.Element]\nReturns the elements of the sequence, shuffled using the given generator as a source for randomness.\nfunc sorted() -> [Self.Element]\nReturns the elements of the sequence, sorted.\nAvailable when Element conforms to Comparable.\nfunc sorted(by: (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]\nReturns the elements of the sequence, sorted using the given predicate as the comparison between elements.\nfunc split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator: (Self.Element) throws -> Bool) rethrows -> [ArraySlice<Self.Element>]\nReturns the longest possible subsequences of the sequence, in order, that don’t contain elements satisfying the given predicate. Elements that are used to split the sequence are not returned as part of any subsequence.\nfunc split(separator: Self.Element, maxSplits: Int, omittingEmptySubsequences: Bool) -> [ArraySlice<Self.Element>]\nReturns the longest possible subsequences of the sequence, in order, around elements equal to the given element.\nAvailable when Element conforms to Equatable.\nfunc starts<PossiblePrefix>(with: PossiblePrefix) -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.\nAvailable when Element conforms to Equatable.\nfunc starts<PossiblePrefix>(with: PossiblePrefix, by: (Self.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool\nReturns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.\nfunc suffix(Int) -> [Self.Element]\nReturns a subsequence, up to the given maximum length, containing the final elements of the sequence.\nfunc withContiguousStorageIfAvailable<R>((UnsafeBufferPointer<Self.Element>) throws -> R) rethrows -> R?\nExecutes a closure on the sequence’s contiguous storage."
  },
  {
    "title": "-=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/additivearithmetic/-=(_:_:)-27vve",
    "html": "Parameters\nlhs\n\nA numeric value.\n\nrhs\n\nThe value to subtract from lhs."
  },
  {
    "title": "+=(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/additivearithmetic/+=(_:_:)-qjxp",
    "html": "Parameters\nlhs\n\nThe first value to add.\n\nrhs\n\nThe second value to add."
  },
  {
    "title": "..<(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/jobpriority/'.._(_:_:)",
    "html": "Parameters\nminimum\n\nThe lower bound for the range.\n\nmaximum\n\nThe upper bound for the range.\n\nDiscussion\n\nUse the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.\n\nlet lessThanFive = 0.0..<5.0\nprint(lessThanFive.contains(3.14))  // Prints \"true\"\nprint(lessThanFive.contains(5.0))   // Prints \"false\"\n\n\nPrecondition\n\nminimum <= maximum."
  },
  {
    "title": "starts(with:by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/starts(with:by:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nareEquivalent\n\nA predicate that returns true if its two arguments are equivalent; otherwise, false.\n\nReturn Value\n\ntrue if the initial elements of the sequence are equivalent to the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThe predicate must be a equivalence relation over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareEquivalent(a, a) is always true. (Reflexivity)\n\nareEquivalent(a, b) implies areEquivalent(b, a). (Symmetry)\n\nIf areEquivalent(a, b) and areEquivalent(b, c) are both true, then areEquivalent(a, c) is also true. (Transitivity)\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "reduce(_:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/reduce(_:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.\n\nnextPartialResult\n\nA closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(_:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of numbers to find their sum or product.\n\nThe nextPartialResult closure is called sequentially with an accumulating value initialized to initialResult and each element of the sequence. This example shows how to find the sum of an array of numbers.\n\nlet numbers = [1, 2, 3, 4]\nlet numberSum = numbers.reduce(0, { x, y in\n    x + y\n})\n// numberSum == 10\n\n\nWhen numbers.reduce(_:_:) is called, the following steps occur:\n\nThe nextPartialResult closure is called with initialResult—0 in this case—and the first element of numbers, returning the sum: 1.\n\nThe closure is called again repeatedly with the previous call’s return value and each element of the sequence.\n\nWhen the sequence is exhausted, the last value returned from the closure is returned to the caller.\n\nIf the sequence has no elements, nextPartialResult is never executed and initialResult is the result of the call to reduce(_:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reversed() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/reversed()",
    "html": "Return Value\n\nAn array containing the elements of this sequence in reverse order.\n\nDiscussion\n\nThe sequence must be finite.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "reduce(into:_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/reduce(into:_:)",
    "html": "Parameters\ninitialResult\n\nThe value to use as the initial accumulating value.\n\nupdateAccumulatingResult\n\nA closure that updates the accumulating value with an element of the sequence.\n\nReturn Value\n\nThe final accumulated value. If the sequence has no elements, the result is initialResult.\n\nDiscussion\n\nUse the reduce(into:_:) method to produce a single value from the elements of an entire sequence. For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.\n\nThis method is preferred over reduce(_:_:) for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.\n\nThe updateAccumulatingResult closure is called sequentially with a mutable accumulating value initialized to initialResult and each element of the sequence. This example shows how to build a dictionary of letter frequencies of a string.\n\nlet letters = \"abracadabra\"\nlet letterCount = letters.reduce(into: [:]) { counts, letter in\n    counts[letter, default: 0] += 1\n}\n// letterCount == [\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1]\n\n\nWhen letters.reduce(into:_:) is called, the following steps occur:\n\nThe updateAccumulatingResult closure is called with the initial accumulating value—[:] in this case—and the first character of letters, modifying the accumulating value by setting 1 for the key \"a\".\n\nThe closure is called again repeatedly with the updated accumulating value and each element of the sequence.\n\nWhen the sequence is exhausted, the accumulating value is returned to the caller.\n\nIf the sequence has no elements, updateAccumulatingResult is never executed and initialResult is the result of the call to reduce(into:_:).\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "shuffled(using:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/shuffled(using:)",
    "html": "Parameters\ngenerator\n\nThe random number generator to use when shuffling the sequence.\n\nReturn Value\n\nAn array of this sequence’s elements in a shuffled order.\n\nDiscussion\n\nYou use this method to randomize the elements of a sequence when you are using a custom random number generator. For example, you can shuffle the numbers between 0 and 9 by calling the shuffled(using:) method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled(using: &myGenerator)\n// shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]\n\n\nComplexity\n\nO(n), where n is the length of the sequence.\n\nNote\n\nThe algorithm used to shuffle a sequence may change in a future version of Swift. If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift."
  },
  {
    "title": "sorted() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/sorted()",
    "html": "Return Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nYou can sort any sequence of elements that conform to the Comparable protocol by calling this method. Elements are sorted in ascending order.\n\nHere’s an example of sorting a list of students’ names. Strings in Swift conform to the Comparable protocol, so the names are sorted in ascending order according to the less-than operator (<).\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet sortedStudents = students.sorted()\nprint(sortedStudents)\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nTo sort the elements of your sequence in descending order, pass the greater-than operator (>) to the sorted(by:) method.\n\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements that compare as equal.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "split(maxSplits:omittingEmptySubsequences:whereSeparator:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/split(maxsplits:omittingemptysubsequences:whereseparator:)",
    "html": "Parameters\nmaxSplits\n\nThe maximum number of times to split the sequence, or one less than the number of subsequences to return. If maxSplits + 1 subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements. maxSplits must be greater than or equal to zero. The default value is Int.max.\n\nomittingEmptySubsequences\n\nIf false, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the isSeparator predicate and for each element at the start or end of the sequence satisfying the isSeparator predicate. If true, only nonempty subsequences are returned. The default value is true.\n\nisSeparator\n\nA closure that returns true if its argument should be used to split the sequence; otherwise, false.\n\nReturn Value\n\nAn array of subsequences, split from this sequence’s elements.\n\nDiscussion\n\nThe following examples show the effects of the maxSplits and omittingEmptySubsequences parameters when splitting a string using a closure that matches spaces. The first use of split returns each word that was originally separated by one or more spaces.\n\nlet line = \"BLANCHE:   I don't want realism. I want magic!\"\nprint(line.split(whereSeparator: { $0 == \" \" })\n          .map(String.init))\n// Prints \"[\"BLANCHE:\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nThe second example passes 1 for the maxSplits parameter, so the original string is split just once, into two new strings.\n\nprint(\n   line.split(maxSplits: 1, whereSeparator: { $0 == \" \" })\n                  .map(String.init))\n// Prints \"[\"BLANCHE:\", \"  I don\\'t want realism. I want magic!\"]\"\n\n\nThe final example passes true for the allowEmptySlices parameter, so the returned array contains empty strings where spaces were repeated.\n\nprint(\n    line.split(\n        omittingEmptySubsequences: false,\n        whereSeparator: { $0 == \" \" }\n    ).map(String.init))\n// Prints \"[\"BLANCHE:\", \"\", \"\", \"I\", \"don\\'t\", \"want\", \"realism.\", \"I\", \"want\", \"magic!\"]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "starts(with:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/starts(with:)",
    "html": "Parameters\npossiblePrefix\n\nA sequence to compare to this sequence.\n\nReturn Value\n\ntrue if the initial elements of the sequence are the same as the elements of possiblePrefix; otherwise, false. If possiblePrefix has no elements, the return value is true.\n\nDiscussion\n\nThis example tests whether one countable range begins with the elements of another countable range.\n\nlet a = 1...3\nlet b = 1...10\n\n\nprint(b.starts(with: a))\n// Prints \"true\"\n\n\nPassing a sequence with no elements or an empty collection as possiblePrefix always results in true.\n\nprint(b.starts(with: []))\n// Prints \"true\"\n\n\nComplexity\n\nO(m), where m is the lesser of the length of the sequence and the length of possiblePrefix."
  },
  {
    "title": "sorted(by:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/sorted(by:)",
    "html": "Parameters\nareInIncreasingOrder\n\nA predicate that returns true if its first argument should be ordered before its second argument; otherwise, false.\n\nReturn Value\n\nA sorted array of the sequence’s elements.\n\nDiscussion\n\nWhen you want to sort a sequence of elements that don’t conform to the Comparable protocol, pass a predicate to this method that returns true when the first element should be ordered before the second. The elements of the resulting array are ordered according to the given predicate.\n\nIn the following example, the predicate provides an ordering for an array of a custom HTTPResponse type. The predicate orders errors before successes and sorts the error responses by their error code.\n\nenum HTTPResponse {\n    case ok\n    case error(Int)\n}\n\n\nlet responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]\nlet sortedResponses = responses.sorted {\n    switch ($0, $1) {\n    // Order errors by code\n    case let (.error(aCode), .error(bCode)):\n        return aCode < bCode\n\n\n    // All successes are equivalent, so none is before any other\n    case (.ok, .ok): return false\n\n\n    // Order errors before successes\n    case (.error, .ok): return true\n    case (.ok, .error): return false\n    }\n}\nprint(sortedResponses)\n// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\"\n\n\nYou also use this method to sort elements that conform to the Comparable protocol in descending order. To sort your sequence in descending order, pass the greater-than operator (>) as the areInIncreasingOrder parameter.\n\nlet students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\nlet descendingStudents = students.sorted(by: >)\nprint(descendingStudents)\n// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\n\nCalling the related sorted() method is equivalent to calling this method and passing the less-than operator (<) as the predicate.\n\nprint(students.sorted())\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\nprint(students.sorted(by: <))\n// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\n\nThe predicate must be a strict weak ordering over the elements. That is, for any elements a, b, and c, the following conditions must hold:\n\nareInIncreasingOrder(a, a) is always false. (Irreflexivity)\n\nIf areInIncreasingOrder(a, b) and areInIncreasingOrder(b, c) are both true, then areInIncreasingOrder(a, c) is also true. (Transitive comparability)\n\nTwo elements are incomparable if neither is ordered before the other according to the predicate. If a and b are incomparable, and b and c are incomparable, then a and c are also incomparable. (Transitive incomparability)\n\nThe sorting algorithm is guaranteed to be stable. A stable sort preserves the relative order of elements for which areInIncreasingOrder does not establish an order.\n\nComplexity\n\nO(n log n), where n is the length of the sequence."
  },
  {
    "title": "shuffled() | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazydropwhilesequence/shuffled()",
    "html": "Return Value\n\nA shuffled array of this sequence’s elements.\n\nDiscussion\n\nFor example, you can shuffle the numbers between 0 and 9 by calling the shuffled() method on that range:\n\nlet numbers = 0...9\nlet shuffledNumbers = numbers.shuffled()\n// shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]\n\n\nThis method is equivalent to calling shuffled(using:), passing in the system’s default random generator.\n\nComplexity\n\nO(n), where n is the length of the sequence."
  },
  {
    "title": "suffix(_:) | Apple Developer Documentation",
    "url": "https://developer.apple.com/documentation/swift/lazymapsequence/suffix(_:)",
    "html": "Parameters\nmaxLength\n\nThe maximum number of elements to return. The value of maxLength must be greater than or equal to zero.\n\nDiscussion\n\nThe sequence must be finite. If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.suffix(2))\n// Prints \"[4, 5]\"\nprint(numbers.suffix(10))\n// Prints \"[1, 2, 3, 4, 5]\"\n\n\nComplexity\n\nO(n), where n is the length of the sequence."
  }
]
